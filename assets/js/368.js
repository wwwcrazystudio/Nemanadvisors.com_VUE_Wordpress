/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([[368],{

/***/ 1332:
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*! Hammer.JS - v2.0.7 - 2016-04-22\n * http://hammerjs.github.io/\n *\n * Copyright (c) 2016 Jorik Tangelder;\n * Licensed under the MIT license */\n(function (window, document, exportName, undefined) {\n  'use strict';\n\n  var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];\n  var TEST_ELEMENT = document.createElement('div');\n  var TYPE_FUNCTION = 'function';\n  var round = Math.round;\n  var abs = Math.abs;\n  var now = Date.now;\n  /**\n   * set a timeout with a given scope\n   * @param {Function} fn\n   * @param {Number} timeout\n   * @param {Object} context\n   * @returns {number}\n   */\n\n  function setTimeoutContext(fn, timeout, context) {\n    return setTimeout(bindFn(fn, context), timeout);\n  }\n  /**\n   * if the argument is an array, we want to execute the fn on each entry\n   * if it aint an array we don't want to do a thing.\n   * this is used by all the methods that accept a single and array argument.\n   * @param {*|Array} arg\n   * @param {String} fn\n   * @param {Object} [context]\n   * @returns {Boolean}\n   */\n\n\n  function invokeArrayArg(arg, fn, context) {\n    if (Array.isArray(arg)) {\n      each(arg, context[fn], context);\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * walk objects and arrays\n   * @param {Object} obj\n   * @param {Function} iterator\n   * @param {Object} context\n   */\n\n\n  function each(obj, iterator, context) {\n    var i;\n\n    if (!obj) {\n      return;\n    }\n\n    if (obj.forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length !== undefined) {\n      i = 0;\n\n      while (i < obj.length) {\n        iterator.call(context, obj[i], i, obj);\n        i++;\n      }\n    } else {\n      for (i in obj) {\n        obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);\n      }\n    }\n  }\n  /**\n   * wrap a method with a deprecation warning and stack trace\n   * @param {Function} method\n   * @param {String} name\n   * @param {String} message\n   * @returns {Function} A new function wrapping the supplied method.\n   */\n\n\n  function deprecate(method, name, message) {\n    var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\\n' + message + ' AT \\n';\n    return function () {\n      var e = new Error('get-stack-trace');\n      var stack = e && e.stack ? e.stack.replace(/^[^\\(]+?[\\n$]/gm, '').replace(/^\\s+at\\s+/gm, '').replace(/^Object.<anonymous>\\s*\\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';\n      var log = window.console && (window.console.warn || window.console.log);\n\n      if (log) {\n        log.call(window.console, deprecationMessage, stack);\n      }\n\n      return method.apply(this, arguments);\n    };\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} target\n   * @param {...Object} objects_to_assign\n   * @returns {Object} target\n   */\n\n\n  var assign;\n\n  if (typeof Object.assign !== 'function') {\n    assign = function assign(target) {\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } else {\n    assign = Object.assign;\n  }\n  /**\n   * extend object.\n   * means that properties in dest will be overwritten by the ones in src.\n   * @param {Object} dest\n   * @param {Object} src\n   * @param {Boolean} [merge=false]\n   * @returns {Object} dest\n   */\n\n\n  var extend = deprecate(function extend(dest, src, merge) {\n    var keys = Object.keys(src);\n    var i = 0;\n\n    while (i < keys.length) {\n      if (!merge || merge && dest[keys[i]] === undefined) {\n        dest[keys[i]] = src[keys[i]];\n      }\n\n      i++;\n    }\n\n    return dest;\n  }, 'extend', 'Use `assign`.');\n  /**\n   * merge the values from src in the dest.\n   * means that properties that exist in dest will not be overwritten by src\n   * @param {Object} dest\n   * @param {Object} src\n   * @returns {Object} dest\n   */\n\n  var merge = deprecate(function merge(dest, src) {\n    return extend(dest, src, true);\n  }, 'merge', 'Use `assign`.');\n  /**\n   * simple class inheritance\n   * @param {Function} child\n   * @param {Function} base\n   * @param {Object} [properties]\n   */\n\n  function inherit(child, base, properties) {\n    var baseP = base.prototype,\n        childP;\n    childP = child.prototype = Object.create(baseP);\n    childP.constructor = child;\n    childP._super = baseP;\n\n    if (properties) {\n      assign(childP, properties);\n    }\n  }\n  /**\n   * simple function bind\n   * @param {Function} fn\n   * @param {Object} context\n   * @returns {Function}\n   */\n\n\n  function bindFn(fn, context) {\n    return function boundFn() {\n      return fn.apply(context, arguments);\n    };\n  }\n  /**\n   * let a boolean value also be a function that must return a boolean\n   * this first item in args will be used as the context\n   * @param {Boolean|Function} val\n   * @param {Array} [args]\n   * @returns {Boolean}\n   */\n\n\n  function boolOrFn(val, args) {\n    if (typeof val == TYPE_FUNCTION) {\n      return val.apply(args ? args[0] || undefined : undefined, args);\n    }\n\n    return val;\n  }\n  /**\n   * use the val2 when val1 is undefined\n   * @param {*} val1\n   * @param {*} val2\n   * @returns {*}\n   */\n\n\n  function ifUndefined(val1, val2) {\n    return val1 === undefined ? val2 : val1;\n  }\n  /**\n   * addEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function addEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.addEventListener(type, handler, false);\n    });\n  }\n  /**\n   * removeEventListener with multiple events at once\n   * @param {EventTarget} target\n   * @param {String} types\n   * @param {Function} handler\n   */\n\n\n  function removeEventListeners(target, types, handler) {\n    each(splitStr(types), function (type) {\n      target.removeEventListener(type, handler, false);\n    });\n  }\n  /**\n   * find if a node is in the given parent\n   * @method hasParent\n   * @param {HTMLElement} node\n   * @param {HTMLElement} parent\n   * @return {Boolean} found\n   */\n\n\n  function hasParent(node, parent) {\n    while (node) {\n      if (node == parent) {\n        return true;\n      }\n\n      node = node.parentNode;\n    }\n\n    return false;\n  }\n  /**\n   * small indexOf wrapper\n   * @param {String} str\n   * @param {String} find\n   * @returns {Boolean} found\n   */\n\n\n  function inStr(str, find) {\n    return str.indexOf(find) > -1;\n  }\n  /**\n   * split string on whitespace\n   * @param {String} str\n   * @returns {Array} words\n   */\n\n\n  function splitStr(str) {\n    return str.trim().split(/\\s+/g);\n  }\n  /**\n   * find if a array contains the object using indexOf or a simple polyFill\n   * @param {Array} src\n   * @param {String} find\n   * @param {String} [findByKey]\n   * @return {Boolean|Number} false when not found, or the index\n   */\n\n\n  function inArray(src, find, findByKey) {\n    if (src.indexOf && !findByKey) {\n      return src.indexOf(find);\n    } else {\n      var i = 0;\n\n      while (i < src.length) {\n        if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {\n          return i;\n        }\n\n        i++;\n      }\n\n      return -1;\n    }\n  }\n  /**\n   * convert array-like objects to real arrays\n   * @param {Object} obj\n   * @returns {Array}\n   */\n\n\n  function toArray(obj) {\n    return Array.prototype.slice.call(obj, 0);\n  }\n  /**\n   * unique array with objects based on a key (like 'id') or just by the array's value\n   * @param {Array} src [{id:1},{id:2},{id:1}]\n   * @param {String} [key]\n   * @param {Boolean} [sort=False]\n   * @returns {Array} [{id:1},{id:2}]\n   */\n\n\n  function uniqueArray(src, key, sort) {\n    var results = [];\n    var values = [];\n    var i = 0;\n\n    while (i < src.length) {\n      var val = key ? src[i][key] : src[i];\n\n      if (inArray(values, val) < 0) {\n        results.push(src[i]);\n      }\n\n      values[i] = val;\n      i++;\n    }\n\n    if (sort) {\n      if (!key) {\n        results = results.sort();\n      } else {\n        results = results.sort(function sortUniqueArray(a, b) {\n          return a[key] > b[key];\n        });\n      }\n    }\n\n    return results;\n  }\n  /**\n   * get the prefixed property\n   * @param {Object} obj\n   * @param {String} property\n   * @returns {String|Undefined} prefixed\n   */\n\n\n  function prefixed(obj, property) {\n    var prefix, prop;\n    var camelProp = property[0].toUpperCase() + property.slice(1);\n    var i = 0;\n\n    while (i < VENDOR_PREFIXES.length) {\n      prefix = VENDOR_PREFIXES[i];\n      prop = prefix ? prefix + camelProp : property;\n\n      if (prop in obj) {\n        return prop;\n      }\n\n      i++;\n    }\n\n    return undefined;\n  }\n  /**\n   * get a unique id\n   * @returns {number} uniqueId\n   */\n\n\n  var _uniqueId = 1;\n\n  function uniqueId() {\n    return _uniqueId++;\n  }\n  /**\n   * get the window object of an element\n   * @param {HTMLElement} element\n   * @returns {DocumentView|Window}\n   */\n\n\n  function getWindowForElement(element) {\n    var doc = element.ownerDocument || element;\n    return doc.defaultView || doc.parentWindow || window;\n  }\n\n  var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;\n  var SUPPORT_TOUCH = ('ontouchstart' in window);\n  var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;\n  var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);\n  var INPUT_TYPE_TOUCH = 'touch';\n  var INPUT_TYPE_PEN = 'pen';\n  var INPUT_TYPE_MOUSE = 'mouse';\n  var INPUT_TYPE_KINECT = 'kinect';\n  var COMPUTE_INTERVAL = 25;\n  var INPUT_START = 1;\n  var INPUT_MOVE = 2;\n  var INPUT_END = 4;\n  var INPUT_CANCEL = 8;\n  var DIRECTION_NONE = 1;\n  var DIRECTION_LEFT = 2;\n  var DIRECTION_RIGHT = 4;\n  var DIRECTION_UP = 8;\n  var DIRECTION_DOWN = 16;\n  var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;\n  var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;\n  var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;\n  var PROPS_XY = ['x', 'y'];\n  var PROPS_CLIENT_XY = ['clientX', 'clientY'];\n  /**\n   * create new input type manager\n   * @param {Manager} manager\n   * @param {Function} callback\n   * @returns {Input}\n   * @constructor\n   */\n\n  function Input(manager, callback) {\n    var self = this;\n    this.manager = manager;\n    this.callback = callback;\n    this.element = manager.element;\n    this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,\n    // so when disabled the input events are completely bypassed.\n\n    this.domHandler = function (ev) {\n      if (boolOrFn(manager.options.enable, [manager])) {\n        self.handler(ev);\n      }\n    };\n\n    this.init();\n  }\n\n  Input.prototype = {\n    /**\n     * should handle the inputEvent data and trigger the callback\n     * @virtual\n     */\n    handler: function () {},\n\n    /**\n     * bind the events\n     */\n    init: function () {\n      this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    },\n\n    /**\n     * unbind the events\n     */\n    destroy: function () {\n      this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);\n      this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);\n      this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);\n    }\n  };\n  /**\n   * create new input type manager\n   * called by the Manager constructor\n   * @param {Hammer} manager\n   * @returns {Input}\n   */\n\n  function createInputInstance(manager) {\n    var Type;\n    var inputClass = manager.options.inputClass;\n\n    if (inputClass) {\n      Type = inputClass;\n    } else if (SUPPORT_POINTER_EVENTS) {\n      Type = PointerEventInput;\n    } else if (SUPPORT_ONLY_TOUCH) {\n      Type = TouchInput;\n    } else if (!SUPPORT_TOUCH) {\n      Type = MouseInput;\n    } else {\n      Type = TouchMouseInput;\n    }\n\n    return new Type(manager, inputHandler);\n  }\n  /**\n   * handle input events\n   * @param {Manager} manager\n   * @param {String} eventType\n   * @param {Object} input\n   */\n\n\n  function inputHandler(manager, eventType, input) {\n    var pointersLen = input.pointers.length;\n    var changedPointersLen = input.changedPointers.length;\n    var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;\n    var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;\n    input.isFirst = !!isFirst;\n    input.isFinal = !!isFinal;\n\n    if (isFirst) {\n      manager.session = {};\n    } // source event is the normalized value of the domEvents\n    // like 'touchstart, mouseup, pointerdown'\n\n\n    input.eventType = eventType; // compute scale, rotation etc\n\n    computeInputData(manager, input); // emit secret event\n\n    manager.emit('hammer.input', input);\n    manager.recognize(input);\n    manager.session.prevInput = input;\n  }\n  /**\n   * extend the data with some usable properties like scale, rotate, velocity etc\n   * @param {Object} manager\n   * @param {Object} input\n   */\n\n\n  function computeInputData(manager, input) {\n    var session = manager.session;\n    var pointers = input.pointers;\n    var pointersLength = pointers.length; // store the first input to calculate the distance and direction\n\n    if (!session.firstInput) {\n      session.firstInput = simpleCloneInputData(input);\n    } // to compute scale and rotation we need to store the multiple touches\n\n\n    if (pointersLength > 1 && !session.firstMultiple) {\n      session.firstMultiple = simpleCloneInputData(input);\n    } else if (pointersLength === 1) {\n      session.firstMultiple = false;\n    }\n\n    var firstInput = session.firstInput;\n    var firstMultiple = session.firstMultiple;\n    var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;\n    var center = input.center = getCenter(pointers);\n    input.timeStamp = now();\n    input.deltaTime = input.timeStamp - firstInput.timeStamp;\n    input.angle = getAngle(offsetCenter, center);\n    input.distance = getDistance(offsetCenter, center);\n    computeDeltaXY(session, input);\n    input.offsetDirection = getDirection(input.deltaX, input.deltaY);\n    var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);\n    input.overallVelocityX = overallVelocity.x;\n    input.overallVelocityY = overallVelocity.y;\n    input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;\n    input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;\n    input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;\n    input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;\n    computeIntervalInputData(session, input); // find the correct target\n\n    var target = manager.element;\n\n    if (hasParent(input.srcEvent.target, target)) {\n      target = input.srcEvent.target;\n    }\n\n    input.target = target;\n  }\n\n  function computeDeltaXY(session, input) {\n    var center = input.center;\n    var offset = session.offsetDelta || {};\n    var prevDelta = session.prevDelta || {};\n    var prevInput = session.prevInput || {};\n\n    if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {\n      prevDelta = session.prevDelta = {\n        x: prevInput.deltaX || 0,\n        y: prevInput.deltaY || 0\n      };\n      offset = session.offsetDelta = {\n        x: center.x,\n        y: center.y\n      };\n    }\n\n    input.deltaX = prevDelta.x + (center.x - offset.x);\n    input.deltaY = prevDelta.y + (center.y - offset.y);\n  }\n  /**\n   * velocity is calculated every x ms\n   * @param {Object} session\n   * @param {Object} input\n   */\n\n\n  function computeIntervalInputData(session, input) {\n    var last = session.lastInterval || input,\n        deltaTime = input.timeStamp - last.timeStamp,\n        velocity,\n        velocityX,\n        velocityY,\n        direction;\n\n    if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n      var deltaX = input.deltaX - last.deltaX;\n      var deltaY = input.deltaY - last.deltaY;\n      var v = getVelocity(deltaTime, deltaX, deltaY);\n      velocityX = v.x;\n      velocityY = v.y;\n      velocity = abs(v.x) > abs(v.y) ? v.x : v.y;\n      direction = getDirection(deltaX, deltaY);\n      session.lastInterval = input;\n    } else {\n      // use latest velocity info if it doesn't overtake a minimum period\n      velocity = last.velocity;\n      velocityX = last.velocityX;\n      velocityY = last.velocityY;\n      direction = last.direction;\n    }\n\n    input.velocity = velocity;\n    input.velocityX = velocityX;\n    input.velocityY = velocityY;\n    input.direction = direction;\n  }\n  /**\n   * create a simple clone from the input used for storage of firstInput and firstMultiple\n   * @param {Object} input\n   * @returns {Object} clonedInputData\n   */\n\n\n  function simpleCloneInputData(input) {\n    // make a simple copy of the pointers because we will get a reference if we don't\n    // we only need clientXY for the calculations\n    var pointers = [];\n    var i = 0;\n\n    while (i < input.pointers.length) {\n      pointers[i] = {\n        clientX: round(input.pointers[i].clientX),\n        clientY: round(input.pointers[i].clientY)\n      };\n      i++;\n    }\n\n    return {\n      timeStamp: now(),\n      pointers: pointers,\n      center: getCenter(pointers),\n      deltaX: input.deltaX,\n      deltaY: input.deltaY\n    };\n  }\n  /**\n   * get the center of all the pointers\n   * @param {Array} pointers\n   * @return {Object} center contains `x` and `y` properties\n   */\n\n\n  function getCenter(pointers) {\n    var pointersLength = pointers.length; // no need to loop when only one touch\n\n    if (pointersLength === 1) {\n      return {\n        x: round(pointers[0].clientX),\n        y: round(pointers[0].clientY)\n      };\n    }\n\n    var x = 0,\n        y = 0,\n        i = 0;\n\n    while (i < pointersLength) {\n      x += pointers[i].clientX;\n      y += pointers[i].clientY;\n      i++;\n    }\n\n    return {\n      x: round(x / pointersLength),\n      y: round(y / pointersLength)\n    };\n  }\n  /**\n   * calculate the velocity between two points. unit is in px per ms.\n   * @param {Number} deltaTime\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Object} velocity `x` and `y`\n   */\n\n\n  function getVelocity(deltaTime, x, y) {\n    return {\n      x: x / deltaTime || 0,\n      y: y / deltaTime || 0\n    };\n  }\n  /**\n   * get the direction between two points\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Number} direction\n   */\n\n\n  function getDirection(x, y) {\n    if (x === y) {\n      return DIRECTION_NONE;\n    }\n\n    if (abs(x) >= abs(y)) {\n      return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n    }\n\n    return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n  }\n  /**\n   * calculate the absolute distance between two points\n   * @param {Object} p1 {x, y}\n   * @param {Object} p2 {x, y}\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} distance\n   */\n\n\n  function getDistance(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.sqrt(x * x + y * y);\n  }\n  /**\n   * calculate the angle between two coordinates\n   * @param {Object} p1\n   * @param {Object} p2\n   * @param {Array} [props] containing x and y keys\n   * @return {Number} angle\n   */\n\n\n  function getAngle(p1, p2, props) {\n    if (!props) {\n      props = PROPS_XY;\n    }\n\n    var x = p2[props[0]] - p1[props[0]],\n        y = p2[props[1]] - p1[props[1]];\n    return Math.atan2(y, x) * 180 / Math.PI;\n  }\n  /**\n   * calculate the rotation degrees between two pointersets\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} rotation\n   */\n\n\n  function getRotation(start, end) {\n    return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n  }\n  /**\n   * calculate the scale factor between two pointersets\n   * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n   * @param {Array} start array of pointers\n   * @param {Array} end array of pointers\n   * @return {Number} scale\n   */\n\n\n  function getScale(start, end) {\n    return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n  }\n\n  var MOUSE_INPUT_MAP = {\n    mousedown: INPUT_START,\n    mousemove: INPUT_MOVE,\n    mouseup: INPUT_END\n  };\n  var MOUSE_ELEMENT_EVENTS = 'mousedown';\n  var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';\n  /**\n   * Mouse events input\n   * @constructor\n   * @extends Input\n   */\n\n  function MouseInput() {\n    this.evEl = MOUSE_ELEMENT_EVENTS;\n    this.evWin = MOUSE_WINDOW_EVENTS;\n    this.pressed = false; // mousedown state\n\n    Input.apply(this, arguments);\n  }\n\n  inherit(MouseInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function MEhandler(ev) {\n      var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down\n\n      if (eventType & INPUT_START && ev.button === 0) {\n        this.pressed = true;\n      }\n\n      if (eventType & INPUT_MOVE && ev.which !== 1) {\n        eventType = INPUT_END;\n      } // mouse must be down\n\n\n      if (!this.pressed) {\n        return;\n      }\n\n      if (eventType & INPUT_END) {\n        this.pressed = false;\n      }\n\n      this.callback(this.manager, eventType, {\n        pointers: [ev],\n        changedPointers: [ev],\n        pointerType: INPUT_TYPE_MOUSE,\n        srcEvent: ev\n      });\n    }\n  });\n  var POINTER_INPUT_MAP = {\n    pointerdown: INPUT_START,\n    pointermove: INPUT_MOVE,\n    pointerup: INPUT_END,\n    pointercancel: INPUT_CANCEL,\n    pointerout: INPUT_CANCEL\n  }; // in IE10 the pointer types is defined as an enum\n\n  var IE10_POINTER_TYPE_ENUM = {\n    2: INPUT_TYPE_TOUCH,\n    3: INPUT_TYPE_PEN,\n    4: INPUT_TYPE_MOUSE,\n    5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816\n\n  };\n  var POINTER_ELEMENT_EVENTS = 'pointerdown';\n  var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive\n\n  if (window.MSPointerEvent && !window.PointerEvent) {\n    POINTER_ELEMENT_EVENTS = 'MSPointerDown';\n    POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';\n  }\n  /**\n   * Pointer events input\n   * @constructor\n   * @extends Input\n   */\n\n\n  function PointerEventInput() {\n    this.evEl = POINTER_ELEMENT_EVENTS;\n    this.evWin = POINTER_WINDOW_EVENTS;\n    Input.apply(this, arguments);\n    this.store = this.manager.session.pointerEvents = [];\n  }\n\n  inherit(PointerEventInput, Input, {\n    /**\n     * handle mouse events\n     * @param {Object} ev\n     */\n    handler: function PEhandler(ev) {\n      var store = this.store;\n      var removePointer = false;\n      var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');\n      var eventType = POINTER_INPUT_MAP[eventTypeNormalized];\n      var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;\n      var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store\n\n      var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down\n\n      if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {\n        if (storeIndex < 0) {\n          store.push(ev);\n          storeIndex = store.length - 1;\n        }\n      } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n        removePointer = true;\n      } // it not found, so the pointer hasn't been down (so it's probably a hover)\n\n\n      if (storeIndex < 0) {\n        return;\n      } // update the event in the store\n\n\n      store[storeIndex] = ev;\n      this.callback(this.manager, eventType, {\n        pointers: store,\n        changedPointers: [ev],\n        pointerType: pointerType,\n        srcEvent: ev\n      });\n\n      if (removePointer) {\n        // remove from the store\n        store.splice(storeIndex, 1);\n      }\n    }\n  });\n  var SINGLE_TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';\n  var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function SingleTouchInput() {\n    this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;\n    this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;\n    this.started = false;\n    Input.apply(this, arguments);\n  }\n\n  inherit(SingleTouchInput, Input, {\n    handler: function TEhandler(ev) {\n      var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?\n\n      if (type === INPUT_START) {\n        this.started = true;\n      }\n\n      if (!this.started) {\n        return;\n      }\n\n      var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state\n\n      if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {\n        this.started = false;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function normalizeSingleTouches(ev, type) {\n    var all = toArray(ev.touches);\n    var changed = toArray(ev.changedTouches);\n\n    if (type & (INPUT_END | INPUT_CANCEL)) {\n      all = uniqueArray(all.concat(changed), 'identifier', true);\n    }\n\n    return [all, changed];\n  }\n\n  var TOUCH_INPUT_MAP = {\n    touchstart: INPUT_START,\n    touchmove: INPUT_MOVE,\n    touchend: INPUT_END,\n    touchcancel: INPUT_CANCEL\n  };\n  var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';\n  /**\n   * Multi-user touch events input\n   * @constructor\n   * @extends Input\n   */\n\n  function TouchInput() {\n    this.evTarget = TOUCH_TARGET_EVENTS;\n    this.targetIds = {};\n    Input.apply(this, arguments);\n  }\n\n  inherit(TouchInput, Input, {\n    handler: function MTEhandler(ev) {\n      var type = TOUCH_INPUT_MAP[ev.type];\n      var touches = getTouches.call(this, ev, type);\n\n      if (!touches) {\n        return;\n      }\n\n      this.callback(this.manager, type, {\n        pointers: touches[0],\n        changedPointers: touches[1],\n        pointerType: INPUT_TYPE_TOUCH,\n        srcEvent: ev\n      });\n    }\n  });\n  /**\n   * @this {TouchInput}\n   * @param {Object} ev\n   * @param {Number} type flag\n   * @returns {undefined|Array} [all, changed]\n   */\n\n  function getTouches(ev, type) {\n    var allTouches = toArray(ev.touches);\n    var targetIds = this.targetIds; // when there is only one touch, the process can be simplified\n\n    if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {\n      targetIds[allTouches[0].identifier] = true;\n      return [allTouches, allTouches];\n    }\n\n    var i,\n        targetTouches,\n        changedTouches = toArray(ev.changedTouches),\n        changedTargetTouches = [],\n        target = this.target; // get target touches from touches\n\n    targetTouches = allTouches.filter(function (touch) {\n      return hasParent(touch.target, target);\n    }); // collect touches\n\n    if (type === INPUT_START) {\n      i = 0;\n\n      while (i < targetTouches.length) {\n        targetIds[targetTouches[i].identifier] = true;\n        i++;\n      }\n    } // filter changed touches to only contain touches that exist in the collected target ids\n\n\n    i = 0;\n\n    while (i < changedTouches.length) {\n      if (targetIds[changedTouches[i].identifier]) {\n        changedTargetTouches.push(changedTouches[i]);\n      } // cleanup removed touches\n\n\n      if (type & (INPUT_END | INPUT_CANCEL)) {\n        delete targetIds[changedTouches[i].identifier];\n      }\n\n      i++;\n    }\n\n    if (!changedTargetTouches.length) {\n      return;\n    }\n\n    return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'\n    uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];\n  }\n  /**\n   * Combined touch and mouse input\n   *\n   * Touch has a higher priority then mouse, and while touching no mouse events are allowed.\n   * This because touch devices also emit mouse events while doing a touch.\n   *\n   * @constructor\n   * @extends Input\n   */\n\n\n  var DEDUP_TIMEOUT = 2500;\n  var DEDUP_DISTANCE = 25;\n\n  function TouchMouseInput() {\n    Input.apply(this, arguments);\n    var handler = bindFn(this.handler, this);\n    this.touch = new TouchInput(this.manager, handler);\n    this.mouse = new MouseInput(this.manager, handler);\n    this.primaryTouch = null;\n    this.lastTouches = [];\n  }\n\n  inherit(TouchMouseInput, Input, {\n    /**\n     * handle mouse and touch events\n     * @param {Hammer} manager\n     * @param {String} inputEvent\n     * @param {Object} inputData\n     */\n    handler: function TMEhandler(manager, inputEvent, inputData) {\n      var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,\n          isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;\n\n      if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {\n        return;\n      } // when we're in a touch event, record touches to  de-dupe synthetic mouse event\n\n\n      if (isTouch) {\n        recordTouches.call(this, inputEvent, inputData);\n      } else if (isMouse && isSyntheticEvent.call(this, inputData)) {\n        return;\n      }\n\n      this.callback(manager, inputEvent, inputData);\n    },\n\n    /**\n     * remove the event listeners\n     */\n    destroy: function destroy() {\n      this.touch.destroy();\n      this.mouse.destroy();\n    }\n  });\n\n  function recordTouches(eventType, eventData) {\n    if (eventType & INPUT_START) {\n      this.primaryTouch = eventData.changedPointers[0].identifier;\n      setLastTouch.call(this, eventData);\n    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {\n      setLastTouch.call(this, eventData);\n    }\n  }\n\n  function setLastTouch(eventData) {\n    var touch = eventData.changedPointers[0];\n\n    if (touch.identifier === this.primaryTouch) {\n      var lastTouch = {\n        x: touch.clientX,\n        y: touch.clientY\n      };\n      this.lastTouches.push(lastTouch);\n      var lts = this.lastTouches;\n\n      var removeLastTouch = function () {\n        var i = lts.indexOf(lastTouch);\n\n        if (i > -1) {\n          lts.splice(i, 1);\n        }\n      };\n\n      setTimeout(removeLastTouch, DEDUP_TIMEOUT);\n    }\n  }\n\n  function isSyntheticEvent(eventData) {\n    var x = eventData.srcEvent.clientX,\n        y = eventData.srcEvent.clientY;\n\n    for (var i = 0; i < this.lastTouches.length; i++) {\n      var t = this.lastTouches[i];\n      var dx = Math.abs(x - t.x),\n          dy = Math.abs(y - t.y);\n\n      if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');\n  var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value\n\n  var TOUCH_ACTION_COMPUTE = 'compute';\n  var TOUCH_ACTION_AUTO = 'auto';\n  var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented\n\n  var TOUCH_ACTION_NONE = 'none';\n  var TOUCH_ACTION_PAN_X = 'pan-x';\n  var TOUCH_ACTION_PAN_Y = 'pan-y';\n  var TOUCH_ACTION_MAP = getTouchActionProps();\n  /**\n   * Touch Action\n   * sets the touchAction property or uses the js alternative\n   * @param {Manager} manager\n   * @param {String} value\n   * @constructor\n   */\n\n  function TouchAction(manager, value) {\n    this.manager = manager;\n    this.set(value);\n  }\n\n  TouchAction.prototype = {\n    /**\n     * set the touchAction value on the element or enable the polyfill\n     * @param {String} value\n     */\n    set: function (value) {\n      // find out the touch-action by the event handlers\n      if (value == TOUCH_ACTION_COMPUTE) {\n        value = this.compute();\n      }\n\n      if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {\n        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;\n      }\n\n      this.actions = value.toLowerCase().trim();\n    },\n\n    /**\n     * just re-set the touchAction value\n     */\n    update: function () {\n      this.set(this.manager.options.touchAction);\n    },\n\n    /**\n     * compute the value for the touchAction property based on the recognizer's settings\n     * @returns {String} value\n     */\n    compute: function () {\n      var actions = [];\n      each(this.manager.recognizers, function (recognizer) {\n        if (boolOrFn(recognizer.options.enable, [recognizer])) {\n          actions = actions.concat(recognizer.getTouchAction());\n        }\n      });\n      return cleanTouchActions(actions.join(' '));\n    },\n\n    /**\n     * this method is called on each input cycle and provides the preventing of the browser behavior\n     * @param {Object} input\n     */\n    preventDefaults: function (input) {\n      var srcEvent = input.srcEvent;\n      var direction = input.offsetDirection; // if the touch action did prevented once this session\n\n      if (this.manager.session.prevented) {\n        srcEvent.preventDefault();\n        return;\n      }\n\n      var actions = this.actions;\n      var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];\n      var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];\n      var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];\n\n      if (hasNone) {\n        //do not prevent defaults if this is a tap gesture\n        var isTapPointer = input.pointers.length === 1;\n        var isTapMovement = input.distance < 2;\n        var isTapTouchTime = input.deltaTime < 250;\n\n        if (isTapPointer && isTapMovement && isTapTouchTime) {\n          return;\n        }\n      }\n\n      if (hasPanX && hasPanY) {\n        // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent\n        return;\n      }\n\n      if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {\n        return this.preventSrc(srcEvent);\n      }\n    },\n\n    /**\n     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)\n     * @param {Object} srcEvent\n     */\n    preventSrc: function (srcEvent) {\n      this.manager.session.prevented = true;\n      srcEvent.preventDefault();\n    }\n  };\n  /**\n   * when the touchActions are collected they are not a valid value, so we need to clean things up. *\n   * @param {String} actions\n   * @returns {*}\n   */\n\n  function cleanTouchActions(actions) {\n    // none\n    if (inStr(actions, TOUCH_ACTION_NONE)) {\n      return TOUCH_ACTION_NONE;\n    }\n\n    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);\n    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers\n    // for different directions, e.g. horizontal pan but vertical swipe?)\n    // we need none (as otherwise with pan-x pan-y combined none of these\n    // recognizers will work, since the browser would handle all panning\n\n    if (hasPanX && hasPanY) {\n      return TOUCH_ACTION_NONE;\n    } // pan-x OR pan-y\n\n\n    if (hasPanX || hasPanY) {\n      return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;\n    } // manipulation\n\n\n    if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {\n      return TOUCH_ACTION_MANIPULATION;\n    }\n\n    return TOUCH_ACTION_AUTO;\n  }\n\n  function getTouchActionProps() {\n    if (!NATIVE_TOUCH_ACTION) {\n      return false;\n    }\n\n    var touchMap = {};\n    var cssSupports = window.CSS && window.CSS.supports;\n    ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {\n      // If css.supports is not supported but there is native touch-action assume it supports\n      // all values. This is the case for IE 10 and 11.\n      touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;\n    });\n    return touchMap;\n  }\n  /**\n   * Recognizer flow explained; *\n   * All recognizers have the initial state of POSSIBLE when a input session starts.\n   * The definition of a input session is from the first input until the last input, with all it's movement in it. *\n   * Example session for mouse-input: mousedown -> mousemove -> mouseup\n   *\n   * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed\n   * which determines with state it should be.\n   *\n   * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to\n   * POSSIBLE to give it another change on the next cycle.\n   *\n   *               Possible\n   *                  |\n   *            +-----+---------------+\n   *            |                     |\n   *      +-----+-----+               |\n   *      |           |               |\n   *   Failed      Cancelled          |\n   *                          +-------+------+\n   *                          |              |\n   *                      Recognized       Began\n   *                                         |\n   *                                      Changed\n   *                                         |\n   *                                  Ended/Recognized\n   */\n\n\n  var STATE_POSSIBLE = 1;\n  var STATE_BEGAN = 2;\n  var STATE_CHANGED = 4;\n  var STATE_ENDED = 8;\n  var STATE_RECOGNIZED = STATE_ENDED;\n  var STATE_CANCELLED = 16;\n  var STATE_FAILED = 32;\n  /**\n   * Recognizer\n   * Every recognizer needs to extend from this class.\n   * @constructor\n   * @param {Object} options\n   */\n\n  function Recognizer(options) {\n    this.options = assign({}, this.defaults, options || {});\n    this.id = uniqueId();\n    this.manager = null; // default is enable true\n\n    this.options.enable = ifUndefined(this.options.enable, true);\n    this.state = STATE_POSSIBLE;\n    this.simultaneous = {};\n    this.requireFail = [];\n  }\n\n  Recognizer.prototype = {\n    /**\n     * @virtual\n     * @type {Object}\n     */\n    defaults: {},\n\n    /**\n     * set options\n     * @param {Object} options\n     * @return {Recognizer}\n     */\n    set: function (options) {\n      assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state\n\n      this.manager && this.manager.touchAction.update();\n      return this;\n    },\n\n    /**\n     * recognize simultaneous with an other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    recognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {\n        return this;\n      }\n\n      var simultaneous = this.simultaneous;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (!simultaneous[otherRecognizer.id]) {\n        simultaneous[otherRecognizer.id] = otherRecognizer;\n        otherRecognizer.recognizeWith(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the simultaneous link. it doesnt remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRecognizeWith: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      delete this.simultaneous[otherRecognizer.id];\n      return this;\n    },\n\n    /**\n     * recognizer can only run when an other is failing\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    requireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {\n        return this;\n      }\n\n      var requireFail = this.requireFail;\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n\n      if (inArray(requireFail, otherRecognizer) === -1) {\n        requireFail.push(otherRecognizer);\n        otherRecognizer.requireFailure(this);\n      }\n\n      return this;\n    },\n\n    /**\n     * drop the requireFailure link. it does not remove the link on the other recognizer.\n     * @param {Recognizer} otherRecognizer\n     * @returns {Recognizer} this\n     */\n    dropRequireFailure: function (otherRecognizer) {\n      if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {\n        return this;\n      }\n\n      otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);\n      var index = inArray(this.requireFail, otherRecognizer);\n\n      if (index > -1) {\n        this.requireFail.splice(index, 1);\n      }\n\n      return this;\n    },\n\n    /**\n     * has require failures boolean\n     * @returns {boolean}\n     */\n    hasRequireFailures: function () {\n      return this.requireFail.length > 0;\n    },\n\n    /**\n     * if the recognizer can recognize simultaneous with an other recognizer\n     * @param {Recognizer} otherRecognizer\n     * @returns {Boolean}\n     */\n    canRecognizeWith: function (otherRecognizer) {\n      return !!this.simultaneous[otherRecognizer.id];\n    },\n\n    /**\n     * You should use `tryEmit` instead of `emit` directly to check\n     * that all the needed recognizers has failed before emitting.\n     * @param {Object} input\n     */\n    emit: function (input) {\n      var self = this;\n      var state = this.state;\n\n      function emit(event) {\n        self.manager.emit(event, input);\n      } // 'panstart' and 'panmove'\n\n\n      if (state < STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n\n      emit(self.options.event); // simple 'eventName' events\n\n      if (input.additionalEvent) {\n        // additional event(panleft, panright, pinchin, pinchout...)\n        emit(input.additionalEvent);\n      } // panend and pancancel\n\n\n      if (state >= STATE_ENDED) {\n        emit(self.options.event + stateStr(state));\n      }\n    },\n\n    /**\n     * Check that all the require failure recognizers has failed,\n     * if true, it emits a gesture event,\n     * otherwise, setup the state to FAILED.\n     * @param {Object} input\n     */\n    tryEmit: function (input) {\n      if (this.canEmit()) {\n        return this.emit(input);\n      } // it's failing anyway\n\n\n      this.state = STATE_FAILED;\n    },\n\n    /**\n     * can we emit?\n     * @returns {boolean}\n     */\n    canEmit: function () {\n      var i = 0;\n\n      while (i < this.requireFail.length) {\n        if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {\n          return false;\n        }\n\n        i++;\n      }\n\n      return true;\n    },\n\n    /**\n     * update the recognizer\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      // make a new copy of the inputData\n      // so we can change the inputData without messing up the other recognizers\n      var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?\n\n      if (!boolOrFn(this.options.enable, [this, inputDataClone])) {\n        this.reset();\n        this.state = STATE_FAILED;\n        return;\n      } // reset when we've reached the end\n\n\n      if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {\n        this.state = STATE_POSSIBLE;\n      }\n\n      this.state = this.process(inputDataClone); // the recognizer has recognized a gesture\n      // so trigger an event\n\n      if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {\n        this.tryEmit(inputDataClone);\n      }\n    },\n\n    /**\n     * return the state of the recognizer\n     * the actual recognizing happens in this method\n     * @virtual\n     * @param {Object} inputData\n     * @returns {Const} STATE\n     */\n    process: function (inputData) {},\n    // jshint ignore:line\n\n    /**\n     * return the preferred touch-action\n     * @virtual\n     * @returns {Array}\n     */\n    getTouchAction: function () {},\n\n    /**\n     * called when the gesture isn't allowed to recognize\n     * like when another is being recognized or it is disabled\n     * @virtual\n     */\n    reset: function () {}\n  };\n  /**\n   * get a usable string, used as event postfix\n   * @param {Const} state\n   * @returns {String} state\n   */\n\n  function stateStr(state) {\n    if (state & STATE_CANCELLED) {\n      return 'cancel';\n    } else if (state & STATE_ENDED) {\n      return 'end';\n    } else if (state & STATE_CHANGED) {\n      return 'move';\n    } else if (state & STATE_BEGAN) {\n      return 'start';\n    }\n\n    return '';\n  }\n  /**\n   * direction cons to string\n   * @param {Const} direction\n   * @returns {String}\n   */\n\n\n  function directionStr(direction) {\n    if (direction == DIRECTION_DOWN) {\n      return 'down';\n    } else if (direction == DIRECTION_UP) {\n      return 'up';\n    } else if (direction == DIRECTION_LEFT) {\n      return 'left';\n    } else if (direction == DIRECTION_RIGHT) {\n      return 'right';\n    }\n\n    return '';\n  }\n  /**\n   * get a recognizer by name if it is bound to a manager\n   * @param {Recognizer|String} otherRecognizer\n   * @param {Recognizer} recognizer\n   * @returns {Recognizer}\n   */\n\n\n  function getRecognizerByNameIfManager(otherRecognizer, recognizer) {\n    var manager = recognizer.manager;\n\n    if (manager) {\n      return manager.get(otherRecognizer);\n    }\n\n    return otherRecognizer;\n  }\n  /**\n   * This recognizer is just used as a base for the simple attribute recognizers.\n   * @constructor\n   * @extends Recognizer\n   */\n\n\n  function AttrRecognizer() {\n    Recognizer.apply(this, arguments);\n  }\n\n  inherit(AttrRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof AttrRecognizer\n     */\n    defaults: {\n      /**\n       * @type {Number}\n       * @default 1\n       */\n      pointers: 1\n    },\n\n    /**\n     * Used to check if it the recognizer receives valid input, like input.distance > 10.\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {Boolean} recognized\n     */\n    attrTest: function (input) {\n      var optionPointers = this.options.pointers;\n      return optionPointers === 0 || input.pointers.length === optionPointers;\n    },\n\n    /**\n     * Process the input and return the state for the recognizer\n     * @memberof AttrRecognizer\n     * @param {Object} input\n     * @returns {*} State\n     */\n    process: function (input) {\n      var state = this.state;\n      var eventType = input.eventType;\n      var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);\n      var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED\n\n      if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {\n        return state | STATE_CANCELLED;\n      } else if (isRecognized || isValid) {\n        if (eventType & INPUT_END) {\n          return state | STATE_ENDED;\n        } else if (!(state & STATE_BEGAN)) {\n          return STATE_BEGAN;\n        }\n\n        return state | STATE_CHANGED;\n      }\n\n      return STATE_FAILED;\n    }\n  });\n  /**\n   * Pan\n   * Recognized when the pointer is down and moved in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PanRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n    this.pX = null;\n    this.pY = null;\n  }\n\n  inherit(PanRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PanRecognizer\n     */\n    defaults: {\n      event: 'pan',\n      threshold: 10,\n      pointers: 1,\n      direction: DIRECTION_ALL\n    },\n    getTouchAction: function () {\n      var direction = this.options.direction;\n      var actions = [];\n\n      if (direction & DIRECTION_HORIZONTAL) {\n        actions.push(TOUCH_ACTION_PAN_Y);\n      }\n\n      if (direction & DIRECTION_VERTICAL) {\n        actions.push(TOUCH_ACTION_PAN_X);\n      }\n\n      return actions;\n    },\n    directionTest: function (input) {\n      var options = this.options;\n      var hasMoved = true;\n      var distance = input.distance;\n      var direction = input.direction;\n      var x = input.deltaX;\n      var y = input.deltaY; // lock to axis?\n\n      if (!(direction & options.direction)) {\n        if (options.direction & DIRECTION_HORIZONTAL) {\n          direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;\n          hasMoved = x != this.pX;\n          distance = Math.abs(input.deltaX);\n        } else {\n          direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;\n          hasMoved = y != this.pY;\n          distance = Math.abs(input.deltaY);\n        }\n      }\n\n      input.direction = direction;\n      return hasMoved && distance > options.threshold && direction & options.direction;\n    },\n    attrTest: function (input) {\n      return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));\n    },\n    emit: function (input) {\n      this.pX = input.deltaX;\n      this.pY = input.deltaY;\n      var direction = directionStr(input.direction);\n\n      if (direction) {\n        input.additionalEvent = this.options.event + direction;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Pinch\n   * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function PinchRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(PinchRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'pinch',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);\n    },\n    emit: function (input) {\n      if (input.scale !== 1) {\n        var inOut = input.scale < 1 ? 'in' : 'out';\n        input.additionalEvent = this.options.event + inOut;\n      }\n\n      this._super.emit.call(this, input);\n    }\n  });\n  /**\n   * Press\n   * Recognized when the pointer is down for x ms without any movement.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function PressRecognizer() {\n    Recognizer.apply(this, arguments);\n    this._timer = null;\n    this._input = null;\n  }\n\n  inherit(PressRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PressRecognizer\n     */\n    defaults: {\n      event: 'press',\n      pointers: 1,\n      time: 251,\n      // minimal time of the pointer to be pressed\n      threshold: 9 // a minimal movement is ok, but keep it low\n\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_AUTO];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTime = input.deltaTime > options.time;\n      this._input = input; // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n      if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {\n        this.reset();\n      } else if (input.eventType & INPUT_START) {\n        this.reset();\n        this._timer = setTimeoutContext(function () {\n          this.state = STATE_RECOGNIZED;\n          this.tryEmit();\n        }, options.time, this);\n      } else if (input.eventType & INPUT_END) {\n        return STATE_RECOGNIZED;\n      }\n\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function (input) {\n      if (this.state !== STATE_RECOGNIZED) {\n        return;\n      }\n\n      if (input && input.eventType & INPUT_END) {\n        this.manager.emit(this.options.event + 'up', input);\n      } else {\n        this._input.timeStamp = now();\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Rotate\n   * Recognized when two or more pointer are moving in a circular motion.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function RotateRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(RotateRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof RotateRecognizer\n     */\n    defaults: {\n      event: 'rotate',\n      threshold: 0,\n      pointers: 2\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_NONE];\n    },\n    attrTest: function (input) {\n      return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);\n    }\n  });\n  /**\n   * Swipe\n   * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.\n   * @constructor\n   * @extends AttrRecognizer\n   */\n\n  function SwipeRecognizer() {\n    AttrRecognizer.apply(this, arguments);\n  }\n\n  inherit(SwipeRecognizer, AttrRecognizer, {\n    /**\n     * @namespace\n     * @memberof SwipeRecognizer\n     */\n    defaults: {\n      event: 'swipe',\n      threshold: 10,\n      velocity: 0.3,\n      direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,\n      pointers: 1\n    },\n    getTouchAction: function () {\n      return PanRecognizer.prototype.getTouchAction.call(this);\n    },\n    attrTest: function (input) {\n      var direction = this.options.direction;\n      var velocity;\n\n      if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {\n        velocity = input.overallVelocity;\n      } else if (direction & DIRECTION_HORIZONTAL) {\n        velocity = input.overallVelocityX;\n      } else if (direction & DIRECTION_VERTICAL) {\n        velocity = input.overallVelocityY;\n      }\n\n      return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;\n    },\n    emit: function (input) {\n      var direction = directionStr(input.offsetDirection);\n\n      if (direction) {\n        this.manager.emit(this.options.event + direction, input);\n      }\n\n      this.manager.emit(this.options.event, input);\n    }\n  });\n  /**\n   * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur\n   * between the given interval and position. The delay option can be used to recognize multi-taps without firing\n   * a single tap.\n   *\n   * The eventData from the emitted event contains the property `tapCount`, which contains the amount of\n   * multi-taps being recognized.\n   * @constructor\n   * @extends Recognizer\n   */\n\n  function TapRecognizer() {\n    Recognizer.apply(this, arguments); // previous time and center,\n    // used for tap counting\n\n    this.pTime = false;\n    this.pCenter = false;\n    this._timer = null;\n    this._input = null;\n    this.count = 0;\n  }\n\n  inherit(TapRecognizer, Recognizer, {\n    /**\n     * @namespace\n     * @memberof PinchRecognizer\n     */\n    defaults: {\n      event: 'tap',\n      pointers: 1,\n      taps: 1,\n      interval: 300,\n      // max time between the multi-tap taps\n      time: 250,\n      // max time of the pointer to be down (like finger on the screen)\n      threshold: 9,\n      // a minimal movement is ok, but keep it low\n      posThreshold: 10 // a multi-tap can be a bit off the initial position\n\n    },\n    getTouchAction: function () {\n      return [TOUCH_ACTION_MANIPULATION];\n    },\n    process: function (input) {\n      var options = this.options;\n      var validPointers = input.pointers.length === options.pointers;\n      var validMovement = input.distance < options.threshold;\n      var validTouchTime = input.deltaTime < options.time;\n      this.reset();\n\n      if (input.eventType & INPUT_START && this.count === 0) {\n        return this.failTimeout();\n      } // we only allow little movement\n      // and we've reached an end event, so a tap is possible\n\n\n      if (validMovement && validTouchTime && validPointers) {\n        if (input.eventType != INPUT_END) {\n          return this.failTimeout();\n        }\n\n        var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;\n        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;\n        this.pTime = input.timeStamp;\n        this.pCenter = input.center;\n\n        if (!validMultiTap || !validInterval) {\n          this.count = 1;\n        } else {\n          this.count += 1;\n        }\n\n        this._input = input; // if tap count matches we have recognized it,\n        // else it has began recognizing...\n\n        var tapCount = this.count % options.taps;\n\n        if (tapCount === 0) {\n          // no failing requirements, immediately trigger the tap event\n          // or wait as long as the multitap interval to trigger\n          if (!this.hasRequireFailures()) {\n            return STATE_RECOGNIZED;\n          } else {\n            this._timer = setTimeoutContext(function () {\n              this.state = STATE_RECOGNIZED;\n              this.tryEmit();\n            }, options.interval, this);\n            return STATE_BEGAN;\n          }\n        }\n      }\n\n      return STATE_FAILED;\n    },\n    failTimeout: function () {\n      this._timer = setTimeoutContext(function () {\n        this.state = STATE_FAILED;\n      }, this.options.interval, this);\n      return STATE_FAILED;\n    },\n    reset: function () {\n      clearTimeout(this._timer);\n    },\n    emit: function () {\n      if (this.state == STATE_RECOGNIZED) {\n        this._input.tapCount = this.count;\n        this.manager.emit(this.options.event, this._input);\n      }\n    }\n  });\n  /**\n   * Simple way to create a manager with a default set of recognizers.\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Hammer(element, options) {\n    options = options || {};\n    options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);\n    return new Manager(element, options);\n  }\n  /**\n   * @const {string}\n   */\n\n\n  Hammer.VERSION = '2.0.7';\n  /**\n   * default settings\n   * @namespace\n   */\n\n  Hammer.defaults = {\n    /**\n     * set if DOM events are being triggered.\n     * But this is slower and unused by simple implementations, so disabled by default.\n     * @type {Boolean}\n     * @default false\n     */\n    domEvents: false,\n\n    /**\n     * The value for the touchAction property/fallback.\n     * When set to `compute` it will magically set the correct value based on the added recognizers.\n     * @type {String}\n     * @default compute\n     */\n    touchAction: TOUCH_ACTION_COMPUTE,\n\n    /**\n     * @type {Boolean}\n     * @default true\n     */\n    enable: true,\n\n    /**\n     * EXPERIMENTAL FEATURE -- can be removed/changed\n     * Change the parent input target element.\n     * If Null, then it is being set the to main element.\n     * @type {Null|EventTarget}\n     * @default null\n     */\n    inputTarget: null,\n\n    /**\n     * force an input class\n     * @type {Null|Function}\n     * @default null\n     */\n    inputClass: null,\n\n    /**\n     * Default recognizer setup when calling `Hammer()`\n     * When creating a new Manager these will be skipped.\n     * @type {Array}\n     */\n    preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]\n    [RotateRecognizer, {\n      enable: false\n    }], [PinchRecognizer, {\n      enable: false\n    }, ['rotate']], [SwipeRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }], [PanRecognizer, {\n      direction: DIRECTION_HORIZONTAL\n    }, ['swipe']], [TapRecognizer], [TapRecognizer, {\n      event: 'doubletap',\n      taps: 2\n    }, ['tap']], [PressRecognizer]],\n\n    /**\n     * Some CSS properties can be used to improve the working of Hammer.\n     * Add them to this method and they will be set when creating a new Manager.\n     * @namespace\n     */\n    cssProps: {\n      /**\n       * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userSelect: 'none',\n\n      /**\n       * Disable the Windows Phone grippers when pressing an element.\n       * @type {String}\n       * @default 'none'\n       */\n      touchSelect: 'none',\n\n      /**\n       * Disables the default callout shown when you touch and hold a touch target.\n       * On iOS, when you touch and hold a touch target such as a link, Safari displays\n       * a callout containing information about the link. This property allows you to disable that callout.\n       * @type {String}\n       * @default 'none'\n       */\n      touchCallout: 'none',\n\n      /**\n       * Specifies whether zooming is enabled. Used by IE10>\n       * @type {String}\n       * @default 'none'\n       */\n      contentZooming: 'none',\n\n      /**\n       * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.\n       * @type {String}\n       * @default 'none'\n       */\n      userDrag: 'none',\n\n      /**\n       * Overrides the highlight color shown when the user taps a link or a JavaScript\n       * clickable element in iOS. This property obeys the alpha value, if specified.\n       * @type {String}\n       * @default 'rgba(0,0,0,0)'\n       */\n      tapHighlightColor: 'rgba(0,0,0,0)'\n    }\n  };\n  var STOP = 1;\n  var FORCED_STOP = 2;\n  /**\n   * Manager\n   * @param {HTMLElement} element\n   * @param {Object} [options]\n   * @constructor\n   */\n\n  function Manager(element, options) {\n    this.options = assign({}, Hammer.defaults, options || {});\n    this.options.inputTarget = this.options.inputTarget || element;\n    this.handlers = {};\n    this.session = {};\n    this.recognizers = [];\n    this.oldCssProps = {};\n    this.element = element;\n    this.input = createInputInstance(this);\n    this.touchAction = new TouchAction(this, this.options.touchAction);\n    toggleCssProps(this, true);\n    each(this.options.recognizers, function (item) {\n      var recognizer = this.add(new item[0](item[1]));\n      item[2] && recognizer.recognizeWith(item[2]);\n      item[3] && recognizer.requireFailure(item[3]);\n    }, this);\n  }\n\n  Manager.prototype = {\n    /**\n     * set options\n     * @param {Object} options\n     * @returns {Manager}\n     */\n    set: function (options) {\n      assign(this.options, options); // Options that need a little more setup\n\n      if (options.touchAction) {\n        this.touchAction.update();\n      }\n\n      if (options.inputTarget) {\n        // Clean up existing event listeners and reinitialize\n        this.input.destroy();\n        this.input.target = options.inputTarget;\n        this.input.init();\n      }\n\n      return this;\n    },\n\n    /**\n     * stop recognizing for this session.\n     * This session will be discarded, when a new [input]start event is fired.\n     * When forced, the recognizer cycle is stopped immediately.\n     * @param {Boolean} [force]\n     */\n    stop: function (force) {\n      this.session.stopped = force ? FORCED_STOP : STOP;\n    },\n\n    /**\n     * run the recognizers!\n     * called by the inputHandler function on every movement of the pointers (touches)\n     * it walks through all the recognizers and tries to detect the gesture that is being made\n     * @param {Object} inputData\n     */\n    recognize: function (inputData) {\n      var session = this.session;\n\n      if (session.stopped) {\n        return;\n      } // run the touch-action polyfill\n\n\n      this.touchAction.preventDefaults(inputData);\n      var recognizer;\n      var recognizers = this.recognizers; // this holds the recognizer that is being recognized.\n      // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED\n      // if no recognizer is detecting a thing, it is set to `null`\n\n      var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized\n      // or when we're in a new session\n\n      if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {\n        curRecognizer = session.curRecognizer = null;\n      }\n\n      var i = 0;\n\n      while (i < recognizers.length) {\n        recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.\n        // 1.   allow if the session is NOT forced stopped (see the .stop() method)\n        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one\n        //      that is being recognized.\n        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.\n        //      this can be setup with the `recognizeWith()` method on the recognizer.\n\n        if (session.stopped !== FORCED_STOP && ( // 1\n        !curRecognizer || recognizer == curRecognizer || // 2\n        recognizer.canRecognizeWith(curRecognizer))) {\n          // 3\n          recognizer.recognize(inputData);\n        } else {\n          recognizer.reset();\n        } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the\n        // current active recognizer. but only if we don't already have an active recognizer\n\n\n        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {\n          curRecognizer = session.curRecognizer = recognizer;\n        }\n\n        i++;\n      }\n    },\n\n    /**\n     * get a recognizer by its event name.\n     * @param {Recognizer|String} recognizer\n     * @returns {Recognizer|Null}\n     */\n    get: function (recognizer) {\n      if (recognizer instanceof Recognizer) {\n        return recognizer;\n      }\n\n      var recognizers = this.recognizers;\n\n      for (var i = 0; i < recognizers.length; i++) {\n        if (recognizers[i].options.event == recognizer) {\n          return recognizers[i];\n        }\n      }\n\n      return null;\n    },\n\n    /**\n     * add a recognizer to the manager\n     * existing recognizers with the same event name will be removed\n     * @param {Recognizer} recognizer\n     * @returns {Recognizer|Manager}\n     */\n    add: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'add', this)) {\n        return this;\n      } // remove existing\n\n\n      var existing = this.get(recognizer.options.event);\n\n      if (existing) {\n        this.remove(existing);\n      }\n\n      this.recognizers.push(recognizer);\n      recognizer.manager = this;\n      this.touchAction.update();\n      return recognizer;\n    },\n\n    /**\n     * remove a recognizer by name or instance\n     * @param {Recognizer|String} recognizer\n     * @returns {Manager}\n     */\n    remove: function (recognizer) {\n      if (invokeArrayArg(recognizer, 'remove', this)) {\n        return this;\n      }\n\n      recognizer = this.get(recognizer); // let's make sure this recognizer exists\n\n      if (recognizer) {\n        var recognizers = this.recognizers;\n        var index = inArray(recognizers, recognizer);\n\n        if (index !== -1) {\n          recognizers.splice(index, 1);\n          this.touchAction.update();\n        }\n      }\n\n      return this;\n    },\n\n    /**\n     * bind event\n     * @param {String} events\n     * @param {Function} handler\n     * @returns {EventEmitter} this\n     */\n    on: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      if (handler === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        handlers[event] = handlers[event] || [];\n        handlers[event].push(handler);\n      });\n      return this;\n    },\n\n    /**\n     * unbind event, leave emit blank to remove all handlers\n     * @param {String} events\n     * @param {Function} [handler]\n     * @returns {EventEmitter} this\n     */\n    off: function (events, handler) {\n      if (events === undefined) {\n        return;\n      }\n\n      var handlers = this.handlers;\n      each(splitStr(events), function (event) {\n        if (!handler) {\n          delete handlers[event];\n        } else {\n          handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);\n        }\n      });\n      return this;\n    },\n\n    /**\n     * emit event to the listeners\n     * @param {String} event\n     * @param {Object} data\n     */\n    emit: function (event, data) {\n      // we also want to trigger dom events\n      if (this.options.domEvents) {\n        triggerDomEvent(event, data);\n      } // no handlers, so skip it all\n\n\n      var handlers = this.handlers[event] && this.handlers[event].slice();\n\n      if (!handlers || !handlers.length) {\n        return;\n      }\n\n      data.type = event;\n\n      data.preventDefault = function () {\n        data.srcEvent.preventDefault();\n      };\n\n      var i = 0;\n\n      while (i < handlers.length) {\n        handlers[i](data);\n        i++;\n      }\n    },\n\n    /**\n     * destroy the manager and unbinds all events\n     * it doesn't unbind dom events, that is the user own responsibility\n     */\n    destroy: function () {\n      this.element && toggleCssProps(this, false);\n      this.handlers = {};\n      this.session = {};\n      this.input.destroy();\n      this.element = null;\n    }\n  };\n  /**\n   * add/remove the css properties as defined in manager.options.cssProps\n   * @param {Manager} manager\n   * @param {Boolean} add\n   */\n\n  function toggleCssProps(manager, add) {\n    var element = manager.element;\n\n    if (!element.style) {\n      return;\n    }\n\n    var prop;\n    each(manager.options.cssProps, function (value, name) {\n      prop = prefixed(element.style, name);\n\n      if (add) {\n        manager.oldCssProps[prop] = element.style[prop];\n        element.style[prop] = value;\n      } else {\n        element.style[prop] = manager.oldCssProps[prop] || '';\n      }\n    });\n\n    if (!add) {\n      manager.oldCssProps = {};\n    }\n  }\n  /**\n   * trigger dom event\n   * @param {String} event\n   * @param {Object} data\n   */\n\n\n  function triggerDomEvent(event, data) {\n    var gestureEvent = document.createEvent('Event');\n    gestureEvent.initEvent(event, true, true);\n    gestureEvent.gesture = data;\n    data.target.dispatchEvent(gestureEvent);\n  }\n\n  assign(Hammer, {\n    INPUT_START: INPUT_START,\n    INPUT_MOVE: INPUT_MOVE,\n    INPUT_END: INPUT_END,\n    INPUT_CANCEL: INPUT_CANCEL,\n    STATE_POSSIBLE: STATE_POSSIBLE,\n    STATE_BEGAN: STATE_BEGAN,\n    STATE_CHANGED: STATE_CHANGED,\n    STATE_ENDED: STATE_ENDED,\n    STATE_RECOGNIZED: STATE_RECOGNIZED,\n    STATE_CANCELLED: STATE_CANCELLED,\n    STATE_FAILED: STATE_FAILED,\n    DIRECTION_NONE: DIRECTION_NONE,\n    DIRECTION_LEFT: DIRECTION_LEFT,\n    DIRECTION_RIGHT: DIRECTION_RIGHT,\n    DIRECTION_UP: DIRECTION_UP,\n    DIRECTION_DOWN: DIRECTION_DOWN,\n    DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,\n    DIRECTION_VERTICAL: DIRECTION_VERTICAL,\n    DIRECTION_ALL: DIRECTION_ALL,\n    Manager: Manager,\n    Input: Input,\n    TouchAction: TouchAction,\n    TouchInput: TouchInput,\n    MouseInput: MouseInput,\n    PointerEventInput: PointerEventInput,\n    TouchMouseInput: TouchMouseInput,\n    SingleTouchInput: SingleTouchInput,\n    Recognizer: Recognizer,\n    AttrRecognizer: AttrRecognizer,\n    Tap: TapRecognizer,\n    Pan: PanRecognizer,\n    Swipe: SwipeRecognizer,\n    Pinch: PinchRecognizer,\n    Rotate: RotateRecognizer,\n    Press: PressRecognizer,\n    on: addEventListeners,\n    off: removeEventListeners,\n    each: each,\n    merge: merge,\n    extend: extend,\n    assign: assign,\n    inherit: inherit,\n    bindFn: bindFn,\n    prefixed: prefixed\n  }); // this prevents errors when Hammer is loaded in the presence of an AMD\n  //  style loader but by script tag, not by the loader.\n\n  var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line\n\n  freeGlobal.Hammer = Hammer;\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return Hammer;\n    }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(window, document, 'Hammer');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFtbWVyanMvaGFtbWVyLmpzP2M4YjUiXSwibmFtZXMiOlsid2luZG93IiwiZG9jdW1lbnQiLCJleHBvcnROYW1lIiwidW5kZWZpbmVkIiwiVkVORE9SX1BSRUZJWEVTIiwiVEVTVF9FTEVNRU5UIiwiY3JlYXRlRWxlbWVudCIsIlRZUEVfRlVOQ1RJT04iLCJyb3VuZCIsIk1hdGgiLCJhYnMiLCJub3ciLCJEYXRlIiwic2V0VGltZW91dENvbnRleHQiLCJmbiIsInRpbWVvdXQiLCJjb250ZXh0Iiwic2V0VGltZW91dCIsImJpbmRGbiIsImludm9rZUFycmF5QXJnIiwiYXJnIiwiQXJyYXkiLCJpc0FycmF5IiwiZWFjaCIsIm9iaiIsIml0ZXJhdG9yIiwiaSIsImZvckVhY2giLCJsZW5ndGgiLCJjYWxsIiwiaGFzT3duUHJvcGVydHkiLCJkZXByZWNhdGUiLCJtZXRob2QiLCJuYW1lIiwibWVzc2FnZSIsImRlcHJlY2F0aW9uTWVzc2FnZSIsImUiLCJFcnJvciIsInN0YWNrIiwicmVwbGFjZSIsImxvZyIsImNvbnNvbGUiLCJ3YXJuIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJhc3NpZ24iLCJPYmplY3QiLCJ0YXJnZXQiLCJUeXBlRXJyb3IiLCJvdXRwdXQiLCJpbmRleCIsInNvdXJjZSIsIm5leHRLZXkiLCJleHRlbmQiLCJkZXN0Iiwic3JjIiwibWVyZ2UiLCJrZXlzIiwiaW5oZXJpdCIsImNoaWxkIiwiYmFzZSIsInByb3BlcnRpZXMiLCJiYXNlUCIsInByb3RvdHlwZSIsImNoaWxkUCIsImNyZWF0ZSIsImNvbnN0cnVjdG9yIiwiX3N1cGVyIiwiYm91bmRGbiIsImJvb2xPckZuIiwidmFsIiwiYXJncyIsImlmVW5kZWZpbmVkIiwidmFsMSIsInZhbDIiLCJhZGRFdmVudExpc3RlbmVycyIsInR5cGVzIiwiaGFuZGxlciIsInNwbGl0U3RyIiwidHlwZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYXNQYXJlbnQiLCJub2RlIiwicGFyZW50IiwicGFyZW50Tm9kZSIsImluU3RyIiwic3RyIiwiZmluZCIsImluZGV4T2YiLCJ0cmltIiwic3BsaXQiLCJpbkFycmF5IiwiZmluZEJ5S2V5IiwidG9BcnJheSIsInNsaWNlIiwidW5pcXVlQXJyYXkiLCJrZXkiLCJzb3J0IiwicmVzdWx0cyIsInZhbHVlcyIsInB1c2giLCJzb3J0VW5pcXVlQXJyYXkiLCJhIiwiYiIsInByZWZpeGVkIiwicHJvcGVydHkiLCJwcmVmaXgiLCJwcm9wIiwiY2FtZWxQcm9wIiwidG9VcHBlckNhc2UiLCJfdW5pcXVlSWQiLCJ1bmlxdWVJZCIsImdldFdpbmRvd0ZvckVsZW1lbnQiLCJlbGVtZW50IiwiZG9jIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiTU9CSUxFX1JFR0VYIiwiU1VQUE9SVF9UT1VDSCIsIlNVUFBPUlRfUE9JTlRFUl9FVkVOVFMiLCJTVVBQT1JUX09OTFlfVE9VQ0giLCJ0ZXN0IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiSU5QVVRfVFlQRV9UT1VDSCIsIklOUFVUX1RZUEVfUEVOIiwiSU5QVVRfVFlQRV9NT1VTRSIsIklOUFVUX1RZUEVfS0lORUNUIiwiQ09NUFVURV9JTlRFUlZBTCIsIklOUFVUX1NUQVJUIiwiSU5QVVRfTU9WRSIsIklOUFVUX0VORCIsIklOUFVUX0NBTkNFTCIsIkRJUkVDVElPTl9OT05FIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fUklHSFQiLCJESVJFQ1RJT05fVVAiLCJESVJFQ1RJT05fRE9XTiIsIkRJUkVDVElPTl9IT1JJWk9OVEFMIiwiRElSRUNUSU9OX1ZFUlRJQ0FMIiwiRElSRUNUSU9OX0FMTCIsIlBST1BTX1hZIiwiUFJPUFNfQ0xJRU5UX1hZIiwiSW5wdXQiLCJtYW5hZ2VyIiwiY2FsbGJhY2siLCJzZWxmIiwib3B0aW9ucyIsImlucHV0VGFyZ2V0IiwiZG9tSGFuZGxlciIsImV2IiwiZW5hYmxlIiwiaW5pdCIsImV2RWwiLCJldlRhcmdldCIsImV2V2luIiwiZGVzdHJveSIsImNyZWF0ZUlucHV0SW5zdGFuY2UiLCJUeXBlIiwiaW5wdXRDbGFzcyIsIlBvaW50ZXJFdmVudElucHV0IiwiVG91Y2hJbnB1dCIsIk1vdXNlSW5wdXQiLCJUb3VjaE1vdXNlSW5wdXQiLCJpbnB1dEhhbmRsZXIiLCJldmVudFR5cGUiLCJpbnB1dCIsInBvaW50ZXJzTGVuIiwicG9pbnRlcnMiLCJjaGFuZ2VkUG9pbnRlcnNMZW4iLCJjaGFuZ2VkUG9pbnRlcnMiLCJpc0ZpcnN0IiwiaXNGaW5hbCIsInNlc3Npb24iLCJjb21wdXRlSW5wdXREYXRhIiwiZW1pdCIsInJlY29nbml6ZSIsInByZXZJbnB1dCIsInBvaW50ZXJzTGVuZ3RoIiwiZmlyc3RJbnB1dCIsInNpbXBsZUNsb25lSW5wdXREYXRhIiwiZmlyc3RNdWx0aXBsZSIsIm9mZnNldENlbnRlciIsImNlbnRlciIsImdldENlbnRlciIsInRpbWVTdGFtcCIsImRlbHRhVGltZSIsImFuZ2xlIiwiZ2V0QW5nbGUiLCJkaXN0YW5jZSIsImdldERpc3RhbmNlIiwiY29tcHV0ZURlbHRhWFkiLCJvZmZzZXREaXJlY3Rpb24iLCJnZXREaXJlY3Rpb24iLCJkZWx0YVgiLCJkZWx0YVkiLCJvdmVyYWxsVmVsb2NpdHkiLCJnZXRWZWxvY2l0eSIsIm92ZXJhbGxWZWxvY2l0eVgiLCJ4Iiwib3ZlcmFsbFZlbG9jaXR5WSIsInkiLCJzY2FsZSIsImdldFNjYWxlIiwicm90YXRpb24iLCJnZXRSb3RhdGlvbiIsIm1heFBvaW50ZXJzIiwiY29tcHV0ZUludGVydmFsSW5wdXREYXRhIiwic3JjRXZlbnQiLCJvZmZzZXQiLCJvZmZzZXREZWx0YSIsInByZXZEZWx0YSIsImxhc3QiLCJsYXN0SW50ZXJ2YWwiLCJ2ZWxvY2l0eSIsInZlbG9jaXR5WCIsInZlbG9jaXR5WSIsImRpcmVjdGlvbiIsInYiLCJjbGllbnRYIiwiY2xpZW50WSIsInAxIiwicDIiLCJwcm9wcyIsInNxcnQiLCJhdGFuMiIsIlBJIiwic3RhcnQiLCJlbmQiLCJNT1VTRV9JTlBVVF9NQVAiLCJtb3VzZWRvd24iLCJtb3VzZW1vdmUiLCJtb3VzZXVwIiwiTU9VU0VfRUxFTUVOVF9FVkVOVFMiLCJNT1VTRV9XSU5ET1dfRVZFTlRTIiwicHJlc3NlZCIsIk1FaGFuZGxlciIsImJ1dHRvbiIsIndoaWNoIiwicG9pbnRlclR5cGUiLCJQT0lOVEVSX0lOUFVUX01BUCIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVyY2FuY2VsIiwicG9pbnRlcm91dCIsIklFMTBfUE9JTlRFUl9UWVBFX0VOVU0iLCJQT0lOVEVSX0VMRU1FTlRfRVZFTlRTIiwiUE9JTlRFUl9XSU5ET1dfRVZFTlRTIiwiTVNQb2ludGVyRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJzdG9yZSIsInBvaW50ZXJFdmVudHMiLCJQRWhhbmRsZXIiLCJyZW1vdmVQb2ludGVyIiwiZXZlbnRUeXBlTm9ybWFsaXplZCIsInRvTG93ZXJDYXNlIiwiaXNUb3VjaCIsInN0b3JlSW5kZXgiLCJwb2ludGVySWQiLCJzcGxpY2UiLCJTSU5HTEVfVE9VQ0hfSU5QVVRfTUFQIiwidG91Y2hzdGFydCIsInRvdWNobW92ZSIsInRvdWNoZW5kIiwidG91Y2hjYW5jZWwiLCJTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUyIsIlNJTkdMRV9UT1VDSF9XSU5ET1dfRVZFTlRTIiwiU2luZ2xlVG91Y2hJbnB1dCIsInN0YXJ0ZWQiLCJURWhhbmRsZXIiLCJ0b3VjaGVzIiwibm9ybWFsaXplU2luZ2xlVG91Y2hlcyIsImFsbCIsImNoYW5nZWQiLCJjaGFuZ2VkVG91Y2hlcyIsImNvbmNhdCIsIlRPVUNIX0lOUFVUX01BUCIsIlRPVUNIX1RBUkdFVF9FVkVOVFMiLCJ0YXJnZXRJZHMiLCJNVEVoYW5kbGVyIiwiZ2V0VG91Y2hlcyIsImFsbFRvdWNoZXMiLCJpZGVudGlmaWVyIiwidGFyZ2V0VG91Y2hlcyIsImNoYW5nZWRUYXJnZXRUb3VjaGVzIiwiZmlsdGVyIiwidG91Y2giLCJERURVUF9USU1FT1VUIiwiREVEVVBfRElTVEFOQ0UiLCJtb3VzZSIsInByaW1hcnlUb3VjaCIsImxhc3RUb3VjaGVzIiwiVE1FaGFuZGxlciIsImlucHV0RXZlbnQiLCJpbnB1dERhdGEiLCJpc01vdXNlIiwic291cmNlQ2FwYWJpbGl0aWVzIiwiZmlyZXNUb3VjaEV2ZW50cyIsInJlY29yZFRvdWNoZXMiLCJpc1N5bnRoZXRpY0V2ZW50IiwiZXZlbnREYXRhIiwic2V0TGFzdFRvdWNoIiwibGFzdFRvdWNoIiwibHRzIiwicmVtb3ZlTGFzdFRvdWNoIiwidCIsImR4IiwiZHkiLCJQUkVGSVhFRF9UT1VDSF9BQ1RJT04iLCJzdHlsZSIsIk5BVElWRV9UT1VDSF9BQ1RJT04iLCJUT1VDSF9BQ1RJT05fQ09NUFVURSIsIlRPVUNIX0FDVElPTl9BVVRPIiwiVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiIsIlRPVUNIX0FDVElPTl9OT05FIiwiVE9VQ0hfQUNUSU9OX1BBTl9YIiwiVE9VQ0hfQUNUSU9OX1BBTl9ZIiwiVE9VQ0hfQUNUSU9OX01BUCIsImdldFRvdWNoQWN0aW9uUHJvcHMiLCJUb3VjaEFjdGlvbiIsInZhbHVlIiwic2V0IiwiY29tcHV0ZSIsImFjdGlvbnMiLCJ1cGRhdGUiLCJ0b3VjaEFjdGlvbiIsInJlY29nbml6ZXJzIiwicmVjb2duaXplciIsImdldFRvdWNoQWN0aW9uIiwiY2xlYW5Ub3VjaEFjdGlvbnMiLCJqb2luIiwicHJldmVudERlZmF1bHRzIiwicHJldmVudGVkIiwicHJldmVudERlZmF1bHQiLCJoYXNOb25lIiwiaGFzUGFuWSIsImhhc1BhblgiLCJpc1RhcFBvaW50ZXIiLCJpc1RhcE1vdmVtZW50IiwiaXNUYXBUb3VjaFRpbWUiLCJwcmV2ZW50U3JjIiwidG91Y2hNYXAiLCJjc3NTdXBwb3J0cyIsIkNTUyIsInN1cHBvcnRzIiwiU1RBVEVfUE9TU0lCTEUiLCJTVEFURV9CRUdBTiIsIlNUQVRFX0NIQU5HRUQiLCJTVEFURV9FTkRFRCIsIlNUQVRFX1JFQ09HTklaRUQiLCJTVEFURV9DQU5DRUxMRUQiLCJTVEFURV9GQUlMRUQiLCJSZWNvZ25pemVyIiwiZGVmYXVsdHMiLCJpZCIsInN0YXRlIiwic2ltdWx0YW5lb3VzIiwicmVxdWlyZUZhaWwiLCJyZWNvZ25pemVXaXRoIiwib3RoZXJSZWNvZ25pemVyIiwiZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlciIsImRyb3BSZWNvZ25pemVXaXRoIiwicmVxdWlyZUZhaWx1cmUiLCJkcm9wUmVxdWlyZUZhaWx1cmUiLCJoYXNSZXF1aXJlRmFpbHVyZXMiLCJjYW5SZWNvZ25pemVXaXRoIiwiZXZlbnQiLCJzdGF0ZVN0ciIsImFkZGl0aW9uYWxFdmVudCIsInRyeUVtaXQiLCJjYW5FbWl0IiwiaW5wdXREYXRhQ2xvbmUiLCJyZXNldCIsInByb2Nlc3MiLCJkaXJlY3Rpb25TdHIiLCJnZXQiLCJBdHRyUmVjb2duaXplciIsImF0dHJUZXN0Iiwib3B0aW9uUG9pbnRlcnMiLCJpc1JlY29nbml6ZWQiLCJpc1ZhbGlkIiwiUGFuUmVjb2duaXplciIsInBYIiwicFkiLCJ0aHJlc2hvbGQiLCJkaXJlY3Rpb25UZXN0IiwiaGFzTW92ZWQiLCJQaW5jaFJlY29nbml6ZXIiLCJpbk91dCIsIlByZXNzUmVjb2duaXplciIsIl90aW1lciIsIl9pbnB1dCIsInRpbWUiLCJ2YWxpZFBvaW50ZXJzIiwidmFsaWRNb3ZlbWVudCIsInZhbGlkVGltZSIsImNsZWFyVGltZW91dCIsIlJvdGF0ZVJlY29nbml6ZXIiLCJTd2lwZVJlY29nbml6ZXIiLCJUYXBSZWNvZ25pemVyIiwicFRpbWUiLCJwQ2VudGVyIiwiY291bnQiLCJ0YXBzIiwiaW50ZXJ2YWwiLCJwb3NUaHJlc2hvbGQiLCJ2YWxpZFRvdWNoVGltZSIsImZhaWxUaW1lb3V0IiwidmFsaWRJbnRlcnZhbCIsInZhbGlkTXVsdGlUYXAiLCJ0YXBDb3VudCIsIkhhbW1lciIsInByZXNldCIsIk1hbmFnZXIiLCJWRVJTSU9OIiwiZG9tRXZlbnRzIiwiY3NzUHJvcHMiLCJ1c2VyU2VsZWN0IiwidG91Y2hTZWxlY3QiLCJ0b3VjaENhbGxvdXQiLCJjb250ZW50Wm9vbWluZyIsInVzZXJEcmFnIiwidGFwSGlnaGxpZ2h0Q29sb3IiLCJTVE9QIiwiRk9SQ0VEX1NUT1AiLCJoYW5kbGVycyIsIm9sZENzc1Byb3BzIiwidG9nZ2xlQ3NzUHJvcHMiLCJpdGVtIiwiYWRkIiwic3RvcCIsImZvcmNlIiwic3RvcHBlZCIsImN1clJlY29nbml6ZXIiLCJleGlzdGluZyIsInJlbW92ZSIsIm9uIiwiZXZlbnRzIiwib2ZmIiwiZGF0YSIsInRyaWdnZXJEb21FdmVudCIsImdlc3R1cmVFdmVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiZ2VzdHVyZSIsImRpc3BhdGNoRXZlbnQiLCJUYXAiLCJQYW4iLCJTd2lwZSIsIlBpbmNoIiwiUm90YXRlIiwiUHJlc3MiLCJmcmVlR2xvYmFsIiwiZGVmaW5lIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxVQUFTQSxNQUFULEVBQWlCQyxRQUFqQixFQUEyQkMsVUFBM0IsRUFBdUNDLFNBQXZDLEVBQWtEO0FBQ2pEOztBQUVGLE1BQUlDLGVBQWUsR0FBRyxDQUFDLEVBQUQsRUFBSyxRQUFMLEVBQWUsS0FBZixFQUFzQixJQUF0QixFQUE0QixJQUE1QixFQUFrQyxHQUFsQyxDQUF0QjtBQUNBLE1BQUlDLFlBQVksR0FBR0osUUFBUSxDQUFDSyxhQUFULENBQXVCLEtBQXZCLENBQW5CO0FBRUEsTUFBSUMsYUFBYSxHQUFHLFVBQXBCO0FBRUEsTUFBSUMsS0FBSyxHQUFHQyxJQUFJLENBQUNELEtBQWpCO0FBQ0EsTUFBSUUsR0FBRyxHQUFHRCxJQUFJLENBQUNDLEdBQWY7QUFDQSxNQUFJQyxHQUFHLEdBQUdDLElBQUksQ0FBQ0QsR0FBZjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFdBQVNFLGlCQUFULENBQTJCQyxFQUEzQixFQUEr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SUFBUCxLQUFnQixXQUFoQixHQUE4QkEsSUFBOUIsR0FBcUMsRUFBakcsQ0Foa0ZtRCxDQWdrRm9EOztBQUN2R21ULFlBQVUsQ0FBQ3pDLE1BQVgsR0FBb0JBLE1BQXBCOztBQUVBLE1BQUksSUFBSixFQUFnRDtBQUM1QzBDLHVDQUFPLFlBQVc7QUFDZCxhQUFPMUMsTUFBUDtBQUNILEtBRks7QUFBQSxrR0FBTjtBQUdILEdBSkQsTUFJTyxFQUlOO0FBRUEsQ0E3a0ZELEVBNmtGRy9aLE1BN2tGSCxFQTZrRldDLFFBN2tGWCxFQTZrRnFCLFFBN2tGckIiLCJmaWxlIjoiMTMzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qISBIYW1tZXIuSlMgLSB2Mi4wLjcgLSAyMDE2LTA0LTIyXG4gKiBodHRwOi8vaGFtbWVyanMuZ2l0aHViLmlvL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNiBKb3JpayBUYW5nZWxkZXI7XG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgKi9cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50LCBleHBvcnROYW1lLCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG52YXIgVkVORE9SX1BSRUZJWEVTID0gWycnLCAnd2Via2l0JywgJ01veicsICdNUycsICdtcycsICdvJ107XG52YXIgVEVTVF9FTEVNRU5UID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbnZhciBUWVBFX0ZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblxudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBub3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBzZXQgYSB0aW1lb3V0IHdpdGggYSBnaXZlbiBzY29wZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gc2V0VGltZW91dENvbnRleHQoZm4sIHRpbWVvdXQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChiaW5kRm4oZm4sIGNvbnRleHQpLCB0aW1lb3V0KTtcbn1cblxuLyoqXG4gKiBpZiB0aGUgYXJndW1lbnQgaXMgYW4gYXJyYXksIHdlIHdhbnQgdG8gZXhlY3V0ZSB0aGUgZm4gb24gZWFjaCBlbnRyeVxuICogaWYgaXQgYWludCBhbiBhcnJheSB3ZSBkb24ndCB3YW50IHRvIGRvIGEgdGhpbmcuXG4gKiB0aGlzIGlzIHVzZWQgYnkgYWxsIHRoZSBtZXRob2RzIHRoYXQgYWNjZXB0IGEgc2luZ2xlIGFuZCBhcnJheSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7KnxBcnJheX0gYXJnXG4gKiBAcGFyYW0ge1N0cmluZ30gZm5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpbnZva2VBcnJheUFyZyhhcmcsIGZuLCBjb250ZXh0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgICBlYWNoKGFyZywgY29udGV4dFtmbl0sIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHdhbGsgb2JqZWN0cyBhbmQgYXJyYXlzXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRvclxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZWFjaChvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgdmFyIGk7XG5cbiAgICBpZiAoIW9iaikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBvYmoubGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgIG9iai5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiB3cmFwIGEgbWV0aG9kIHdpdGggYSBkZXByZWNhdGlvbiB3YXJuaW5nIGFuZCBzdGFjayB0cmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gQSBuZXcgZnVuY3Rpb24gd3JhcHBpbmcgdGhlIHN1cHBsaWVkIG1ldGhvZC5cbiAqL1xuZnVuY3Rpb24gZGVwcmVjYXRlKG1ldGhvZCwgbmFtZSwgbWVzc2FnZSkge1xuICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSAnREVQUkVDQVRFRCBNRVRIT0Q6ICcgKyBuYW1lICsgJ1xcbicgKyBtZXNzYWdlICsgJyBBVCBcXG4nO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ2dldC1zdGFjay10cmFjZScpO1xuICAgICAgICB2YXIgc3RhY2sgPSBlICYmIGUuc3RhY2sgPyBlLnN0YWNrLnJlcGxhY2UoL15bXlxcKF0rP1tcXG4kXS9nbSwgJycpXG4gICAgICAgICAgICAucmVwbGFjZSgvXlxccythdFxccysvZ20sICcnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoL2dtLCAne2Fub255bW91c30oKUAnKSA6ICdVbmtub3duIFN0YWNrIFRyYWNlJztcblxuICAgICAgICB2YXIgbG9nID0gd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLndhcm4gfHwgd2luZG93LmNvbnNvbGUubG9nKTtcbiAgICAgICAgaWYgKGxvZykge1xuICAgICAgICAgICAgbG9nLmNhbGwod2luZG93LmNvbnNvbGUsIGRlcHJlY2F0aW9uTWVzc2FnZSwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIGV4dGVuZCBvYmplY3QuXG4gKiBtZWFucyB0aGF0IHByb3BlcnRpZXMgaW4gZGVzdCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBvbmVzIGluIHNyYy5cbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBvYmplY3RzX3RvX2Fzc2lnblxuICogQHJldHVybnMge09iamVjdH0gdGFyZ2V0XG4gKi9cbnZhciBhc3NpZ247XG5pZiAodHlwZW9mIE9iamVjdC5hc3NpZ24gIT09ICdmdW5jdGlvbicpIHtcbiAgICBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IE9iamVjdCh0YXJnZXQpO1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQgJiYgc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbmV4dEtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5oYXNPd25Qcm9wZXJ0eShuZXh0S2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0W25leHRLZXldID0gc291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcbn1cblxuLyoqXG4gKiBleHRlbmQgb2JqZWN0LlxuICogbWVhbnMgdGhhdCBwcm9wZXJ0aWVzIGluIGRlc3Qgd2lsbCBiZSBvdmVyd3JpdHRlbiBieSB0aGUgb25lcyBpbiBzcmMuXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHBhcmFtIHtCb29sZWFufSBbbWVyZ2U9ZmFsc2VdXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBkZXN0XG4gKi9cbnZhciBleHRlbmQgPSBkZXByZWNhdGUoZnVuY3Rpb24gZXh0ZW5kKGRlc3QsIHNyYywgbWVyZ2UpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHNyYyk7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwga2V5cy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFtZXJnZSB8fCAobWVyZ2UgJiYgZGVzdFtrZXlzW2ldXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgZGVzdFtrZXlzW2ldXSA9IHNyY1trZXlzW2ldXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufSwgJ2V4dGVuZCcsICdVc2UgYGFzc2lnbmAuJyk7XG5cbi8qKlxuICogbWVyZ2UgdGhlIHZhbHVlcyBmcm9tIHNyYyBpbiB0aGUgZGVzdC5cbiAqIG1lYW5zIHRoYXQgcHJvcGVydGllcyB0aGF0IGV4aXN0IGluIGRlc3Qgd2lsbCBub3QgYmUgb3ZlcndyaXR0ZW4gYnkgc3JjXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdFxuICogQHBhcmFtIHtPYmplY3R9IHNyY1xuICogQHJldHVybnMge09iamVjdH0gZGVzdFxuICovXG52YXIgbWVyZ2UgPSBkZXByZWNhdGUoZnVuY3Rpb24gbWVyZ2UoZGVzdCwgc3JjKSB7XG4gICAgcmV0dXJuIGV4dGVuZChkZXN0LCBzcmMsIHRydWUpO1xufSwgJ21lcmdlJywgJ1VzZSBgYXNzaWduYC4nKTtcblxuLyoqXG4gKiBzaW1wbGUgY2xhc3MgaW5oZXJpdGFuY2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNoaWxkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdXG4gKi9cbmZ1bmN0aW9uIGluaGVyaXQoY2hpbGQsIGJhc2UsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgYmFzZVAgPSBiYXNlLnByb3RvdHlwZSxcbiAgICAgICAgY2hpbGRQO1xuXG4gICAgY2hpbGRQID0gY2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShiYXNlUCk7XG4gICAgY2hpbGRQLmNvbnN0cnVjdG9yID0gY2hpbGQ7XG4gICAgY2hpbGRQLl9zdXBlciA9IGJhc2VQO1xuXG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgYXNzaWduKGNoaWxkUCwgcHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIHNpbXBsZSBmdW5jdGlvbiBiaW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gYmluZEZuKGZuLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGJvdW5kRm4oKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbi8qKlxuICogbGV0IGEgYm9vbGVhbiB2YWx1ZSBhbHNvIGJlIGEgZnVuY3Rpb24gdGhhdCBtdXN0IHJldHVybiBhIGJvb2xlYW5cbiAqIHRoaXMgZmlyc3QgaXRlbSBpbiBhcmdzIHdpbGwgYmUgdXNlZCBhcyB0aGUgY29udGV4dFxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSB2YWxcbiAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGJvb2xPckZuKHZhbCwgYXJncykge1xuICAgIGlmICh0eXBlb2YgdmFsID09IFRZUEVfRlVOQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIHZhbC5hcHBseShhcmdzID8gYXJnc1swXSB8fCB1bmRlZmluZWQgOiB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIHVzZSB0aGUgdmFsMiB3aGVuIHZhbDEgaXMgdW5kZWZpbmVkXG4gKiBAcGFyYW0geyp9IHZhbDFcbiAqIEBwYXJhbSB7Kn0gdmFsMlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGlmVW5kZWZpbmVkKHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gKHZhbDEgPT09IHVuZGVmaW5lZCkgPyB2YWwyIDogdmFsMTtcbn1cblxuLyoqXG4gKiBhZGRFdmVudExpc3RlbmVyIHdpdGggbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2VcbiAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKHRhcmdldCwgdHlwZXMsIGhhbmRsZXIpIHtcbiAgICBlYWNoKHNwbGl0U3RyKHR5cGVzKSwgZnVuY3Rpb24odHlwZSkge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogcmVtb3ZlRXZlbnRMaXN0ZW5lciB3aXRoIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyh0YXJnZXQsIHR5cGVzLCBoYW5kbGVyKSB7XG4gICAgZWFjaChzcGxpdFN0cih0eXBlcyksIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIGZpbmQgaWYgYSBub2RlIGlzIGluIHRoZSBnaXZlbiBwYXJlbnRcbiAqIEBtZXRob2QgaGFzUGFyZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGZvdW5kXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChub2RlLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBzbWFsbCBpbmRleE9mIHdyYXBwZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaW5kXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gZm91bmRcbiAqL1xuZnVuY3Rpb24gaW5TdHIoc3RyLCBmaW5kKSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKGZpbmQpID4gLTE7XG59XG5cbi8qKlxuICogc3BsaXQgc3RyaW5nIG9uIHdoaXRlc3BhY2VcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm5zIHtBcnJheX0gd29yZHNcbiAqL1xuZnVuY3Rpb24gc3BsaXRTdHIoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCkuc3BsaXQoL1xccysvZyk7XG59XG5cbi8qKlxuICogZmluZCBpZiBhIGFycmF5IGNvbnRhaW5zIHRoZSBvYmplY3QgdXNpbmcgaW5kZXhPZiBvciBhIHNpbXBsZSBwb2x5RmlsbFxuICogQHBhcmFtIHtBcnJheX0gc3JjXG4gKiBAcGFyYW0ge1N0cmluZ30gZmluZFxuICogQHBhcmFtIHtTdHJpbmd9IFtmaW5kQnlLZXldXG4gKiBAcmV0dXJuIHtCb29sZWFufE51bWJlcn0gZmFsc2Ugd2hlbiBub3QgZm91bmQsIG9yIHRoZSBpbmRleFxuICovXG5mdW5jdGlvbiBpbkFycmF5KHNyYywgZmluZCwgZmluZEJ5S2V5KSB7XG4gICAgaWYgKHNyYy5pbmRleE9mICYmICFmaW5kQnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHNyYy5pbmRleE9mKGZpbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoKGZpbmRCeUtleSAmJiBzcmNbaV1bZmluZEJ5S2V5XSA9PSBmaW5kKSB8fCAoIWZpbmRCeUtleSAmJiBzcmNbaV0gPT09IGZpbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn1cblxuLyoqXG4gKiBjb252ZXJ0IGFycmF5LWxpa2Ugb2JqZWN0cyB0byByZWFsIGFycmF5c1xuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybnMge0FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmosIDApO1xufVxuXG4vKipcbiAqIHVuaXF1ZSBhcnJheSB3aXRoIG9iamVjdHMgYmFzZWQgb24gYSBrZXkgKGxpa2UgJ2lkJykgb3IganVzdCBieSB0aGUgYXJyYXkncyB2YWx1ZVxuICogQHBhcmFtIHtBcnJheX0gc3JjIFt7aWQ6MX0se2lkOjJ9LHtpZDoxfV1cbiAqIEBwYXJhbSB7U3RyaW5nfSBba2V5XVxuICogQHBhcmFtIHtCb29sZWFufSBbc29ydD1GYWxzZV1cbiAqIEByZXR1cm5zIHtBcnJheX0gW3tpZDoxfSx7aWQ6Mn1dXG4gKi9cbmZ1bmN0aW9uIHVuaXF1ZUFycmF5KHNyYywga2V5LCBzb3J0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWwgPSBrZXkgPyBzcmNbaV1ba2V5XSA6IHNyY1tpXTtcbiAgICAgICAgaWYgKGluQXJyYXkodmFsdWVzLCB2YWwpIDwgMCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHNyY1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzW2ldID0gdmFsO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgaWYgKHNvcnQpIHtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLnNvcnQoZnVuY3Rpb24gc29ydFVuaXF1ZUFycmF5KGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVtrZXldID4gYltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBnZXQgdGhlIHByZWZpeGVkIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm5zIHtTdHJpbmd8VW5kZWZpbmVkfSBwcmVmaXhlZFxuICovXG5mdW5jdGlvbiBwcmVmaXhlZChvYmosIHByb3BlcnR5KSB7XG4gICAgdmFyIHByZWZpeCwgcHJvcDtcbiAgICB2YXIgY2FtZWxQcm9wID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgVkVORE9SX1BSRUZJWEVTLmxlbmd0aCkge1xuICAgICAgICBwcmVmaXggPSBWRU5ET1JfUFJFRklYRVNbaV07XG4gICAgICAgIHByb3AgPSAocHJlZml4KSA/IHByZWZpeCArIGNhbWVsUHJvcCA6IHByb3BlcnR5O1xuXG4gICAgICAgIGlmIChwcm9wIGluIG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHByb3A7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIGdldCBhIHVuaXF1ZSBpZFxuICogQHJldHVybnMge251bWJlcn0gdW5pcXVlSWRcbiAqL1xudmFyIF91bmlxdWVJZCA9IDE7XG5mdW5jdGlvbiB1bmlxdWVJZCgpIHtcbiAgICByZXR1cm4gX3VuaXF1ZUlkKys7XG59XG5cbi8qKlxuICogZ2V0IHRoZSB3aW5kb3cgb2JqZWN0IG9mIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtEb2N1bWVudFZpZXd8V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3dGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgZG9jID0gZWxlbWVudC5vd25lckRvY3VtZW50IHx8IGVsZW1lbnQ7XG4gICAgcmV0dXJuIChkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cpO1xufVxuXG52YXIgTU9CSUxFX1JFR0VYID0gL21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZC9pO1xuXG52YXIgU1VQUE9SVF9UT1VDSCA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xudmFyIFNVUFBPUlRfUE9JTlRFUl9FVkVOVFMgPSBwcmVmaXhlZCh3aW5kb3csICdQb2ludGVyRXZlbnQnKSAhPT0gdW5kZWZpbmVkO1xudmFyIFNVUFBPUlRfT05MWV9UT1VDSCA9IFNVUFBPUlRfVE9VQ0ggJiYgTU9CSUxFX1JFR0VYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbnZhciBJTlBVVF9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbnZhciBJTlBVVF9UWVBFX1BFTiA9ICdwZW4nO1xudmFyIElOUFVUX1RZUEVfTU9VU0UgPSAnbW91c2UnO1xudmFyIElOUFVUX1RZUEVfS0lORUNUID0gJ2tpbmVjdCc7XG5cbnZhciBDT01QVVRFX0lOVEVSVkFMID0gMjU7XG5cbnZhciBJTlBVVF9TVEFSVCA9IDE7XG52YXIgSU5QVVRfTU9WRSA9IDI7XG52YXIgSU5QVVRfRU5EID0gNDtcbnZhciBJTlBVVF9DQU5DRUwgPSA4O1xuXG52YXIgRElSRUNUSU9OX05PTkUgPSAxO1xudmFyIERJUkVDVElPTl9MRUZUID0gMjtcbnZhciBESVJFQ1RJT05fUklHSFQgPSA0O1xudmFyIERJUkVDVElPTl9VUCA9IDg7XG52YXIgRElSRUNUSU9OX0RPV04gPSAxNjtcblxudmFyIERJUkVDVElPTl9IT1JJWk9OVEFMID0gRElSRUNUSU9OX0xFRlQgfCBESVJFQ1RJT05fUklHSFQ7XG52YXIgRElSRUNUSU9OX1ZFUlRJQ0FMID0gRElSRUNUSU9OX1VQIHwgRElSRUNUSU9OX0RPV047XG52YXIgRElSRUNUSU9OX0FMTCA9IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMO1xuXG52YXIgUFJPUFNfWFkgPSBbJ3gnLCAneSddO1xudmFyIFBST1BTX0NMSUVOVF9YWSA9IFsnY2xpZW50WCcsICdjbGllbnRZJ107XG5cbi8qKlxuICogY3JlYXRlIG5ldyBpbnB1dCB0eXBlIG1hbmFnZXJcbiAqIEBwYXJhbSB7TWFuYWdlcn0gbWFuYWdlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtJbnB1dH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnB1dChtYW5hZ2VyLCBjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLmVsZW1lbnQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgdGhpcy50YXJnZXQgPSBtYW5hZ2VyLm9wdGlvbnMuaW5wdXRUYXJnZXQ7XG5cbiAgICAvLyBzbWFsbGVyIHdyYXBwZXIgYXJvdW5kIHRoZSBoYW5kbGVyLCBmb3IgdGhlIHNjb3BlIGFuZCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbWFuYWdlcixcbiAgICAvLyBzbyB3aGVuIGRpc2FibGVkIHRoZSBpbnB1dCBldmVudHMgYXJlIGNvbXBsZXRlbHkgYnlwYXNzZWQuXG4gICAgdGhpcy5kb21IYW5kbGVyID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgaWYgKGJvb2xPckZuKG1hbmFnZXIub3B0aW9ucy5lbmFibGUsIFttYW5hZ2VyXSkpIHtcbiAgICAgICAgICAgIHNlbGYuaGFuZGxlcihldik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5pbml0KCk7XG5cbn1cblxuSW5wdXQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNob3VsZCBoYW5kbGUgdGhlIGlucHV0RXZlbnQgZGF0YSBhbmQgdHJpZ2dlciB0aGUgY2FsbGJhY2tcbiAgICAgKiBAdmlydHVhbFxuICAgICAqL1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiBhZGRFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiBhZGRFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVuYmluZCB0aGUgZXZlbnRzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZXZFbCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLmVsZW1lbnQsIHRoaXMuZXZFbCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldlRhcmdldCAmJiByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnRhcmdldCwgdGhpcy5ldlRhcmdldCwgdGhpcy5kb21IYW5kbGVyKTtcbiAgICAgICAgdGhpcy5ldldpbiAmJiByZW1vdmVFdmVudExpc3RlbmVycyhnZXRXaW5kb3dGb3JFbGVtZW50KHRoaXMuZWxlbWVudCksIHRoaXMuZXZXaW4sIHRoaXMuZG9tSGFuZGxlcik7XG4gICAgfVxufTtcblxuLyoqXG4gKiBjcmVhdGUgbmV3IGlucHV0IHR5cGUgbWFuYWdlclxuICogY2FsbGVkIGJ5IHRoZSBNYW5hZ2VyIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hhbW1lcn0gbWFuYWdlclxuICogQHJldHVybnMge0lucHV0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnB1dEluc3RhbmNlKG1hbmFnZXIpIHtcbiAgICB2YXIgVHlwZTtcbiAgICB2YXIgaW5wdXRDbGFzcyA9IG1hbmFnZXIub3B0aW9ucy5pbnB1dENsYXNzO1xuXG4gICAgaWYgKGlucHV0Q2xhc3MpIHtcbiAgICAgICAgVHlwZSA9IGlucHV0Q2xhc3M7XG4gICAgfSBlbHNlIGlmIChTVVBQT1JUX1BPSU5URVJfRVZFTlRTKSB7XG4gICAgICAgIFR5cGUgPSBQb2ludGVyRXZlbnRJbnB1dDtcbiAgICB9IGVsc2UgaWYgKFNVUFBPUlRfT05MWV9UT1VDSCkge1xuICAgICAgICBUeXBlID0gVG91Y2hJbnB1dDtcbiAgICB9IGVsc2UgaWYgKCFTVVBQT1JUX1RPVUNIKSB7XG4gICAgICAgIFR5cGUgPSBNb3VzZUlucHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIFR5cGUgPSBUb3VjaE1vdXNlSW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBuZXcgKFR5cGUpKG1hbmFnZXIsIGlucHV0SGFuZGxlcik7XG59XG5cbi8qKlxuICogaGFuZGxlIGlucHV0IGV2ZW50c1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gaW5wdXRIYW5kbGVyKG1hbmFnZXIsIGV2ZW50VHlwZSwgaW5wdXQpIHtcbiAgICB2YXIgcG9pbnRlcnNMZW4gPSBpbnB1dC5wb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGNoYW5nZWRQb2ludGVyc0xlbiA9IGlucHV0LmNoYW5nZWRQb2ludGVycy5sZW5ndGg7XG4gICAgdmFyIGlzRmlyc3QgPSAoZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG4gICAgdmFyIGlzRmluYWwgPSAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkgJiYgKHBvaW50ZXJzTGVuIC0gY2hhbmdlZFBvaW50ZXJzTGVuID09PSAwKSk7XG5cbiAgICBpbnB1dC5pc0ZpcnN0ID0gISFpc0ZpcnN0O1xuICAgIGlucHV0LmlzRmluYWwgPSAhIWlzRmluYWw7XG5cbiAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICBtYW5hZ2VyLnNlc3Npb24gPSB7fTtcbiAgICB9XG5cbiAgICAvLyBzb3VyY2UgZXZlbnQgaXMgdGhlIG5vcm1hbGl6ZWQgdmFsdWUgb2YgdGhlIGRvbUV2ZW50c1xuICAgIC8vIGxpa2UgJ3RvdWNoc3RhcnQsIG1vdXNldXAsIHBvaW50ZXJkb3duJ1xuICAgIGlucHV0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcblxuICAgIC8vIGNvbXB1dGUgc2NhbGUsIHJvdGF0aW9uIGV0Y1xuICAgIGNvbXB1dGVJbnB1dERhdGEobWFuYWdlciwgaW5wdXQpO1xuXG4gICAgLy8gZW1pdCBzZWNyZXQgZXZlbnRcbiAgICBtYW5hZ2VyLmVtaXQoJ2hhbW1lci5pbnB1dCcsIGlucHV0KTtcblxuICAgIG1hbmFnZXIucmVjb2duaXplKGlucHV0KTtcbiAgICBtYW5hZ2VyLnNlc3Npb24ucHJldklucHV0ID0gaW5wdXQ7XG59XG5cbi8qKlxuICogZXh0ZW5kIHRoZSBkYXRhIHdpdGggc29tZSB1c2FibGUgcHJvcGVydGllcyBsaWtlIHNjYWxlLCByb3RhdGUsIHZlbG9jaXR5IGV0Y1xuICogQHBhcmFtIHtPYmplY3R9IG1hbmFnZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICovXG5mdW5jdGlvbiBjb21wdXRlSW5wdXREYXRhKG1hbmFnZXIsIGlucHV0KSB7XG4gICAgdmFyIHNlc3Npb24gPSBtYW5hZ2VyLnNlc3Npb247XG4gICAgdmFyIHBvaW50ZXJzID0gaW5wdXQucG9pbnRlcnM7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gc3RvcmUgdGhlIGZpcnN0IGlucHV0IHRvIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYW5kIGRpcmVjdGlvblxuICAgIGlmICghc2Vzc2lvbi5maXJzdElucHV0KSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RJbnB1dCA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9XG5cbiAgICAvLyB0byBjb21wdXRlIHNjYWxlIGFuZCByb3RhdGlvbiB3ZSBuZWVkIHRvIHN0b3JlIHRoZSBtdWx0aXBsZSB0b3VjaGVzXG4gICAgaWYgKHBvaW50ZXJzTGVuZ3RoID4gMSAmJiAhc2Vzc2lvbi5maXJzdE11bHRpcGxlKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KTtcbiAgICB9IGVsc2UgaWYgKHBvaW50ZXJzTGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHNlc3Npb24uZmlyc3RNdWx0aXBsZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBmaXJzdElucHV0ID0gc2Vzc2lvbi5maXJzdElucHV0O1xuICAgIHZhciBmaXJzdE11bHRpcGxlID0gc2Vzc2lvbi5maXJzdE11bHRpcGxlO1xuICAgIHZhciBvZmZzZXRDZW50ZXIgPSBmaXJzdE11bHRpcGxlID8gZmlyc3RNdWx0aXBsZS5jZW50ZXIgOiBmaXJzdElucHV0LmNlbnRlcjtcblxuICAgIHZhciBjZW50ZXIgPSBpbnB1dC5jZW50ZXIgPSBnZXRDZW50ZXIocG9pbnRlcnMpO1xuICAgIGlucHV0LnRpbWVTdGFtcCA9IG5vdygpO1xuICAgIGlucHV0LmRlbHRhVGltZSA9IGlucHV0LnRpbWVTdGFtcCAtIGZpcnN0SW5wdXQudGltZVN0YW1wO1xuXG4gICAgaW5wdXQuYW5nbGUgPSBnZXRBbmdsZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG4gICAgaW5wdXQuZGlzdGFuY2UgPSBnZXREaXN0YW5jZShvZmZzZXRDZW50ZXIsIGNlbnRlcik7XG5cbiAgICBjb21wdXRlRGVsdGFYWShzZXNzaW9uLCBpbnB1dCk7XG4gICAgaW5wdXQub2Zmc2V0RGlyZWN0aW9uID0gZ2V0RGlyZWN0aW9uKGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcblxuICAgIHZhciBvdmVyYWxsVmVsb2NpdHkgPSBnZXRWZWxvY2l0eShpbnB1dC5kZWx0YVRpbWUsIGlucHV0LmRlbHRhWCwgaW5wdXQuZGVsdGFZKTtcbiAgICBpbnB1dC5vdmVyYWxsVmVsb2NpdHlYID0gb3ZlcmFsbFZlbG9jaXR5Lng7XG4gICAgaW5wdXQub3ZlcmFsbFZlbG9jaXR5WSA9IG92ZXJhbGxWZWxvY2l0eS55O1xuICAgIGlucHV0Lm92ZXJhbGxWZWxvY2l0eSA9IChhYnMob3ZlcmFsbFZlbG9jaXR5LngpID4gYWJzKG92ZXJhbGxWZWxvY2l0eS55KSkgPyBvdmVyYWxsVmVsb2NpdHkueCA6IG92ZXJhbGxWZWxvY2l0eS55O1xuXG4gICAgaW5wdXQuc2NhbGUgPSBmaXJzdE11bHRpcGxlID8gZ2V0U2NhbGUoZmlyc3RNdWx0aXBsZS5wb2ludGVycywgcG9pbnRlcnMpIDogMTtcbiAgICBpbnB1dC5yb3RhdGlvbiA9IGZpcnN0TXVsdGlwbGUgPyBnZXRSb3RhdGlvbihmaXJzdE11bHRpcGxlLnBvaW50ZXJzLCBwb2ludGVycykgOiAwO1xuXG4gICAgaW5wdXQubWF4UG9pbnRlcnMgPSAhc2Vzc2lvbi5wcmV2SW5wdXQgPyBpbnB1dC5wb2ludGVycy5sZW5ndGggOiAoKGlucHV0LnBvaW50ZXJzLmxlbmd0aCA+XG4gICAgICAgIHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKSA/IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA6IHNlc3Npb24ucHJldklucHV0Lm1heFBvaW50ZXJzKTtcblxuICAgIGNvbXB1dGVJbnRlcnZhbElucHV0RGF0YShzZXNzaW9uLCBpbnB1dCk7XG5cbiAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IHRhcmdldFxuICAgIHZhciB0YXJnZXQgPSBtYW5hZ2VyLmVsZW1lbnQ7XG4gICAgaWYgKGhhc1BhcmVudChpbnB1dC5zcmNFdmVudC50YXJnZXQsIHRhcmdldCkpIHtcbiAgICAgICAgdGFyZ2V0ID0gaW5wdXQuc3JjRXZlbnQudGFyZ2V0O1xuICAgIH1cbiAgICBpbnB1dC50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEZWx0YVhZKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGNlbnRlciA9IGlucHV0LmNlbnRlcjtcbiAgICB2YXIgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSB8fCB7fTtcbiAgICB2YXIgcHJldkRlbHRhID0gc2Vzc2lvbi5wcmV2RGVsdGEgfHwge307XG4gICAgdmFyIHByZXZJbnB1dCA9IHNlc3Npb24ucHJldklucHV0IHx8IHt9O1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfU1RBUlQgfHwgcHJldklucHV0LmV2ZW50VHlwZSA9PT0gSU5QVVRfRU5EKSB7XG4gICAgICAgIHByZXZEZWx0YSA9IHNlc3Npb24ucHJldkRlbHRhID0ge1xuICAgICAgICAgICAgeDogcHJldklucHV0LmRlbHRhWCB8fCAwLFxuICAgICAgICAgICAgeTogcHJldklucHV0LmRlbHRhWSB8fCAwXG4gICAgICAgIH07XG5cbiAgICAgICAgb2Zmc2V0ID0gc2Vzc2lvbi5vZmZzZXREZWx0YSA9IHtcbiAgICAgICAgICAgIHg6IGNlbnRlci54LFxuICAgICAgICAgICAgeTogY2VudGVyLnlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICBpbnB1dC5kZWx0YVkgPSBwcmV2RGVsdGEueSArIChjZW50ZXIueSAtIG9mZnNldC55KTtcbn1cblxuLyoqXG4gKiB2ZWxvY2l0eSBpcyBjYWxjdWxhdGVkIGV2ZXJ5IHggbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uXG4gKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUludGVydmFsSW5wdXREYXRhKHNlc3Npb24sIGlucHV0KSB7XG4gICAgdmFyIGxhc3QgPSBzZXNzaW9uLmxhc3RJbnRlcnZhbCB8fCBpbnB1dCxcbiAgICAgICAgZGVsdGFUaW1lID0gaW5wdXQudGltZVN0YW1wIC0gbGFzdC50aW1lU3RhbXAsXG4gICAgICAgIHZlbG9jaXR5LCB2ZWxvY2l0eVgsIHZlbG9jaXR5WSwgZGlyZWN0aW9uO1xuXG4gICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9DQU5DRUwgJiYgKGRlbHRhVGltZSA+IENPTVBVVEVfSU5URVJWQUwgfHwgbGFzdC52ZWxvY2l0eSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICB2YXIgZGVsdGFYID0gaW5wdXQuZGVsdGFYIC0gbGFzdC5kZWx0YVg7XG4gICAgICAgIHZhciBkZWx0YVkgPSBpbnB1dC5kZWx0YVkgLSBsYXN0LmRlbHRhWTtcblxuICAgICAgICB2YXIgdiA9IGdldFZlbG9jaXR5KGRlbHRhVGltZSwgZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICB2ZWxvY2l0eVggPSB2Lng7XG4gICAgICAgIHZlbG9jaXR5WSA9IHYueTtcbiAgICAgICAgdmVsb2NpdHkgPSAoYWJzKHYueCkgPiBhYnModi55KSkgPyB2LnggOiB2Lnk7XG4gICAgICAgIGRpcmVjdGlvbiA9IGdldERpcmVjdGlvbihkZWx0YVgsIGRlbHRhWSk7XG5cbiAgICAgICAgc2Vzc2lvbi5sYXN0SW50ZXJ2YWwgPSBpbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1c2UgbGF0ZXN0IHZlbG9jaXR5IGluZm8gaWYgaXQgZG9lc24ndCBvdmVydGFrZSBhIG1pbmltdW0gcGVyaW9kXG4gICAgICAgIHZlbG9jaXR5ID0gbGFzdC52ZWxvY2l0eTtcbiAgICAgICAgdmVsb2NpdHlYID0gbGFzdC52ZWxvY2l0eVg7XG4gICAgICAgIHZlbG9jaXR5WSA9IGxhc3QudmVsb2NpdHlZO1xuICAgICAgICBkaXJlY3Rpb24gPSBsYXN0LmRpcmVjdGlvbjtcbiAgICB9XG5cbiAgICBpbnB1dC52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIGlucHV0LnZlbG9jaXR5WCA9IHZlbG9jaXR5WDtcbiAgICBpbnB1dC52ZWxvY2l0eVkgPSB2ZWxvY2l0eVk7XG4gICAgaW5wdXQuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xufVxuXG4vKipcbiAqIGNyZWF0ZSBhIHNpbXBsZSBjbG9uZSBmcm9tIHRoZSBpbnB1dCB1c2VkIGZvciBzdG9yYWdlIG9mIGZpcnN0SW5wdXQgYW5kIGZpcnN0TXVsdGlwbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICogQHJldHVybnMge09iamVjdH0gY2xvbmVkSW5wdXREYXRhXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZUNsb25lSW5wdXREYXRhKGlucHV0KSB7XG4gICAgLy8gbWFrZSBhIHNpbXBsZSBjb3B5IG9mIHRoZSBwb2ludGVycyBiZWNhdXNlIHdlIHdpbGwgZ2V0IGEgcmVmZXJlbmNlIGlmIHdlIGRvbid0XG4gICAgLy8gd2Ugb25seSBuZWVkIGNsaWVudFhZIGZvciB0aGUgY2FsY3VsYXRpb25zXG4gICAgdmFyIHBvaW50ZXJzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgaW5wdXQucG9pbnRlcnMubGVuZ3RoKSB7XG4gICAgICAgIHBvaW50ZXJzW2ldID0ge1xuICAgICAgICAgICAgY2xpZW50WDogcm91bmQoaW5wdXQucG9pbnRlcnNbaV0uY2xpZW50WCksXG4gICAgICAgICAgICBjbGllbnRZOiByb3VuZChpbnB1dC5wb2ludGVyc1tpXS5jbGllbnRZKVxuICAgICAgICB9O1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGltZVN0YW1wOiBub3coKSxcbiAgICAgICAgcG9pbnRlcnM6IHBvaW50ZXJzLFxuICAgICAgICBjZW50ZXI6IGdldENlbnRlcihwb2ludGVycyksXG4gICAgICAgIGRlbHRhWDogaW5wdXQuZGVsdGFYLFxuICAgICAgICBkZWx0YVk6IGlucHV0LmRlbHRhWVxuICAgIH07XG59XG5cbi8qKlxuICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSBwb2ludGVyc1xuICogQHBhcmFtIHtBcnJheX0gcG9pbnRlcnNcbiAqIEByZXR1cm4ge09iamVjdH0gY2VudGVyIGNvbnRhaW5zIGB4YCBhbmQgYHlgIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Q2VudGVyKHBvaW50ZXJzKSB7XG4gICAgdmFyIHBvaW50ZXJzTGVuZ3RoID0gcG9pbnRlcnMubGVuZ3RoO1xuXG4gICAgLy8gbm8gbmVlZCB0byBsb29wIHdoZW4gb25seSBvbmUgdG91Y2hcbiAgICBpZiAocG9pbnRlcnNMZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHJvdW5kKHBvaW50ZXJzWzBdLmNsaWVudFgpLFxuICAgICAgICAgICAgeTogcm91bmQocG9pbnRlcnNbMF0uY2xpZW50WSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgeCA9IDAsIHkgPSAwLCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHBvaW50ZXJzTGVuZ3RoKSB7XG4gICAgICAgIHggKz0gcG9pbnRlcnNbaV0uY2xpZW50WDtcbiAgICAgICAgeSArPSBwb2ludGVyc1tpXS5jbGllbnRZO1xuICAgICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcm91bmQoeCAvIHBvaW50ZXJzTGVuZ3RoKSxcbiAgICAgICAgeTogcm91bmQoeSAvIHBvaW50ZXJzTGVuZ3RoKVxuICAgIH07XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSB2ZWxvY2l0eSBiZXR3ZWVuIHR3byBwb2ludHMuIHVuaXQgaXMgaW4gcHggcGVyIG1zLlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbHRhVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtPYmplY3R9IHZlbG9jaXR5IGB4YCBhbmQgYHlgXG4gKi9cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhVGltZSwgeCwgeSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHggLyBkZWx0YVRpbWUgfHwgMCxcbiAgICAgICAgeTogeSAvIGRlbHRhVGltZSB8fCAwXG4gICAgfTtcbn1cblxuLyoqXG4gKiBnZXQgdGhlIGRpcmVjdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiBAcGFyYW0ge051bWJlcn0geVxuICogQHJldHVybiB7TnVtYmVyfSBkaXJlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKHgsIHkpIHtcbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICByZXR1cm4gRElSRUNUSU9OX05PTkU7XG4gICAgfVxuXG4gICAgaWYgKGFicyh4KSA+PSBhYnMoeSkpIHtcbiAgICAgICAgcmV0dXJuIHggPCAwID8gRElSRUNUSU9OX0xFRlQgOiBESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIHJldHVybiB5IDwgMCA/IERJUkVDVElPTl9VUCA6IERJUkVDVElPTl9ET1dOO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgYWJzb2x1dGUgZGlzdGFuY2UgYmV0d2VlbiB0d28gcG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gcDEge3gsIHl9XG4gKiBAcGFyYW0ge09iamVjdH0gcDIge3gsIHl9XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHNdIGNvbnRhaW5pbmcgeCBhbmQgeSBrZXlzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERpc3RhbmNlKHAxLCBwMiwgcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzKSB7XG4gICAgICAgIHByb3BzID0gUFJPUFNfWFk7XG4gICAgfVxuICAgIHZhciB4ID0gcDJbcHJvcHNbMF1dIC0gcDFbcHJvcHNbMF1dLFxuICAgICAgICB5ID0gcDJbcHJvcHNbMV1dIC0gcDFbcHJvcHNbMV1dO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCgoeCAqIHgpICsgKHkgKiB5KSk7XG59XG5cbi8qKlxuICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IHAxXG4gKiBAcGFyYW0ge09iamVjdH0gcDJcbiAqIEBwYXJhbSB7QXJyYXl9IFtwcm9wc10gY29udGFpbmluZyB4IGFuZCB5IGtleXNcbiAqIEByZXR1cm4ge051bWJlcn0gYW5nbGVcbiAqL1xuZnVuY3Rpb24gZ2V0QW5nbGUocDEsIHAyLCBwcm9wcykge1xuICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgcHJvcHMgPSBQUk9QU19YWTtcbiAgICB9XG4gICAgdmFyIHggPSBwMltwcm9wc1swXV0gLSBwMVtwcm9wc1swXV0sXG4gICAgICAgIHkgPSBwMltwcm9wc1sxXV0gLSBwMVtwcm9wc1sxXV07XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgcm90YXRpb24gZGVncmVlcyBiZXR3ZWVuIHR3byBwb2ludGVyc2V0c1xuICogQHBhcmFtIHtBcnJheX0gc3RhcnQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGVuZCBhcnJheSBvZiBwb2ludGVyc1xuICogQHJldHVybiB7TnVtYmVyfSByb3RhdGlvblxuICovXG5mdW5jdGlvbiBnZXRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIGdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdLCBQUk9QU19DTElFTlRfWFkpICsgZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdLCBQUk9QU19DTElFTlRfWFkpO1xufVxuXG4vKipcbiAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHBvaW50ZXJzZXRzXG4gKiBubyBzY2FsZSBpcyAxLCBhbmQgZ29lcyBkb3duIHRvIDAgd2hlbiBwaW5jaGVkIHRvZ2V0aGVyLCBhbmQgYmlnZ2VyIHdoZW4gcGluY2hlZCBvdXRcbiAqIEBwYXJhbSB7QXJyYXl9IHN0YXJ0IGFycmF5IG9mIHBvaW50ZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBlbmQgYXJyYXkgb2YgcG9pbnRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gc2NhbGVcbiAqL1xuZnVuY3Rpb24gZ2V0U2NhbGUoc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiBnZXREaXN0YW5jZShlbmRbMF0sIGVuZFsxXSwgUFJPUFNfQ0xJRU5UX1hZKSAvIGdldERpc3RhbmNlKHN0YXJ0WzBdLCBzdGFydFsxXSwgUFJPUFNfQ0xJRU5UX1hZKTtcbn1cblxudmFyIE1PVVNFX0lOUFVUX01BUCA9IHtcbiAgICBtb3VzZWRvd246IElOUFVUX1NUQVJULFxuICAgIG1vdXNlbW92ZTogSU5QVVRfTU9WRSxcbiAgICBtb3VzZXVwOiBJTlBVVF9FTkRcbn07XG5cbnZhciBNT1VTRV9FTEVNRU5UX0VWRU5UUyA9ICdtb3VzZWRvd24nO1xudmFyIE1PVVNFX1dJTkRPV19FVkVOVFMgPSAnbW91c2Vtb3ZlIG1vdXNldXAnO1xuXG4vKipcbiAqIE1vdXNlIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBNb3VzZUlucHV0KCkge1xuICAgIHRoaXMuZXZFbCA9IE1PVVNFX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBNT1VTRV9XSU5ET1dfRVZFTlRTO1xuXG4gICAgdGhpcy5wcmVzc2VkID0gZmFsc2U7IC8vIG1vdXNlZG93biBzdGF0ZVxuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChNb3VzZUlucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBNRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IE1PVVNFX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBvbiBzdGFydCB3ZSB3YW50IHRvIGhhdmUgdGhlIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIGV2LmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVzc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9NT1ZFICYmIGV2LndoaWNoICE9PSAxKSB7XG4gICAgICAgICAgICBldmVudFR5cGUgPSBJTlBVVF9FTkQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKCF0aGlzLnByZXNzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHRoaXMucHJlc3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IFtldl0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9NT1VTRSxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxudmFyIFBPSU5URVJfSU5QVVRfTUFQID0ge1xuICAgIHBvaW50ZXJkb3duOiBJTlBVVF9TVEFSVCxcbiAgICBwb2ludGVybW92ZTogSU5QVVRfTU9WRSxcbiAgICBwb2ludGVydXA6IElOUFVUX0VORCxcbiAgICBwb2ludGVyY2FuY2VsOiBJTlBVVF9DQU5DRUwsXG4gICAgcG9pbnRlcm91dDogSU5QVVRfQ0FOQ0VMXG59O1xuXG4vLyBpbiBJRTEwIHRoZSBwb2ludGVyIHR5cGVzIGlzIGRlZmluZWQgYXMgYW4gZW51bVxudmFyIElFMTBfUE9JTlRFUl9UWVBFX0VOVU0gPSB7XG4gICAgMjogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAzOiBJTlBVVF9UWVBFX1BFTixcbiAgICA0OiBJTlBVVF9UWVBFX01PVVNFLFxuICAgIDU6IElOUFVUX1RZUEVfS0lORUNUIC8vIHNlZSBodHRwczovL3R3aXR0ZXIuY29tL2phY29icm9zc2kvc3RhdHVzLzQ4MDU5NjQzODQ4OTg5MDgxNlxufTtcblxudmFyIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAncG9pbnRlcmRvd24nO1xudmFyIFBPSU5URVJfV0lORE9XX0VWRU5UUyA9ICdwb2ludGVybW92ZSBwb2ludGVydXAgcG9pbnRlcmNhbmNlbCc7XG5cbi8vIElFMTAgaGFzIHByZWZpeGVkIHN1cHBvcnQsIGFuZCBjYXNlLXNlbnNpdGl2ZVxuaWYgKHdpbmRvdy5NU1BvaW50ZXJFdmVudCAmJiAhd2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgIFBPSU5URVJfRUxFTUVOVF9FVkVOVFMgPSAnTVNQb2ludGVyRG93bic7XG4gICAgUE9JTlRFUl9XSU5ET1dfRVZFTlRTID0gJ01TUG9pbnRlck1vdmUgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcbn1cblxuLyoqXG4gKiBQb2ludGVyIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBQb2ludGVyRXZlbnRJbnB1dCgpIHtcbiAgICB0aGlzLmV2RWwgPSBQT0lOVEVSX0VMRU1FTlRfRVZFTlRTO1xuICAgIHRoaXMuZXZXaW4gPSBQT0lOVEVSX1dJTkRPV19FVkVOVFM7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgdGhpcy5zdG9yZSA9ICh0aGlzLm1hbmFnZXIuc2Vzc2lvbi5wb2ludGVyRXZlbnRzID0gW10pO1xufVxuXG5pbmhlcml0KFBvaW50ZXJFdmVudElucHV0LCBJbnB1dCwge1xuICAgIC8qKlxuICAgICAqIGhhbmRsZSBtb3VzZSBldmVudHNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZcbiAgICAgKi9cbiAgICBoYW5kbGVyOiBmdW5jdGlvbiBQRWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgdmFyIHJlbW92ZVBvaW50ZXIgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZXZlbnRUeXBlTm9ybWFsaXplZCA9IGV2LnR5cGUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKCdtcycsICcnKTtcbiAgICAgICAgdmFyIGV2ZW50VHlwZSA9IFBPSU5URVJfSU5QVVRfTUFQW2V2ZW50VHlwZU5vcm1hbGl6ZWRdO1xuICAgICAgICB2YXIgcG9pbnRlclR5cGUgPSBJRTEwX1BPSU5URVJfVFlQRV9FTlVNW2V2LnBvaW50ZXJUeXBlXSB8fCBldi5wb2ludGVyVHlwZTtcblxuICAgICAgICB2YXIgaXNUb3VjaCA9IChwb2ludGVyVHlwZSA9PSBJTlBVVF9UWVBFX1RPVUNIKTtcblxuICAgICAgICAvLyBnZXQgaW5kZXggb2YgdGhlIGV2ZW50IGluIHRoZSBzdG9yZVxuICAgICAgICB2YXIgc3RvcmVJbmRleCA9IGluQXJyYXkoc3RvcmUsIGV2LnBvaW50ZXJJZCwgJ3BvaW50ZXJJZCcpO1xuXG4gICAgICAgIC8vIHN0YXJ0IGFuZCBtb3VzZSBtdXN0IGJlIGRvd25cbiAgICAgICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUICYmIChldi5idXR0b24gPT09IDAgfHwgaXNUb3VjaCkpIHtcbiAgICAgICAgICAgIGlmIChzdG9yZUluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIHN0b3JlLnB1c2goZXYpO1xuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXggPSBzdG9yZS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpKSB7XG4gICAgICAgICAgICByZW1vdmVQb2ludGVyID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGl0IG5vdCBmb3VuZCwgc28gdGhlIHBvaW50ZXIgaGFzbid0IGJlZW4gZG93biAoc28gaXQncyBwcm9iYWJseSBhIGhvdmVyKVxuICAgICAgICBpZiAoc3RvcmVJbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgZXZlbnQgaW4gdGhlIHN0b3JlXG4gICAgICAgIHN0b3JlW3N0b3JlSW5kZXhdID0gZXY7XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIGV2ZW50VHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHN0b3JlLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiBbZXZdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IHBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgc3JjRXZlbnQ6IGV2XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyZW1vdmVQb2ludGVyKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZnJvbSB0aGUgc3RvcmVcbiAgICAgICAgICAgIHN0b3JlLnNwbGljZShzdG9yZUluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG52YXIgU0lOR0xFX1RPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgU0lOR0xFX1RPVUNIX1RBUkdFVF9FVkVOVFMgPSAndG91Y2hzdGFydCc7XG52YXIgU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFMgPSAndG91Y2hzdGFydCB0b3VjaG1vdmUgdG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXG4vKipcbiAqIFRvdWNoIGV2ZW50cyBpbnB1dFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5mdW5jdGlvbiBTaW5nbGVUb3VjaElucHV0KCkge1xuICAgIHRoaXMuZXZUYXJnZXQgPSBTSU5HTEVfVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLmV2V2luID0gU0lOR0xFX1RPVUNIX1dJTkRPV19FVkVOVFM7XG4gICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG5cbiAgICBJbnB1dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFNpbmdsZVRvdWNoSW5wdXQsIElucHV0LCB7XG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVEVoYW5kbGVyKGV2KSB7XG4gICAgICAgIHZhciB0eXBlID0gU0lOR0xFX1RPVUNIX0lOUFVUX01BUFtldi50eXBlXTtcblxuICAgICAgICAvLyBzaG91bGQgd2UgaGFuZGxlIHRoZSB0b3VjaCBldmVudHM/XG4gICAgICAgIGlmICh0eXBlID09PSBJTlBVVF9TVEFSVCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG91Y2hlcyA9IG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMuY2FsbCh0aGlzLCBldiwgdHlwZSk7XG5cbiAgICAgICAgLy8gd2hlbiBkb25lLCByZXNldCB0aGUgc3RhcnRlZCBzdGF0ZVxuICAgICAgICBpZiAodHlwZSAmIChJTlBVVF9FTkQgfCBJTlBVVF9DQU5DRUwpICYmIHRvdWNoZXNbMF0ubGVuZ3RoIC0gdG91Y2hlc1sxXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLm1hbmFnZXIsIHR5cGUsIHtcbiAgICAgICAgICAgIHBvaW50ZXJzOiB0b3VjaGVzWzBdLFxuICAgICAgICAgICAgY2hhbmdlZFBvaW50ZXJzOiB0b3VjaGVzWzFdLFxuICAgICAgICAgICAgcG9pbnRlclR5cGU6IElOUFVUX1RZUEVfVE9VQ0gsXG4gICAgICAgICAgICBzcmNFdmVudDogZXZcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogQHRoaXMge1RvdWNoSW5wdXR9XG4gKiBAcGFyYW0ge09iamVjdH0gZXZcbiAqIEBwYXJhbSB7TnVtYmVyfSB0eXBlIGZsYWdcbiAqIEByZXR1cm5zIHt1bmRlZmluZWR8QXJyYXl9IFthbGwsIGNoYW5nZWRdXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNpbmdsZVRvdWNoZXMoZXYsIHR5cGUpIHtcbiAgICB2YXIgYWxsID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgY2hhbmdlZCA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpO1xuXG4gICAgaWYgKHR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSkge1xuICAgICAgICBhbGwgPSB1bmlxdWVBcnJheShhbGwuY29uY2F0KGNoYW5nZWQpLCAnaWRlbnRpZmllcicsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiBbYWxsLCBjaGFuZ2VkXTtcbn1cblxudmFyIFRPVUNIX0lOUFVUX01BUCA9IHtcbiAgICB0b3VjaHN0YXJ0OiBJTlBVVF9TVEFSVCxcbiAgICB0b3VjaG1vdmU6IElOUFVUX01PVkUsXG4gICAgdG91Y2hlbmQ6IElOUFVUX0VORCxcbiAgICB0b3VjaGNhbmNlbDogSU5QVVRfQ0FOQ0VMXG59O1xuXG52YXIgVE9VQ0hfVEFSR0VUX0VWRU5UUyA9ICd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cbi8qKlxuICogTXVsdGktdXNlciB0b3VjaCBldmVudHMgaW5wdXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgSW5wdXRcbiAqL1xuZnVuY3Rpb24gVG91Y2hJbnB1dCgpIHtcbiAgICB0aGlzLmV2VGFyZ2V0ID0gVE9VQ0hfVEFSR0VUX0VWRU5UUztcbiAgICB0aGlzLnRhcmdldElkcyA9IHt9O1xuXG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChUb3VjaElucHV0LCBJbnB1dCwge1xuICAgIGhhbmRsZXI6IGZ1bmN0aW9uIE1URWhhbmRsZXIoZXYpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBUT1VDSF9JTlBVVF9NQVBbZXYudHlwZV07XG4gICAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlcy5jYWxsKHRoaXMsIGV2LCB0eXBlKTtcbiAgICAgICAgaWYgKCF0b3VjaGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKHRoaXMubWFuYWdlciwgdHlwZSwge1xuICAgICAgICAgICAgcG9pbnRlcnM6IHRvdWNoZXNbMF0sXG4gICAgICAgICAgICBjaGFuZ2VkUG9pbnRlcnM6IHRvdWNoZXNbMV0sXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogSU5QVVRfVFlQRV9UT1VDSCxcbiAgICAgICAgICAgIHNyY0V2ZW50OiBldlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBAdGhpcyB7VG91Y2hJbnB1dH1cbiAqIEBwYXJhbSB7T2JqZWN0fSBldlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGUgZmxhZ1xuICogQHJldHVybnMge3VuZGVmaW5lZHxBcnJheX0gW2FsbCwgY2hhbmdlZF1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hlcyhldiwgdHlwZSkge1xuICAgIHZhciBhbGxUb3VjaGVzID0gdG9BcnJheShldi50b3VjaGVzKTtcbiAgICB2YXIgdGFyZ2V0SWRzID0gdGhpcy50YXJnZXRJZHM7XG5cbiAgICAvLyB3aGVuIHRoZXJlIGlzIG9ubHkgb25lIHRvdWNoLCB0aGUgcHJvY2VzcyBjYW4gYmUgc2ltcGxpZmllZFxuICAgIGlmICh0eXBlICYgKElOUFVUX1NUQVJUIHwgSU5QVVRfTU9WRSkgJiYgYWxsVG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGFyZ2V0SWRzW2FsbFRvdWNoZXNbMF0uaWRlbnRpZmllcl0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gW2FsbFRvdWNoZXMsIGFsbFRvdWNoZXNdO1xuICAgIH1cblxuICAgIHZhciBpLFxuICAgICAgICB0YXJnZXRUb3VjaGVzLFxuICAgICAgICBjaGFuZ2VkVG91Y2hlcyA9IHRvQXJyYXkoZXYuY2hhbmdlZFRvdWNoZXMpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcyA9IFtdLFxuICAgICAgICB0YXJnZXQgPSB0aGlzLnRhcmdldDtcblxuICAgIC8vIGdldCB0YXJnZXQgdG91Y2hlcyBmcm9tIHRvdWNoZXNcbiAgICB0YXJnZXRUb3VjaGVzID0gYWxsVG91Y2hlcy5maWx0ZXIoZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhcmVudCh0b3VjaC50YXJnZXQsIHRhcmdldCk7XG4gICAgfSk7XG5cbiAgICAvLyBjb2xsZWN0IHRvdWNoZXNcbiAgICBpZiAodHlwZSA9PT0gSU5QVVRfU1RBUlQpIHtcbiAgICAgICAgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGFyZ2V0VG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRhcmdldElkc1t0YXJnZXRUb3VjaGVzW2ldLmlkZW50aWZpZXJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbHRlciBjaGFuZ2VkIHRvdWNoZXMgdG8gb25seSBjb250YWluIHRvdWNoZXMgdGhhdCBleGlzdCBpbiB0aGUgY29sbGVjdGVkIHRhcmdldCBpZHNcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGNoYW5nZWRUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodGFyZ2V0SWRzW2NoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXJdKSB7XG4gICAgICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlcy5wdXNoKGNoYW5nZWRUb3VjaGVzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNsZWFudXAgcmVtb3ZlZCB0b3VjaGVzXG4gICAgICAgIGlmICh0eXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXRJZHNbY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcl07XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cblxuICAgIGlmICghY2hhbmdlZFRhcmdldFRvdWNoZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgICAvLyBtZXJnZSB0YXJnZXRUb3VjaGVzIHdpdGggY2hhbmdlZFRhcmdldFRvdWNoZXMgc28gaXQgY29udGFpbnMgQUxMIHRvdWNoZXMsIGluY2x1ZGluZyAnZW5kJyBhbmQgJ2NhbmNlbCdcbiAgICAgICAgdW5pcXVlQXJyYXkodGFyZ2V0VG91Y2hlcy5jb25jYXQoY2hhbmdlZFRhcmdldFRvdWNoZXMpLCAnaWRlbnRpZmllcicsIHRydWUpLFxuICAgICAgICBjaGFuZ2VkVGFyZ2V0VG91Y2hlc1xuICAgIF07XG59XG5cbi8qKlxuICogQ29tYmluZWQgdG91Y2ggYW5kIG1vdXNlIGlucHV0XG4gKlxuICogVG91Y2ggaGFzIGEgaGlnaGVyIHByaW9yaXR5IHRoZW4gbW91c2UsIGFuZCB3aGlsZSB0b3VjaGluZyBubyBtb3VzZSBldmVudHMgYXJlIGFsbG93ZWQuXG4gKiBUaGlzIGJlY2F1c2UgdG91Y2ggZGV2aWNlcyBhbHNvIGVtaXQgbW91c2UgZXZlbnRzIHdoaWxlIGRvaW5nIGEgdG91Y2guXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBJbnB1dFxuICovXG5cbnZhciBERURVUF9USU1FT1VUID0gMjUwMDtcbnZhciBERURVUF9ESVNUQU5DRSA9IDI1O1xuXG5mdW5jdGlvbiBUb3VjaE1vdXNlSW5wdXQoKSB7XG4gICAgSW5wdXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHZhciBoYW5kbGVyID0gYmluZEZuKHRoaXMuaGFuZGxlciwgdGhpcyk7XG4gICAgdGhpcy50b3VjaCA9IG5ldyBUb3VjaElucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZUlucHV0KHRoaXMubWFuYWdlciwgaGFuZGxlcik7XG5cbiAgICB0aGlzLnByaW1hcnlUb3VjaCA9IG51bGw7XG4gICAgdGhpcy5sYXN0VG91Y2hlcyA9IFtdO1xufVxuXG5pbmhlcml0KFRvdWNoTW91c2VJbnB1dCwgSW5wdXQsIHtcbiAgICAvKipcbiAgICAgKiBoYW5kbGUgbW91c2UgYW5kIHRvdWNoIGV2ZW50c1xuICAgICAqIEBwYXJhbSB7SGFtbWVyfSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlucHV0RXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXREYXRhXG4gICAgICovXG4gICAgaGFuZGxlcjogZnVuY3Rpb24gVE1FaGFuZGxlcihtYW5hZ2VyLCBpbnB1dEV2ZW50LCBpbnB1dERhdGEpIHtcbiAgICAgICAgdmFyIGlzVG91Y2ggPSAoaW5wdXREYXRhLnBvaW50ZXJUeXBlID09IElOUFVUX1RZUEVfVE9VQ0gpLFxuICAgICAgICAgICAgaXNNb3VzZSA9IChpbnB1dERhdGEucG9pbnRlclR5cGUgPT0gSU5QVVRfVFlQRV9NT1VTRSk7XG5cbiAgICAgICAgaWYgKGlzTW91c2UgJiYgaW5wdXREYXRhLnNvdXJjZUNhcGFiaWxpdGllcyAmJiBpbnB1dERhdGEuc291cmNlQ2FwYWJpbGl0aWVzLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdoZW4gd2UncmUgaW4gYSB0b3VjaCBldmVudCwgcmVjb3JkIHRvdWNoZXMgdG8gIGRlLWR1cGUgc3ludGhldGljIG1vdXNlIGV2ZW50XG4gICAgICAgIGlmIChpc1RvdWNoKSB7XG4gICAgICAgICAgICByZWNvcmRUb3VjaGVzLmNhbGwodGhpcywgaW5wdXRFdmVudCwgaW5wdXREYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdXNlICYmIGlzU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBpbnB1dERhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKG1hbmFnZXIsIGlucHV0RXZlbnQsIGlucHV0RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlbW92ZSB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy50b3VjaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubW91c2UuZGVzdHJveSgpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiByZWNvcmRUb3VjaGVzKGV2ZW50VHlwZSwgZXZlbnREYXRhKSB7XG4gICAgaWYgKGV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgIHRoaXMucHJpbWFyeVRvdWNoID0gZXZlbnREYXRhLmNoYW5nZWRQb2ludGVyc1swXS5pZGVudGlmaWVyO1xuICAgICAgICBzZXRMYXN0VG91Y2guY2FsbCh0aGlzLCBldmVudERhdGEpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlICYgKElOUFVUX0VORCB8IElOUFVUX0NBTkNFTCkpIHtcbiAgICAgICAgc2V0TGFzdFRvdWNoLmNhbGwodGhpcywgZXZlbnREYXRhKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldExhc3RUb3VjaChldmVudERhdGEpIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudERhdGEuY2hhbmdlZFBvaW50ZXJzWzBdO1xuXG4gICAgaWYgKHRvdWNoLmlkZW50aWZpZXIgPT09IHRoaXMucHJpbWFyeVRvdWNoKSB7XG4gICAgICAgIHZhciBsYXN0VG91Y2ggPSB7eDogdG91Y2guY2xpZW50WCwgeTogdG91Y2guY2xpZW50WX07XG4gICAgICAgIHRoaXMubGFzdFRvdWNoZXMucHVzaChsYXN0VG91Y2gpO1xuICAgICAgICB2YXIgbHRzID0gdGhpcy5sYXN0VG91Y2hlcztcbiAgICAgICAgdmFyIHJlbW92ZUxhc3RUb3VjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGkgPSBsdHMuaW5kZXhPZihsYXN0VG91Y2gpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGx0cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNldFRpbWVvdXQocmVtb3ZlTGFzdFRvdWNoLCBERURVUF9USU1FT1VUKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljRXZlbnQoZXZlbnREYXRhKSB7XG4gICAgdmFyIHggPSBldmVudERhdGEuc3JjRXZlbnQuY2xpZW50WCwgeSA9IGV2ZW50RGF0YS5zcmNFdmVudC5jbGllbnRZO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYXN0VG91Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdCA9IHRoaXMubGFzdFRvdWNoZXNbaV07XG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpLCBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xuICAgICAgICBpZiAoZHggPD0gREVEVVBfRElTVEFOQ0UgJiYgZHkgPD0gREVEVVBfRElTVEFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxudmFyIFBSRUZJWEVEX1RPVUNIX0FDVElPTiA9IHByZWZpeGVkKFRFU1RfRUxFTUVOVC5zdHlsZSwgJ3RvdWNoQWN0aW9uJyk7XG52YXIgTkFUSVZFX1RPVUNIX0FDVElPTiA9IFBSRUZJWEVEX1RPVUNIX0FDVElPTiAhPT0gdW5kZWZpbmVkO1xuXG4vLyBtYWdpY2FsIHRvdWNoQWN0aW9uIHZhbHVlXG52YXIgVE9VQ0hfQUNUSU9OX0NPTVBVVEUgPSAnY29tcHV0ZSc7XG52YXIgVE9VQ0hfQUNUSU9OX0FVVE8gPSAnYXV0byc7XG52YXIgVE9VQ0hfQUNUSU9OX01BTklQVUxBVElPTiA9ICdtYW5pcHVsYXRpb24nOyAvLyBub3QgaW1wbGVtZW50ZWRcbnZhciBUT1VDSF9BQ1RJT05fTk9ORSA9ICdub25lJztcbnZhciBUT1VDSF9BQ1RJT05fUEFOX1ggPSAncGFuLXgnO1xudmFyIFRPVUNIX0FDVElPTl9QQU5fWSA9ICdwYW4teSc7XG52YXIgVE9VQ0hfQUNUSU9OX01BUCA9IGdldFRvdWNoQWN0aW9uUHJvcHMoKTtcblxuLyoqXG4gKiBUb3VjaCBBY3Rpb25cbiAqIHNldHMgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5IG9yIHVzZXMgdGhlIGpzIGFsdGVybmF0aXZlXG4gKiBAcGFyYW0ge01hbmFnZXJ9IG1hbmFnZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFRvdWNoQWN0aW9uKG1hbmFnZXIsIHZhbHVlKSB7XG4gICAgdGhpcy5tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB0aGlzLnNldCh2YWx1ZSk7XG59XG5cblRvdWNoQWN0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHRvdWNoQWN0aW9uIHZhbHVlIG9uIHRoZSBlbGVtZW50IG9yIGVuYWJsZSB0aGUgcG9seWZpbGxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIGZpbmQgb3V0IHRoZSB0b3VjaC1hY3Rpb24gYnkgdGhlIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIGlmICh2YWx1ZSA9PSBUT1VDSF9BQ1RJT05fQ09NUFVURSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmNvbXB1dGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChOQVRJVkVfVE9VQ0hfQUNUSU9OICYmIHRoaXMubWFuYWdlci5lbGVtZW50LnN0eWxlICYmIFRPVUNIX0FDVElPTl9NQVBbdmFsdWVdKSB7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZWxlbWVudC5zdHlsZVtQUkVGSVhFRF9UT1VDSF9BQ1RJT05dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3Rpb25zID0gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGp1c3QgcmUtc2V0IHRoZSB0b3VjaEFjdGlvbiB2YWx1ZVxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMubWFuYWdlci5vcHRpb25zLnRvdWNoQWN0aW9uKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogY29tcHV0ZSB0aGUgdmFsdWUgZm9yIHRoZSB0b3VjaEFjdGlvbiBwcm9wZXJ0eSBiYXNlZCBvbiB0aGUgcmVjb2duaXplcidzIHNldHRpbmdzXG4gICAgICogQHJldHVybnMge1N0cmluZ30gdmFsdWVcbiAgICAgKi9cbiAgICBjb21wdXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSBbXTtcbiAgICAgICAgZWFjaCh0aGlzLm1hbmFnZXIucmVjb2duaXplcnMsIGZ1bmN0aW9uKHJlY29nbml6ZXIpIHtcbiAgICAgICAgICAgIGlmIChib29sT3JGbihyZWNvZ25pemVyLm9wdGlvbnMuZW5hYmxlLCBbcmVjb2duaXplcl0pKSB7XG4gICAgICAgICAgICAgICAgYWN0aW9ucyA9IGFjdGlvbnMuY29uY2F0KHJlY29nbml6ZXIuZ2V0VG91Y2hBY3Rpb24oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucy5qb2luKCcgJykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQgb24gZWFjaCBpbnB1dCBjeWNsZSBhbmQgcHJvdmlkZXMgdGhlIHByZXZlbnRpbmcgb2YgdGhlIGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBwcmV2ZW50RGVmYXVsdHM6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzcmNFdmVudCA9IGlucHV0LnNyY0V2ZW50O1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gaW5wdXQub2Zmc2V0RGlyZWN0aW9uO1xuXG4gICAgICAgIC8vIGlmIHRoZSB0b3VjaCBhY3Rpb24gZGlkIHByZXZlbnRlZCBvbmNlIHRoaXMgc2Vzc2lvblxuICAgICAgICBpZiAodGhpcy5tYW5hZ2VyLnNlc3Npb24ucHJldmVudGVkKSB7XG4gICAgICAgICAgICBzcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG4gICAgICAgIHZhciBoYXNOb25lID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9OT05FXTtcbiAgICAgICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpICYmICFUT1VDSF9BQ1RJT05fTUFQW1RPVUNIX0FDVElPTl9QQU5fWV07XG4gICAgICAgIHZhciBoYXNQYW5YID0gaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX1BBTl9YKSAmJiAhVE9VQ0hfQUNUSU9OX01BUFtUT1VDSF9BQ1RJT05fUEFOX1hdO1xuXG4gICAgICAgIGlmIChoYXNOb25lKSB7XG4gICAgICAgICAgICAvL2RvIG5vdCBwcmV2ZW50IGRlZmF1bHRzIGlmIHRoaXMgaXMgYSB0YXAgZ2VzdHVyZVxuXG4gICAgICAgICAgICB2YXIgaXNUYXBQb2ludGVyID0gaW5wdXQucG9pbnRlcnMubGVuZ3RoID09PSAxO1xuICAgICAgICAgICAgdmFyIGlzVGFwTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IDI7XG4gICAgICAgICAgICB2YXIgaXNUYXBUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCAyNTA7XG5cbiAgICAgICAgICAgIGlmIChpc1RhcFBvaW50ZXIgJiYgaXNUYXBNb3ZlbWVudCAmJiBpc1RhcFRvdWNoVGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNQYW5YICYmIGhhc1BhblkpIHtcbiAgICAgICAgICAgIC8vIGBwYW4teCBwYW4teWAgbWVhbnMgYnJvd3NlciBoYW5kbGVzIGFsbCBzY3JvbGxpbmcvcGFubmluZywgZG8gbm90IHByZXZlbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNOb25lIHx8XG4gICAgICAgICAgICAoaGFzUGFuWSAmJiBkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkgfHxcbiAgICAgICAgICAgIChoYXNQYW5YICYmIGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRTcmMoc3JjRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGNhbGwgcHJldmVudERlZmF1bHQgdG8gcHJldmVudCB0aGUgYnJvd3NlcidzIGRlZmF1bHQgYmVoYXZpb3IgKHNjcm9sbGluZyBpbiBtb3N0IGNhc2VzKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmNFdmVudFxuICAgICAqL1xuICAgIHByZXZlbnRTcmM6IGZ1bmN0aW9uKHNyY0V2ZW50KSB7XG4gICAgICAgIHRoaXMubWFuYWdlci5zZXNzaW9uLnByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgIHNyY0V2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiB3aGVuIHRoZSB0b3VjaEFjdGlvbnMgYXJlIGNvbGxlY3RlZCB0aGV5IGFyZSBub3QgYSB2YWxpZCB2YWx1ZSwgc28gd2UgbmVlZCB0byBjbGVhbiB0aGluZ3MgdXAuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gY2xlYW5Ub3VjaEFjdGlvbnMoYWN0aW9ucykge1xuICAgIC8vIG5vbmVcbiAgICBpZiAoaW5TdHIoYWN0aW9ucywgVE9VQ0hfQUNUSU9OX05PTkUpKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICB2YXIgaGFzUGFuWCA9IGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgdmFyIGhhc1BhblkgPSBpblN0cihhY3Rpb25zLCBUT1VDSF9BQ1RJT05fUEFOX1kpO1xuXG4gICAgLy8gaWYgYm90aCBwYW4teCBhbmQgcGFuLXkgYXJlIHNldCAoZGlmZmVyZW50IHJlY29nbml6ZXJzXG4gICAgLy8gZm9yIGRpZmZlcmVudCBkaXJlY3Rpb25zLCBlLmcuIGhvcml6b250YWwgcGFuIGJ1dCB2ZXJ0aWNhbCBzd2lwZT8pXG4gICAgLy8gd2UgbmVlZCBub25lIChhcyBvdGhlcndpc2Ugd2l0aCBwYW4teCBwYW4teSBjb21iaW5lZCBub25lIG9mIHRoZXNlXG4gICAgLy8gcmVjb2duaXplcnMgd2lsbCB3b3JrLCBzaW5jZSB0aGUgYnJvd3NlciB3b3VsZCBoYW5kbGUgYWxsIHBhbm5pbmdcbiAgICBpZiAoaGFzUGFuWCAmJiBoYXNQYW5ZKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTk9ORTtcbiAgICB9XG5cbiAgICAvLyBwYW4teCBPUiBwYW4teVxuICAgIGlmIChoYXNQYW5YIHx8IGhhc1BhblkpIHtcbiAgICAgICAgcmV0dXJuIGhhc1BhblggPyBUT1VDSF9BQ1RJT05fUEFOX1ggOiBUT1VDSF9BQ1RJT05fUEFOX1k7XG4gICAgfVxuXG4gICAgLy8gbWFuaXB1bGF0aW9uXG4gICAgaWYgKGluU3RyKGFjdGlvbnMsIFRPVUNIX0FDVElPTl9NQU5JUFVMQVRJT04pKSB7XG4gICAgICAgIHJldHVybiBUT1VDSF9BQ1RJT05fTUFOSVBVTEFUSU9OO1xuICAgIH1cblxuICAgIHJldHVybiBUT1VDSF9BQ1RJT05fQVVUTztcbn1cblxuZnVuY3Rpb24gZ2V0VG91Y2hBY3Rpb25Qcm9wcygpIHtcbiAgICBpZiAoIU5BVElWRV9UT1VDSF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgdG91Y2hNYXAgPSB7fTtcbiAgICB2YXIgY3NzU3VwcG9ydHMgPSB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1Muc3VwcG9ydHM7XG4gICAgWydhdXRvJywgJ21hbmlwdWxhdGlvbicsICdwYW4teScsICdwYW4teCcsICdwYW4teCBwYW4teScsICdub25lJ10uZm9yRWFjaChmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAvLyBJZiBjc3Muc3VwcG9ydHMgaXMgbm90IHN1cHBvcnRlZCBidXQgdGhlcmUgaXMgbmF0aXZlIHRvdWNoLWFjdGlvbiBhc3N1bWUgaXQgc3VwcG9ydHNcbiAgICAgICAgLy8gYWxsIHZhbHVlcy4gVGhpcyBpcyB0aGUgY2FzZSBmb3IgSUUgMTAgYW5kIDExLlxuICAgICAgICB0b3VjaE1hcFt2YWxdID0gY3NzU3VwcG9ydHMgPyB3aW5kb3cuQ1NTLnN1cHBvcnRzKCd0b3VjaC1hY3Rpb24nLCB2YWwpIDogdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG91Y2hNYXA7XG59XG5cbi8qKlxuICogUmVjb2duaXplciBmbG93IGV4cGxhaW5lZDsgKlxuICogQWxsIHJlY29nbml6ZXJzIGhhdmUgdGhlIGluaXRpYWwgc3RhdGUgb2YgUE9TU0lCTEUgd2hlbiBhIGlucHV0IHNlc3Npb24gc3RhcnRzLlxuICogVGhlIGRlZmluaXRpb24gb2YgYSBpbnB1dCBzZXNzaW9uIGlzIGZyb20gdGhlIGZpcnN0IGlucHV0IHVudGlsIHRoZSBsYXN0IGlucHV0LCB3aXRoIGFsbCBpdCdzIG1vdmVtZW50IGluIGl0LiAqXG4gKiBFeGFtcGxlIHNlc3Npb24gZm9yIG1vdXNlLWlucHV0OiBtb3VzZWRvd24gLT4gbW91c2Vtb3ZlIC0+IG1vdXNldXBcbiAqXG4gKiBPbiBlYWNoIHJlY29nbml6aW5nIGN5Y2xlIChzZWUgTWFuYWdlci5yZWNvZ25pemUpIHRoZSAucmVjb2duaXplKCkgbWV0aG9kIGlzIGV4ZWN1dGVkXG4gKiB3aGljaCBkZXRlcm1pbmVzIHdpdGggc3RhdGUgaXQgc2hvdWxkIGJlLlxuICpcbiAqIElmIHRoZSByZWNvZ25pemVyIGhhcyB0aGUgc3RhdGUgRkFJTEVELCBDQU5DRUxMRUQgb3IgUkVDT0dOSVpFRCAoZXF1YWxzIEVOREVEKSwgaXQgaXMgcmVzZXQgdG9cbiAqIFBPU1NJQkxFIHRvIGdpdmUgaXQgYW5vdGhlciBjaGFuZ2Ugb24gdGhlIG5leHQgY3ljbGUuXG4gKlxuICogICAgICAgICAgICAgICBQb3NzaWJsZVxuICogICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICstLS0tLSstLS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICstLS0tLSstLS0tLSsgICAgICAgICAgICAgICB8XG4gKiAgICAgIHwgICAgICAgICAgIHwgICAgICAgICAgICAgICB8XG4gKiAgIEZhaWxlZCAgICAgIENhbmNlbGxlZCAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0rLS0tLS0tK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgIFJlY29nbml6ZWQgICAgICAgQmVnYW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVuZGVkL1JlY29nbml6ZWRcbiAqL1xudmFyIFNUQVRFX1BPU1NJQkxFID0gMTtcbnZhciBTVEFURV9CRUdBTiA9IDI7XG52YXIgU1RBVEVfQ0hBTkdFRCA9IDQ7XG52YXIgU1RBVEVfRU5ERUQgPSA4O1xudmFyIFNUQVRFX1JFQ09HTklaRUQgPSBTVEFURV9FTkRFRDtcbnZhciBTVEFURV9DQU5DRUxMRUQgPSAxNjtcbnZhciBTVEFURV9GQUlMRUQgPSAzMjtcblxuLyoqXG4gKiBSZWNvZ25pemVyXG4gKiBFdmVyeSByZWNvZ25pemVyIG5lZWRzIHRvIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFJlY29nbml6ZXIob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IGFzc2lnbih7fSwgdGhpcy5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLmlkID0gdW5pcXVlSWQoKTtcblxuICAgIHRoaXMubWFuYWdlciA9IG51bGw7XG5cbiAgICAvLyBkZWZhdWx0IGlzIGVuYWJsZSB0cnVlXG4gICAgdGhpcy5vcHRpb25zLmVuYWJsZSA9IGlmVW5kZWZpbmVkKHRoaXMub3B0aW9ucy5lbmFibGUsIHRydWUpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuXG4gICAgdGhpcy5zaW11bHRhbmVvdXMgPSB7fTtcbiAgICB0aGlzLnJlcXVpcmVGYWlsID0gW107XG59XG5cblJlY29nbml6ZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIEB2aXJ0dWFsXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBkZWZhdWx0czoge30sXG5cbiAgICAvKipcbiAgICAgKiBzZXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybiB7UmVjb2duaXplcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHRvdWNoQWN0aW9uLCBpbiBjYXNlIHNvbWV0aGluZyBjaGFuZ2VkIGFib3V0IHRoZSBkaXJlY3Rpb25zL2VuYWJsZWQgc3RhdGVcbiAgICAgICAgdGhpcy5tYW5hZ2VyICYmIHRoaXMubWFuYWdlci50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyLlxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ3JlY29nbml6ZVdpdGgnLCB0aGlzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2ltdWx0YW5lb3VzID0gdGhpcy5zaW11bHRhbmVvdXM7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKCFzaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXSkge1xuICAgICAgICAgICAgc2ltdWx0YW5lb3VzW290aGVyUmVjb2duaXplci5pZF0gPSBvdGhlclJlY29nbml6ZXI7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVjb2duaXplV2l0aCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZHJvcCB0aGUgc2ltdWx0YW5lb3VzIGxpbmsuIGl0IGRvZXNudCByZW1vdmUgdGhlIGxpbmsgb24gdGhlIG90aGVyIHJlY29nbml6ZXIuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7UmVjb2duaXplcn0gdGhpc1xuICAgICAqL1xuICAgIGRyb3BSZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZWNvZ25pemVXaXRoJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXJSZWNvZ25pemVyID0gZ2V0UmVjb2duaXplckJ5TmFtZUlmTWFuYWdlcihvdGhlclJlY29nbml6ZXIsIHRoaXMpO1xuICAgICAgICBkZWxldGUgdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJlY29nbml6ZXIgY2FuIG9ubHkgcnVuIHdoZW4gYW4gb3RoZXIgaXMgZmFpbGluZ1xuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gb3RoZXJSZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge1JlY29nbml6ZXJ9IHRoaXNcbiAgICAgKi9cbiAgICByZXF1aXJlRmFpbHVyZTogZnVuY3Rpb24ob3RoZXJSZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhvdGhlclJlY29nbml6ZXIsICdyZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXF1aXJlRmFpbCA9IHRoaXMucmVxdWlyZUZhaWw7XG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgaWYgKGluQXJyYXkocmVxdWlyZUZhaWwsIG90aGVyUmVjb2duaXplcikgPT09IC0xKSB7XG4gICAgICAgICAgICByZXF1aXJlRmFpbC5wdXNoKG90aGVyUmVjb2duaXplcik7XG4gICAgICAgICAgICBvdGhlclJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRyb3AgdGhlIHJlcXVpcmVGYWlsdXJlIGxpbmsuIGl0IGRvZXMgbm90IHJlbW92ZSB0aGUgbGluayBvbiB0aGUgb3RoZXIgcmVjb2duaXplci5cbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ9IG90aGVyUmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfSB0aGlzXG4gICAgICovXG4gICAgZHJvcFJlcXVpcmVGYWlsdXJlOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgaWYgKGludm9rZUFycmF5QXJnKG90aGVyUmVjb2duaXplciwgJ2Ryb3BSZXF1aXJlRmFpbHVyZScsIHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIG90aGVyUmVjb2duaXplciA9IGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCB0aGlzKTtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheSh0aGlzLnJlcXVpcmVGYWlsLCBvdGhlclJlY29nbml6ZXIpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1aXJlRmFpbC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoYXMgcmVxdWlyZSBmYWlsdXJlcyBib29sZWFuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzUmVxdWlyZUZhaWx1cmVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoID4gMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogaWYgdGhlIHJlY29nbml6ZXIgY2FuIHJlY29nbml6ZSBzaW11bHRhbmVvdXMgd2l0aCBhbiBvdGhlciByZWNvZ25pemVyXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfSBvdGhlclJlY29nbml6ZXJcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5SZWNvZ25pemVXaXRoOiBmdW5jdGlvbihvdGhlclJlY29nbml6ZXIpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zaW11bHRhbmVvdXNbb3RoZXJSZWNvZ25pemVyLmlkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWW91IHNob3VsZCB1c2UgYHRyeUVtaXRgIGluc3RlYWQgb2YgYGVtaXRgIGRpcmVjdGx5IHRvIGNoZWNrXG4gICAgICogdGhhdCBhbGwgdGhlIG5lZWRlZCByZWNvZ25pemVycyBoYXMgZmFpbGVkIGJlZm9yZSBlbWl0dGluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5wdXRcbiAgICAgKi9cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG5cbiAgICAgICAgZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgICAgICAgc2VsZi5tYW5hZ2VyLmVtaXQoZXZlbnQsIGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICdwYW5zdGFydCcgYW5kICdwYW5tb3ZlJ1xuICAgICAgICBpZiAoc3RhdGUgPCBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQpOyAvLyBzaW1wbGUgJ2V2ZW50TmFtZScgZXZlbnRzXG5cbiAgICAgICAgaWYgKGlucHV0LmFkZGl0aW9uYWxFdmVudCkgeyAvLyBhZGRpdGlvbmFsIGV2ZW50KHBhbmxlZnQsIHBhbnJpZ2h0LCBwaW5jaGluLCBwaW5jaG91dC4uLilcbiAgICAgICAgICAgIGVtaXQoaW5wdXQuYWRkaXRpb25hbEV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHBhbmVuZCBhbmQgcGFuY2FuY2VsXG4gICAgICAgIGlmIChzdGF0ZSA+PSBTVEFURV9FTkRFRCkge1xuICAgICAgICAgICAgZW1pdChzZWxmLm9wdGlvbnMuZXZlbnQgKyBzdGF0ZVN0cihzdGF0ZSkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrIHRoYXQgYWxsIHRoZSByZXF1aXJlIGZhaWx1cmUgcmVjb2duaXplcnMgaGFzIGZhaWxlZCxcbiAgICAgKiBpZiB0cnVlLCBpdCBlbWl0cyBhIGdlc3R1cmUgZXZlbnQsXG4gICAgICogb3RoZXJ3aXNlLCBzZXR1cCB0aGUgc3RhdGUgdG8gRkFJTEVELlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqL1xuICAgIHRyeUVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLmNhbkVtaXQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXQncyBmYWlsaW5nIGFueXdheVxuICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBjYW4gd2UgZW1pdD9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBjYW5FbWl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IHRoaXMucmVxdWlyZUZhaWwubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLnJlcXVpcmVGYWlsW2ldLnN0YXRlICYgKFNUQVRFX0ZBSUxFRCB8IFNUQVRFX1BPU1NJQkxFKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSB0aGUgcmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICAvLyBtYWtlIGEgbmV3IGNvcHkgb2YgdGhlIGlucHV0RGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gY2hhbmdlIHRoZSBpbnB1dERhdGEgd2l0aG91dCBtZXNzaW5nIHVwIHRoZSBvdGhlciByZWNvZ25pemVyc1xuICAgICAgICB2YXIgaW5wdXREYXRhQ2xvbmUgPSBhc3NpZ24oe30sIGlucHV0RGF0YSk7XG5cbiAgICAgICAgLy8gaXMgaXMgZW5hYmxlZCBhbmQgYWxsb3cgcmVjb2duaXppbmc/XG4gICAgICAgIGlmICghYm9vbE9yRm4odGhpcy5vcHRpb25zLmVuYWJsZSwgW3RoaXMsIGlucHV0RGF0YUNsb25lXSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9GQUlMRUQ7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZXNldCB3aGVuIHdlJ3ZlIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAmIChTVEFURV9SRUNPR05JWkVEIHwgU1RBVEVfQ0FOQ0VMTEVEIHwgU1RBVEVfRkFJTEVEKSkge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IFNUQVRFX1BPU1NJQkxFO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMucHJvY2VzcyhpbnB1dERhdGFDbG9uZSk7XG5cbiAgICAgICAgLy8gdGhlIHJlY29nbml6ZXIgaGFzIHJlY29nbml6ZWQgYSBnZXN0dXJlXG4gICAgICAgIC8vIHNvIHRyaWdnZXIgYW4gZXZlbnRcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgJiAoU1RBVEVfQkVHQU4gfCBTVEFURV9DSEFOR0VEIHwgU1RBVEVfRU5ERUQgfCBTVEFURV9DQU5DRUxMRUQpKSB7XG4gICAgICAgICAgICB0aGlzLnRyeUVtaXQoaW5wdXREYXRhQ2xvbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybiB0aGUgc3RhdGUgb2YgdGhlIHJlY29nbml6ZXJcbiAgICAgKiB0aGUgYWN0dWFsIHJlY29nbml6aW5nIGhhcHBlbnMgaW4gdGhpcyBtZXRob2RcbiAgICAgKiBAdmlydHVhbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKiBAcmV0dXJucyB7Q29uc3R9IFNUQVRFXG4gICAgICovXG4gICAgcHJvY2VzczogZnVuY3Rpb24oaW5wdXREYXRhKSB7IH0sIC8vIGpzaGludCBpZ25vcmU6bGluZVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRoZSBwcmVmZXJyZWQgdG91Y2gtYWN0aW9uXG4gICAgICogQHZpcnR1YWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkgeyB9LFxuXG4gICAgLyoqXG4gICAgICogY2FsbGVkIHdoZW4gdGhlIGdlc3R1cmUgaXNuJ3QgYWxsb3dlZCB0byByZWNvZ25pemVcbiAgICAgKiBsaWtlIHdoZW4gYW5vdGhlciBpcyBiZWluZyByZWNvZ25pemVkIG9yIGl0IGlzIGRpc2FibGVkXG4gICAgICogQHZpcnR1YWxcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7IH1cbn07XG5cbi8qKlxuICogZ2V0IGEgdXNhYmxlIHN0cmluZywgdXNlZCBhcyBldmVudCBwb3N0Zml4XG4gKiBAcGFyYW0ge0NvbnN0fSBzdGF0ZVxuICogQHJldHVybnMge1N0cmluZ30gc3RhdGVcbiAqL1xuZnVuY3Rpb24gc3RhdGVTdHIoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgJiBTVEFURV9DQU5DRUxMRUQpIHtcbiAgICAgICAgcmV0dXJuICdjYW5jZWwnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUgJiBTVEFURV9FTkRFRCkge1xuICAgICAgICByZXR1cm4gJ2VuZCc7XG4gICAgfSBlbHNlIGlmIChzdGF0ZSAmIFNUQVRFX0NIQU5HRUQpIHtcbiAgICAgICAgcmV0dXJuICdtb3ZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlICYgU1RBVEVfQkVHQU4pIHtcbiAgICAgICAgcmV0dXJuICdzdGFydCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBkaXJlY3Rpb24gY29ucyB0byBzdHJpbmdcbiAqIEBwYXJhbSB7Q29uc3R9IGRpcmVjdGlvblxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZGlyZWN0aW9uU3RyKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0RPV04pIHtcbiAgICAgICAgcmV0dXJuICdkb3duJztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fVVApIHtcbiAgICAgICAgcmV0dXJuICd1cCc7XG4gICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT0gRElSRUNUSU9OX0xFRlQpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PSBESVJFQ1RJT05fUklHSFQpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBnZXQgYSByZWNvZ25pemVyIGJ5IG5hbWUgaWYgaXQgaXMgYm91bmQgdG8gYSBtYW5hZ2VyXG4gKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSBvdGhlclJlY29nbml6ZXJcbiAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICogQHJldHVybnMge1JlY29nbml6ZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldFJlY29nbml6ZXJCeU5hbWVJZk1hbmFnZXIob3RoZXJSZWNvZ25pemVyLCByZWNvZ25pemVyKSB7XG4gICAgdmFyIG1hbmFnZXIgPSByZWNvZ25pemVyLm1hbmFnZXI7XG4gICAgaWYgKG1hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZXIuZ2V0KG90aGVyUmVjb2duaXplcik7XG4gICAgfVxuICAgIHJldHVybiBvdGhlclJlY29nbml6ZXI7XG59XG5cbi8qKlxuICogVGhpcyByZWNvZ25pemVyIGlzIGp1c3QgdXNlZCBhcyBhIGJhc2UgZm9yIHRoZSBzaW1wbGUgYXR0cmlidXRlIHJlY29nbml6ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIEF0dHJSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuaW5oZXJpdChBdHRyUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgQXR0clJlY29nbml6ZXJcbiAgICAgKi9cbiAgICBkZWZhdWx0czoge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAgICogQGRlZmF1bHQgMVxuICAgICAgICAgKi9cbiAgICAgICAgcG9pbnRlcnM6IDFcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBjaGVjayBpZiBpdCB0aGUgcmVjb2duaXplciByZWNlaXZlcyB2YWxpZCBpbnB1dCwgbGlrZSBpbnB1dC5kaXN0YW5jZSA+IDEwLlxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSByZWNvZ25pemVkXG4gICAgICovXG4gICAgYXR0clRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25Qb2ludGVycyA9IHRoaXMub3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgcmV0dXJuIG9wdGlvblBvaW50ZXJzID09PSAwIHx8IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9uUG9pbnRlcnM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgdGhlIGlucHV0IGFuZCByZXR1cm4gdGhlIHN0YXRlIGZvciB0aGUgcmVjb2duaXplclxuICAgICAqIEBtZW1iZXJvZiBBdHRyUmVjb2duaXplclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgICAqIEByZXR1cm5zIHsqfSBTdGF0ZVxuICAgICAqL1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBpbnB1dC5ldmVudFR5cGU7XG5cbiAgICAgICAgdmFyIGlzUmVjb2duaXplZCA9IHN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gdGhpcy5hdHRyVGVzdChpbnB1dCk7XG5cbiAgICAgICAgLy8gb24gY2FuY2VsIGlucHV0IGFuZCB3ZSd2ZSByZWNvZ25pemVkIGJlZm9yZSwgcmV0dXJuIFNUQVRFX0NBTkNFTExFRFxuICAgICAgICBpZiAoaXNSZWNvZ25pemVkICYmIChldmVudFR5cGUgJiBJTlBVVF9DQU5DRUwgfHwgIWlzVmFsaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9DQU5DRUxMRUQ7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNSZWNvZ25pemVkIHx8IGlzVmFsaWQpIHtcbiAgICAgICAgICAgIGlmIChldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUgfCBTVEFURV9FTkRFRDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShzdGF0ZSAmIFNUQVRFX0JFR0FOKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9CRUdBTjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZSB8IFNUQVRFX0NIQU5HRUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFNUQVRFX0ZBSUxFRDtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBQYW5cbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGFuZCBtb3ZlZCBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBhblJlY29nbml6ZXIoKSB7XG4gICAgQXR0clJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIHRoaXMucFggPSBudWxsO1xuICAgIHRoaXMucFkgPSBudWxsO1xufVxuXG5pbmhlcml0KFBhblJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBQYW5SZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwYW4nLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICBwb2ludGVyczogMSxcbiAgICAgICAgZGlyZWN0aW9uOiBESVJFQ1RJT05fQUxMXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciBhY3Rpb25zID0gW107XG4gICAgICAgIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpcmVjdGlvbiAmIERJUkVDVElPTl9WRVJUSUNBTCkge1xuICAgICAgICAgICAgYWN0aW9ucy5wdXNoKFRPVUNIX0FDVElPTl9QQU5fWCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjdGlvbnM7XG4gICAgfSxcblxuICAgIGRpcmVjdGlvblRlc3Q6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB2YXIgaGFzTW92ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbnB1dC5kaXN0YW5jZTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGlucHV0LmRpcmVjdGlvbjtcbiAgICAgICAgdmFyIHggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHZhciB5ID0gaW5wdXQuZGVsdGFZO1xuXG4gICAgICAgIC8vIGxvY2sgdG8gYXhpcz9cbiAgICAgICAgaWYgKCEoZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kaXJlY3Rpb24gJiBESVJFQ1RJT05fSE9SSVpPTlRBTCkge1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9ICh4ID09PSAwKSA/IERJUkVDVElPTl9OT05FIDogKHggPCAwKSA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgICAgICAgICAgIGhhc01vdmVkID0geCAhPSB0aGlzLnBYO1xuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoaW5wdXQuZGVsdGFYKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gKHkgPT09IDApID8gRElSRUNUSU9OX05PTkUgOiAoeSA8IDApID8gRElSRUNUSU9OX1VQIDogRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgICAgICAgaGFzTW92ZWQgPSB5ICE9IHRoaXMucFk7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicyhpbnB1dC5kZWx0YVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlucHV0LmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgcmV0dXJuIGhhc01vdmVkICYmIGRpc3RhbmNlID4gb3B0aW9ucy50aHJlc2hvbGQgJiYgZGlyZWN0aW9uICYgb3B0aW9ucy5kaXJlY3Rpb247XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gQXR0clJlY29nbml6ZXIucHJvdG90eXBlLmF0dHJUZXN0LmNhbGwodGhpcywgaW5wdXQpICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSAmIFNUQVRFX0JFR0FOIHx8ICghKHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTikgJiYgdGhpcy5kaXJlY3Rpb25UZXN0KGlucHV0KSkpO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuXG4gICAgICAgIHRoaXMucFggPSBpbnB1dC5kZWx0YVg7XG4gICAgICAgIHRoaXMucFkgPSBpbnB1dC5kZWx0YVk7XG5cbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGRpcmVjdGlvblN0cihpbnB1dC5kaXJlY3Rpb24pO1xuXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGRpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdXBlci5lbWl0LmNhbGwodGhpcywgaW5wdXQpO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIFBpbmNoXG4gKiBSZWNvZ25pemVkIHdoZW4gdHdvIG9yIG1vcmUgcG9pbnRlcnMgYXJlIG1vdmluZyB0b3dhcmQgKHpvb20taW4pIG9yIGF3YXkgZnJvbSBlYWNoIG90aGVyICh6b29tLW91dCkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFBpbmNoUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFBpbmNoUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAncGluY2gnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5zY2FsZSAtIDEpID4gdGhpcy5vcHRpb25zLnRocmVzaG9sZCB8fCB0aGlzLnN0YXRlICYgU1RBVEVfQkVHQU4pO1xuICAgIH0sXG5cbiAgICBlbWl0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuc2NhbGUgIT09IDEpIHtcbiAgICAgICAgICAgIHZhciBpbk91dCA9IGlucHV0LnNjYWxlIDwgMSA/ICdpbicgOiAnb3V0JztcbiAgICAgICAgICAgIGlucHV0LmFkZGl0aW9uYWxFdmVudCA9IHRoaXMub3B0aW9ucy5ldmVudCArIGluT3V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N1cGVyLmVtaXQuY2FsbCh0aGlzLCBpbnB1dCk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogUHJlc3NcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb3duIGZvciB4IG1zIHdpdGhvdXQgYW55IG1vdmVtZW50LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFByZXNzUmVjb2duaXplcigpIHtcbiAgICBSZWNvZ25pemVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xufVxuXG5pbmhlcml0KFByZXNzUmVjb2duaXplciwgUmVjb2duaXplciwge1xuICAgIC8qKlxuICAgICAqIEBuYW1lc3BhY2VcbiAgICAgKiBAbWVtYmVyb2YgUHJlc3NSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdwcmVzcycsXG4gICAgICAgIHBvaW50ZXJzOiAxLFxuICAgICAgICB0aW1lOiAyNTEsIC8vIG1pbmltYWwgdGltZSBvZiB0aGUgcG9pbnRlciB0byBiZSBwcmVzc2VkXG4gICAgICAgIHRocmVzaG9sZDogOSAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbVE9VQ0hfQUNUSU9OX0FVVE9dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdmFyIHZhbGlkUG9pbnRlcnMgPSBpbnB1dC5wb2ludGVycy5sZW5ndGggPT09IG9wdGlvbnMucG9pbnRlcnM7XG4gICAgICAgIHZhciB2YWxpZE1vdmVtZW50ID0gaW5wdXQuZGlzdGFuY2UgPCBvcHRpb25zLnRocmVzaG9sZDtcbiAgICAgICAgdmFyIHZhbGlkVGltZSA9IGlucHV0LmRlbHRhVGltZSA+IG9wdGlvbnMudGltZTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKCF2YWxpZE1vdmVtZW50IHx8ICF2YWxpZFBvaW50ZXJzIHx8IChpbnB1dC5ldmVudFR5cGUgJiAoSU5QVVRfRU5EIHwgSU5QVVRfQ0FOQ0VMKSAmJiAhdmFsaWRUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmV2ZW50VHlwZSAmIElOUFVUX1NUQVJUKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXRDb250ZXh0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTVEFURV9GQUlMRUQ7XG4gICAgfSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcbiAgICB9LFxuXG4gICAgZW1pdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IFNUQVRFX1JFQ09HTklaRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dCAmJiAoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfRU5EKSkge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgJ3VwJywgaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faW5wdXQudGltZVN0YW1wID0gbm93KCk7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFJvdGF0ZVxuICogUmVjb2duaXplZCB3aGVuIHR3byBvciBtb3JlIHBvaW50ZXIgYXJlIG1vdmluZyBpbiBhIGNpcmN1bGFyIG1vdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQXR0clJlY29nbml6ZXJcbiAqL1xuZnVuY3Rpb24gUm90YXRlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFJvdGF0ZVJlY29nbml6ZXIsIEF0dHJSZWNvZ25pemVyLCB7XG4gICAgLyoqXG4gICAgICogQG5hbWVzcGFjZVxuICAgICAqIEBtZW1iZXJvZiBSb3RhdGVSZWNvZ25pemVyXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgZXZlbnQ6ICdyb3RhdGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDAsXG4gICAgICAgIHBvaW50ZXJzOiAyXG4gICAgfSxcblxuICAgIGdldFRvdWNoQWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtUT1VDSF9BQ1RJT05fTk9ORV07XG4gICAgfSxcblxuICAgIGF0dHJUZXN0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIuYXR0clRlc3QuY2FsbCh0aGlzLCBpbnB1dCkgJiZcbiAgICAgICAgICAgIChNYXRoLmFicyhpbnB1dC5yb3RhdGlvbikgPiB0aGlzLm9wdGlvbnMudGhyZXNob2xkIHx8IHRoaXMuc3RhdGUgJiBTVEFURV9CRUdBTik7XG4gICAgfVxufSk7XG5cbi8qKlxuICogU3dpcGVcbiAqIFJlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBtb3ZpbmcgZmFzdCAodmVsb2NpdHkpLCB3aXRoIGVub3VnaCBkaXN0YW5jZSBpbiB0aGUgYWxsb3dlZCBkaXJlY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEF0dHJSZWNvZ25pemVyXG4gKi9cbmZ1bmN0aW9uIFN3aXBlUmVjb2duaXplcigpIHtcbiAgICBBdHRyUmVjb2duaXplci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5pbmhlcml0KFN3aXBlUmVjb2duaXplciwgQXR0clJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFN3aXBlUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAnc3dpcGUnLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwLFxuICAgICAgICB2ZWxvY2l0eTogMC4zLFxuICAgICAgICBkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgICAgICBwb2ludGVyczogMVxuICAgIH0sXG5cbiAgICBnZXRUb3VjaEFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQYW5SZWNvZ25pemVyLnByb3RvdHlwZS5nZXRUb3VjaEFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICBhdHRyVGVzdDogZnVuY3Rpb24oaW5wdXQpIHtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IHRoaXMub3B0aW9ucy5kaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZWxvY2l0eTtcblxuICAgICAgICBpZiAoZGlyZWN0aW9uICYgKERJUkVDVElPTl9IT1JJWk9OVEFMIHwgRElSRUNUSU9OX1ZFUlRJQ0FMKSkge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSBpbnB1dC5vdmVyYWxsVmVsb2NpdHk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlyZWN0aW9uICYgRElSRUNUSU9OX0hPUklaT05UQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WDtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gJiBESVJFQ1RJT05fVkVSVElDQUwpIHtcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gaW5wdXQub3ZlcmFsbFZlbG9jaXR5WTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9zdXBlci5hdHRyVGVzdC5jYWxsKHRoaXMsIGlucHV0KSAmJlxuICAgICAgICAgICAgZGlyZWN0aW9uICYgaW5wdXQub2Zmc2V0RGlyZWN0aW9uICYmXG4gICAgICAgICAgICBpbnB1dC5kaXN0YW5jZSA+IHRoaXMub3B0aW9ucy50aHJlc2hvbGQgJiZcbiAgICAgICAgICAgIGlucHV0Lm1heFBvaW50ZXJzID09IHRoaXMub3B0aW9ucy5wb2ludGVycyAmJlxuICAgICAgICAgICAgYWJzKHZlbG9jaXR5KSA+IHRoaXMub3B0aW9ucy52ZWxvY2l0eSAmJiBpbnB1dC5ldmVudFR5cGUgJiBJTlBVVF9FTkQ7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBkaXJlY3Rpb25TdHIoaW5wdXQub2Zmc2V0RGlyZWN0aW9uKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5tYW5hZ2VyLmVtaXQodGhpcy5vcHRpb25zLmV2ZW50ICsgZGlyZWN0aW9uLCBpbnB1dCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIGlucHV0KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBBIHRhcCBpcyBlY29nbml6ZWQgd2hlbiB0aGUgcG9pbnRlciBpcyBkb2luZyBhIHNtYWxsIHRhcC9jbGljay4gTXVsdGlwbGUgdGFwcyBhcmUgcmVjb2duaXplZCBpZiB0aGV5IG9jY3VyXG4gKiBiZXR3ZWVuIHRoZSBnaXZlbiBpbnRlcnZhbCBhbmQgcG9zaXRpb24uIFRoZSBkZWxheSBvcHRpb24gY2FuIGJlIHVzZWQgdG8gcmVjb2duaXplIG11bHRpLXRhcHMgd2l0aG91dCBmaXJpbmdcbiAqIGEgc2luZ2xlIHRhcC5cbiAqXG4gKiBUaGUgZXZlbnREYXRhIGZyb20gdGhlIGVtaXR0ZWQgZXZlbnQgY29udGFpbnMgdGhlIHByb3BlcnR5IGB0YXBDb3VudGAsIHdoaWNoIGNvbnRhaW5zIHRoZSBhbW91bnQgb2ZcbiAqIG11bHRpLXRhcHMgYmVpbmcgcmVjb2duaXplZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgUmVjb2duaXplclxuICovXG5mdW5jdGlvbiBUYXBSZWNvZ25pemVyKCkge1xuICAgIFJlY29nbml6ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHByZXZpb3VzIHRpbWUgYW5kIGNlbnRlcixcbiAgICAvLyB1c2VkIGZvciB0YXAgY291bnRpbmdcbiAgICB0aGlzLnBUaW1lID0gZmFsc2U7XG4gICAgdGhpcy5wQ2VudGVyID0gZmFsc2U7XG5cbiAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgdGhpcy5faW5wdXQgPSBudWxsO1xuICAgIHRoaXMuY291bnQgPSAwO1xufVxuXG5pbmhlcml0KFRhcFJlY29nbml6ZXIsIFJlY29nbml6ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICogQG1lbWJlcm9mIFBpbmNoUmVjb2duaXplclxuICAgICAqL1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIGV2ZW50OiAndGFwJyxcbiAgICAgICAgcG9pbnRlcnM6IDEsXG4gICAgICAgIHRhcHM6IDEsXG4gICAgICAgIGludGVydmFsOiAzMDAsIC8vIG1heCB0aW1lIGJldHdlZW4gdGhlIG11bHRpLXRhcCB0YXBzXG4gICAgICAgIHRpbWU6IDI1MCwgLy8gbWF4IHRpbWUgb2YgdGhlIHBvaW50ZXIgdG8gYmUgZG93biAobGlrZSBmaW5nZXIgb24gdGhlIHNjcmVlbilcbiAgICAgICAgdGhyZXNob2xkOiA5LCAvLyBhIG1pbmltYWwgbW92ZW1lbnQgaXMgb2ssIGJ1dCBrZWVwIGl0IGxvd1xuICAgICAgICBwb3NUaHJlc2hvbGQ6IDEwIC8vIGEgbXVsdGktdGFwIGNhbiBiZSBhIGJpdCBvZmYgdGhlIGluaXRpYWwgcG9zaXRpb25cbiAgICB9LFxuXG4gICAgZ2V0VG91Y2hBY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW1RPVUNIX0FDVElPTl9NQU5JUFVMQVRJT05dO1xuICAgIH0sXG5cbiAgICBwcm9jZXNzOiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgICB2YXIgdmFsaWRQb2ludGVycyA9IGlucHV0LnBvaW50ZXJzLmxlbmd0aCA9PT0gb3B0aW9ucy5wb2ludGVycztcbiAgICAgICAgdmFyIHZhbGlkTW92ZW1lbnQgPSBpbnB1dC5kaXN0YW5jZSA8IG9wdGlvbnMudGhyZXNob2xkO1xuICAgICAgICB2YXIgdmFsaWRUb3VjaFRpbWUgPSBpbnB1dC5kZWx0YVRpbWUgPCBvcHRpb25zLnRpbWU7XG5cbiAgICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICAgIGlmICgoaW5wdXQuZXZlbnRUeXBlICYgSU5QVVRfU1RBUlQpICYmICh0aGlzLmNvdW50ID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmFpbFRpbWVvdXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG9ubHkgYWxsb3cgbGl0dGxlIG1vdmVtZW50XG4gICAgICAgIC8vIGFuZCB3ZSd2ZSByZWFjaGVkIGFuIGVuZCBldmVudCwgc28gYSB0YXAgaXMgcG9zc2libGVcbiAgICAgICAgaWYgKHZhbGlkTW92ZW1lbnQgJiYgdmFsaWRUb3VjaFRpbWUgJiYgdmFsaWRQb2ludGVycykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmV2ZW50VHlwZSAhPSBJTlBVVF9FTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mYWlsVGltZW91dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdmFsaWRJbnRlcnZhbCA9IHRoaXMucFRpbWUgPyAoaW5wdXQudGltZVN0YW1wIC0gdGhpcy5wVGltZSA8IG9wdGlvbnMuaW50ZXJ2YWwpIDogdHJ1ZTtcbiAgICAgICAgICAgIHZhciB2YWxpZE11bHRpVGFwID0gIXRoaXMucENlbnRlciB8fCBnZXREaXN0YW5jZSh0aGlzLnBDZW50ZXIsIGlucHV0LmNlbnRlcikgPCBvcHRpb25zLnBvc1RocmVzaG9sZDtcblxuICAgICAgICAgICAgdGhpcy5wVGltZSA9IGlucHV0LnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHRoaXMucENlbnRlciA9IGlucHV0LmNlbnRlcjtcblxuICAgICAgICAgICAgaWYgKCF2YWxpZE11bHRpVGFwIHx8ICF2YWxpZEludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCA9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcblxuICAgICAgICAgICAgLy8gaWYgdGFwIGNvdW50IG1hdGNoZXMgd2UgaGF2ZSByZWNvZ25pemVkIGl0LFxuICAgICAgICAgICAgLy8gZWxzZSBpdCBoYXMgYmVnYW4gcmVjb2duaXppbmcuLi5cbiAgICAgICAgICAgIHZhciB0YXBDb3VudCA9IHRoaXMuY291bnQgJSBvcHRpb25zLnRhcHM7XG4gICAgICAgICAgICBpZiAodGFwQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBubyBmYWlsaW5nIHJlcXVpcmVtZW50cywgaW1tZWRpYXRlbHkgdHJpZ2dlciB0aGUgdGFwIGV2ZW50XG4gICAgICAgICAgICAgICAgLy8gb3Igd2FpdCBhcyBsb25nIGFzIHRoZSBtdWx0aXRhcCBpbnRlcnZhbCB0byB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmhhc1JlcXVpcmVGYWlsdXJlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTVEFURV9SRUNPR05JWkVEO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfUkVDT0dOSVpFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJ5RW1pdCgpO1xuICAgICAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmludGVydmFsLCB0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNUQVRFX0JFR0FOO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICBmYWlsVGltZW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dENvbnRleHQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU1RBVEVfRkFJTEVEO1xuICAgICAgICB9LCB0aGlzLm9wdGlvbnMuaW50ZXJ2YWwsIHRoaXMpO1xuICAgICAgICByZXR1cm4gU1RBVEVfRkFJTEVEO1xuICAgIH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgfSxcblxuICAgIGVtaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PSBTVEFURV9SRUNPR05JWkVEKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnB1dC50YXBDb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgICAgICB0aGlzLm1hbmFnZXIuZW1pdCh0aGlzLm9wdGlvbnMuZXZlbnQsIHRoaXMuX2lucHV0KTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vKipcbiAqIFNpbXBsZSB3YXkgdG8gY3JlYXRlIGEgbWFuYWdlciB3aXRoIGEgZGVmYXVsdCBzZXQgb2YgcmVjb2duaXplcnMuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSGFtbWVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnJlY29nbml6ZXJzID0gaWZVbmRlZmluZWQob3B0aW9ucy5yZWNvZ25pemVycywgSGFtbWVyLmRlZmF1bHRzLnByZXNldCk7XG4gICAgcmV0dXJuIG5ldyBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEBjb25zdCB7c3RyaW5nfVxuICovXG5IYW1tZXIuVkVSU0lPTiA9ICcyLjAuNyc7XG5cbi8qKlxuICogZGVmYXVsdCBzZXR0aW5nc1xuICogQG5hbWVzcGFjZVxuICovXG5IYW1tZXIuZGVmYXVsdHMgPSB7XG4gICAgLyoqXG4gICAgICogc2V0IGlmIERPTSBldmVudHMgYXJlIGJlaW5nIHRyaWdnZXJlZC5cbiAgICAgKiBCdXQgdGhpcyBpcyBzbG93ZXIgYW5kIHVudXNlZCBieSBzaW1wbGUgaW1wbGVtZW50YXRpb25zLCBzbyBkaXNhYmxlZCBieSBkZWZhdWx0LlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgZG9tRXZlbnRzOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhlIHRvdWNoQWN0aW9uIHByb3BlcnR5L2ZhbGxiYWNrLlxuICAgICAqIFdoZW4gc2V0IHRvIGBjb21wdXRlYCBpdCB3aWxsIG1hZ2ljYWxseSBzZXQgdGhlIGNvcnJlY3QgdmFsdWUgYmFzZWQgb24gdGhlIGFkZGVkIHJlY29nbml6ZXJzLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQGRlZmF1bHQgY29tcHV0ZVxuICAgICAqL1xuICAgIHRvdWNoQWN0aW9uOiBUT1VDSF9BQ1RJT05fQ09NUFVURSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgKi9cbiAgICBlbmFibGU6IHRydWUsXG5cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUwgRkVBVFVSRSAtLSBjYW4gYmUgcmVtb3ZlZC9jaGFuZ2VkXG4gICAgICogQ2hhbmdlIHRoZSBwYXJlbnQgaW5wdXQgdGFyZ2V0IGVsZW1lbnQuXG4gICAgICogSWYgTnVsbCwgdGhlbiBpdCBpcyBiZWluZyBzZXQgdGhlIHRvIG1haW4gZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7TnVsbHxFdmVudFRhcmdldH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG4gICAgaW5wdXRUYXJnZXQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBmb3JjZSBhbiBpbnB1dCBjbGFzc1xuICAgICAqIEB0eXBlIHtOdWxsfEZ1bmN0aW9ufVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cbiAgICBpbnB1dENsYXNzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWNvZ25pemVyIHNldHVwIHdoZW4gY2FsbGluZyBgSGFtbWVyKClgXG4gICAgICogV2hlbiBjcmVhdGluZyBhIG5ldyBNYW5hZ2VyIHRoZXNlIHdpbGwgYmUgc2tpcHBlZC5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgcHJlc2V0OiBbXG4gICAgICAgIC8vIFJlY29nbml6ZXJDbGFzcywgb3B0aW9ucywgW3JlY29nbml6ZVdpdGgsIC4uLl0sIFtyZXF1aXJlRmFpbHVyZSwgLi4uXVxuICAgICAgICBbUm90YXRlUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9XSxcbiAgICAgICAgW1BpbmNoUmVjb2duaXplciwge2VuYWJsZTogZmFsc2V9LCBbJ3JvdGF0ZSddXSxcbiAgICAgICAgW1N3aXBlUmVjb2duaXplciwge2RpcmVjdGlvbjogRElSRUNUSU9OX0hPUklaT05UQUx9XSxcbiAgICAgICAgW1BhblJlY29nbml6ZXIsIHtkaXJlY3Rpb246IERJUkVDVElPTl9IT1JJWk9OVEFMfSwgWydzd2lwZSddXSxcbiAgICAgICAgW1RhcFJlY29nbml6ZXJdLFxuICAgICAgICBbVGFwUmVjb2duaXplciwge2V2ZW50OiAnZG91YmxldGFwJywgdGFwczogMn0sIFsndGFwJ11dLFxuICAgICAgICBbUHJlc3NSZWNvZ25pemVyXVxuICAgIF0sXG5cbiAgICAvKipcbiAgICAgKiBTb21lIENTUyBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIHRvIGltcHJvdmUgdGhlIHdvcmtpbmcgb2YgSGFtbWVyLlxuICAgICAqIEFkZCB0aGVtIHRvIHRoaXMgbWV0aG9kIGFuZCB0aGV5IHdpbGwgYmUgc2V0IHdoZW4gY3JlYXRpbmcgYSBuZXcgTWFuYWdlci5cbiAgICAgKiBAbmFtZXNwYWNlXG4gICAgICovXG4gICAgY3NzUHJvcHM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRleHQgc2VsZWN0aW9uIHRvIGltcHJvdmUgdGhlIGRyYWdnaW5nIGdlc3R1cmUuIE1haW5seSBmb3IgZGVza3RvcCBicm93c2Vycy5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGUgdGhlIFdpbmRvd3MgUGhvbmUgZ3JpcHBlcnMgd2hlbiBwcmVzc2luZyBhbiBlbGVtZW50LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoU2VsZWN0OiAnbm9uZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERpc2FibGVzIHRoZSBkZWZhdWx0IGNhbGxvdXQgc2hvd24gd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQuXG4gICAgICAgICAqIE9uIGlPUywgd2hlbiB5b3UgdG91Y2ggYW5kIGhvbGQgYSB0b3VjaCB0YXJnZXQgc3VjaCBhcyBhIGxpbmssIFNhZmFyaSBkaXNwbGF5c1xuICAgICAgICAgKiBhIGNhbGxvdXQgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGluay4gVGhpcyBwcm9wZXJ0eSBhbGxvd3MgeW91IHRvIGRpc2FibGUgdGhhdCBjYWxsb3V0LlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAnbm9uZSdcbiAgICAgICAgICovXG4gICAgICAgIHRvdWNoQ2FsbG91dDogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgd2hldGhlciB6b29taW5nIGlzIGVuYWJsZWQuIFVzZWQgYnkgSUUxMD5cbiAgICAgICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgICAgICogQGRlZmF1bHQgJ25vbmUnXG4gICAgICAgICAqL1xuICAgICAgICBjb250ZW50Wm9vbWluZzogJ25vbmUnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWZpZXMgdGhhdCBhbiBlbnRpcmUgZWxlbWVudCBzaG91bGQgYmUgZHJhZ2dhYmxlIGluc3RlYWQgb2YgaXRzIGNvbnRlbnRzLiBNYWlubHkgZm9yIGRlc2t0b3AgYnJvd3NlcnMuXG4gICAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgICAqIEBkZWZhdWx0ICdub25lJ1xuICAgICAgICAgKi9cbiAgICAgICAgdXNlckRyYWc6ICdub25lJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBoaWdobGlnaHQgY29sb3Igc2hvd24gd2hlbiB0aGUgdXNlciB0YXBzIGEgbGluayBvciBhIEphdmFTY3JpcHRcbiAgICAgICAgICogY2xpY2thYmxlIGVsZW1lbnQgaW4gaU9TLiBUaGlzIHByb3BlcnR5IG9iZXlzIHRoZSBhbHBoYSB2YWx1ZSwgaWYgc3BlY2lmaWVkLlxuICAgICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICAgKiBAZGVmYXVsdCAncmdiYSgwLDAsMCwwKSdcbiAgICAgICAgICovXG4gICAgICAgIHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcbiAgICB9XG59O1xuXG52YXIgU1RPUCA9IDE7XG52YXIgRk9SQ0VEX1NUT1AgPSAyO1xuXG4vKipcbiAqIE1hbmFnZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBNYW5hZ2VyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBhc3NpZ24oe30sIEhhbW1lci5kZWZhdWx0cywgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgPSB0aGlzLm9wdGlvbnMuaW5wdXRUYXJnZXQgfHwgZWxlbWVudDtcblxuICAgIHRoaXMuaGFuZGxlcnMgPSB7fTtcbiAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICB0aGlzLnJlY29nbml6ZXJzID0gW107XG4gICAgdGhpcy5vbGRDc3NQcm9wcyA9IHt9O1xuXG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmlucHV0ID0gY3JlYXRlSW5wdXRJbnN0YW5jZSh0aGlzKTtcbiAgICB0aGlzLnRvdWNoQWN0aW9uID0gbmV3IFRvdWNoQWN0aW9uKHRoaXMsIHRoaXMub3B0aW9ucy50b3VjaEFjdGlvbik7XG5cbiAgICB0b2dnbGVDc3NQcm9wcyh0aGlzLCB0cnVlKTtcblxuICAgIGVhY2godGhpcy5vcHRpb25zLnJlY29nbml6ZXJzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciByZWNvZ25pemVyID0gdGhpcy5hZGQobmV3IChpdGVtWzBdKShpdGVtWzFdKSk7XG4gICAgICAgIGl0ZW1bMl0gJiYgcmVjb2duaXplci5yZWNvZ25pemVXaXRoKGl0ZW1bMl0pO1xuICAgICAgICBpdGVtWzNdICYmIHJlY29nbml6ZXIucmVxdWlyZUZhaWx1cmUoaXRlbVszXSk7XG4gICAgfSwgdGhpcyk7XG59XG5cbk1hbmFnZXIucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAqIHNldCBvcHRpb25zXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7TWFuYWdlcn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgYXNzaWduKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gT3B0aW9ucyB0aGF0IG5lZWQgYSBsaXR0bGUgbW9yZSBzZXR1cFxuICAgICAgICBpZiAob3B0aW9ucy50b3VjaEFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy50b3VjaEFjdGlvbi51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pbnB1dFRhcmdldCkge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJzIGFuZCByZWluaXRpYWxpemVcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dC50YXJnZXQgPSBvcHRpb25zLmlucHV0VGFyZ2V0O1xuICAgICAgICAgICAgdGhpcy5pbnB1dC5pbml0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN0b3AgcmVjb2duaXppbmcgZm9yIHRoaXMgc2Vzc2lvbi5cbiAgICAgKiBUaGlzIHNlc3Npb24gd2lsbCBiZSBkaXNjYXJkZWQsIHdoZW4gYSBuZXcgW2lucHV0XXN0YXJ0IGV2ZW50IGlzIGZpcmVkLlxuICAgICAqIFdoZW4gZm9yY2VkLCB0aGUgcmVjb2duaXplciBjeWNsZSBpcyBzdG9wcGVkIGltbWVkaWF0ZWx5LlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlXVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbi5zdG9wcGVkID0gZm9yY2UgPyBGT1JDRURfU1RPUCA6IFNUT1A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJ1biB0aGUgcmVjb2duaXplcnMhXG4gICAgICogY2FsbGVkIGJ5IHRoZSBpbnB1dEhhbmRsZXIgZnVuY3Rpb24gb24gZXZlcnkgbW92ZW1lbnQgb2YgdGhlIHBvaW50ZXJzICh0b3VjaGVzKVxuICAgICAqIGl0IHdhbGtzIHRocm91Z2ggYWxsIHRoZSByZWNvZ25pemVycyBhbmQgdHJpZXMgdG8gZGV0ZWN0IHRoZSBnZXN0dXJlIHRoYXQgaXMgYmVpbmcgbWFkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dERhdGFcbiAgICAgKi9cbiAgICByZWNvZ25pemU6IGZ1bmN0aW9uKGlucHV0RGF0YSkge1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuc2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlc3Npb24uc3RvcHBlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcnVuIHRoZSB0b3VjaC1hY3Rpb24gcG9seWZpbGxcbiAgICAgICAgdGhpcy50b3VjaEFjdGlvbi5wcmV2ZW50RGVmYXVsdHMoaW5wdXREYXRhKTtcblxuICAgICAgICB2YXIgcmVjb2duaXplcjtcbiAgICAgICAgdmFyIHJlY29nbml6ZXJzID0gdGhpcy5yZWNvZ25pemVycztcblxuICAgICAgICAvLyB0aGlzIGhvbGRzIHRoZSByZWNvZ25pemVyIHRoYXQgaXMgYmVpbmcgcmVjb2duaXplZC5cbiAgICAgICAgLy8gc28gdGhlIHJlY29nbml6ZXIncyBzdGF0ZSBuZWVkcyB0byBiZSBCRUdBTiwgQ0hBTkdFRCwgRU5ERUQgb3IgUkVDT0dOSVpFRFxuICAgICAgICAvLyBpZiBubyByZWNvZ25pemVyIGlzIGRldGVjdGluZyBhIHRoaW5nLCBpdCBpcyBzZXQgdG8gYG51bGxgXG4gICAgICAgIHZhciBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyO1xuXG4gICAgICAgIC8vIHJlc2V0IHdoZW4gdGhlIGxhc3QgcmVjb2duaXplciBpcyByZWNvZ25pemVkXG4gICAgICAgIC8vIG9yIHdoZW4gd2UncmUgaW4gYSBuZXcgc2Vzc2lvblxuICAgICAgICBpZiAoIWN1clJlY29nbml6ZXIgfHwgKGN1clJlY29nbml6ZXIgJiYgY3VyUmVjb2duaXplci5zdGF0ZSAmIFNUQVRFX1JFQ09HTklaRUQpKSB7XG4gICAgICAgICAgICBjdXJSZWNvZ25pemVyID0gc2Vzc2lvbi5jdXJSZWNvZ25pemVyID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCByZWNvZ25pemVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlY29nbml6ZXIgPSByZWNvZ25pemVyc1tpXTtcblxuICAgICAgICAgICAgLy8gZmluZCBvdXQgaWYgd2UgYXJlIGFsbG93ZWQgdHJ5IHRvIHJlY29nbml6ZSB0aGUgaW5wdXQgZm9yIHRoaXMgb25lLlxuICAgICAgICAgICAgLy8gMS4gICBhbGxvdyBpZiB0aGUgc2Vzc2lvbiBpcyBOT1QgZm9yY2VkIHN0b3BwZWQgKHNlZSB0aGUgLnN0b3AoKSBtZXRob2QpXG4gICAgICAgICAgICAvLyAyLiAgIGFsbG93IGlmIHdlIHN0aWxsIGhhdmVuJ3QgcmVjb2duaXplZCBhIGdlc3R1cmUgaW4gdGhpcyBzZXNzaW9uLCBvciB0aGUgdGhpcyByZWNvZ25pemVyIGlzIHRoZSBvbmVcbiAgICAgICAgICAgIC8vICAgICAgdGhhdCBpcyBiZWluZyByZWNvZ25pemVkLlxuICAgICAgICAgICAgLy8gMy4gICBhbGxvdyBpZiB0aGUgcmVjb2duaXplciBpcyBhbGxvd2VkIHRvIHJ1biBzaW11bHRhbmVvdXMgd2l0aCB0aGUgY3VycmVudCByZWNvZ25pemVkIHJlY29nbml6ZXIuXG4gICAgICAgICAgICAvLyAgICAgIHRoaXMgY2FuIGJlIHNldHVwIHdpdGggdGhlIGByZWNvZ25pemVXaXRoKClgIG1ldGhvZCBvbiB0aGUgcmVjb2duaXplci5cbiAgICAgICAgICAgIGlmIChzZXNzaW9uLnN0b3BwZWQgIT09IEZPUkNFRF9TVE9QICYmICggLy8gMVxuICAgICAgICAgICAgICAgICAgICAhY3VyUmVjb2duaXplciB8fCByZWNvZ25pemVyID09IGN1clJlY29nbml6ZXIgfHwgLy8gMlxuICAgICAgICAgICAgICAgICAgICByZWNvZ25pemVyLmNhblJlY29nbml6ZVdpdGgoY3VyUmVjb2duaXplcikpKSB7IC8vIDNcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlY29nbml6ZShpbnB1dERhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWNvZ25pemVyIGhhcyBiZWVuIHJlY29nbml6aW5nIHRoZSBpbnB1dCBhcyBhIHZhbGlkIGdlc3R1cmUsIHdlIHdhbnQgdG8gc3RvcmUgdGhpcyBvbmUgYXMgdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGFjdGl2ZSByZWNvZ25pemVyLiBidXQgb25seSBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYW4gYWN0aXZlIHJlY29nbml6ZXJcbiAgICAgICAgICAgIGlmICghY3VyUmVjb2duaXplciAmJiByZWNvZ25pemVyLnN0YXRlICYgKFNUQVRFX0JFR0FOIHwgU1RBVEVfQ0hBTkdFRCB8IFNUQVRFX0VOREVEKSkge1xuICAgICAgICAgICAgICAgIGN1clJlY29nbml6ZXIgPSBzZXNzaW9uLmN1clJlY29nbml6ZXIgPSByZWNvZ25pemVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGdldCBhIHJlY29nbml6ZXIgYnkgaXRzIGV2ZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHtSZWNvZ25pemVyfFN0cmluZ30gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE51bGx9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChyZWNvZ25pemVyIGluc3RhbmNlb2YgUmVjb2duaXplcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocmVjb2duaXplcnNbaV0ub3B0aW9ucy5ldmVudCA9PSByZWNvZ25pemVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY29nbml6ZXJzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBhZGQgYSByZWNvZ25pemVyIHRvIHRoZSBtYW5hZ2VyXG4gICAgICogZXhpc3RpbmcgcmVjb2duaXplcnMgd2l0aCB0aGUgc2FtZSBldmVudCBuYW1lIHdpbGwgYmUgcmVtb3ZlZFxuICAgICAqIEBwYXJhbSB7UmVjb2duaXplcn0gcmVjb2duaXplclxuICAgICAqIEByZXR1cm5zIHtSZWNvZ25pemVyfE1hbmFnZXJ9XG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAnYWRkJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIGV4aXN0aW5nXG4gICAgICAgIHZhciBleGlzdGluZyA9IHRoaXMuZ2V0KHJlY29nbml6ZXIub3B0aW9ucy5ldmVudCk7XG4gICAgICAgIGlmIChleGlzdGluZykge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoZXhpc3RpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvZ25pemVycy5wdXNoKHJlY29nbml6ZXIpO1xuICAgICAgICByZWNvZ25pemVyLm1hbmFnZXIgPSB0aGlzO1xuXG4gICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgIHJldHVybiByZWNvZ25pemVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiByZW1vdmUgYSByZWNvZ25pemVyIGJ5IG5hbWUgb3IgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0ge1JlY29nbml6ZXJ8U3RyaW5nfSByZWNvZ25pemVyXG4gICAgICogQHJldHVybnMge01hbmFnZXJ9XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihyZWNvZ25pemVyKSB7XG4gICAgICAgIGlmIChpbnZva2VBcnJheUFyZyhyZWNvZ25pemVyLCAncmVtb3ZlJywgdGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjb2duaXplciA9IHRoaXMuZ2V0KHJlY29nbml6ZXIpO1xuXG4gICAgICAgIC8vIGxldCdzIG1ha2Ugc3VyZSB0aGlzIHJlY29nbml6ZXIgZXhpc3RzXG4gICAgICAgIGlmIChyZWNvZ25pemVyKSB7XG4gICAgICAgICAgICB2YXIgcmVjb2duaXplcnMgPSB0aGlzLnJlY29nbml6ZXJzO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gaW5BcnJheShyZWNvZ25pemVycywgcmVjb2duaXplcik7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZWNvZ25pemVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMudG91Y2hBY3Rpb24udXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogYmluZCBldmVudFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihldmVudHMsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdID0gaGFuZGxlcnNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdLnB1c2goaGFuZGxlcik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogdW5iaW5kIGV2ZW50LCBsZWF2ZSBlbWl0IGJsYW5rIHRvIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gdGhpc1xuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24oZXZlbnRzLCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcbiAgICAgICAgZWFjaChzcGxpdFN0cihldmVudHMpLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhhbmRsZXJzW2V2ZW50XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcnNbZXZlbnRdICYmIGhhbmRsZXJzW2V2ZW50XS5zcGxpY2UoaW5BcnJheShoYW5kbGVyc1tldmVudF0sIGhhbmRsZXIpLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbWl0IGV2ZW50IHRvIHRoZSBsaXN0ZW5lcnNcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqL1xuICAgIGVtaXQ6IGZ1bmN0aW9uKGV2ZW50LCBkYXRhKSB7XG4gICAgICAgIC8vIHdlIGFsc28gd2FudCB0byB0cmlnZ2VyIGRvbSBldmVudHNcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb21FdmVudHMpIHtcbiAgICAgICAgICAgIHRyaWdnZXJEb21FdmVudChldmVudCwgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBubyBoYW5kbGVycywgc28gc2tpcCBpdCBhbGxcbiAgICAgICAgdmFyIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVyc1tldmVudF0gJiYgdGhpcy5oYW5kbGVyc1tldmVudF0uc2xpY2UoKTtcbiAgICAgICAgaWYgKCFoYW5kbGVycyB8fCAhaGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnR5cGUgPSBldmVudDtcbiAgICAgICAgZGF0YS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGF0YS5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBoYW5kbGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzW2ldKGRhdGEpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGRlc3Ryb3kgdGhlIG1hbmFnZXIgYW5kIHVuYmluZHMgYWxsIGV2ZW50c1xuICAgICAqIGl0IGRvZXNuJ3QgdW5iaW5kIGRvbSBldmVudHMsIHRoYXQgaXMgdGhlIHVzZXIgb3duIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCAmJiB0b2dnbGVDc3NQcm9wcyh0aGlzLCBmYWxzZSk7XG5cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnNlc3Npb24gPSB7fTtcbiAgICAgICAgdGhpcy5pbnB1dC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBhZGQvcmVtb3ZlIHRoZSBjc3MgcHJvcGVydGllcyBhcyBkZWZpbmVkIGluIG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wc1xuICogQHBhcmFtIHtNYW5hZ2VyfSBtYW5hZ2VyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFkZFxuICovXG5mdW5jdGlvbiB0b2dnbGVDc3NQcm9wcyhtYW5hZ2VyLCBhZGQpIHtcbiAgICB2YXIgZWxlbWVudCA9IG1hbmFnZXIuZWxlbWVudDtcbiAgICBpZiAoIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcHJvcDtcbiAgICBlYWNoKG1hbmFnZXIub3B0aW9ucy5jc3NQcm9wcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgcHJvcCA9IHByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIG5hbWUpO1xuICAgICAgICBpZiAoYWRkKSB7XG4gICAgICAgICAgICBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdID0gZWxlbWVudC5zdHlsZVtwcm9wXTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBtYW5hZ2VyLm9sZENzc1Byb3BzW3Byb3BdIHx8ICcnO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhZGQpIHtcbiAgICAgICAgbWFuYWdlci5vbGRDc3NQcm9wcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiB0cmlnZ2VyIGRvbSBldmVudFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICovXG5mdW5jdGlvbiB0cmlnZ2VyRG9tRXZlbnQoZXZlbnQsIGRhdGEpIHtcbiAgICB2YXIgZ2VzdHVyZUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZ2VzdHVyZUV2ZW50LmluaXRFdmVudChldmVudCwgdHJ1ZSwgdHJ1ZSk7XG4gICAgZ2VzdHVyZUV2ZW50Lmdlc3R1cmUgPSBkYXRhO1xuICAgIGRhdGEudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZ2VzdHVyZUV2ZW50KTtcbn1cblxuYXNzaWduKEhhbW1lciwge1xuICAgIElOUFVUX1NUQVJUOiBJTlBVVF9TVEFSVCxcbiAgICBJTlBVVF9NT1ZFOiBJTlBVVF9NT1ZFLFxuICAgIElOUFVUX0VORDogSU5QVVRfRU5ELFxuICAgIElOUFVUX0NBTkNFTDogSU5QVVRfQ0FOQ0VMLFxuXG4gICAgU1RBVEVfUE9TU0lCTEU6IFNUQVRFX1BPU1NJQkxFLFxuICAgIFNUQVRFX0JFR0FOOiBTVEFURV9CRUdBTixcbiAgICBTVEFURV9DSEFOR0VEOiBTVEFURV9DSEFOR0VELFxuICAgIFNUQVRFX0VOREVEOiBTVEFURV9FTkRFRCxcbiAgICBTVEFURV9SRUNPR05JWkVEOiBTVEFURV9SRUNPR05JWkVELFxuICAgIFNUQVRFX0NBTkNFTExFRDogU1RBVEVfQ0FOQ0VMTEVELFxuICAgIFNUQVRFX0ZBSUxFRDogU1RBVEVfRkFJTEVELFxuXG4gICAgRElSRUNUSU9OX05PTkU6IERJUkVDVElPTl9OT05FLFxuICAgIERJUkVDVElPTl9MRUZUOiBESVJFQ1RJT05fTEVGVCxcbiAgICBESVJFQ1RJT05fUklHSFQ6IERJUkVDVElPTl9SSUdIVCxcbiAgICBESVJFQ1RJT05fVVA6IERJUkVDVElPTl9VUCxcbiAgICBESVJFQ1RJT05fRE9XTjogRElSRUNUSU9OX0RPV04sXG4gICAgRElSRUNUSU9OX0hPUklaT05UQUw6IERJUkVDVElPTl9IT1JJWk9OVEFMLFxuICAgIERJUkVDVElPTl9WRVJUSUNBTDogRElSRUNUSU9OX1ZFUlRJQ0FMLFxuICAgIERJUkVDVElPTl9BTEw6IERJUkVDVElPTl9BTEwsXG5cbiAgICBNYW5hZ2VyOiBNYW5hZ2VyLFxuICAgIElucHV0OiBJbnB1dCxcbiAgICBUb3VjaEFjdGlvbjogVG91Y2hBY3Rpb24sXG5cbiAgICBUb3VjaElucHV0OiBUb3VjaElucHV0LFxuICAgIE1vdXNlSW5wdXQ6IE1vdXNlSW5wdXQsXG4gICAgUG9pbnRlckV2ZW50SW5wdXQ6IFBvaW50ZXJFdmVudElucHV0LFxuICAgIFRvdWNoTW91c2VJbnB1dDogVG91Y2hNb3VzZUlucHV0LFxuICAgIFNpbmdsZVRvdWNoSW5wdXQ6IFNpbmdsZVRvdWNoSW5wdXQsXG5cbiAgICBSZWNvZ25pemVyOiBSZWNvZ25pemVyLFxuICAgIEF0dHJSZWNvZ25pemVyOiBBdHRyUmVjb2duaXplcixcbiAgICBUYXA6IFRhcFJlY29nbml6ZXIsXG4gICAgUGFuOiBQYW5SZWNvZ25pemVyLFxuICAgIFN3aXBlOiBTd2lwZVJlY29nbml6ZXIsXG4gICAgUGluY2g6IFBpbmNoUmVjb2duaXplcixcbiAgICBSb3RhdGU6IFJvdGF0ZVJlY29nbml6ZXIsXG4gICAgUHJlc3M6IFByZXNzUmVjb2duaXplcixcblxuICAgIG9uOiBhZGRFdmVudExpc3RlbmVycyxcbiAgICBvZmY6IHJlbW92ZUV2ZW50TGlzdGVuZXJzLFxuICAgIGVhY2g6IGVhY2gsXG4gICAgbWVyZ2U6IG1lcmdlLFxuICAgIGV4dGVuZDogZXh0ZW5kLFxuICAgIGFzc2lnbjogYXNzaWduLFxuICAgIGluaGVyaXQ6IGluaGVyaXQsXG4gICAgYmluZEZuOiBiaW5kRm4sXG4gICAgcHJlZml4ZWQ6IHByZWZpeGVkXG59KTtcblxuLy8gdGhpcyBwcmV2ZW50cyBlcnJvcnMgd2hlbiBIYW1tZXIgaXMgbG9hZGVkIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTURcbi8vICBzdHlsZSBsb2FkZXIgYnV0IGJ5IHNjcmlwdCB0YWcsIG5vdCBieSB0aGUgbG9hZGVyLlxudmFyIGZyZWVHbG9iYWwgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9KSk7IC8vIGpzaGludCBpZ25vcmU6bGluZVxuZnJlZUdsb2JhbC5IYW1tZXIgPSBIYW1tZXI7XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXI7XG4gICAgfSk7XG59IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEhhbW1lcjtcbn0gZWxzZSB7XG4gICAgd2luZG93W2V4cG9ydE5hbWVdID0gSGFtbWVyO1xufVxuXG59KSh3aW5kb3csIGRvY3VtZW50LCAnSGFtbWVyJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1332\n");

/***/ }),

/***/ 1900:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Z\": () => (/* binding */ normalizeComponent)\n/* harmony export */ });\n/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nfunction normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n        injectStyles.call(\n          this,\n          (options.functional ? this.parent : this).$root.$options.shadowRoot\n        )\n      }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzPzI4NzciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTkwMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbHMgX19WVUVfU1NSX0NPTlRFWFRfXyAqL1xuXG4vLyBJTVBPUlRBTlQ6IERvIE5PVCB1c2UgRVMyMDE1IGZlYXR1cmVzIGluIHRoaXMgZmlsZSAoZXhjZXB0IGZvciBtb2R1bGVzKS5cbi8vIFRoaXMgbW9kdWxlIGlzIGEgcnVudGltZSB1dGlsaXR5IGZvciBjbGVhbmVyIGNvbXBvbmVudCBtb2R1bGUgb3V0cHV0IGFuZCB3aWxsXG4vLyBiZSBpbmNsdWRlZCBpbiB0aGUgZmluYWwgd2VicGFjayB1c2VyIGJ1bmRsZS5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50IChcbiAgc2NyaXB0RXhwb3J0cyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyLCAvKiBzZXJ2ZXIgb25seSAqL1xuICBzaGFkb3dNb2RlIC8qIHZ1ZS1jbGkgb25seSAqL1xuKSB7XG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAocmVuZGVyKSB7XG4gICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZuc1xuICAgIG9wdGlvbnMuX2NvbXBpbGVkID0gdHJ1ZVxuICB9XG5cbiAgLy8gZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoZnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgb3B0aW9ucy5mdW5jdGlvbmFsID0gdHJ1ZVxuICB9XG5cbiAgLy8gc2NvcGVkSWRcbiAgaWYgKHNjb3BlSWQpIHtcbiAgICBvcHRpb25zLl9zY29wZUlkID0gJ2RhdGEtdi0nICsgc2NvcGVJZFxuICB9XG5cbiAgdmFyIGhvb2tcbiAgaWYgKG1vZHVsZUlkZW50aWZpZXIpIHsgLy8gc2VydmVyIGJ1aWxkXG4gICAgaG9vayA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAvLyAyLjMgaW5qZWN0aW9uXG4gICAgICBjb250ZXh0ID1cbiAgICAgICAgY29udGV4dCB8fCAvLyBjYWNoZWQgY2FsbFxuICAgICAgICAodGhpcy4kdm5vZGUgJiYgdGhpcy4kdm5vZGUuc3NyQ29udGV4dCkgfHwgLy8gc3RhdGVmdWxcbiAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LiR2bm9kZSAmJiB0aGlzLnBhcmVudC4kdm5vZGUuc3NyQ29udGV4dCkgLy8gZnVuY3Rpb25hbFxuICAgICAgLy8gMi4yIHdpdGggcnVuSW5OZXdDb250ZXh0OiB0cnVlXG4gICAgICBpZiAoIWNvbnRleHQgJiYgdHlwZW9mIF9fVlVFX1NTUl9DT05URVhUX18gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnRleHQgPSBfX1ZVRV9TU1JfQ09OVEVYVF9fXG4gICAgICB9XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHN0eWxlc1xuICAgICAgaWYgKGluamVjdFN0eWxlcykge1xuICAgICAgICBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCBjb250ZXh0KVxuICAgICAgfVxuICAgICAgLy8gcmVnaXN0ZXIgY29tcG9uZW50IG1vZHVsZSBpZGVudGlmaWVyIGZvciBhc3luYyBjaHVuayBpbmZlcnJlbmNlXG4gICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cy5hZGQobW9kdWxlSWRlbnRpZmllcilcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAvLyBuZXZlciBnZXRzIGNhbGxlZFxuICAgIG9wdGlvbnMuX3NzclJlZ2lzdGVyID0gaG9va1xuICB9IGVsc2UgaWYgKGluamVjdFN0eWxlcykge1xuICAgIGhvb2sgPSBzaGFkb3dNb2RlXG4gICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICAob3B0aW9ucy5mdW5jdGlvbmFsID8gdGhpcy5wYXJlbnQgOiB0aGlzKS4kcm9vdC4kb3B0aW9ucy5zaGFkb3dSb290XG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb25hbCBjb21wb25lbnQgaW4gdnVlIGZpbGVcbiAgICAgIHZhciBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyXG4gICAgICBvcHRpb25zLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcldpdGhTdHlsZUluamVjdGlvbiAoaCwgY29udGV4dCkge1xuICAgICAgICBob29rLmNhbGwoY29udGV4dClcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsUmVuZGVyKGgsIGNvbnRleHQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgcmVnaXN0cmF0aW9uIGFzIGJlZm9yZUNyZWF0ZSBob29rXG4gICAgICB2YXIgZXhpc3RpbmcgPSBvcHRpb25zLmJlZm9yZUNyZWF0ZVxuICAgICAgb3B0aW9ucy5iZWZvcmVDcmVhdGUgPSBleGlzdGluZ1xuICAgICAgICA/IFtdLmNvbmNhdChleGlzdGluZywgaG9vaylcbiAgICAgICAgOiBbaG9va11cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1900\n");

/***/ })

}]);