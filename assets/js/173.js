/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([[173],{

/***/ 8049:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("!function (t, e) {\n   true ? module.exports = e(__webpack_require__(603)) : 0;\n}(\"undefined\" != typeof self ? self : this, function (t) {\n  return function (t) {\n    function e(n) {\n      if (r[n]) return r[n].exports;\n      var o = r[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return t[n].call(o.exports, o, o.exports, e), o.l = !0, o.exports;\n    }\n\n    var r = {};\n    return e.m = t, e.c = r, e.d = function (t, r, n) {\n      e.o(t, r) || Object.defineProperty(t, r, {\n        configurable: !1,\n        enumerable: !0,\n        get: n\n      });\n    }, e.n = function (t) {\n      var r = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return e.d(r, \"a\", r), r;\n    }, e.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, e.p = \"\", e(e.s = 1);\n  }([function (e, r) {\n    e.exports = t;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function n(t) {\n      var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      t.component(e.tagName || \"highcharts\", Object(o.a)(e.highcharts || i.a));\n    }\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.default = n, r.d(e, \"Chart\", function () {\n      return a;\n    });\n    var o = r(2),\n        c = r(0),\n        i = r.n(c),\n        a = Object(o.a)(i.a);\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function n(t) {\n      return i(t) || c(t) || o();\n    }\n\n    function o() {\n      throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n    }\n\n    function c(t) {\n      if (Symbol.iterator in Object(t) || \"[object Arguments]\" === Object.prototype.toString.call(t)) return Array.from(t);\n    }\n\n    function i(t) {\n      if (Array.isArray(t)) {\n        for (var e = 0, r = new Array(t.length); e < t.length; e++) r[e] = t[e];\n\n        return r;\n      }\n    }\n\n    var a = r(3),\n        s = function (t) {\n      return {\n        template: '<div ref=\"chart\"></div>',\n        render: function (t) {\n          return t(\"div\", {\n            ref: \"chart\"\n          });\n        },\n        props: {\n          constructorType: {\n            type: String,\n            default: \"chart\"\n          },\n          options: {\n            type: Object,\n            required: !0\n          },\n          callback: Function,\n          updateArgs: {\n            type: Array,\n            default: function () {\n              return [!0, !0];\n            }\n          },\n          highcharts: {\n            type: Object\n          },\n          deepCopyOnUpdate: {\n            type: Boolean,\n            default: !0\n          }\n        },\n        watch: {\n          options: {\n            handler: function (t) {\n              var e;\n              (e = this.chart).update.apply(e, [Object(a.a)(t, this.deepCopyOnUpdate)].concat(n(this.updateArgs)));\n            },\n            deep: !0\n          }\n        },\n        mounted: function () {\n          var e = this.highcharts || t;\n          this.options && e[this.constructorType] ? this.chart = e[this.constructorType](this.$refs.chart, Object(a.a)(this.options, !0), this.callback ? this.callback : null) : this.options ? console.warn(\"'\".concat(this.constructorType, \"' constructor-type is incorrect. Sometimes this error is caused by the fact, that the corresponding module wasn't imported.\")) : console.warn('The \"options\" parameter was not passed.');\n        },\n        beforeDestroy: function () {\n          this.chart && this.chart.destroy();\n        }\n      };\n    };\n\n    e.a = s;\n  }, function (t, e, r) {\n    \"use strict\";\n\n    function n(t, e, r) {\n      function o(o, i) {\n        !c.a.isObject(o, !r) || c.a.isClass(o) || c.a.isDOMElement(o) ? t[i] = e[i] : t[i] = n(t[i] || c.a.isArray(o) ? [] : {}, o, r);\n      }\n\n      return c.a.isArray(e) ? e.forEach(o) : c.a.objectEach(e, o), t;\n    }\n\n    r.d(e, \"a\", function () {\n      return i;\n    });\n\n    var o = r(0),\n        c = r.n(o),\n        i = function (t, e) {\n      return n({}, t, e);\n    };\n  }]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGlnaGNoYXJ0cy12dWUvZGlzdC9oaWdoY2hhcnRzLXZ1ZS5taW4uanM/NDQ1MiJdLCJuYW1lcyI6WyJ0IiwiZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwic2VsZiIsIm4iLCJyIiwibyIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsImdldCIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwIiwicyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNvbXBvbmVudCIsInRhZ05hbWUiLCJhIiwiaGlnaGNoYXJ0cyIsInZhbHVlIiwiVHlwZUVycm9yIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJ0b1N0cmluZyIsIkFycmF5IiwiZnJvbSIsImlzQXJyYXkiLCJ0ZW1wbGF0ZSIsInJlbmRlciIsInJlZiIsInByb3BzIiwiY29uc3RydWN0b3JUeXBlIiwidHlwZSIsIlN0cmluZyIsIm9wdGlvbnMiLCJyZXF1aXJlZCIsImNhbGxiYWNrIiwiRnVuY3Rpb24iLCJ1cGRhdGVBcmdzIiwiZGVlcENvcHlPblVwZGF0ZSIsIkJvb2xlYW4iLCJ3YXRjaCIsImhhbmRsZXIiLCJjaGFydCIsInVwZGF0ZSIsImFwcGx5IiwiY29uY2F0IiwiZGVlcCIsIm1vdW50ZWQiLCIkcmVmcyIsImNvbnNvbGUiLCJ3YXJuIiwiYmVmb3JlRGVzdHJveSIsImRlc3Ryb3kiLCJpc09iamVjdCIsImlzQ2xhc3MiLCJpc0RPTUVsZW1lbnQiLCJmb3JFYWNoIiwib2JqZWN0RWFjaCJdLCJtYXBwaW5ncyI6IkFBQUEsQ0FBQyxVQUFTQSxDQUFULEVBQVdDLENBQVgsRUFBYTtBQUFDLFVBQWtEQyxNQUFNLENBQUNDLE9BQVAsR0FBZUYsQ0FBQyxDQUFDRyxtQkFBTyxDQUFDLEdBQUQsQ0FBUixDQUFs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LENBQVU5RCxDQUFWLENBQWYsR0FBNEJLLENBQUMsQ0FBQ2lCLENBQUYsQ0FBSXlDLFVBQUosQ0FBZXRFLENBQWYsRUFBaUJPLENBQWpCLENBQTVCLEVBQWdEUixDQUF2RDtBQUF5RDs7QUFBQU8sS0FBQyxDQUFDTyxDQUFGLENBQUliLENBQUosRUFBTSxHQUFOLEVBQVUsWUFBVTtBQUFDLGFBQU9RLENBQVA7QUFBUyxLQUE5Qjs7QUFBZ0MsUUFBSUQsQ0FBQyxHQUFDRCxDQUFDLENBQUMsQ0FBRCxDQUFQO0FBQUEsUUFBV00sQ0FBQyxHQUFDTixDQUFDLENBQUNELENBQUYsQ0FBSUUsQ0FBSixDQUFiO0FBQUEsUUFBb0JDLENBQUMsR0FBQyxVQUFTVCxDQUFULEVBQVdDLENBQVgsRUFBYTtBQUFDLGFBQU9LLENBQUMsQ0FBQyxFQUFELEVBQUlOLENBQUosRUFBTUMsQ0FBTixDQUFSO0FBQWlCLEtBQXJEO0FBQXNELEdBQTcvRCxDQUFsZCxDQUFQO0FBQXk5RSxDQUF4eEYsQ0FBRCIsImZpbGUiOiI4MDQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9ZShyZXF1aXJlKFwiaGlnaGNoYXJ0c1wiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJoaWdoY2hhcnRzXCJdLGUpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP2V4cG9ydHMuSGlnaGNoYXJ0c1Z1ZT1lKHJlcXVpcmUoXCJoaWdoY2hhcnRzXCIpKTp0LkhpZ2hjaGFydHNWdWU9ZSh0LkhpZ2hjaGFydHMpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIGUobil7aWYocltuXSlyZXR1cm4gcltuXS5leHBvcnRzO3ZhciBvPXJbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiB0W25dLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLGUpLG8ubD0hMCxvLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIGUubT10LGUuYz1yLGUuZD1mdW5jdGlvbih0LHIsbil7ZS5vKHQscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LHIse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LGUubj1mdW5jdGlvbih0KXt2YXIgcj10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gZS5kKHIsXCJhXCIscikscn0sZS5vPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpfSxlLnA9XCJcIixlKGUucz0xKX0oW2Z1bmN0aW9uKGUscil7ZS5leHBvcnRzPXR9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7fTt0LmNvbXBvbmVudChlLnRhZ05hbWV8fFwiaGlnaGNoYXJ0c1wiLE9iamVjdChvLmEpKGUuaGlnaGNoYXJ0c3x8aS5hKSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5kZWZhdWx0PW4sci5kKGUsXCJDaGFydFwiLGZ1bmN0aW9uKCl7cmV0dXJuIGF9KTt2YXIgbz1yKDIpLGM9cigwKSxpPXIubihjKSxhPU9iamVjdChvLmEpKGkuYSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBuKHQpe3JldHVybiBpKHQpfHxjKHQpfHxvKCl9ZnVuY3Rpb24gbygpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX1mdW5jdGlvbiBjKHQpe2lmKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QodCl8fFwiW29iamVjdCBBcmd1bWVudHNdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCkpcmV0dXJuIEFycmF5LmZyb20odCl9ZnVuY3Rpb24gaSh0KXtpZihBcnJheS5pc0FycmF5KHQpKXtmb3IodmFyIGU9MCxyPW5ldyBBcnJheSh0Lmxlbmd0aCk7ZTx0Lmxlbmd0aDtlKyspcltlXT10W2VdO3JldHVybiByfX12YXIgYT1yKDMpLHM9ZnVuY3Rpb24odCl7cmV0dXJue3RlbXBsYXRlOic8ZGl2IHJlZj1cImNoYXJ0XCI+PC9kaXY+JyxyZW5kZXI6ZnVuY3Rpb24odCl7cmV0dXJuIHQoXCJkaXZcIix7cmVmOlwiY2hhcnRcIn0pfSxwcm9wczp7Y29uc3RydWN0b3JUeXBlOnt0eXBlOlN0cmluZyxkZWZhdWx0OlwiY2hhcnRcIn0sb3B0aW9uczp7dHlwZTpPYmplY3QscmVxdWlyZWQ6ITB9LGNhbGxiYWNrOkZ1bmN0aW9uLHVwZGF0ZUFyZ3M6e3R5cGU6QXJyYXksZGVmYXVsdDpmdW5jdGlvbigpe3JldHVyblshMCwhMF19fSxoaWdoY2hhcnRzOnt0eXBlOk9iamVjdH0sZGVlcENvcHlPblVwZGF0ZTp7dHlwZTpCb29sZWFuLGRlZmF1bHQ6ITB9fSx3YXRjaDp7b3B0aW9uczp7aGFuZGxlcjpmdW5jdGlvbih0KXt2YXIgZTsoZT10aGlzLmNoYXJ0KS51cGRhdGUuYXBwbHkoZSxbT2JqZWN0KGEuYSkodCx0aGlzLmRlZXBDb3B5T25VcGRhdGUpXS5jb25jYXQobih0aGlzLnVwZGF0ZUFyZ3MpKSl9LGRlZXA6ITB9fSxtb3VudGVkOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oaWdoY2hhcnRzfHx0O3RoaXMub3B0aW9ucyYmZVt0aGlzLmNvbnN0cnVjdG9yVHlwZV0/dGhpcy5jaGFydD1lW3RoaXMuY29uc3RydWN0b3JUeXBlXSh0aGlzLiRyZWZzLmNoYXJ0LE9iamVjdChhLmEpKHRoaXMub3B0aW9ucywhMCksdGhpcy5jYWxsYmFjaz90aGlzLmNhbGxiYWNrOm51bGwpOnRoaXMub3B0aW9ucz9jb25zb2xlLndhcm4oXCInXCIuY29uY2F0KHRoaXMuY29uc3RydWN0b3JUeXBlLFwiJyBjb25zdHJ1Y3Rvci10eXBlIGlzIGluY29ycmVjdC4gU29tZXRpbWVzIHRoaXMgZXJyb3IgaXMgY2F1c2VkIGJ5IHRoZSBmYWN0LCB0aGF0IHRoZSBjb3JyZXNwb25kaW5nIG1vZHVsZSB3YXNuJ3QgaW1wb3J0ZWQuXCIpKTpjb25zb2xlLndhcm4oJ1RoZSBcIm9wdGlvbnNcIiBwYXJhbWV0ZXIgd2FzIG5vdCBwYXNzZWQuJyl9LGJlZm9yZURlc3Ryb3k6ZnVuY3Rpb24oKXt0aGlzLmNoYXJ0JiZ0aGlzLmNoYXJ0LmRlc3Ryb3koKX19fTtlLmE9c30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIG4odCxlLHIpe2Z1bmN0aW9uIG8obyxpKXshYy5hLmlzT2JqZWN0KG8sIXIpfHxjLmEuaXNDbGFzcyhvKXx8Yy5hLmlzRE9NRWxlbWVudChvKT90W2ldPWVbaV06dFtpXT1uKHRbaV18fGMuYS5pc0FycmF5KG8pP1tdOnt9LG8scil9cmV0dXJuIGMuYS5pc0FycmF5KGUpP2UuZm9yRWFjaChvKTpjLmEub2JqZWN0RWFjaChlLG8pLHR9ci5kKGUsXCJhXCIsZnVuY3Rpb24oKXtyZXR1cm4gaX0pO3ZhciBvPXIoMCksYz1yLm4obyksaT1mdW5jdGlvbih0LGUpe3JldHVybiBuKHt9LHQsZSl9fV0pfSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8049\n");

/***/ }),

/***/ 603:
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n Highcharts JS v9.0.1 (2021-02-15)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (W, P) {\n   true && module.exports ? (P[\"default\"] = P, module.exports = W.document ? P(W) : P) :  true ? !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return P(W);\n  }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(\"undefined\" !== typeof window ? window : this, function (W) {\n  function P(f, d, k, x) {\n    f.hasOwnProperty(d) || (f[d] = x.apply(null, k));\n  }\n\n  var k = {};\n  P(k, \"Core/Globals.js\", [], function () {\n    var f = \"undefined\" !== typeof W ? W : \"undefined\" !== typeof window ? window : {},\n        d = f.document,\n        k = f.navigator && f.navigator.userAgent || \"\",\n        x = d && d.createElementNS && !!d.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\").createSVGRect,\n        B = /(edge|msie|trident)/i.test(k) && !f.opera,\n        G = -1 !== k.indexOf(\"Firefox\"),\n        D = -1 !== k.indexOf(\"Chrome\"),\n        H = G && 4 > parseInt(k.split(\"Firefox/\")[1], 10),\n        t = function () {};\n\n    return {\n      product: \"Highcharts\",\n      version: \"9.0.1\",\n      deg2rad: 2 * Math.PI / 360,\n      doc: d,\n      hasBidiBug: H,\n      hasTouch: !!f.TouchEvent,\n      isMS: B,\n      isWebKit: -1 !== k.indexOf(\"AppleWebKit\"),\n      isFirefox: G,\n      isChrome: D,\n      isSafari: !D && -1 !== k.indexOf(\"Safari\"),\n      isTouchDevice: /(Mobile|Android|Windows Phone)/.test(k),\n      SVG_NS: \"http://www.w3.org/2000/svg\",\n      chartCount: 0,\n      seriesTypes: {},\n      supportsPassiveEvents: function () {\n        var C = !1;\n\n        if (!B) {\n          var l = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              C = !0;\n            }\n          });\n          f.addEventListener && f.removeEventListener && (f.addEventListener(\"testPassive\", t, l), f.removeEventListener(\"testPassive\", t, l));\n        }\n\n        return C;\n      }(),\n      symbolSizes: {},\n      svg: x,\n      win: f,\n      marginNames: [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"],\n      noop: t,\n      charts: [],\n      dateFormats: {}\n    };\n  });\n  P(k, \"Core/Utilities.js\", [k[\"Core/Globals.js\"]], function (f) {\n    function d(a, c, v, L) {\n      var p = c ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === a && (a = p + \": Deprecated member\");\n      var K = l(a),\n          h = K ? p + \" #\" + a + \": www.highcharts.com/errors/\" + a + \"/\" : a.toString();\n\n      p = function () {\n        if (c) throw Error(h);\n        b.console && -1 === d.messages.indexOf(h) && console.warn(h);\n      };\n\n      if (\"undefined\" !== typeof L) {\n        var g = \"\";\n        K && (h += \"?\");\n        m(L, function (p, a) {\n          g += \"\\n - \" + a + \": \" + p;\n          K && (h += encodeURI(a) + \"=\" + encodeURI(p));\n        });\n        h += g;\n      }\n\n      v ? e(v, \"displayError\", {\n        code: a,\n        message: h,\n        params: L\n      }, p) : p();\n      d.messages.push(h);\n    }\n\n    function k() {\n      var a,\n          b = arguments,\n          v = {},\n          L = function (p, a) {\n        \"object\" !== typeof p && (p = {});\n        m(a, function (b, u) {\n          \"__proto__\" !== u && \"constructor\" !== u && (!H(b, !0) || C(b) || t(b) ? p[u] = a[u] : p[u] = L(p[u] || {}, b));\n        });\n        return p;\n      };\n\n      !0 === b[0] && (v = b[1], b = Array.prototype.slice.call(b, 2));\n      var p = b.length;\n\n      for (a = 0; a < p; a++) v = L(v, b[a]);\n\n      return v;\n    }\n\n    function x(a, b) {\n      var v = {};\n      m(a, function (L, p) {\n        if (H(a[p], !0) && !a.nodeType && b[p]) L = x(a[p], b[p]), Object.keys(L).length && (v[p] = L);else if (H(a[p]) || a[p] !== b[p]) v[p] = a[p];\n      });\n      return v;\n    }\n\n    function B(a, b) {\n      return parseInt(a, b || 10);\n    }\n\n    function G(a) {\n      return \"string\" === typeof a;\n    }\n\n    function D(a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    }\n\n    function H(a, b) {\n      return !!a && \"object\" === typeof a && (!b || !D(a));\n    }\n\n    function t(a) {\n      return H(a) && \"number\" === typeof a.nodeType;\n    }\n\n    function C(a) {\n      var b = a && a.constructor;\n      return !(!H(a, !0) || t(a) || !b || !b.name || \"Object\" === b.name);\n    }\n\n    function l(a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    }\n\n    function E(a) {\n      return \"undefined\" !== typeof a && null !== a;\n    }\n\n    function g(a, b, v) {\n      var L;\n      G(b) ? E(v) ? a.setAttribute(b, v) : a && a.getAttribute && ((L = a.getAttribute(b)) || \"class\" !== b || (L = a.getAttribute(b + \"Name\"))) : m(b, function (p, b) {\n        a.setAttribute(b, p);\n      });\n      return L;\n    }\n\n    function y(a, b) {\n      var v;\n      a || (a = {});\n\n      for (v in b) a[v] = b[v];\n\n      return a;\n    }\n\n    function c() {\n      for (var a = arguments, b = a.length, v = 0; v < b; v++) {\n        var L = a[v];\n        if (\"undefined\" !== typeof L && null !== L) return L;\n      }\n    }\n\n    function q(a, b) {\n      f.isMS && !f.svg && b && \"undefined\" !== typeof b.opacity && (b.filter = \"alpha(opacity=\" + 100 * b.opacity + \")\");\n      y(a.style, b);\n    }\n\n    function n(b, e, v, L, p) {\n      b = a.createElement(b);\n      e && y(b, e);\n      p && q(b, {\n        padding: \"0\",\n        border: \"none\",\n        margin: \"0\"\n      });\n      v && q(b, v);\n      L && L.appendChild(b);\n      return b;\n    }\n\n    function A(a, b) {\n      return parseFloat(a.toPrecision(b || 14));\n    }\n\n    function M(a, b, v, L) {\n      a = +a || 0;\n      b = +b;\n      var p = f.defaultOptions.lang,\n          K = (a.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          e = a.toString().split(\"e\"),\n          h = b;\n      if (-1 === b) b = Math.min(K, 20);else if (!l(b)) b = 2;else if (b && e[1] && 0 > e[1]) {\n        var u = b + +e[1];\n        0 <= u ? (e[0] = (+e[0]).toExponential(u).split(\"e\")[0], b = u) : (e[0] = e[0].split(\".\")[0] || 0, a = 20 > b ? (e[0] * Math.pow(10, e[1])).toFixed(b) : 0, e[1] = 0);\n      }\n      var m = (Math.abs(e[1] ? e[0] : a) + Math.pow(10, -Math.max(b, K) - 1)).toFixed(b);\n      K = String(B(m));\n      u = 3 < K.length ? K.length % 3 : 0;\n      v = c(v, p.decimalPoint);\n      L = c(L, p.thousandsSep);\n      a = (0 > a ? \"-\" : \"\") + (u ? K.substr(0, u) + L : \"\");\n      a = 0 > +e[1] && !h ? \"0\" : a + K.substr(u).replace(/(\\d{3})(?=\\d)/g, \"$1\" + L);\n      b && (a += v + m.slice(-b));\n      e[1] && 0 !== +a && (a += \"e\" + e[1]);\n      return a;\n    }\n\n    function z(a, b) {\n      if (!a) return b;\n      var v = a.split(\".\").reverse();\n      if (1 === v.length) return b[a];\n\n      for (a = v.pop(); \"undefined\" !== typeof a && \"undefined\" !== typeof b && null !== b;) b = b[a], a = v.pop();\n\n      return b;\n    }\n\n    function m(a, b, v) {\n      for (var e in a) Object.hasOwnProperty.call(a, e) && b.call(v || a[e], a[e], e, a);\n    }\n\n    function r(a, b, v) {\n      function e(p, b) {\n        var u = a.removeEventListener || f.removeEventListenerPolyfill;\n        u && u.call(a, p, b, !1);\n      }\n\n      function p(p) {\n        var u;\n\n        if (a.nodeName) {\n          if (b) {\n            var v = {};\n            v[b] = !0;\n          } else v = p;\n\n          m(v, function (a, b) {\n            if (p[b]) for (u = p[b].length; u--;) e(b, p[b][u].fn);\n          });\n        }\n      }\n\n      var K = \"function\" === typeof a && a.prototype || a;\n\n      if (Object.hasOwnProperty.call(K, \"hcEvents\")) {\n        var h = K.hcEvents;\n        b ? (K = h[b] || [], v ? (h[b] = K.filter(function (a) {\n          return v !== a.fn;\n        }), e(b, v)) : (p(h), h[b] = [])) : (p(h), delete K.hcEvents);\n      }\n    }\n\n    function e(b, e, v, L) {\n      v = v || {};\n\n      if (a.createEvent && (b.dispatchEvent || b.fireEvent)) {\n        var p = a.createEvent(\"Events\");\n        p.initEvent(e, !0, !0);\n        y(p, v);\n        b.dispatchEvent ? b.dispatchEvent(p) : b.fireEvent(e, p);\n      } else if (b.hcEvents) {\n        v.target || y(v, {\n          preventDefault: function () {\n            v.defaultPrevented = !0;\n          },\n          target: b,\n          type: e\n        });\n        p = [];\n\n        for (var K = b, h = !1; K.hcEvents;) Object.hasOwnProperty.call(K, \"hcEvents\") && K.hcEvents[e] && (p.length && (h = !0), p.unshift.apply(p, K.hcEvents[e])), K = Object.getPrototypeOf(K);\n\n        h && p.sort(function (a, p) {\n          return a.order - p.order;\n        });\n        p.forEach(function (a) {\n          !1 === a.fn.call(b, v) && v.preventDefault();\n        });\n      }\n\n      L && !v.defaultPrevented && L.call(b, v);\n    }\n\n    var h = f.charts,\n        a = f.doc,\n        b = f.win;\n    \"\";\n    (d || (d = {})).messages = [];\n    var w;\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    var J = Array.prototype.find ? function (a, b) {\n      return a.find(b);\n    } : function (a, b) {\n      var v,\n          e = a.length;\n\n      for (v = 0; v < e; v++) if (b(a[v], v)) return a[v];\n    };\n    m({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (a, b) {\n      f[b] = function (v) {\n        var e;\n        d(32, !1, void 0, (e = {}, e[\"Highcharts.\" + b] = \"use Array.\" + a, e));\n        return Array.prototype[a].apply(v, [].slice.call(arguments, 1));\n      };\n    });\n\n    var O,\n        F = function () {\n      var a = Math.random().toString(36).substring(2, 9) + \"-\",\n          b = 0;\n      return function () {\n        return \"highcharts-\" + (O ? \"\" : a) + b++;\n      };\n    }(),\n        N = f.getOptions = function () {\n      return f.defaultOptions;\n    },\n        R = f.setOptions = function (a) {\n      f.defaultOptions = k(!0, f.defaultOptions, a);\n      (a.time || a.global) && f.time.update(k(f.defaultOptions.global, f.defaultOptions.time, a.global, a.time));\n      return f.defaultOptions;\n    };\n\n    b.jQuery && (b.jQuery.fn.highcharts = function () {\n      var a = [].slice.call(arguments);\n      if (this[0]) return a[0] ? (new f[G(a[0]) ? a.shift() : \"Chart\"](this[0], a[0], a[1]), this) : h[g(this[0], \"data-highcharts-chart\")];\n    });\n    return {\n      addEvent: function (a, b, v, e) {\n        void 0 === e && (e = {});\n        var p = \"function\" === typeof a && a.prototype || a;\n        Object.hasOwnProperty.call(p, \"hcEvents\") || (p.hcEvents = {});\n        p = p.hcEvents;\n        f.Point && a instanceof f.Point && a.series && a.series.chart && (a.series.chart.runTrackerClick = !0);\n        var K = a.addEventListener || f.addEventListenerPolyfill;\n        K && K.call(a, b, v, f.supportsPassiveEvents ? {\n          passive: void 0 === e.passive ? -1 !== b.indexOf(\"touch\") : e.passive,\n          capture: !1\n        } : !1);\n        p[b] || (p[b] = []);\n        p[b].push({\n          fn: v,\n          order: \"number\" === typeof e.order ? e.order : Infinity\n        });\n        p[b].sort(function (a, b) {\n          return a.order - b.order;\n        });\n        return function () {\n          r(a, b, v);\n        };\n      },\n      arrayMax: function (a) {\n        for (var b = a.length, v = a[0]; b--;) a[b] > v && (v = a[b]);\n\n        return v;\n      },\n      arrayMin: function (a) {\n        for (var b = a.length, v = a[0]; b--;) a[b] < v && (v = a[b]);\n\n        return v;\n      },\n      attr: g,\n      clamp: function (a, b, v) {\n        return a > b ? a < v ? a : v : b;\n      },\n      cleanRecursively: x,\n      clearTimeout: function (a) {\n        E(a) && clearTimeout(a);\n      },\n      correctFloat: A,\n      createElement: n,\n      css: q,\n      defined: E,\n      destroyObjectProperties: function (a, b) {\n        m(a, function (v, e) {\n          v && v !== b && v.destroy && v.destroy();\n          delete a[e];\n        });\n      },\n      discardElement: function (a) {\n        w || (w = n(\"div\"));\n        a && w.appendChild(a);\n        w.innerHTML = \"\";\n      },\n      erase: function (a, b) {\n        for (var v = a.length; v--;) if (a[v] === b) {\n          a.splice(v, 1);\n          break;\n        }\n      },\n      error: d,\n      extend: y,\n      extendClass: function (a, b) {\n        var v = function () {};\n\n        v.prototype = new a();\n        y(v.prototype, b);\n        return v;\n      },\n      find: J,\n      fireEvent: e,\n      format: function (a, b, v) {\n        var e = \"{\",\n            p = !1,\n            K = [],\n            h = /f$/,\n            c = /\\.([0-9])/,\n            u = f.defaultOptions.lang,\n            m = v && v.time || f.time;\n\n        for (v = v && v.numberFormatter || M; a;) {\n          var I = a.indexOf(e);\n          if (-1 === I) break;\n          var g = a.slice(0, I);\n\n          if (p) {\n            g = g.split(\":\");\n            e = z(g.shift() || \"\", b);\n            if (g.length && \"number\" === typeof e) if (g = g.join(\":\"), h.test(g)) {\n              var w = parseInt((g.match(c) || [\"\", \"-1\"])[1], 10);\n              null !== e && (e = v(e, w, u.decimalPoint, -1 < g.indexOf(\",\") ? u.thousandsSep : \"\"));\n            } else e = m.dateFormat(g, e);\n            K.push(e);\n          } else K.push(g);\n\n          a = a.slice(I + 1);\n          e = (p = !p) ? \"}\" : \"{\";\n        }\n\n        K.push(a);\n        return K.join(\"\");\n      },\n      getMagnitude: function (a) {\n        return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n      },\n      getNestedProperty: z,\n      getOptions: N,\n      getStyle: function (a, e, v) {\n        if (\"width\" === e) return e = Math.min(a.offsetWidth, a.scrollWidth), v = a.getBoundingClientRect && a.getBoundingClientRect().width, v < e && v >= e - 1 && (e = Math.floor(v)), Math.max(0, e - f.getStyle(a, \"padding-left\") - f.getStyle(a, \"padding-right\"));\n        if (\"height\" === e) return Math.max(0, Math.min(a.offsetHeight, a.scrollHeight) - f.getStyle(a, \"padding-top\") - f.getStyle(a, \"padding-bottom\"));\n        b.getComputedStyle || d(27, !0);\n        if (a = b.getComputedStyle(a, void 0)) a = a.getPropertyValue(e), c(v, \"opacity\" !== e) && (a = B(a));\n        return a;\n      },\n      inArray: function (a, b, v) {\n        d(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return b.indexOf(a, v);\n      },\n      isArray: D,\n      isClass: C,\n      isDOMElement: t,\n      isFunction: function (a) {\n        return \"function\" === typeof a;\n      },\n      isNumber: l,\n      isObject: H,\n      isString: G,\n      keys: function (a) {\n        d(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(a);\n      },\n      merge: k,\n      normalizeTickInterval: function (a, b, v, e, p) {\n        var K = a;\n        v = c(v, 1);\n        var h = a / v;\n        b || (b = p ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === e && (1 === v ? b = b.filter(function (a) {\n          return 0 === a % 1;\n        }) : .1 >= v && (b = [1 / v])));\n\n        for (e = 0; e < b.length && !(K = b[e], p && K * v >= a || !p && h <= (b[e] + (b[e + 1] || b[e])) / 2); e++);\n\n        return K = A(K * v, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      numberFormat: M,\n      objectEach: m,\n      offset: function (e) {\n        var h = a.documentElement;\n        e = e.parentElement || e.parentNode ? e.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: e.top + (b.pageYOffset || h.scrollTop) - (h.clientTop || 0),\n          left: e.left + (b.pageXOffset || h.scrollLeft) - (h.clientLeft || 0),\n          width: e.width,\n          height: e.height\n        };\n      },\n      pad: function (a, b, v) {\n        return Array((b || 2) + 1 - String(a).replace(\"-\", \"\").length).join(v || \"0\") + a;\n      },\n      pick: c,\n      pInt: B,\n      relativeLength: function (a, b, v) {\n        return /%$/.test(a) ? b * parseFloat(a) / 100 + (v || 0) : parseFloat(a);\n      },\n      removeEvent: r,\n      setOptions: R,\n      splat: function (a) {\n        return D(a) ? a : [a];\n      },\n      stableSort: function (a, b) {\n        var v = a.length,\n            e,\n            p;\n\n        for (p = 0; p < v; p++) a[p].safeI = p;\n\n        a.sort(function (a, p) {\n          e = b(a, p);\n          return 0 === e ? a.safeI - p.safeI : e;\n        });\n\n        for (p = 0; p < v; p++) delete a[p].safeI;\n      },\n      syncTimeout: function (a, b, v) {\n        if (0 < b) return setTimeout(a, b, v);\n        a.call(0, v);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: F,\n      useSerialIds: function (a) {\n        return O = c(a, O);\n      },\n      wrap: function (a, b, v) {\n        var e = a[b];\n\n        a[b] = function () {\n          var a = Array.prototype.slice.call(arguments),\n              b = arguments,\n              h = this;\n\n          h.proceed = function () {\n            e.apply(h, arguments.length ? arguments : b);\n          };\n\n          a.unshift(e);\n          a = v.apply(this, a);\n          h.proceed = null;\n          return a;\n        };\n      }\n    };\n  });\n  P(k, \"Core/Renderer/HTML/AST.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = f.SVG_NS,\n        x = d.attr,\n        B = d.createElement,\n        G = d.discardElement,\n        D = d.error,\n        H = d.isString,\n        t = d.objectEach,\n        C = d.splat;\n    \"\";\n    var l = !1;\n\n    try {\n      l = !!new DOMParser().parseFromString(\"\", \"text/html\");\n    } catch (E) {}\n\n    return function () {\n      function E(g) {\n        this.nodes = \"string\" === typeof g ? this.parseMarkup(g) : g;\n      }\n\n      E.filterUserAttributes = function (g) {\n        t(g, function (y, c) {\n          var q = !0;\n          -1 === E.allowedAttributes.indexOf(c) && (q = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(c) && (q = H(y) && E.allowedReferences.some(function (c) {\n            return 0 === y.indexOf(c);\n          }));\n          q || (D(\"Highcharts warning: Invalid attribute '\" + c + \"' in config\"), delete g[c]);\n        });\n        return g;\n      };\n\n      E.setElementHTML = function (g, y) {\n        g.innerHTML = \"\";\n        y && new E(y).addToDOM(g);\n      };\n\n      E.prototype.addToDOM = function (g) {\n        function y(c, g) {\n          var n;\n          C(c).forEach(function (c) {\n            var q = c.tagName,\n                A = c.textContent ? f.doc.createTextNode(c.textContent) : void 0;\n            if (q) if (\"#text\" === q) var m = A;else if (-1 !== E.allowedTags.indexOf(q)) {\n              q = f.doc.createElementNS(\"svg\" === q ? k : g.namespaceURI || k, q);\n              var r = c.attributes || {};\n              t(c, function (e, h) {\n                \"tagName\" !== h && \"attributes\" !== h && \"children\" !== h && \"textContent\" !== h && (r[h] = e);\n              });\n              x(q, E.filterUserAttributes(r));\n              A && q.appendChild(A);\n              y(c.children || [], q);\n              m = q;\n            } else D(\"Highcharts warning: Invalid tagName '\" + q + \"' in config\");\n            m && g.appendChild(m);\n            n = m;\n          });\n          return n;\n        }\n\n        return y(this.nodes, g);\n      };\n\n      E.prototype.parseMarkup = function (g) {\n        var y = [];\n        if (l) g = new DOMParser().parseFromString(g, \"text/html\");else {\n          var c = B(\"div\");\n          c.innerHTML = g;\n          g = {\n            body: c\n          };\n        }\n\n        var q = function (c, g) {\n          var n = c.nodeName.toLowerCase(),\n              A = {\n            tagName: n\n          };\n\n          if (\"#text\" === n) {\n            n = c.textContent || \"\";\n            if (/^[\\s]*$/.test(n)) return;\n            A.textContent = n;\n          }\n\n          if (n = c.attributes) {\n            var m = {};\n            [].forEach.call(n, function (e) {\n              m[e.name] = e.value;\n            });\n            A.attributes = m;\n          }\n\n          if (c.childNodes.length) {\n            var r = [];\n            [].forEach.call(c.childNodes, function (e) {\n              q(e, r);\n            });\n            r.length && (A.children = r);\n          }\n\n          g.push(A);\n        };\n\n        [].forEach.call(g.body.childNodes, function (c) {\n          return q(c, y);\n        });\n        c && G(c);\n        return y;\n      };\n\n      E.allowedTags = \"a b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr ul #text\".split(\" \");\n      E.allowedAttributes = \"aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style result rowspan summary target tabindex text-align textAnchor textLength type valign width x x1 xy y y1 y2 zIndex\".split(\" \");\n      E.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n      return E;\n    }();\n  });\n  P(k, \"Core/Color/Color.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = d.isNumber,\n        x = d.merge,\n        B = d.pInt;\n    \"\";\n\n    d = function () {\n      function d(D) {\n        this.parsers = [{\n          regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n          parse: function (d) {\n            return [B(d[1]), B(d[2]), B(d[3]), parseFloat(d[4], 10)];\n          }\n        }, {\n          regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n          parse: function (d) {\n            return [B(d[1]), B(d[2]), B(d[3]), 1];\n          }\n        }];\n        this.rgba = [];\n        if (f.Color !== d) return new f.Color(D);\n        if (!(this instanceof d)) return new d(D);\n        this.init(D);\n      }\n\n      d.parse = function (f) {\n        return new d(f);\n      };\n\n      d.prototype.init = function (f) {\n        var k, t;\n        if ((this.input = f = d.names[f && f.toLowerCase ? f.toLowerCase() : \"\"] || f) && f.stops) this.stops = f.stops.map(function (l) {\n          return new d(l[1]);\n        });else {\n          if (f && f.charAt && \"#\" === f.charAt()) {\n            var C = f.length;\n            f = parseInt(f.substr(1), 16);\n            7 === C ? k = [(f & 16711680) >> 16, (f & 65280) >> 8, f & 255, 1] : 4 === C && (k = [(f & 3840) >> 4 | (f & 3840) >> 8, (f & 240) >> 4 | f & 240, (f & 15) << 4 | f & 15, 1]);\n          }\n\n          if (!k) for (t = this.parsers.length; t-- && !k;) {\n            var l = this.parsers[t];\n            (C = l.regex.exec(f)) && (k = l.parse(C));\n          }\n        }\n        this.rgba = k || [];\n      };\n\n      d.prototype.get = function (d) {\n        var f = this.input,\n            t = this.rgba;\n\n        if (\"undefined\" !== typeof this.stops) {\n          var C = x(f);\n          C.stops = [].concat(C.stops);\n          this.stops.forEach(function (l, E) {\n            C.stops[E] = [C.stops[E][0], l.get(d)];\n          });\n        } else C = t && k(t[0]) ? \"rgb\" === d || !d && 1 === t[3] ? \"rgb(\" + t[0] + \",\" + t[1] + \",\" + t[2] + \")\" : \"a\" === d ? t[3] : \"rgba(\" + t.join(\",\") + \")\" : f;\n\n        return C;\n      };\n\n      d.prototype.brighten = function (d) {\n        var f,\n            t = this.rgba;\n        if (this.stops) this.stops.forEach(function (C) {\n          C.brighten(d);\n        });else if (k(d) && 0 !== d) for (f = 0; 3 > f; f++) t[f] += B(255 * d), 0 > t[f] && (t[f] = 0), 255 < t[f] && (t[f] = 255);\n        return this;\n      };\n\n      d.prototype.setOpacity = function (d) {\n        this.rgba[3] = d;\n        return this;\n      };\n\n      d.prototype.tweenTo = function (d, f) {\n        var t = this.rgba,\n            C = d.rgba;\n        C.length && t && t.length ? (d = 1 !== C[3] || 1 !== t[3], f = (d ? \"rgba(\" : \"rgb(\") + Math.round(C[0] + (t[0] - C[0]) * (1 - f)) + \",\" + Math.round(C[1] + (t[1] - C[1]) * (1 - f)) + \",\" + Math.round(C[2] + (t[2] - C[2]) * (1 - f)) + (d ? \",\" + (C[3] + (t[3] - C[3]) * (1 - f)) : \"\") + \")\") : f = d.input || \"none\";\n        return f;\n      };\n\n      d.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      return d;\n    }();\n\n    f.Color = d;\n    f.color = d.parse;\n    return d;\n  });\n  P(k, \"Core/Color/Palette.js\", [], function () {\n    return {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \"),\n      backgroundColor: \"#ffffff\",\n      neutralColor100: \"#000000\",\n      neutralColor80: \"#333333\",\n      neutralColor60: \"#666666\",\n      neutralColor40: \"#999999\",\n      neutralColor20: \"#cccccc\",\n      neutralColor10: \"#e6e6e6\",\n      neutralColor5: \"#f2f2f2\",\n      neutralColor3: \"#f7f7f7\",\n      highlightColor100: \"#003399\",\n      highlightColor80: \"#335cad\",\n      highlightColor60: \"#6685c2\",\n      highlightColor20: \"#ccd6eb\",\n      highlightColor10: \"#e6ebf5\",\n      indicatorPositiveLine: \"#06b535\",\n      indicatorNegativeLine: \"#f21313\"\n    };\n  });\n  P(k, \"Core/Animation/Fx.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = f.win,\n        x = d.isNumber,\n        B = d.objectEach;\n\n    d = function () {\n      function d(d, f, t) {\n        this.pos = NaN;\n        this.options = f;\n        this.elem = d;\n        this.prop = t;\n      }\n\n      d.prototype.dSetter = function () {\n        var d = this.paths,\n            f = d && d[0];\n        d = d && d[1];\n        var t = [],\n            C = this.now || 0;\n        if (1 !== C && f && d) {\n          if (f.length === d.length && 1 > C) for (var l = 0; l < d.length; l++) {\n            for (var E = f[l], g = d[l], y = [], c = 0; c < g.length; c++) {\n              var q = E[c],\n                  n = g[c];\n              x(q) && x(n) && (\"A\" !== g[0] || 4 !== c && 5 !== c) ? y[c] = q + C * (n - q) : y[c] = n;\n            }\n\n            t.push(y);\n          } else t = d;\n        } else t = this.toD || [];\n        this.elem.attr(\"d\", t, void 0, !0);\n      };\n\n      d.prototype.update = function () {\n        var d = this.elem,\n            f = this.prop,\n            t = this.now,\n            C = this.options.step;\n        if (this[f + \"Setter\"]) this[f + \"Setter\"]();else d.attr ? d.element && d.attr(f, t, null, !0) : d.style[f] = t + this.unit;\n        C && C.call(d, t, this);\n      };\n\n      d.prototype.run = function (f, H, t) {\n        var C = this,\n            l = C.options,\n            E = function (c) {\n          return E.stopped ? !1 : C.step(c);\n        },\n            g = k.requestAnimationFrame || function (c) {\n          setTimeout(c, 13);\n        },\n            y = function () {\n          for (var c = 0; c < d.timers.length; c++) d.timers[c]() || d.timers.splice(c--, 1);\n\n          d.timers.length && g(y);\n        };\n\n        f !== H || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = f, this.end = H, this.unit = t, this.now = this.start, this.pos = 0, E.elem = this.elem, E.prop = this.prop, E() && 1 === d.timers.push(E) && g(y)) : (delete l.curAnim[this.prop], l.complete && 0 === Object.keys(l.curAnim).length && l.complete.call(this.elem));\n      };\n\n      d.prototype.step = function (d) {\n        var f = +new Date(),\n            t = this.options,\n            C = this.elem,\n            l = t.complete,\n            E = t.duration,\n            g = t.curAnim;\n        if (C.attr && !C.element) d = !1;else if (d || f >= E + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var y = g[this.prop] = !0;\n          B(g, function (c) {\n            !0 !== c && (y = !1);\n          });\n          y && l && l.call(C);\n          d = !1;\n        } else this.pos = t.easing((f - this.startTime) / E), this.now = this.start + (this.end - this.start) * this.pos, this.update(), d = !0;\n        return d;\n      };\n\n      d.prototype.initPath = function (d, f, t) {\n        function C(c, g) {\n          for (; c.length < A;) {\n            var m = c[0],\n                n = g[A - c.length];\n            n && \"M\" === m[0] && (c[0] = \"C\" === n[0] ? [\"C\", m[1], m[2], m[1], m[2], m[1], m[2]] : [\"L\", m[1], m[2]]);\n            c.unshift(m);\n            y && c.push(c[c.length - 1]);\n          }\n        }\n\n        function l(g, n) {\n          for (; g.length < A;) if (n = g[g.length / c - 1].slice(), \"C\" === n[0] && (n[1] = n[5], n[2] = n[6]), y) {\n            var m = g[g.length / c].slice();\n            g.splice(g.length / 2, 0, n, m);\n          } else g.push(n);\n        }\n\n        var E = d.startX,\n            g = d.endX;\n        f = f && f.slice();\n        t = t.slice();\n        var y = d.isArea,\n            c = y ? 2 : 1;\n        if (!f) return [t, t];\n\n        if (E && g) {\n          for (d = 0; d < E.length; d++) if (E[d] === g[0]) {\n            var q = d;\n            break;\n          } else if (E[0] === g[g.length - E.length + d]) {\n            q = d;\n            var n = !0;\n            break;\n          } else if (E[E.length - 1] === g[g.length - E.length + d]) {\n            q = E.length - d;\n            break;\n          }\n\n          \"undefined\" === typeof q && (f = []);\n        }\n\n        if (f.length && x(q)) {\n          var A = t.length + q * c;\n          n ? (C(f, t), l(t, f)) : (C(t, f), l(f, t));\n        }\n\n        return [f, t];\n      };\n\n      d.prototype.fillSetter = function () {\n        d.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      d.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, f.color(this.start).tweenTo(f.color(this.end), this.pos), null, !0);\n      };\n\n      d.timers = [];\n      return d;\n    }();\n\n    f.Fx = d;\n    f.timers = d.timers;\n    return d;\n  });\n  P(k, \"Core/Animation/AnimationUtilities.js\", [k[\"Core/Animation/Fx.js\"], k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d, k) {\n    var x = k.defined,\n        B = k.getStyle,\n        S = k.isArray,\n        D = k.isNumber,\n        H = k.isObject,\n        t = k.merge,\n        C = k.objectEach,\n        l = k.pick;\n\n    k = d.setAnimation = function (c, g) {\n      g.renderer.globalAnimation = l(c, g.options.chart.animation, !0);\n    };\n\n    var E = d.animObject = function (c) {\n      return H(c) ? t({\n        duration: 500,\n        defer: 0\n      }, c) : {\n        duration: c ? 500 : 0,\n        defer: 0\n      };\n    },\n        g = d.getDeferredAnimation = function (c, g, n) {\n      var q = E(g),\n          y = 0,\n          l = 0;\n      (n ? [n] : c.series).forEach(function (c) {\n        c = E(c.options.animation);\n        y = g && x(g.defer) ? q.defer : Math.max(y, c.duration + c.defer);\n        l = Math.min(q.duration, c.duration);\n      });\n      c.renderer.forExport && (y = 0);\n      return {\n        defer: Math.max(0, y - l),\n        duration: Math.min(y, l)\n      };\n    },\n        y = d.stop = function (c, g) {\n      for (var n = f.timers.length; n--;) f.timers[n].elem !== c || g && g !== f.timers[n].prop || (f.timers[n].stopped = !0);\n    };\n\n    return {\n      animate: function (c, g, n) {\n        var q,\n            l = \"\",\n            d,\n            m;\n\n        if (!H(n)) {\n          var r = arguments;\n          n = {\n            duration: r[2],\n            easing: r[3],\n            complete: r[4]\n          };\n        }\n\n        D(n.duration) || (n.duration = 400);\n        n.easing = \"function\" === typeof n.easing ? n.easing : Math[n.easing] || Math.easeInOutSine;\n        n.curAnim = t(g);\n        C(g, function (e, h) {\n          y(c, h);\n          m = new f(c, n, h);\n          d = null;\n          \"d\" === h && S(g.d) ? (m.paths = m.initPath(c, c.pathArray, g.d), m.toD = g.d, q = 0, d = 1) : c.attr ? q = c.attr(h) : (q = parseFloat(B(c, h)) || 0, \"opacity\" !== h && (l = \"px\"));\n          d || (d = e);\n          d && d.match && d.match(\"px\") && (d = d.replace(/px/g, \"\"));\n          m.run(q, d, l);\n        });\n      },\n      animObject: E,\n      getDeferredAnimation: g,\n      setAnimation: k,\n      stop: y\n    };\n  });\n  P(k, \"Core/Renderer/SVG/SVGElement.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Renderer/HTML/AST.js\"], k[\"Core/Color/Color.js\"], k[\"Core/Globals.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G) {\n    var D = f.animate,\n        H = f.animObject,\n        t = f.stop,\n        C = x.deg2rad,\n        l = x.doc,\n        E = x.hasTouch,\n        g = x.noop,\n        y = x.svg,\n        c = x.SVG_NS,\n        q = x.win,\n        n = G.attr,\n        A = G.createElement,\n        M = G.css,\n        z = G.defined,\n        m = G.erase,\n        r = G.extend,\n        e = G.fireEvent,\n        h = G.isArray,\n        a = G.isFunction,\n        b = G.isNumber,\n        w = G.isString,\n        J = G.merge,\n        O = G.objectEach,\n        F = G.pick,\n        N = G.pInt,\n        R = G.syncTimeout,\n        Q = G.uniqueKey;\n    \"\";\n\n    f = function () {\n      function f() {\n        this.height = this.element = void 0;\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = c;\n        this.symbolCustomAttribs = \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \");\n        this.width = void 0;\n      }\n\n      f.prototype._defaultGetter = function (a) {\n        a = F(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      };\n\n      f.prototype._defaultSetter = function (a, b, p) {\n        p.setAttribute(b, a);\n      };\n\n      f.prototype.add = function (a) {\n        var b = this.renderer,\n            p = this.element;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && b.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) var e = this.zIndexSetter();\n        e || (a ? a.element : b.box).appendChild(p);\n        if (this.onAdd) this.onAdd();\n        return this;\n      };\n\n      f.prototype.addClass = function (a, b) {\n        var p = b ? \"\" : this.attr(\"class\") || \"\";\n        a = (a || \"\").split(/ /g).reduce(function (a, b) {\n          -1 === p.indexOf(b) && a.push(b);\n          return a;\n        }, p ? [p] : []).join(\" \");\n        a !== p && this.attr(\"class\", a);\n        return this;\n      };\n\n      f.prototype.afterSetters = function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      };\n\n      f.prototype.align = function (a, b, p) {\n        var e,\n            v = {};\n        var c = this.renderer;\n        var u = c.alignedObjects;\n        var h, I;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = b, !p || w(p)) this.alignTo = e = p || \"renderer\", m(u, this), u.push(this), p = void 0;\n        } else a = this.alignOptions, b = this.alignByTranslate, e = this.alignTo;\n\n        p = F(p, c[e], c);\n        e = a.align;\n        c = a.verticalAlign;\n        u = (p.x || 0) + (a.x || 0);\n        var g = (p.y || 0) + (a.y || 0);\n        \"right\" === e ? h = 1 : \"center\" === e && (h = 2);\n        h && (u += (p.width - (a.width || 0)) / h);\n        v[b ? \"translateX\" : \"x\"] = Math.round(u);\n        \"bottom\" === c ? I = 1 : \"middle\" === c && (I = 2);\n        I && (g += (p.height - (a.height || 0)) / I);\n        v[b ? \"translateY\" : \"y\"] = Math.round(g);\n        this[this.placed ? \"animate\" : \"attr\"](v);\n        this.placed = !0;\n        this.alignAttr = v;\n        return this;\n      };\n\n      f.prototype.alignSetter = function (a) {\n        var b = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        b[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", b[a]));\n      };\n\n      f.prototype.animate = function (a, b, p) {\n        var e = this,\n            v = H(F(b, this.renderer.globalAnimation, !0));\n        b = v.defer;\n        F(l.hidden, l.msHidden, l.webkitHidden, !1) && (v.duration = 0);\n        0 !== v.duration ? (p && (v.complete = p), R(function () {\n          e.element && D(e, a, v);\n        }, b)) : (this.attr(a, void 0, p), O(a, function (a, b) {\n          v.step && v.step.call(this, a, {\n            prop: b,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      };\n\n      f.prototype.applyTextOutline = function (a) {\n        var b = this.element;\n        -1 !== a.indexOf(\"contrast\") && (a = a.replace(/contrast/g, this.renderer.getContrast(b.style.fill)));\n        var p = a.split(\" \");\n        a = p[p.length - 1];\n\n        if ((p = p[0]) && \"none\" !== p && x.svg) {\n          this.fakeTS = !0;\n          this.ySetter = this.xSetter;\n          p = p.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, b, p) {\n            return 2 * Number(b) + p;\n          });\n          this.removeTextOutline();\n          var e = l.createElementNS(c, \"tspan\");\n          n(e, {\n            \"class\": \"highcharts-text-outline\",\n            fill: a,\n            stroke: a,\n            \"stroke-width\": p,\n            \"stroke-linejoin\": \"round\"\n          });\n          [].forEach.call(b.childNodes, function (a) {\n            var b = a.cloneNode(!0);\n            b.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(function (a) {\n              return b.removeAttribute(a);\n            });\n            e.appendChild(b);\n          });\n          a = l.createElementNS(c, \"tspan\");\n          a.textContent = \"\\u200b\";\n          n(a, {\n            x: b.getAttribute(\"x\"),\n            y: b.getAttribute(\"y\")\n          });\n          e.appendChild(a);\n          b.insertBefore(e, b.firstChild);\n        }\n      };\n\n      f.prototype.attr = function (a, b, p, e) {\n        var K = this.element,\n            v,\n            u = this,\n            c,\n            h,\n            g = this.symbolCustomAttribs;\n\n        if (\"string\" === typeof a && \"undefined\" !== typeof b) {\n          var L = a;\n          a = {};\n          a[L] = b;\n        }\n\n        \"string\" === typeof a ? u = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, K) : (O(a, function (b, p) {\n          c = !1;\n          e || t(this, p);\n          this.symbolName && -1 !== g.indexOf(p) && (v || (this.symbolAttr(a), v = !0), c = !0);\n          !this.rotation || \"x\" !== p && \"y\" !== p || (this.doTransform = !0);\n          c || (h = this[p + \"Setter\"] || this._defaultSetter, h.call(this, b, p, K), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(p) && this.updateShadows(p, b, h));\n        }, this), this.afterSetters());\n        p && p.call(this);\n        return u;\n      };\n\n      f.prototype.clip = function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      };\n\n      f.prototype.crisp = function (a, b) {\n        b = b || a.strokeWidth || 0;\n        var p = Math.round(b) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + p;\n        a.y = Math.floor(a.y || this.y || 0) + p;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * p);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * p);\n        z(a.strokeWidth) && (a.strokeWidth = b);\n        return a;\n      };\n\n      f.prototype.complexColor = function (a, b, p) {\n        var K = this.renderer,\n            v,\n            c,\n            u,\n            g,\n            I,\n            m,\n            L,\n            w,\n            n,\n            r,\n            q = [],\n            F;\n        e(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          a.radialGradient ? c = \"radialGradient\" : a.linearGradient && (c = \"linearGradient\");\n\n          if (c) {\n            u = a[c];\n            I = K.gradients;\n            m = a.stops;\n            n = p.radialReference;\n            h(u) && (a[c] = u = {\n              x1: u[0],\n              y1: u[1],\n              x2: u[2],\n              y2: u[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === c && n && !z(u.gradientUnits) && (g = u, u = J(u, K.getRadialAttr(n, g), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            O(u, function (a, b) {\n              \"id\" !== b && q.push(b, a);\n            });\n            O(m, function (a) {\n              q.push(a);\n            });\n            q = q.join(\",\");\n            if (I[q]) r = I[q].attr(\"id\");else {\n              u.id = r = Q();\n              var e = I[q] = K.createElement(c).attr(u).add(K.defs);\n              e.radAttr = g;\n              e.stops = [];\n              m.forEach(function (a) {\n                0 === a[1].indexOf(\"rgba\") ? (v = k.parse(a[1]), L = v.get(\"rgb\"), w = v.get(\"a\")) : (L = a[1], w = 1);\n                a = K.createElement(\"stop\").attr({\n                  offset: a[0],\n                  \"stop-color\": L,\n                  \"stop-opacity\": w\n                }).add(e);\n                e.stops.push(a);\n              });\n            }\n            F = \"url(\" + K.url + \"#\" + r + \")\";\n            p.setAttribute(b, F);\n            p.gradient = q;\n\n            a.toString = function () {\n              return F;\n            };\n          }\n        });\n      };\n\n      f.prototype.css = function (a) {\n        var b = this.styles,\n            p = {},\n            e = this.element,\n            c = \"\",\n            v = !b,\n            u = [\"textOutline\", \"textOverflow\", \"width\"];\n        a && a.color && (a.fill = a.color);\n        b && O(a, function (a, u) {\n          b && b[u] !== a && (p[u] = a, v = !0);\n        });\n\n        if (v) {\n          b && (a = r(b, p));\n          if (a) if (null === a.width || \"auto\" === a.width) delete this.textWidth;else if (\"text\" === e.nodeName.toLowerCase() && a.width) var h = this.textWidth = N(a.width);\n          this.styles = a;\n          h && !y && this.renderer.forExport && delete a.width;\n\n          if (e.namespaceURI === this.SVG_NS) {\n            var g = function (a, b) {\n              return \"-\" + b.toLowerCase();\n            };\n\n            O(a, function (a, b) {\n              -1 === u.indexOf(b) && (c += b.replace(/([A-Z])/g, g) + \":\" + a + \";\");\n            });\n            c && n(e, \"style\", c);\n          } else M(e, a);\n\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a && a.textOutline && this.applyTextOutline(a.textOutline));\n        }\n\n        return this;\n      };\n\n      f.prototype.dashstyleSetter = function (a) {\n        var b = this[\"stroke-width\"];\n        \"inherit\" === b && (b = 1);\n\n        if (a = a && a.toLowerCase()) {\n          var p = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (a = p.length; a--;) p[a] = \"\" + N(p[a]) * F(b, NaN);\n\n          a = p.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      };\n\n      f.prototype.destroy = function () {\n        var a = this,\n            b = a.element || {},\n            p = a.renderer,\n            e = p.isSVG && \"SPAN\" === b.nodeName && a.parentGroup || void 0,\n            c = b.ownerSVGElement;\n        b.onclick = b.onmouseout = b.onmouseover = b.onmousemove = b.point = null;\n        t(a);\n\n        if (a.clipPath && c) {\n          var h = a.clipPath;\n          [].forEach.call(c.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n            -1 < a.getAttribute(\"clip-path\").indexOf(h.element.id) && a.removeAttribute(\"clip-path\");\n          });\n          a.clipPath = h.destroy();\n        }\n\n        if (a.stops) {\n          for (c = 0; c < a.stops.length; c++) a.stops[c].destroy();\n\n          a.stops.length = 0;\n          a.stops = void 0;\n        }\n\n        a.safeRemoveChild(b);\n\n        for (p.styledMode || a.destroyShadows(); e && e.div && 0 === e.div.childNodes.length;) b = e.parentGroup, a.safeRemoveChild(e.div), delete e.div, e = b;\n\n        a.alignTo && m(p.alignedObjects, a);\n        O(a, function (b, p) {\n          a[p] && a[p].parentGroup === a && a[p].destroy && a[p].destroy();\n          delete a[p];\n        });\n      };\n\n      f.prototype.destroyShadows = function () {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      };\n\n      f.prototype.destroyTextPath = function (a, b) {\n        var p = a.getElementsByTagName(\"text\")[0];\n\n        if (p) {\n          if (p.removeAttribute(\"dx\"), p.removeAttribute(\"dy\"), b.element.setAttribute(\"id\", \"\"), this.textPathWrapper && p.getElementsByTagName(\"textPath\").length) {\n            for (a = this.textPathWrapper.element.childNodes; a.length;) p.appendChild(a[0]);\n\n            p.removeChild(this.textPathWrapper.element);\n          }\n        } else if (a.getAttribute(\"dx\") || a.getAttribute(\"dy\")) a.removeAttribute(\"dx\"), a.removeAttribute(\"dy\");\n\n        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());\n      };\n\n      f.prototype.dSetter = function (a, b, p) {\n        h(a) && (\"string\" === typeof a[0] && (a = this.renderer.pathToSegments(a)), this.pathArray = a, a = a.reduce(function (a, b, p) {\n          return b && b.join ? (p ? a + \" \" : \"\") + b.join(\" \") : (b || \"\").toString();\n        }, \"\"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[b] !== a && (p.setAttribute(b, a), this[b] = a);\n      };\n\n      f.prototype.fadeOut = function (a) {\n        var b = this;\n        b.animate({\n          opacity: 0\n        }, {\n          duration: F(a, 150),\n          complete: function () {\n            b.attr({\n              y: -9999\n            }).hide();\n          }\n        });\n      };\n\n      f.prototype.fillSetter = function (a, b, p) {\n        \"string\" === typeof a ? p.setAttribute(b, a) : a && this.complexColor(a, b, p);\n      };\n\n      f.prototype.getBBox = function (b, e) {\n        var p,\n            c = this.renderer,\n            h = this.element,\n            g = this.styles,\n            u = this.textStr,\n            m = c.cache,\n            I = c.cacheKeys,\n            v = h.namespaceURI === this.SVG_NS;\n        e = F(e, this.rotation, 0);\n        var L = c.styledMode ? h && f.prototype.getStyle.call(h, \"font-size\") : g && g.fontSize;\n\n        if (z(u)) {\n          var w = u.toString();\n          -1 === w.indexOf(\"<\") && (w = w.replace(/[0-9]/g, \"0\"));\n          w += [\"\", e, L, this.textWidth, g && g.textOverflow, g && g.fontWeight].join();\n        }\n\n        w && !b && (p = m[w]);\n\n        if (!p) {\n          if (v || c.forExport) {\n            try {\n              var n = this.fakeTS && function (a) {\n                var b = h.querySelector(\".highcharts-text-outline\");\n                b && M(b, {\n                  display: a\n                });\n              };\n\n              a(n) && n(\"none\");\n              p = h.getBBox ? r({}, h.getBBox()) : {\n                width: h.offsetWidth,\n                height: h.offsetHeight\n              };\n              a(n) && n(\"\");\n            } catch (da) {\n              \"\";\n            }\n\n            if (!p || 0 > p.width) p = {\n              width: 0,\n              height: 0\n            };\n          } else p = this.htmlGetBBox();\n\n          c.isSVG && (b = p.width, c = p.height, v && (p.height = c = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[g && g.fontSize + \",\" + Math.round(c)] || c), e && (g = e * C, p.width = Math.abs(c * Math.sin(g)) + Math.abs(b * Math.cos(g)), p.height = Math.abs(c * Math.cos(g)) + Math.abs(b * Math.sin(g))));\n\n          if (w && 0 < p.height) {\n            for (; 250 < I.length;) delete m[I.shift()];\n\n            m[w] || I.push(w);\n            m[w] = p;\n          }\n        }\n\n        return p;\n      };\n\n      f.prototype.getStyle = function (a) {\n        return q.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      };\n\n      f.prototype.hasClass = function (a) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(a);\n      };\n\n      f.prototype.hide = function (a) {\n        a ? this.attr({\n          y: -9999\n        }) : this.attr({\n          visibility: \"hidden\"\n        });\n        return this;\n      };\n\n      f.prototype.htmlGetBBox = function () {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      };\n\n      f.prototype.init = function (a, b) {\n        this.element = \"span\" === b ? A(b) : l.createElementNS(this.SVG_NS, b);\n        this.renderer = a;\n        e(this, \"afterInit\");\n      };\n\n      f.prototype.invert = function (a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      };\n\n      f.prototype.on = function (a, b) {\n        var p,\n            e,\n            c = this.element,\n            h;\n        E && \"click\" === a ? (c.ontouchstart = function (a) {\n          p = a.touches[0].clientX;\n          e = a.touches[0].clientY;\n        }, c.ontouchend = function (a) {\n          p && 4 <= Math.sqrt(Math.pow(p - a.changedTouches[0].clientX, 2) + Math.pow(e - a.changedTouches[0].clientY, 2)) || b.call(c, a);\n          h = !0;\n          !1 !== a.cancelable && a.preventDefault();\n        }, c.onclick = function (a) {\n          h || b.call(c, a);\n        }) : c[\"on\" + a] = b;\n        return this;\n      };\n\n      f.prototype.opacitySetter = function (a, b, p) {\n        this.opacity = a = Number(Number(a).toFixed(3));\n        p.setAttribute(b, a);\n      };\n\n      f.prototype.removeClass = function (a) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(w(a) ? new RegExp(\"(^| )\" + a + \"( |$)\") : a, \" \").replace(/ +/g, \" \").trim());\n      };\n\n      f.prototype.removeTextOutline = function () {\n        var a = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        a && this.safeRemoveChild(a);\n      };\n\n      f.prototype.safeRemoveChild = function (a) {\n        var b = a.parentNode;\n        b && b.removeChild(a);\n      };\n\n      f.prototype.setRadialReference = function (a) {\n        var b = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr));\n        return this;\n      };\n\n      f.prototype.setTextPath = function (a, e) {\n        var p = this.element,\n            c = this.text ? this.text.element : p,\n            h = {\n          textAnchor: \"text-anchor\"\n        },\n            m = !1,\n            u = this.textPathWrapper,\n            v = !u;\n        e = J(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, e);\n        var I = d.filterUserAttributes(e.attributes);\n\n        if (a && e && e.enabled) {\n          u && null === u.element.parentNode ? (v = !0, u = u.destroy()) : u && this.removeTextOutline.call(u.parentGroup);\n          this.options && this.options.padding && (I.dx = -this.options.padding);\n          u || (this.textPathWrapper = u = this.renderer.createElement(\"textPath\"), m = !0);\n          var w = u.element;\n          (e = a.element.getAttribute(\"id\")) || a.element.setAttribute(\"id\", e = Q());\n          if (v) for (c.setAttribute(\"y\", 0), b(I.dx) && c.setAttribute(\"x\", -I.dx), a = [].slice.call(c.childNodes), v = 0; v < a.length; v++) {\n            var n = a[v];\n            n.nodeType !== Node.TEXT_NODE && \"tspan\" !== n.nodeName || w.appendChild(n);\n          }\n          m && u && u.add({\n            element: c\n          });\n          w.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + e);\n          z(I.dy) && (w.parentNode.setAttribute(\"dy\", I.dy), delete I.dy);\n          z(I.dx) && (w.parentNode.setAttribute(\"dx\", I.dx), delete I.dx);\n          O(I, function (a, b) {\n            w.setAttribute(h[b] || b, a);\n          });\n          p.removeAttribute(\"transform\");\n          this.removeTextOutline.call(u);\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = g;\n        } else u && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(p, a), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));\n\n        return this;\n      };\n\n      f.prototype.shadow = function (a, b, p) {\n        var e = [],\n            c = this.element,\n            h = !1,\n            u = this.oldShadowOptions;\n        var g = {\n          color: B.neutralColor100,\n          offsetX: 1,\n          offsetY: 1,\n          opacity: .15,\n          width: 3\n        };\n        var I;\n        !0 === a ? I = g : \"object\" === typeof a && (I = r(g, a));\n        I && (I && u && O(I, function (a, b) {\n          a !== u[b] && (h = !0);\n        }), h && this.destroyShadows(), this.oldShadowOptions = I);\n        if (!I) this.destroyShadows();else if (!this.shadows) {\n          var m = I.opacity / I.width;\n          var v = this.parentInverted ? \"translate(-1,-1)\" : \"translate(\" + I.offsetX + \", \" + I.offsetY + \")\";\n\n          for (g = 1; g <= I.width; g++) {\n            var w = c.cloneNode(!1);\n            var L = 2 * I.width + 1 - 2 * g;\n            n(w, {\n              stroke: a.color || B.neutralColor100,\n              \"stroke-opacity\": m * g,\n              \"stroke-width\": L,\n              transform: v,\n              fill: \"none\"\n            });\n            w.setAttribute(\"class\", (w.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            p && (n(w, \"height\", Math.max(n(w, \"height\") - L, 0)), w.cutHeight = L);\n            b ? b.element.appendChild(w) : c.parentNode && c.parentNode.insertBefore(w, c);\n            e.push(w);\n          }\n\n          this.shadows = e;\n        }\n        return this;\n      };\n\n      f.prototype.show = function (a) {\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      };\n\n      f.prototype.strokeSetter = function (a, b, p) {\n        this[b] = a;\n        this.stroke && this[\"stroke-width\"] ? (f.prototype.fillSetter.call(this, this.stroke, \"stroke\", p), p.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === b && 0 === a && this.hasStroke ? (p.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (p.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n      };\n\n      f.prototype.strokeWidth = function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            b = 0;\n        if (a.indexOf(\"px\") === a.length - 2) b = N(a);else if (\"\" !== a) {\n          var p = l.createElementNS(c, \"rect\");\n          n(p, {\n            width: a,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(p);\n          b = p.getBBox().width;\n          p.parentNode.removeChild(p);\n        }\n        return b;\n      };\n\n      f.prototype.symbolAttr = function (a) {\n        var b = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (p) {\n          b[p] = F(a[p], b[p]);\n        });\n        b.attr({\n          d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)\n        });\n      };\n\n      f.prototype.textSetter = function (a) {\n        a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      };\n\n      f.prototype.titleSetter = function (a) {\n        var b = this.element,\n            p = b.getElementsByTagName(\"title\")[0] || l.createElementNS(this.SVG_NS, \"title\");\n        b.insertBefore ? b.insertBefore(p, b.firstChild) : b.appendChild(p);\n        p.textContent = String(F(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      };\n\n      f.prototype.toFront = function () {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      };\n\n      f.prototype.translate = function (a, b) {\n        return this.attr({\n          translateX: a,\n          translateY: b\n        });\n      };\n\n      f.prototype.updateShadows = function (a, b, p) {\n        var e = this.shadows;\n        if (e) for (var c = e.length; c--;) p.call(e[c], \"height\" === a ? Math.max(b - (e[c].cutHeight || 0), 0) : \"d\" === a ? this.d : b, a, e[c]);\n      };\n\n      f.prototype.updateTransform = function () {\n        var a = this.translateX || 0,\n            b = this.translateY || 0,\n            p = this.scaleX,\n            e = this.scaleY,\n            c = this.inverted,\n            h = this.rotation,\n            u = this.matrix,\n            g = this.element;\n        c && (a += this.width, b += this.height);\n        a = [\"translate(\" + a + \",\" + b + \")\"];\n        z(u) && a.push(\"matrix(\" + u.join(\",\") + \")\");\n        c ? a.push(\"rotate(90) scale(-1,1)\") : h && a.push(\"rotate(\" + h + \" \" + F(this.rotationOriginX, g.getAttribute(\"x\"), 0) + \" \" + F(this.rotationOriginY, g.getAttribute(\"y\") || 0) + \")\");\n        (z(p) || z(e)) && a.push(\"scale(\" + F(p, 1) + \" \" + F(e, 1) + \")\");\n        a.length && g.setAttribute(\"transform\", a.join(\" \"));\n      };\n\n      f.prototype.visibilitySetter = function (a, b, p) {\n        \"inherit\" === a ? p.removeAttribute(b) : this[b] !== a && p.setAttribute(b, a);\n        this[b] = a;\n      };\n\n      f.prototype.xGetter = function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      };\n\n      f.prototype.zIndexSetter = function (a, b) {\n        var p = this.renderer,\n            e = this.parentGroup,\n            c = (e || p).element || p.box,\n            h = this.element,\n            u = !1;\n        p = c === p.box;\n        var g = this.added;\n        var I;\n        z(a) ? (h.setAttribute(\"data-z-index\", a), a = +a, this[b] === a && (g = !1)) : z(this[b]) && h.removeAttribute(\"data-z-index\");\n        this[b] = a;\n\n        if (g) {\n          (a = this.zIndex) && e && (e.handleZ = !0);\n          b = c.childNodes;\n\n          for (I = b.length - 1; 0 <= I && !u; I--) {\n            e = b[I];\n            g = e.getAttribute(\"data-z-index\");\n            var m = !z(g);\n            if (e !== h) if (0 > a && m && !p && !I) c.insertBefore(h, b[I]), u = !0;else if (N(g) <= a || m && (!z(a) || 0 <= a)) c.insertBefore(h, b[I + 1] || null), u = !0;\n          }\n\n          u || (c.insertBefore(h, b[p ? 3 : 0] || null), u = !0);\n        }\n\n        return u;\n      };\n\n      return f;\n    }();\n\n    f.prototype[\"stroke-widthSetter\"] = f.prototype.strokeSetter;\n    f.prototype.yGetter = f.prototype.xGetter;\n\n    f.prototype.matrixSetter = f.prototype.rotationOriginXSetter = f.prototype.rotationOriginYSetter = f.prototype.rotationSetter = f.prototype.scaleXSetter = f.prototype.scaleYSetter = f.prototype.translateXSetter = f.prototype.translateYSetter = f.prototype.verticalAlignSetter = function (a, b) {\n      this[b] = a;\n      this.doTransform = !0;\n    };\n\n    x.SVGElement = f;\n    return x.SVGElement;\n  });\n  P(k, \"Core/Renderer/SVG/SVGLabel.js\", [k[\"Core/Renderer/SVG/SVGElement.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    function k(f, d) {\n      D(f) ? f !== this[d] && (this[d] = f, this.updateTextPadding()) : this[d] = void 0;\n    }\n\n    var x = this && this.__extends || function () {\n      var f = function (d, g) {\n        f = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (g, c) {\n          g.__proto__ = c;\n        } || function (g, c) {\n          for (var q in c) c.hasOwnProperty(q) && (g[q] = c[q]);\n        };\n\n        return f(d, g);\n      };\n\n      return function (d, g) {\n        function y() {\n          this.constructor = d;\n        }\n\n        f(d, g);\n        d.prototype = null === g ? Object.create(g) : (y.prototype = g.prototype, new y());\n      };\n    }(),\n        B = d.defined,\n        G = d.extend,\n        D = d.isNumber,\n        H = d.merge,\n        t = d.pick,\n        C = d.removeEvent;\n\n    return function (d) {\n      function l(g, f, c, q, n, A, M, z, m, r) {\n        var e = d.call(this) || this;\n        e.paddingSetter = k;\n        e.paddingLeftSetter = k;\n        e.paddingRightSetter = k;\n        e.init(g, \"g\");\n        e.textStr = f;\n        e.x = c;\n        e.y = q;\n        e.anchorX = A;\n        e.anchorY = M;\n        e.baseline = m;\n        e.className = r;\n        \"button\" !== r && e.addClass(\"highcharts-label\");\n        r && e.addClass(\"highcharts-\" + r);\n        e.text = g.text(\"\", 0, 0, z).attr({\n          zIndex: 1\n        });\n\n        if (\"string\" === typeof n) {\n          var h = /^url\\((.*?)\\)$/.test(n);\n          if (e.renderer.symbols[n] || h) e.symbolKey = n;\n        }\n\n        e.bBox = l.emptyBBox;\n        e.padding = 3;\n        e.baselineOffset = 0;\n        e.needsBox = g.styledMode || h;\n        e.deferredAttr = {};\n        e.alignFactor = 0;\n        return e;\n      }\n\n      x(l, d);\n\n      l.prototype.alignSetter = function (g) {\n        g = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[g];\n        g !== this.alignFactor && (this.alignFactor = g, this.bBox && D(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      };\n\n      l.prototype.anchorXSetter = function (g, l) {\n        this.anchorX = g;\n        this.boxAttr(l, Math.round(g) - this.getCrispAdjust() - this.xSetting);\n      };\n\n      l.prototype.anchorYSetter = function (g, l) {\n        this.anchorY = g;\n        this.boxAttr(l, g - this.ySetting);\n      };\n\n      l.prototype.boxAttr = function (g, l) {\n        this.box ? this.box.attr(g, l) : this.deferredAttr[g] = l;\n      };\n\n      l.prototype.css = function (g) {\n        if (g) {\n          var d = {};\n          g = H(g);\n          l.textProps.forEach(function (c) {\n            \"undefined\" !== typeof g[c] && (d[c] = g[c], delete g[c]);\n          });\n          this.text.css(d);\n          var c = (\"width\" in d);\n          \"fontSize\" in d || \"fontWeight\" in d ? this.updateTextPadding() : c && this.updateBoxSize();\n        }\n\n        return f.prototype.css.call(this, g);\n      };\n\n      l.prototype.destroy = function () {\n        C(this.element, \"mouseenter\");\n        C(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        f.prototype.destroy.call(this);\n      };\n\n      l.prototype.fillSetter = function (g, l) {\n        g && (this.needsBox = !0);\n        this.fill = g;\n        this.boxAttr(l, g);\n      };\n\n      l.prototype.getBBox = function () {\n        var g = this.bBox,\n            l = this.padding,\n            c = t(this.paddingLeft, l);\n        return {\n          width: this.width,\n          height: this.height,\n          x: g.x - c,\n          y: g.y - l\n        };\n      };\n\n      l.prototype.getCrispAdjust = function () {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      };\n\n      l.prototype.heightSetter = function (g) {\n        this.heightSetting = g;\n      };\n\n      l.prototype.on = function (g, l) {\n        var c = this,\n            q = c.text,\n            n = q && \"SPAN\" === q.element.tagName ? q : void 0;\n\n        if (n) {\n          var d = function (q) {\n            (\"mouseenter\" === g || \"mouseleave\" === g) && q.relatedTarget instanceof Element && (c.element.compareDocumentPosition(q.relatedTarget) & Node.DOCUMENT_POSITION_CONTAINED_BY || n.element.compareDocumentPosition(q.relatedTarget) & Node.DOCUMENT_POSITION_CONTAINED_BY) || l.call(c.element, q);\n          };\n\n          n.on(g, d);\n        }\n\n        f.prototype.on.call(c, g, d || l);\n        return c;\n      };\n\n      l.prototype.onAdd = function () {\n        var g = this.textStr;\n        this.text.add(this);\n        this.attr({\n          text: B(g) ? g : \"\",\n          x: this.x,\n          y: this.y\n        });\n        this.box && B(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      };\n\n      l.prototype.rSetter = function (g, l) {\n        this.boxAttr(l, g);\n      };\n\n      l.prototype.shadow = function (g) {\n        g && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(g));\n        return this;\n      };\n\n      l.prototype.strokeSetter = function (g, l) {\n        this.stroke = g;\n        this.boxAttr(l, g);\n      };\n\n      l.prototype[\"stroke-widthSetter\"] = function (g, l) {\n        g && (this.needsBox = !0);\n        this[\"stroke-width\"] = g;\n        this.boxAttr(l, g);\n      };\n\n      l.prototype[\"text-alignSetter\"] = function (g) {\n        this.textAlign = g;\n      };\n\n      l.prototype.textSetter = function (g) {\n        \"undefined\" !== typeof g && this.text.attr({\n          text: g\n        });\n        this.updateTextPadding();\n      };\n\n      l.prototype.updateBoxSize = function () {\n        var g = this.text.element.style,\n            d = {},\n            c = this.padding,\n            q = this.bBox = D(this.widthSetting) && D(this.heightSetting) && !this.textAlign || !B(this.text.textStr) ? l.emptyBBox : this.text.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || q.height || 0) + 2 * c;\n        this.baselineOffset = c + Math.min(this.renderer.fontMetrics(g && g.fontSize, this.text).b, q.height || Infinity);\n        this.needsBox && (this.box || (g = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), g.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), g.add(this)), g = this.getCrispAdjust(), d.x = g, d.y = (this.baseline ? -this.baselineOffset : 0) + g, d.width = Math.round(this.width), d.height = Math.round(this.height), this.box.attr(G(d, this.deferredAttr)), this.deferredAttr = {});\n      };\n\n      l.prototype.updateTextPadding = function () {\n        var g = this.text;\n        this.updateBoxSize();\n        var l = this.baseline ? 0 : this.baselineOffset,\n            c = t(this.paddingLeft, this.padding);\n        B(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (c += {\n          center: .5,\n          right: 1\n        }[this.textAlign] * (this.widthSetting - this.bBox.width));\n        if (c !== g.x || l !== g.y) g.attr(\"x\", c), g.hasBoxWidthChanged && (this.bBox = g.getBBox(!0)), \"undefined\" !== typeof l && g.attr(\"y\", l);\n        g.x = c;\n        g.y = l;\n      };\n\n      l.prototype.widthSetter = function (g) {\n        this.widthSetting = D(g) ? g : void 0;\n      };\n\n      l.prototype.getPaddedWidth = function () {\n        var g = this.padding,\n            l = t(this.paddingLeft, g);\n        g = t(this.paddingRight, g);\n        return (this.widthSetting || this.bBox.width || 0) + l + g;\n      };\n\n      l.prototype.xSetter = function (g) {\n        this.x = g;\n        this.alignFactor && (g -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(g);\n        this.attr(\"translateX\", this.xSetting);\n      };\n\n      l.prototype.ySetter = function (g) {\n        this.ySetting = this.y = Math.round(g);\n        this.attr(\"translateY\", this.ySetting);\n      };\n\n      l.emptyBBox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      l.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width\".split(\" \");\n      return l;\n    }(f);\n  });\n  P(k, \"Core/Renderer/SVG/TextBuilder.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"], k[\"Core/Renderer/HTML/AST.js\"]], function (f, d, k) {\n    var x = f.doc,\n        B = f.SVG_NS,\n        S = d.attr,\n        D = d.isString,\n        H = d.objectEach,\n        t = d.pick;\n    return function () {\n      function d(l) {\n        var d = l.styles;\n        this.renderer = l.renderer;\n        this.svgElement = l;\n        this.width = l.textWidth;\n        this.textLineHeight = d && d.lineHeight;\n        this.textOutline = d && d.textOutline;\n        this.ellipsis = !(!d || \"ellipsis\" !== d.textOverflow);\n        this.noWrap = !(!d || \"nowrap\" !== d.whiteSpace);\n        this.fontSize = d && d.fontSize;\n      }\n\n      d.prototype.buildSVG = function () {\n        var l = this.svgElement,\n            d = l.element,\n            g = l.renderer,\n            f = t(l.textStr, \"\").toString(),\n            c = -1 !== f.indexOf(\"<\"),\n            q = d.childNodes,\n            n = q.length;\n        g = this.width && !l.added && g.box;\n        var A = /<br.*?>/g;\n        var M = [f, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();\n\n        if (M !== l.textCache) {\n          l.textCache = M;\n\n          for (delete l.actualWidth; n--;) d.removeChild(q[n]);\n\n          c || this.ellipsis || this.width || -1 !== f.indexOf(\" \") && (!this.noWrap || A.test(f)) ? \"\" !== f && (g && g.appendChild(d), f = new k(f), this.modifyTree(f.nodes), f.addToDOM(l.element), this.modifyDOM(), this.ellipsis && -1 !== (d.textContent || \"\").indexOf(\"\\u2026\") && l.attr(\"title\", this.unescapeEntities(l.textStr || \"\", [\"&lt;\", \"&gt;\"])), g && g.removeChild(d)) : d.appendChild(x.createTextNode(this.unescapeEntities(f)));\n          D(this.textOutline) && l.applyTextOutline && l.applyTextOutline(this.textOutline);\n        }\n      };\n\n      d.prototype.modifyDOM = function () {\n        var d = this,\n            f = this.svgElement,\n            g = S(f.element, \"x\");\n        [].forEach.call(f.element.querySelectorAll(\"tspan.highcharts-br\"), function (c) {\n          c.nextSibling && c.previousSibling && S(c, {\n            dy: d.getLineHeight(c.nextSibling),\n            x: g\n          });\n        });\n        var y = this.width || 0;\n\n        if (y) {\n          var c = function (c, q) {\n            var n = c.textContent || \"\",\n                l = n.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                m = !d.noWrap && (1 < l.length || 1 < f.element.childNodes.length),\n                r = d.getLineHeight(q),\n                e = 0,\n                h = f.actualWidth;\n            if (d.ellipsis) n && d.truncate(c, n, void 0, 0, Math.max(0, y - parseInt(d.fontSize || 12, 10)), function (a, b) {\n              return a.substring(0, b) + \"\\u2026\";\n            });else if (m) {\n              n = [];\n\n              for (m = []; q.firstChild && q.firstChild !== c;) m.push(q.firstChild), q.removeChild(q.firstChild);\n\n              for (; l.length;) l.length && !d.noWrap && 0 < e && (n.push(c.textContent || \"\"), c.textContent = l.join(\" \").replace(/- /g, \"-\")), d.truncate(c, void 0, l, 0 === e ? h || 0 : 0, y, function (a, b) {\n                return l.slice(0, b).join(\" \").replace(/- /g, \"-\");\n              }), h = f.actualWidth, e++;\n\n              m.forEach(function (a) {\n                q.insertBefore(a, c);\n              });\n              n.forEach(function (a) {\n                q.insertBefore(x.createTextNode(a), c);\n                a = x.createElementNS(B, \"tspan\");\n                a.textContent = \"\\u200b\";\n                S(a, {\n                  dy: r,\n                  x: g\n                });\n                q.insertBefore(a, c);\n              });\n            }\n          },\n              q = function (g) {\n            [].slice.call(g.childNodes).forEach(function (n) {\n              n.nodeType === Node.TEXT_NODE ? c(n, g) : (-1 !== n.className.baseVal.indexOf(\"highcharts-br\") && (f.actualWidth = 0), q(n));\n            });\n          };\n\n          q(f.element);\n        }\n      };\n\n      d.prototype.getLineHeight = function (d) {\n        var l;\n        d = d.nodeType === Node.TEXT_NODE ? d.parentElement : d;\n        this.renderer.styledMode || (l = d && /(px|em)$/.test(d.style.fontSize) ? d.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(l, d || this.svgElement.element).h;\n      };\n\n      d.prototype.modifyTree = function (d) {\n        var l = this,\n            g = function (f, c) {\n          var q = f.tagName,\n              n = l.renderer.styledMode,\n              A = f.attributes || {};\n          if (\"b\" === q || \"strong\" === q) n ? A[\"class\"] = \"highcharts-strong\" : A.style = \"font-weight:bold;\" + (A.style || \"\");else if (\"i\" === q || \"em\" === q) n ? A[\"class\"] = \"highcharts-emphasized\" : A.style = \"font-style:italic;\" + (A.style || \"\");\n          D(A.style) && (A.style = A.style.replace(/(;| |^)color([ :])/, \"$1fill$2\"));\n          \"br\" === q && (A[\"class\"] = \"highcharts-br\", f.textContent = \"\\u200b\", (c = d[c + 1]) && c.textContent && (c.textContent = c.textContent.replace(/^ +/gm, \"\")));\n          \"#text\" !== q && \"a\" !== q && (f.tagName = \"tspan\");\n          f.attributes = A;\n          f.children && f.children.filter(function (c) {\n            return \"#text\" !== c.tagName;\n          }).forEach(g);\n        };\n\n        for (d.forEach(g); d[0] && \"tspan\" === d[0].tagName && !d[0].children;) d.splice(0, 1);\n      };\n\n      d.prototype.truncate = function (d, f, g, y, c, q) {\n        var n = this.svgElement,\n            l = n.renderer,\n            M = n.rotation,\n            z = [],\n            m = g ? 1 : 0,\n            r = (f || g || \"\").length,\n            e = r,\n            h,\n            a = function (a, b) {\n          b = b || a;\n          var e = d.parentNode;\n          if (e && \"undefined\" === typeof z[b]) if (e.getSubStringLength) try {\n            z[b] = y + e.getSubStringLength(0, g ? b + 1 : b);\n          } catch (F) {\n            \"\";\n          } else l.getSpanWidth && (d.textContent = q(f || g, a), z[b] = y + l.getSpanWidth(n, d));\n          return z[b];\n        };\n\n        n.rotation = 0;\n        var b = a(d.textContent.length);\n\n        if (y + b > c) {\n          for (; m <= r;) e = Math.ceil((m + r) / 2), g && (h = q(g, e)), b = a(e, h && h.length - 1), m === r ? m = r + 1 : b > c ? r = e - 1 : m = e;\n\n          0 === r ? d.textContent = \"\" : f && r === f.length - 1 || (d.textContent = h || q(f || g, e));\n        }\n\n        g && g.splice(0, e);\n        n.actualWidth = b;\n        n.rotation = M;\n      };\n\n      d.prototype.unescapeEntities = function (d, f) {\n        H(this.renderer.escapes, function (g, l) {\n          f && -1 !== f.indexOf(g) || (d = d.toString().replace(new RegExp(g, \"g\"), l));\n        });\n        return d;\n      };\n\n      return d;\n    }();\n  });\n  P(k, \"Core/Renderer/SVG/SVGRenderer.js\", [k[\"Core/Color/Color.js\"], k[\"Core/Globals.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Renderer/SVG/SVGElement.js\"], k[\"Core/Renderer/SVG/SVGLabel.js\"], k[\"Core/Renderer/HTML/AST.js\"], k[\"Core/Renderer/SVG/TextBuilder.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G, D, H) {\n    var t = H.addEvent,\n        C = H.attr,\n        l = H.createElement,\n        E = H.css,\n        g = H.defined,\n        y = H.destroyObjectProperties,\n        c = H.extend,\n        q = H.isArray,\n        n = H.isNumber,\n        A = H.isObject,\n        M = H.isString,\n        z = H.merge,\n        m = H.pick,\n        r = H.pInt,\n        e = H.uniqueKey,\n        h = d.charts,\n        a = d.deg2rad,\n        b = d.doc,\n        w = d.isFirefox,\n        J = d.isMS,\n        O = d.isWebKit;\n    H = d.noop;\n\n    var F = d.SVG_NS,\n        N = d.symbolSizes,\n        R = d.win,\n        Q,\n        T = function () {\n      function d(a, b, e, c, h, u, g) {\n        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(a, b, e, c, h, u, g);\n      }\n\n      d.prototype.init = function (a, p, e, c, h, u, g) {\n        var K = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        });\n        g || K.css(this.getStyle(c));\n        c = K.element;\n        a.appendChild(c);\n        C(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && C(c, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = c;\n        this.boxWrapper = K;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(b.createTextNode(\"Created with Highcharts 9.0.1\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = u;\n        this.forExport = h;\n        this.styledMode = g;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(p, e, !1);\n        var m;\n        w && a.getBoundingClientRect && (p = function () {\n          E(a, {\n            left: 0,\n            top: 0\n          });\n          m = a.getBoundingClientRect();\n          E(a, {\n            left: Math.ceil(m.left) - m.left + \"px\",\n            top: Math.ceil(m.top) - m.top + \"px\"\n          });\n        }, p(), this.unSubPixelFix = t(R, \"resize\", p));\n      };\n\n      d.prototype.definition = function (a) {\n        return new G([a]).addToDOM(this.defs.element);\n      };\n\n      d.prototype.getReferenceURL = function () {\n        if ((w || O) && b.getElementsByTagName(\"base\").length) {\n          if (!g(Q)) {\n            var a = e();\n            a = new G([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: a\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": \"url(#\" + a + \")\",\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(b.body);\n            E(a, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            var p = b.elementFromPoint(6, 6);\n            Q = \"hitme\" === (p && p.id);\n            b.body.removeChild(a);\n          }\n\n          if (Q) return R.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n\n        return \"\";\n      };\n\n      d.prototype.getStyle = function (a) {\n        return this.style = c({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      };\n\n      d.prototype.setStyle = function (a) {\n        this.boxWrapper.css(this.getStyle(a));\n      };\n\n      d.prototype.isHidden = function () {\n        return !this.boxWrapper.getBBox().width;\n      };\n\n      d.prototype.destroy = function () {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        y(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      };\n\n      d.prototype.createElement = function (a) {\n        var b = new this.Element();\n        b.init(this, a);\n        return b;\n      };\n\n      d.prototype.getRadialAttr = function (a, b) {\n        return {\n          cx: a[0] - a[2] / 2 + b.cx * a[2],\n          cy: a[1] - a[2] / 2 + b.cy * a[2],\n          r: b.r * a[2]\n        };\n      };\n\n      d.prototype.buildText = function (a) {\n        new D(a).buildSVG();\n      };\n\n      d.prototype.getContrast = function (a) {\n        a = f.parse(a).rgba;\n        a[0] *= 1;\n        a[1] *= 1.2;\n        a[2] *= .5;\n        return 459 < a[0] + a[1] + a[2] ? \"#000000\" : \"#FFFFFF\";\n      };\n\n      d.prototype.button = function (a, b, e, h, g, u, m, I, w, d) {\n        var p = this.label(a, b, e, w, void 0, void 0, d, void 0, \"button\"),\n            K = 0,\n            n = this.styledMode,\n            q = g ? z(g) : {};\n        a = q && q.style || {};\n        q = G.filterUserAttributes(q);\n        p.attr(z({\n          padding: 8,\n          r: 2\n        }, q));\n\n        if (!n) {\n          q = z({\n            fill: k.neutralColor3,\n            stroke: k.neutralColor20,\n            \"stroke-width\": 1,\n            style: {\n              color: k.neutralColor80,\n              cursor: \"pointer\",\n              fontWeight: \"normal\"\n            }\n          }, {\n            style: a\n          }, q);\n          var r = q.style;\n          delete q.style;\n          u = z(q, {\n            fill: k.neutralColor10\n          }, G.filterUserAttributes(u || {}));\n          var aa = u.style;\n          delete u.style;\n          m = z(q, {\n            fill: k.highlightColor10,\n            style: {\n              color: k.neutralColor100,\n              fontWeight: \"bold\"\n            }\n          }, G.filterUserAttributes(m || {}));\n          var f = m.style;\n          delete m.style;\n          I = z(q, {\n            style: {\n              color: k.neutralColor20\n            }\n          }, G.filterUserAttributes(I || {}));\n          var v = I.style;\n          delete I.style;\n        }\n\n        t(p.element, J ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== K && p.setState(1);\n        });\n        t(p.element, J ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== K && p.setState(K);\n        });\n\n        p.setState = function (a) {\n          1 !== a && (p.state = K = a);\n          p.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          n || p.attr([q, u, m, I][a || 0]).css([r, aa, f, v][a || 0]);\n        };\n\n        n || p.attr(q).css(c({\n          cursor: \"default\"\n        }, r));\n        return p.on(\"click\", function (a) {\n          3 !== K && h.call(p, a);\n        });\n      };\n\n      d.prototype.crispLine = function (a, b, e) {\n        void 0 === e && (e = \"round\");\n        var p = a[0],\n            c = a[1];\n        p[1] === c[1] && (p[1] = c[1] = Math[e](p[1]) - b % 2 / 2);\n        p[2] === c[2] && (p[2] = c[2] = Math[e](p[2]) + b % 2 / 2);\n        return a;\n      };\n\n      d.prototype.path = function (a) {\n        var b = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        q(a) ? b.d = a : A(a) && c(b, a);\n        return this.createElement(\"path\").attr(b);\n      };\n\n      d.prototype.circle = function (a, b, e) {\n        a = A(a) ? a : \"undefined\" === typeof a ? {} : {\n          x: a,\n          y: b,\n          r: e\n        };\n        b = this.createElement(\"circle\");\n\n        b.xSetter = b.ySetter = function (a, b, p) {\n          p.setAttribute(\"c\" + b, a);\n        };\n\n        return b.attr(a);\n      };\n\n      d.prototype.arc = function (a, b, e, c, h, u) {\n        A(a) ? (c = a, b = c.y, e = c.r, a = c.x) : c = {\n          innerR: c,\n          start: h,\n          end: u\n        };\n        a = this.symbol(\"arc\", a, b, e, e, c);\n        a.r = e;\n        return a;\n      };\n\n      d.prototype.rect = function (a, b, e, c, h, u) {\n        h = A(a) ? a.r : h;\n        var p = this.createElement(\"rect\");\n        a = A(a) ? a : \"undefined\" === typeof a ? {} : {\n          x: a,\n          y: b,\n          width: Math.max(e, 0),\n          height: Math.max(c, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof u && (a.strokeWidth = u, a = p.crisp(a)), a.fill = \"none\");\n        h && (a.r = h);\n\n        p.rSetter = function (a, b, e) {\n          p.r = a;\n          C(e, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        p.rGetter = function () {\n          return p.r;\n        };\n\n        return p.attr(a);\n      };\n\n      d.prototype.setSize = function (a, b, e) {\n        var p = this.alignedObjects,\n            c = p.length;\n        this.width = a;\n        this.height = b;\n\n        for (this.boxWrapper.animate({\n          width: a,\n          height: b\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: m(e, !0) ? void 0 : 0\n        }); c--;) p[c].align();\n      };\n\n      d.prototype.g = function (a) {\n        var b = this.createElement(\"g\");\n        return a ? b.attr({\n          \"class\": \"highcharts-\" + a\n        }) : b;\n      };\n\n      d.prototype.image = function (a, b, e, h, g, u) {\n        var p = {\n          preserveAspectRatio: \"none\"\n        },\n            K = function (a, b) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", b) : a.setAttribute(\"hc-svg-href\", b);\n        },\n            m = function (b) {\n          K(w.element, a);\n          u.call(w, b);\n        };\n\n        1 < arguments.length && c(p, {\n          x: b,\n          y: e,\n          width: h,\n          height: g\n        });\n        var w = this.createElement(\"image\").attr(p);\n        u ? (K(w.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), p = new R.Image(), t(p, \"load\", m), p.src = a, p.complete && m({})) : K(w.element, a);\n        return w;\n      };\n\n      d.prototype.symbol = function (a, p, e, w, d, u) {\n        var K = this,\n            I = /^url\\((.*?)\\)$/,\n            q = I.test(a),\n            n = !q && (this.symbols[a] ? a : \"circle\"),\n            r = n && this.symbols[n],\n            J;\n\n        if (r) {\n          \"number\" === typeof p && (J = r.call(this.symbols, Math.round(p || 0), Math.round(e || 0), w || 0, d || 0, u));\n          var f = this.path(J);\n          K.styledMode || f.attr(\"fill\", \"none\");\n          c(f, {\n            symbolName: n,\n            x: p,\n            y: e,\n            width: w,\n            height: d\n          });\n          u && c(f, u);\n        } else if (q) {\n          var v = a.match(I)[1];\n          f = this.image(v);\n          f.imgwidth = m(N[v] && N[v].width, u && u.width);\n          f.imgheight = m(N[v] && N[v].height, u && u.height);\n\n          var F = function () {\n            f.attr({\n              width: f.width,\n              height: f.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (a) {\n            f[a + \"Setter\"] = function (a, b) {\n              var p = {},\n                  e = this[\"img\" + b],\n                  c = \"width\" === b ? \"translateX\" : \"translateY\";\n              this[b] = a;\n              g(e) && (u && \"within\" === u.backgroundSize && this.width && this.height && (e = Math.round(e * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(b, e), this.alignByTranslate || (p[c] = ((this[b] || 0) - e) / 2, this.attr(p)));\n            };\n          });\n          g(p) && f.attr({\n            x: p,\n            y: e\n          });\n          f.isImg = !0;\n          g(f.imgwidth) && g(f.imgheight) ? F() : (f.attr({\n            width: 0,\n            height: 0\n          }), l(\"img\", {\n            onload: function () {\n              var a = h[K.chartIndex];\n              0 === this.width && (E(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), b.body.appendChild(this));\n              N[v] = {\n                width: this.width,\n                height: this.height\n              };\n              f.imgwidth = this.width;\n              f.imgheight = this.height;\n              f.element && F();\n              this.parentNode && this.parentNode.removeChild(this);\n              K.imgCount--;\n              if (!K.imgCount && a && !a.hasLoaded) a.onload();\n            },\n            src: v\n          }), this.imgCount++);\n        }\n\n        return f;\n      };\n\n      d.prototype.clipRect = function (a, b, c, h) {\n        var p = e() + \"-\",\n            u = this.createElement(\"clipPath\").attr({\n          id: p\n        }).add(this.defs);\n        a = this.rect(a, b, c, h, 0).add(u);\n        a.id = p;\n        a.clipPath = u;\n        a.count = 0;\n        return a;\n      };\n\n      d.prototype.text = function (a, b, e, c) {\n        var p = {};\n        if (c && (this.allowHTML || !this.forExport)) return this.html(a, b, e);\n        p.x = Math.round(b || 0);\n        e && (p.y = Math.round(e));\n        g(a) && (p.text = a);\n        a = this.createElement(\"text\").attr(p);\n        c || (a.xSetter = function (a, b, p) {\n          var e = p.getElementsByTagName(\"tspan\"),\n              u = p.getAttribute(b),\n              c;\n\n          for (c = 0; c < e.length; c++) {\n            var h = e[c];\n            h.getAttribute(b) === u && h.setAttribute(b, a);\n          }\n\n          p.setAttribute(b, a);\n        });\n        return a;\n      };\n\n      d.prototype.fontMetrics = function (a, b) {\n        a = !this.styledMode && /px/.test(a) || !R.getComputedStyle ? a || b && b.style && b.style.fontSize || this.style && this.style.fontSize : b && x.prototype.getStyle.call(b, \"font-size\");\n        a = /px/.test(a) ? r(a) : 12;\n        b = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: b,\n          b: Math.round(.8 * b),\n          f: a\n        };\n      };\n\n      d.prototype.rotCorr = function (b, p, e) {\n        var c = b;\n        p && e && (c = Math.max(c * Math.cos(p * a), 4));\n        return {\n          x: -b / 3 * Math.sin(p * a),\n          y: c\n        };\n      };\n\n      d.prototype.pathToSegments = function (a) {\n        for (var b = [], e = [], c = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        }, h = 0; h < a.length; h++) M(e[0]) && n(a[h]) && e.length === c[e[0].toUpperCase()] && a.splice(h, 0, e[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof a[h] && (e.length && b.push(e.slice(0)), e.length = 0), e.push(a[h]);\n\n        b.push(e.slice(0));\n        return b;\n      };\n\n      d.prototype.label = function (a, b, e, c, h, u, g, m, w) {\n        return new B(this, a, b, e, c, h, u, g, m, w);\n      };\n\n      return d;\n    }();\n\n    T.prototype.Element = x;\n    T.prototype.SVG_NS = F;\n    T.prototype.draw = H;\n    T.prototype.escapes = {\n      \"&\": \"&amp;\",\n      \"<\": \"&lt;\",\n      \">\": \"&gt;\",\n      \"'\": \"&#39;\",\n      '\"': \"&quot;\"\n    };\n    T.prototype.symbols = {\n      circle: function (a, b, e, c) {\n        return this.arc(a + e / 2, b + c / 2, e / 2, c / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      square: function (a, b, e, c) {\n        return [[\"M\", a, b], [\"L\", a + e, b], [\"L\", a + e, b + c], [\"L\", a, b + c], [\"Z\"]];\n      },\n      triangle: function (a, b, e, c) {\n        return [[\"M\", a + e / 2, b], [\"L\", a + e, b + c], [\"L\", a, b + c], [\"Z\"]];\n      },\n      \"triangle-down\": function (a, b, e, c) {\n        return [[\"M\", a, b], [\"L\", a + e, b], [\"L\", a + e / 2, b + c], [\"Z\"]];\n      },\n      diamond: function (a, b, e, c) {\n        return [[\"M\", a + e / 2, b], [\"L\", a + e, b + c / 2], [\"L\", a + e / 2, b + c], [\"L\", a, b + c / 2], [\"Z\"]];\n      },\n      arc: function (a, b, e, c, h) {\n        var p = [];\n\n        if (h) {\n          var u = h.start || 0,\n              K = h.end || 0,\n              I = h.r || e;\n          e = h.r || c || e;\n          var w = .001 > Math.abs(K - u - 2 * Math.PI);\n          K -= .001;\n          c = h.innerR;\n          w = m(h.open, w);\n          var d = Math.cos(u),\n              n = Math.sin(u),\n              q = Math.cos(K),\n              r = Math.sin(K);\n          u = m(h.longArc, .001 > K - u - Math.PI ? 0 : 1);\n          p.push([\"M\", a + I * d, b + e * n], [\"A\", I, e, 0, u, m(h.clockwise, 1), a + I * q, b + e * r]);\n          g(c) && p.push(w ? [\"M\", a + c * q, b + c * r] : [\"L\", a + c * q, b + c * r], [\"A\", c, c, 0, u, g(h.clockwise) ? 1 - h.clockwise : 0, a + c * d, b + c * n]);\n          w || p.push([\"Z\"]);\n        }\n\n        return p;\n      },\n      callout: function (a, b, e, c, h) {\n        var p = Math.min(h && h.r || 0, e, c),\n            u = p + 6,\n            g = h && h.anchorX;\n        h = h && h.anchorY || 0;\n        var m = [[\"M\", a + p, b], [\"L\", a + e - p, b], [\"C\", a + e, b, a + e, b, a + e, b + p], [\"L\", a + e, b + c - p], [\"C\", a + e, b + c, a + e, b + c, a + e - p, b + c], [\"L\", a + p, b + c], [\"C\", a, b + c, a, b + c, a, b + c - p], [\"L\", a, b + p], [\"C\", a, b, a, b, a + p, b]];\n        if (!n(g)) return m;\n        a + g >= e ? h > b + u && h < b + c - u ? m.splice(3, 1, [\"L\", a + e, h - 6], [\"L\", a + e + 6, h], [\"L\", a + e, h + 6], [\"L\", a + e, b + c - p]) : m.splice(3, 1, [\"L\", a + e, c / 2], [\"L\", g, h], [\"L\", a + e, c / 2], [\"L\", a + e, b + c - p]) : 0 >= a + g ? h > b + u && h < b + c - u ? m.splice(7, 1, [\"L\", a, h + 6], [\"L\", a - 6, h], [\"L\", a, h - 6], [\"L\", a, b + p]) : m.splice(7, 1, [\"L\", a, c / 2], [\"L\", g, h], [\"L\", a, c / 2], [\"L\", a, b + p]) : h && h > c && g > a + u && g < a + e - u ? m.splice(5, 1, [\"L\", g + 6, b + c], [\"L\", g, b + c + 6], [\"L\", g - 6, b + c], [\"L\", a + p, b + c]) : h && 0 > h && g > a + u && g < a + e - u && m.splice(1, 1, [\"L\", g - 6, b], [\"L\", g, b - 6], [\"L\", g + 6, b], [\"L\", e - p, b]);\n        return m;\n      }\n    };\n    d.SVGRenderer = T;\n    d.Renderer = d.SVGRenderer;\n    return d.Renderer;\n  });\n  P(k, \"Core/Renderer/HTML/HTMLElement.js\", [k[\"Core/Globals.js\"], k[\"Core/Renderer/SVG/SVGElement.js\"], k[\"Core/Utilities.js\"]], function (f, d, k) {\n    var x = k.css,\n        B = k.defined,\n        S = k.extend,\n        D = k.pick,\n        H = k.pInt,\n        t = f.isFirefox;\n    S(d.prototype, {\n      htmlCss: function (d) {\n        var f = \"SPAN\" === this.element.tagName && d && \"width\" in d,\n            t = D(f && d.width, void 0);\n\n        if (f) {\n          delete d.width;\n          this.textWidth = t;\n          var g = !0;\n        }\n\n        d && \"ellipsis\" === d.textOverflow && (d.whiteSpace = \"nowrap\", d.overflow = \"hidden\");\n        this.styles = S(this.styles, d);\n        x(this.element, d);\n        g && this.htmlUpdateTransform();\n        return this;\n      },\n      htmlGetBBox: function () {\n        var d = this.element;\n        return {\n          x: d.offsetLeft,\n          y: d.offsetTop,\n          width: d.offsetWidth,\n          height: d.offsetHeight\n        };\n      },\n      htmlUpdateTransform: function () {\n        if (this.added) {\n          var d = this.renderer,\n              f = this.element,\n              t = this.translateX || 0,\n              g = this.translateY || 0,\n              y = this.x || 0,\n              c = this.y || 0,\n              q = this.textAlign || \"left\",\n              n = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[q],\n              A = this.styles,\n              M = A && A.whiteSpace;\n          x(f, {\n            marginLeft: t,\n            marginTop: g\n          });\n          !d.styledMode && this.shadows && this.shadows.forEach(function (e) {\n            x(e, {\n              marginLeft: t + 1,\n              marginTop: g + 1\n            });\n          });\n          this.inverted && [].forEach.call(f.childNodes, function (e) {\n            d.invertChild(e, f);\n          });\n\n          if (\"SPAN\" === f.tagName) {\n            A = this.rotation;\n            var z = this.textWidth && H(this.textWidth),\n                m = [A, q, f.innerHTML, this.textWidth, this.textAlign].join(),\n                r;\n            (r = z !== this.oldTextWidth) && !(r = z > this.oldTextWidth) && ((r = this.textPxLength) || (x(f, {\n              width: \"\",\n              whiteSpace: M || \"nowrap\"\n            }), r = f.offsetWidth), r = r > z);\n            r && (/[ \\-]/.test(f.textContent || f.innerText) || \"ellipsis\" === f.style.textOverflow) ? (x(f, {\n              width: z + \"px\",\n              display: \"block\",\n              whiteSpace: M || \"normal\"\n            }), this.oldTextWidth = z, this.hasBoxWidthChanged = !0) : this.hasBoxWidthChanged = !1;\n            m !== this.cTT && (M = d.fontMetrics(f.style.fontSize, f).b, !B(A) || A === (this.oldRotation || 0) && q === this.oldAlign || this.setSpanRotation(A, n, M), this.getSpanCorrection(!B(A) && this.textPxLength || f.offsetWidth, M, n, A, q));\n            x(f, {\n              left: y + (this.xCorr || 0) + \"px\",\n              top: c + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = m;\n            this.oldRotation = A;\n            this.oldAlign = q;\n          }\n        } else this.alignOnAdd = !0;\n      },\n      setSpanRotation: function (d, f, k) {\n        var g = {},\n            l = this.renderer.getTransformKey();\n        g[l] = g.transform = \"rotate(\" + d + \"deg)\";\n        g[l + (t ? \"Origin\" : \"-origin\")] = g.transformOrigin = 100 * f + \"% \" + k + \"px\";\n        x(this.element, g);\n      },\n      getSpanCorrection: function (d, f, t) {\n        this.xCorr = -d * t;\n        this.yCorr = -f;\n      }\n    });\n    return d;\n  });\n  P(k, \"Core/Renderer/HTML/HTMLRenderer.js\", [k[\"Core/Globals.js\"], k[\"Core/Renderer/HTML/AST.js\"], k[\"Core/Renderer/SVG/SVGElement.js\"], k[\"Core/Renderer/SVG/SVGRenderer.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B) {\n    var S = f.isFirefox,\n        D = f.isMS,\n        H = f.isWebKit,\n        t = f.win,\n        C = B.attr,\n        l = B.createElement,\n        E = B.extend,\n        g = B.pick;\n    E(x.prototype, {\n      getTransformKey: function () {\n        return D && !/Edge/.test(t.navigator.userAgent) ? \"-ms-transform\" : H ? \"-webkit-transform\" : S ? \"MozTransform\" : t.opera ? \"-o-transform\" : \"\";\n      },\n      html: function (f, c, q) {\n        var n = this.createElement(\"span\"),\n            A = n.element,\n            M = n.renderer,\n            z = M.isSVG,\n            m = function (c, e) {\n          [\"opacity\", \"visibility\"].forEach(function (h) {\n            c[h + \"Setter\"] = function (a, b, g) {\n              var m = c.div ? c.div.style : e;\n              k.prototype[h + \"Setter\"].call(this, a, b, g);\n              m && (m[b] = a);\n            };\n          });\n          c.addedSetters = !0;\n        };\n\n        n.textSetter = function (c) {\n          c !== this.textStr && (delete this.bBox, delete this.oldTextWidth, d.setElementHTML(this.element, g(c, \"\")), this.textStr = c, n.doTransform = !0);\n        };\n\n        z && m(n, n.element.style);\n\n        n.xSetter = n.ySetter = n.alignSetter = n.rotationSetter = function (c, e) {\n          \"align\" === e ? n.alignValue = n.textAlign = c : n[e] = c;\n          n.doTransform = !0;\n        };\n\n        n.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        n.attr({\n          text: f,\n          x: Math.round(c),\n          y: Math.round(q)\n        }).css({\n          position: \"absolute\"\n        });\n        M.styledMode || n.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        A.style.whiteSpace = \"nowrap\";\n        n.css = n.htmlCss;\n        z && (n.add = function (c) {\n          var e = M.box.parentNode,\n              h = [];\n\n          if (this.parentGroup = c) {\n            var a = c.div;\n\n            if (!a) {\n              for (; c;) h.push(c), c = c.parentGroup;\n\n              h.reverse().forEach(function (b) {\n                function c(a, e) {\n                  b[e] = a;\n                  \"translateX\" === e ? q.left = a + \"px\" : q.top = a + \"px\";\n                  b.doTransform = !0;\n                }\n\n                var g = C(b.element, \"class\"),\n                    d = b.styles || {};\n                a = b.div = b.div || l(\"div\", g ? {\n                  className: g\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (b.translateX || 0) + \"px\",\n                  top: (b.translateY || 0) + \"px\",\n                  display: b.display,\n                  opacity: b.opacity,\n                  cursor: d.cursor,\n                  pointerEvents: d.pointerEvents\n                }, a || e);\n                var q = a.style;\n                E(b, {\n                  classSetter: function (a) {\n                    return function (b) {\n                      this.element.setAttribute(\"class\", b);\n                      a.className = b;\n                    };\n                  }(a),\n                  on: function () {\n                    h[0].div && n.on.apply({\n                      element: h[0].div\n                    }, arguments);\n                    return b;\n                  },\n                  translateXSetter: c,\n                  translateYSetter: c\n                });\n                b.addedSetters || m(b);\n              });\n            }\n          } else a = e;\n\n          a.appendChild(A);\n          n.added = !0;\n          n.alignOnAdd && n.htmlUpdateTransform();\n          return n;\n        });\n        return n;\n      }\n    });\n    return x;\n  });\n  P(k, \"Core/Time.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = f.win,\n        x = d.defined,\n        B = d.error,\n        G = d.extend,\n        D = d.isObject,\n        H = d.merge,\n        t = d.objectEach,\n        C = d.pad,\n        l = d.pick,\n        E = d.splat,\n        g = d.timeUnits;\n    \"\";\n\n    d = function () {\n      function d(c) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = k.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(c);\n      }\n\n      d.prototype.get = function (c, g) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var d = g.getTime(),\n              q = d - this.getTimezoneOffset(g);\n          g.setTime(q);\n          c = g[\"getUTC\" + c]();\n          g.setTime(d);\n          return c;\n        }\n\n        return this.useUTC ? g[\"getUTC\" + c]() : g[\"get\" + c]();\n      };\n\n      d.prototype.set = function (c, g, d) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === c || \"Seconds\" === c || \"Minutes\" === c && 0 === this.getTimezoneOffset(g) % 36E5) return g[\"setUTC\" + c](d);\n          var n = this.getTimezoneOffset(g);\n          n = g.getTime() - n;\n          g.setTime(n);\n          g[\"setUTC\" + c](d);\n          c = this.getTimezoneOffset(g);\n          n = g.getTime() + c;\n          return g.setTime(n);\n        }\n\n        return this.useUTC ? g[\"setUTC\" + c](d) : g[\"set\" + c](d);\n      };\n\n      d.prototype.update = function (c) {\n        var g = l(c && c.useUTC, !0);\n        this.options = c = H(!0, this.options || {}, c);\n        this.Date = c.Date || k.Date || Date;\n        this.timezoneOffset = (this.useUTC = g) && c.timezoneOffset;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = g && !(!c.getTimezoneOffset && !c.timezone);\n      };\n\n      d.prototype.makeTime = function (c, g, d, A, M, z) {\n        if (this.useUTC) {\n          var m = this.Date.UTC.apply(0, arguments);\n          var n = this.getTimezoneOffset(m);\n          m += n;\n          var e = this.getTimezoneOffset(m);\n          n !== e ? m += e - n : n - 36E5 !== this.getTimezoneOffset(m - 36E5) || f.isSafari || (m -= 36E5);\n        } else m = new this.Date(c, g, l(d, 1), l(A, 0), l(M, 0), l(z, 0)).getTime();\n\n        return m;\n      };\n\n      d.prototype.timezoneOffsetFunction = function () {\n        var c = this,\n            g = this.options,\n            d = g.moment || k.moment;\n        if (!this.useUTC) return function (c) {\n          return 6E4 * new Date(c.toString()).getTimezoneOffset();\n        };\n\n        if (g.timezone) {\n          if (d) return function (c) {\n            return 6E4 * -d.tz(c, g.timezone).utcOffset();\n          };\n          B(25);\n        }\n\n        return this.useUTC && g.getTimezoneOffset ? function (c) {\n          return 6E4 * g.getTimezoneOffset(c.valueOf());\n        } : function () {\n          return 6E4 * (c.timezoneOffset || 0);\n        };\n      };\n\n      d.prototype.dateFormat = function (c, g, d) {\n        var n;\n        if (!x(g) || isNaN(g)) return (null === (n = f.defaultOptions.lang) || void 0 === n ? void 0 : n.invalidDate) || \"\";\n        c = l(c, \"%Y-%m-%d %H:%M:%S\");\n        var q = this;\n        n = new this.Date(g);\n        var z = this.get(\"Hours\", n),\n            m = this.get(\"Day\", n),\n            r = this.get(\"Date\", n),\n            e = this.get(\"Month\", n),\n            h = this.get(\"FullYear\", n),\n            a = f.defaultOptions.lang,\n            b = null === a || void 0 === a ? void 0 : a.weekdays,\n            w = null === a || void 0 === a ? void 0 : a.shortWeekdays;\n        n = G({\n          a: w ? w[m] : b[m].substr(0, 3),\n          A: b[m],\n          d: C(r),\n          e: C(r, 2, \" \"),\n          w: m,\n          b: a.shortMonths[e],\n          B: a.months[e],\n          m: C(e + 1),\n          o: e + 1,\n          y: h.toString().substr(2, 2),\n          Y: h,\n          H: C(z),\n          k: z,\n          I: C(z % 12 || 12),\n          l: z % 12 || 12,\n          M: C(this.get(\"Minutes\", n)),\n          p: 12 > z ? \"AM\" : \"PM\",\n          P: 12 > z ? \"am\" : \"pm\",\n          S: C(n.getSeconds()),\n          L: C(Math.floor(g % 1E3), 3)\n        }, f.dateFormats);\n        t(n, function (a, b) {\n          for (; -1 !== c.indexOf(\"%\" + b);) c = c.replace(\"%\" + b, \"function\" === typeof a ? a.call(q, g) : a);\n        });\n        return d ? c.substr(0, 1).toUpperCase() + c.substr(1) : c;\n      };\n\n      d.prototype.resolveDTLFormat = function (c) {\n        return D(c, !0) ? c : (c = E(c), {\n          main: c[0],\n          from: c[1],\n          to: c[2]\n        });\n      };\n\n      d.prototype.getTimeTicks = function (c, d, n, f) {\n        var q = this,\n            A = [],\n            m = {};\n        var r = new q.Date(d);\n        var e = c.unitRange,\n            h = c.count || 1,\n            a;\n        f = l(f, 1);\n\n        if (x(d)) {\n          q.set(\"Milliseconds\", r, e >= g.second ? 0 : h * Math.floor(q.get(\"Milliseconds\", r) / h));\n          e >= g.second && q.set(\"Seconds\", r, e >= g.minute ? 0 : h * Math.floor(q.get(\"Seconds\", r) / h));\n          e >= g.minute && q.set(\"Minutes\", r, e >= g.hour ? 0 : h * Math.floor(q.get(\"Minutes\", r) / h));\n          e >= g.hour && q.set(\"Hours\", r, e >= g.day ? 0 : h * Math.floor(q.get(\"Hours\", r) / h));\n          e >= g.day && q.set(\"Date\", r, e >= g.month ? 1 : Math.max(1, h * Math.floor(q.get(\"Date\", r) / h)));\n\n          if (e >= g.month) {\n            q.set(\"Month\", r, e >= g.year ? 0 : h * Math.floor(q.get(\"Month\", r) / h));\n            var b = q.get(\"FullYear\", r);\n          }\n\n          e >= g.year && q.set(\"FullYear\", r, b - b % h);\n          e === g.week && (b = q.get(\"Day\", r), q.set(\"Date\", r, q.get(\"Date\", r) - b + f + (b < f ? -7 : 0)));\n          b = q.get(\"FullYear\", r);\n          f = q.get(\"Month\", r);\n          var w = q.get(\"Date\", r),\n              J = q.get(\"Hours\", r);\n          d = r.getTime();\n          !q.variableTimezone && q.useUTC || !x(n) || (a = n - d > 4 * g.month || q.getTimezoneOffset(d) !== q.getTimezoneOffset(n));\n          d = r.getTime();\n\n          for (r = 1; d < n;) A.push(d), d = e === g.year ? q.makeTime(b + r * h, 0) : e === g.month ? q.makeTime(b, f + r * h) : !a || e !== g.day && e !== g.week ? a && e === g.hour && 1 < h ? q.makeTime(b, f, w, J + r * h) : d + e * h : q.makeTime(b, f, w + r * h * (e === g.day ? 1 : 7)), r++;\n\n          A.push(d);\n          e <= g.hour && 1E4 > A.length && A.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === q.dateFormat(\"%H%M%S%L\", a) && (m[a] = \"day\");\n          });\n        }\n\n        A.info = G(c, {\n          higherRanks: m,\n          totalRange: e * h\n        });\n        return A;\n      };\n\n      return d;\n    }();\n\n    f.Time = d;\n    return f.Time;\n  });\n  P(k, \"Core/Options.js\", [k[\"Core/Globals.js\"], k[\"Core/Color/Color.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Time.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B) {\n    var G = f.isTouchDevice,\n        D = f.svg;\n    d = d.parse;\n    B = B.merge;\n    \"\";\n    f.defaultOptions = {\n      colors: k.colors,\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      chart: {\n        styledMode: !1,\n        borderRadius: 0,\n        colorCount: 10,\n        defaultSeriesType: \"line\",\n        ignoreHiddenSeries: !0,\n        spacing: [10, 10, 15, 10],\n        resetZoomButton: {\n          theme: {\n            zIndex: 6\n          },\n          position: {\n            align: \"right\",\n            x: -10,\n            y: 10\n          }\n        },\n        zoomBySingleTouch: !1,\n        width: null,\n        height: null,\n        borderColor: k.highlightColor80,\n        backgroundColor: k.backgroundColor,\n        plotBorderColor: k.neutralColor20\n      },\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: k.neutralColor80\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: k.neutralColor40,\n        borderRadius: 0,\n        navigation: {\n          activeColor: k.highlightColor100,\n          inactiveColor: k.neutralColor20\n        },\n        itemStyle: {\n          color: k.neutralColor80,\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: k.neutralColor100\n        },\n        itemHiddenStyle: {\n          color: k.neutralColor20\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: k.backgroundColor,\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: D,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        padding: 8,\n        snap: G ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: d(k.neutralColor3).setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        style: {\n          color: k.neutralColor80,\n          cursor: \"default\",\n          fontSize: \"12px\",\n          whiteSpace: \"nowrap\"\n        }\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: k.neutralColor40,\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n    f.defaultOptions.chart.styledMode = !1;\n    \"\";\n    f.time = new x(B(f.defaultOptions.global, f.defaultOptions.time));\n\n    f.dateFormat = function (d, t, k) {\n      return f.time.dateFormat(d, t, k);\n    };\n\n    return {\n      dateFormat: f.dateFormat,\n      defaultOptions: f.defaultOptions,\n      time: f.time\n    };\n  });\n  P(k, \"Core/Axis/Tick.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = f.deg2rad,\n        x = d.clamp,\n        B = d.correctFloat,\n        G = d.defined,\n        D = d.destroyObjectProperties,\n        H = d.extend,\n        t = d.fireEvent,\n        C = d.isNumber,\n        l = d.merge,\n        E = d.objectEach,\n        g = d.pick;\n    \"\";\n\n    d = function () {\n      function d(c, g, d, f, l) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = c;\n        this.pos = g;\n        this.type = d || \"\";\n        this.parameters = l || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        t(this, \"init\");\n        d || f || this.addLabel();\n      }\n\n      d.prototype.addLabel = function () {\n        var c = this,\n            d = c.axis,\n            n = d.options,\n            f = d.chart,\n            l = d.categories,\n            z = d.logarithmic,\n            m = d.names,\n            r = c.pos,\n            e = g(c.options && c.options.labels, n.labels),\n            h = d.tickPositions,\n            a = r === h[0],\n            b = r === h[h.length - 1];\n        m = this.parameters.category || (l ? g(l[r], m[r], r) : r);\n        var w = c.label;\n        l = (!e.step || 1 === e.step) && 1 === d.tickInterval;\n        h = h.info;\n        var J, O;\n\n        if (d.dateTime && h) {\n          var F = f.time.resolveDTLFormat(n.dateTimeLabelFormats[!n.grid && h.higherRanks[r] || h.unitName]);\n          var N = F.main;\n        }\n\n        c.isFirst = a;\n        c.isLast = b;\n        c.formatCtx = {\n          axis: d,\n          chart: f,\n          isFirst: a,\n          isLast: b,\n          dateTimeLabelFormat: N,\n          tickPositionInfo: h,\n          value: z ? B(z.lin2log(m)) : m,\n          pos: r\n        };\n        n = d.labelFormatter.call(c.formatCtx, this.formatCtx);\n        if (O = F && F.list) c.shortenLabel = function () {\n          for (J = 0; J < O.length; J++) if (w.attr({\n            text: d.labelFormatter.call(H(c.formatCtx, {\n              dateTimeLabelFormat: O[J]\n            }))\n          }), w.getBBox().width < d.getSlotWidth(c) - 2 * g(e.padding, 5)) return;\n\n          w.attr({\n            text: \"\"\n          });\n        };\n        l && d._addedPlotLB && c.moveLabel(n, e);\n        G(w) || c.movedLabel ? w && w.textStr !== n && !l && (!w.textWidth || e.style && e.style.width || w.styles.width || w.css({\n          width: null\n        }), w.attr({\n          text: n\n        }), w.textPxLength = w.getBBox().width) : (c.label = w = c.createLabel({\n          x: 0,\n          y: 0\n        }, n, e), c.rotation = 0);\n      };\n\n      d.prototype.createLabel = function (c, g, d) {\n        var n = this.axis,\n            f = n.chart;\n        if (c = G(g) && d.enabled ? f.renderer.text(g, c.x, c.y, d.useHTML).add(n.labelGroup) : null) f.styledMode || c.css(l(d.style)), c.textPxLength = c.getBBox().width;\n        return c;\n      };\n\n      d.prototype.destroy = function () {\n        D(this, this.axis);\n      };\n\n      d.prototype.getPosition = function (c, g, d, f) {\n        var n = this.axis,\n            q = n.chart,\n            m = f && q.oldChartHeight || q.chartHeight;\n        c = {\n          x: c ? B(n.translate(g + d, null, null, f) + n.transB) : n.left + n.offset + (n.opposite ? (f && q.oldChartWidth || q.chartWidth) - n.right - n.left : 0),\n          y: c ? m - n.bottom + n.offset - (n.opposite ? n.height : 0) : B(m - n.translate(g + d, null, null, f) - n.transB)\n        };\n        c.y = x(c.y, -1E5, 1E5);\n        t(this, \"afterGetPosition\", {\n          pos: c\n        });\n        return c;\n      };\n\n      d.prototype.getLabelPosition = function (c, g, d, f, l, z, m, r) {\n        var e = this.axis,\n            h = e.transA,\n            a = e.isLinked && e.linkedParent ? e.linkedParent.reversed : e.reversed,\n            b = e.staggerLines,\n            w = e.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            n = l.y,\n            q = f || e.reserveSpaceDefault ? 0 : -e.labelOffset * (\"center\" === e.labelAlign ? .5 : 1),\n            F = {};\n        G(n) || (n = 0 === e.side ? d.rotation ? -8 : -d.getBBox().height : 2 === e.side ? w.y + 8 : Math.cos(d.rotation * k) * (w.y - d.getBBox(!1, 0).height / 2));\n        c = c + l.x + q + w.x - (z && f ? z * h * (a ? -1 : 1) : 0);\n        g = g + n - (z && !f ? z * h * (a ? 1 : -1) : 0);\n        b && (d = m / (r || 1) % b, e.opposite && (d = b - d - 1), g += e.labelOffset / b * d);\n        F.x = c;\n        F.y = Math.round(g);\n        t(this, \"afterGetLabelPosition\", {\n          pos: F,\n          tickmarkOffset: z,\n          index: m\n        });\n        return F;\n      };\n\n      d.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      d.prototype.getMarkPath = function (c, g, d, f, l, z) {\n        return z.crispLine([[\"M\", c, g], [\"L\", c + (l ? 0 : -d), g + (l ? d : 0)]], f);\n      };\n\n      d.prototype.handleOverflow = function (c) {\n        var d = this.axis,\n            f = d.options.labels,\n            l = c.x,\n            t = d.chart.chartWidth,\n            z = d.chart.spacing,\n            m = g(d.labelLeft, Math.min(d.pos, z[3]));\n        z = g(d.labelRight, Math.max(d.isRadial ? 0 : d.pos + d.len, t - z[1]));\n        var r = this.label,\n            e = this.rotation,\n            h = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[d.labelAlign || r.attr(\"align\")],\n            a = r.getBBox().width,\n            b = d.getSlotWidth(this),\n            w = b,\n            J = 1,\n            O,\n            F = {};\n        if (e || \"justify\" !== g(f.overflow, \"justify\")) 0 > e && l - h * a < m ? O = Math.round(l / Math.cos(e * k) - m) : 0 < e && l + h * a > z && (O = Math.round((t - l) / Math.cos(e * k)));else if (t = l + (1 - h) * a, l - h * a < m ? w = c.x + w * (1 - h) - m : t > z && (w = z - c.x + w * h, J = -1), w = Math.min(b, w), w < b && \"center\" === d.labelAlign && (c.x += J * (b - w - h * (b - Math.min(a, w)))), a > w || d.autoRotation && (r.styles || {}).width) O = w;\n        O && (this.shortenLabel ? this.shortenLabel() : (F.width = Math.floor(O) + \"px\", (f.style || {}).textOverflow || (F.textOverflow = \"ellipsis\"), r.css(F)));\n      };\n\n      d.prototype.moveLabel = function (c, g) {\n        var d = this,\n            f = d.label,\n            q = !1,\n            l = d.axis,\n            m = l.reversed;\n        f && f.textStr === c ? (d.movedLabel = f, q = !0, delete d.label) : E(l.ticks, function (e) {\n          q || e.isNew || e === d || !e.label || e.label.textStr !== c || (d.movedLabel = e.label, q = !0, e.labelPos = d.movedLabel.xy, delete e.label);\n        });\n\n        if (!q && (d.labelPos || f)) {\n          var r = d.labelPos || f.xy;\n          f = l.horiz ? m ? 0 : l.width + l.left : r.x;\n          l = l.horiz ? r.y : m ? l.width + l.left : 0;\n          d.movedLabel = d.createLabel({\n            x: f,\n            y: l\n          }, c, g);\n          d.movedLabel && d.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      d.prototype.render = function (c, d, f) {\n        var n = this.axis,\n            q = n.horiz,\n            l = this.pos,\n            m = g(this.tickmarkOffset, n.tickmarkOffset);\n        l = this.getPosition(q, l, m, d);\n        m = l.x;\n        var r = l.y;\n        n = q && m === n.pos + n.len || !q && r === n.pos ? -1 : 1;\n        f = g(f, 1);\n        this.isActive = !0;\n        this.renderGridLine(d, f, n);\n        this.renderMark(l, f, n);\n        this.renderLabel(l, d, f, c);\n        this.isNew = !1;\n        t(this, \"afterRender\");\n      };\n\n      d.prototype.renderGridLine = function (c, d, f) {\n        var n = this.axis,\n            q = n.options,\n            l = this.gridLine,\n            m = {},\n            r = this.pos,\n            e = this.type,\n            h = g(this.tickmarkOffset, n.tickmarkOffset),\n            a = n.chart.renderer,\n            b = e ? e + \"Grid\" : \"grid\",\n            w = q[b + \"LineWidth\"],\n            J = q[b + \"LineColor\"];\n        q = q[b + \"LineDashStyle\"];\n        l || (n.chart.styledMode || (m.stroke = J, m[\"stroke-width\"] = w, q && (m.dashstyle = q)), e || (m.zIndex = 1), c && (d = 0), this.gridLine = l = a.path().attr(m).addClass(\"highcharts-\" + (e ? e + \"-\" : \"\") + \"grid-line\").add(n.gridGroup));\n        if (l && (f = n.getPlotLinePath({\n          value: r + h,\n          lineWidth: l.strokeWidth() * f,\n          force: \"pass\",\n          old: c\n        }))) l[c || this.isNew ? \"attr\" : \"animate\"]({\n          d: f,\n          opacity: d\n        });\n      };\n\n      d.prototype.renderMark = function (c, d, f) {\n        var n = this.axis,\n            q = n.options,\n            l = n.chart.renderer,\n            m = this.type,\n            r = m ? m + \"Tick\" : \"tick\",\n            e = n.tickSize(r),\n            h = this.mark,\n            a = !h,\n            b = c.x;\n        c = c.y;\n        var w = g(q[r + \"Width\"], !m && n.isXAxis ? 1 : 0);\n        q = q[r + \"Color\"];\n        e && (n.opposite && (e[0] = -e[0]), a && (this.mark = h = l.path().addClass(\"highcharts-\" + (m ? m + \"-\" : \"\") + \"tick\").add(n.axisGroup), n.chart.styledMode || h.attr({\n          stroke: q,\n          \"stroke-width\": w\n        })), h[a ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(b, c, e[0], h.strokeWidth() * f, n.horiz, l),\n          opacity: d\n        }));\n      };\n\n      d.prototype.renderLabel = function (c, d, f, l) {\n        var n = this.axis,\n            q = n.horiz,\n            m = n.options,\n            r = this.label,\n            e = m.labels,\n            h = e.step;\n        n = g(this.tickmarkOffset, n.tickmarkOffset);\n        var a = !0,\n            b = c.x;\n        c = c.y;\n        r && C(b) && (r.xy = c = this.getLabelPosition(b, c, r, q, e, n, l, h), this.isFirst && !this.isLast && !g(m.showFirstLabel, 1) || this.isLast && !this.isFirst && !g(m.showLastLabel, 1) ? a = !1 : !q || e.step || e.rotation || d || 0 === f || this.handleOverflow(c), h && l % h && (a = !1), a && C(c.y) ? (c.opacity = f, r[this.isNewLabel ? \"attr\" : \"animate\"](c), this.isNewLabel = !1) : (r.attr(\"y\", -9999), this.isNewLabel = !0));\n      };\n\n      d.prototype.replaceMovedLabel = function () {\n        var c = this.label,\n            g = this.axis,\n            d = g.reversed;\n\n        if (c && !this.isNew) {\n          var f = g.horiz ? d ? g.left : g.width + g.left : c.xy.x;\n          d = g.horiz ? c.xy.y : d ? g.width + g.top : g.top;\n          c.animate({\n            x: f,\n            y: d,\n            opacity: 0\n          }, void 0, c.destroy);\n          delete this.label;\n        }\n\n        g.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return d;\n    }();\n\n    f.Tick = d;\n    return f.Tick;\n  });\n  P(k, \"Core/Axis/Axis.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Color/Color.js\"], k[\"Core/Globals.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Options.js\"], k[\"Core/Axis/Tick.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G, D) {\n    var H = f.animObject,\n        t = B.defaultOptions,\n        C = D.addEvent,\n        l = D.arrayMax,\n        E = D.arrayMin,\n        g = D.clamp,\n        y = D.correctFloat,\n        c = D.defined,\n        q = D.destroyObjectProperties,\n        n = D.erase,\n        A = D.error,\n        M = D.extend,\n        z = D.fireEvent,\n        m = D.format,\n        r = D.getMagnitude,\n        e = D.isArray,\n        h = D.isFunction,\n        a = D.isNumber,\n        b = D.isString,\n        w = D.merge,\n        J = D.normalizeTickInterval,\n        O = D.objectEach,\n        F = D.pick,\n        N = D.relativeLength,\n        R = D.removeEvent,\n        Q = D.splat,\n        T = D.syncTimeout;\n    \"\";\n    var v = k.deg2rad;\n\n    f = function () {\n      function f(a, b) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.coll = this.closestPointRange = this.chart = this.categories = this.bottom = this.alternateBands = void 0;\n        this.init(a, b);\n      }\n\n      f.prototype.init = function (a, b) {\n        var e = b.isX,\n            p = this;\n        p.chart = a;\n        p.horiz = a.inverted && !p.isZAxis ? !e : e;\n        p.isXAxis = e;\n        p.coll = p.coll || (e ? \"xAxis\" : \"yAxis\");\n        z(this, \"init\", {\n          userOptions: b\n        });\n        p.opposite = F(b.opposite, p.opposite);\n        p.side = F(b.side, p.side, p.horiz ? p.opposite ? 0 : 2 : p.opposite ? 1 : 3);\n        p.setOptions(b);\n        var u = this.options,\n            g = u.type;\n        p.labelFormatter = u.labels.formatter || p.defaultLabelFormatter;\n        p.userOptions = b;\n        p.minPixelPadding = 0;\n        p.reversed = F(u.reversed, p.reversed);\n        p.visible = !1 !== u.visible;\n        p.zoomEnabled = !1 !== u.zoomEnabled;\n        p.hasNames = \"category\" === g || !0 === u.categories;\n        p.categories = u.categories || p.hasNames;\n        p.names || (p.names = [], p.names.keys = {});\n        p.plotLinesAndBandsGroups = {};\n        p.positiveValuesOnly = !!p.logarithmic;\n        p.isLinked = c(u.linkedTo);\n        p.ticks = {};\n        p.labelEdge = [];\n        p.minorTicks = {};\n        p.plotLinesAndBands = [];\n        p.alternateBands = {};\n        p.len = 0;\n        p.minRange = p.userMinRange = u.minRange || u.maxZoom;\n        p.range = u.range;\n        p.offset = u.offset || 0;\n        p.max = null;\n        p.min = null;\n        p.crosshair = F(u.crosshair, Q(a.options.tooltip.crosshairs)[e ? 0 : 1], !1);\n        b = p.options.events;\n        -1 === a.axes.indexOf(p) && (e ? a.axes.splice(a.xAxis.length, 0, p) : a.axes.push(p), a[p.coll].push(p));\n        p.series = p.series || [];\n        a.inverted && !p.isZAxis && e && \"undefined\" === typeof p.reversed && (p.reversed = !0);\n        p.labelRotation = p.options.labels.rotation;\n        O(b, function (a, b) {\n          h(a) && C(p, b, a);\n        });\n        z(this, \"afterInit\");\n      };\n\n      f.prototype.setOptions = function (a) {\n        this.options = w(f.defaultOptions, \"yAxis\" === this.coll && f.defaultYAxisOptions, [f.defaultTopAxisOptions, f.defaultRightAxisOptions, f.defaultBottomAxisOptions, f.defaultLeftAxisOptions][this.side], w(t[this.coll], a));\n        z(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      };\n\n      f.prototype.defaultLabelFormatter = function () {\n        var b = this.axis,\n            e = a(this.value) ? this.value : NaN,\n            c = b.chart.time,\n            g = b.categories,\n            u = this.dateTimeLabelFormat,\n            h = t.lang,\n            d = h.numericSymbols;\n        h = h.numericSymbolMagnitude || 1E3;\n        var f = d && d.length,\n            w = b.options.labels.format;\n        b = b.logarithmic ? Math.abs(e) : b.tickInterval;\n        var n = this.chart,\n            q = n.numberFormatter;\n        if (w) var r = m(w, this, n);else if (g) r = \"\" + this.value;else if (u) r = c.dateFormat(u, e);else if (f && 1E3 <= b) for (; f-- && \"undefined\" === typeof r;) c = Math.pow(h, f + 1), b >= c && 0 === 10 * e % c && null !== d[f] && 0 !== e && (r = q(e / c, -1) + d[f]);\n        \"undefined\" === typeof r && (r = 1E4 <= Math.abs(e) ? q(e, -1) : q(e, -1, void 0, \"\"));\n        return r;\n      };\n\n      f.prototype.getSeriesExtremes = function () {\n        var b = this,\n            e = b.chart,\n            g;\n        z(this, \"getSeriesExtremes\", null, function () {\n          b.hasVisibleSeries = !1;\n          b.dataMin = b.dataMax = b.threshold = null;\n          b.softThreshold = !b.isXAxis;\n          b.stacking && b.stacking.buildStacks();\n          b.series.forEach(function (p) {\n            if (p.visible || !e.options.chart.ignoreHiddenSeries) {\n              var u = p.options,\n                  h = u.threshold;\n              b.hasVisibleSeries = !0;\n              b.positiveValuesOnly && 0 >= h && (h = null);\n\n              if (b.isXAxis) {\n                if (u = p.xData, u.length) {\n                  u = b.logarithmic ? u.filter(b.validatePositiveValue) : u;\n                  g = p.getXExtremes(u);\n                  var d = g.min;\n                  var f = g.max;\n                  a(d) || d instanceof Date || (u = u.filter(a), g = p.getXExtremes(u), d = g.min, f = g.max);\n                  u.length && (b.dataMin = Math.min(F(b.dataMin, d), d), b.dataMax = Math.max(F(b.dataMax, f), f));\n                }\n              } else if (p = p.applyExtremes(), a(p.dataMin) && (d = p.dataMin, b.dataMin = Math.min(F(b.dataMin, d), d)), a(p.dataMax) && (f = p.dataMax, b.dataMax = Math.max(F(b.dataMax, f), f)), c(h) && (b.threshold = h), !u.softThreshold || b.positiveValuesOnly) b.softThreshold = !1;\n            }\n          });\n        });\n        z(this, \"afterGetSeriesExtremes\");\n      };\n\n      f.prototype.translate = function (b, e, c, g, u, h) {\n        var p = this.linkedParent || this,\n            d = 1,\n            f = 0,\n            m = g && p.old ? p.old.transA : p.transA;\n        g = g && p.old ? p.old.min : p.min;\n        var w = p.minPixelPadding;\n        u = (p.isOrdinal || p.brokenAxis && p.brokenAxis.hasBreaks || p.logarithmic && u) && p.lin2val;\n        m || (m = p.transA);\n        c && (d *= -1, f = p.len);\n        p.reversed && (d *= -1, f -= d * (p.sector || p.len));\n        e ? (b = (b * d + f - w) / m + g, u && (b = p.lin2val(b))) : (u && (b = p.val2lin(b)), b = a(g) ? d * (b - g) * m + f + d * w + (a(h) ? m * h : 0) : void 0);\n        return b;\n      };\n\n      f.prototype.toPixels = function (a, b) {\n        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);\n      };\n\n      f.prototype.toValue = function (a, b) {\n        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);\n      };\n\n      f.prototype.getPlotLinePath = function (b) {\n        function e(a, b, e) {\n          if (\"pass\" !== n && a < b || a > e) n ? a = g(a, b, e) : Z = !0;\n          return a;\n        }\n\n        var c = this,\n            p = c.chart,\n            u = c.left,\n            h = c.top,\n            d = b.old,\n            f = b.value,\n            m = b.translatedValue,\n            w = b.lineWidth,\n            n = b.force,\n            r,\n            q,\n            l,\n            J,\n            v = d && p.oldChartHeight || p.chartHeight,\n            V = d && p.oldChartWidth || p.chartWidth,\n            Z,\n            N = c.transB;\n        b = {\n          value: f,\n          lineWidth: w,\n          old: d,\n          force: n,\n          acrossPanes: b.acrossPanes,\n          translatedValue: m\n        };\n        z(this, \"getPlotLinePath\", b, function (b) {\n          m = F(m, c.translate(f, null, null, d));\n          m = g(m, -1E5, 1E5);\n          r = l = Math.round(m + N);\n          q = J = Math.round(v - m - N);\n          a(m) ? c.horiz ? (q = h, J = v - c.bottom, r = l = e(r, u, u + c.width)) : (r = u, l = V - c.right, q = J = e(q, h, h + c.height)) : (Z = !0, n = !1);\n          b.path = Z && !n ? null : p.renderer.crispLine([[\"M\", r, q], [\"L\", l, J]], w || 1);\n        });\n        return b.path;\n      };\n\n      f.prototype.getLinearTickPositions = function (a, b, e) {\n        var c = y(Math.floor(b / a) * a);\n        e = y(Math.ceil(e / a) * a);\n        var p = [],\n            g;\n        y(c + a) === c && (g = 20);\n        if (this.single) return [b];\n\n        for (b = c; b <= e;) {\n          p.push(b);\n          b = y(b + a, g);\n          if (b === h) break;\n          var h = b;\n        }\n\n        return p;\n      };\n\n      f.prototype.getMinorTickInterval = function () {\n        var a = this.options;\n        return !0 === a.minorTicks ? F(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      };\n\n      f.prototype.getMinorTickPositions = function () {\n        var a = this.options,\n            b = this.tickPositions,\n            e = this.minorTickInterval,\n            c = [],\n            u = this.pointRangePadding || 0,\n            g = this.min - u;\n        u = this.max + u;\n        var h = u - g;\n\n        if (h && h / e < this.len / 3) {\n          var d = this.logarithmic;\n          if (d) this.paddedTicks.forEach(function (a, b, p) {\n            b && c.push.apply(c, d.getLogTickPositions(e, p[b - 1], p[b], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) c = c.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(e), g, u, a.startOfWeek));else for (a = g + (b[0] - g) % e; a <= u && a !== c[0]; a += e) c.push(a);\n        }\n\n        0 !== c.length && this.trimTicks(c);\n        return c;\n      };\n\n      f.prototype.adjustForMinRange = function () {\n        var a = this.options,\n            b = this.min,\n            e = this.max,\n            g = this.logarithmic,\n            u = 0,\n            h,\n            d,\n            f,\n            m;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !g && (c(a.min) || c(a.max) ? this.minRange = null : (this.series.forEach(function (a) {\n          f = a.xData;\n          m = a.xIncrement ? 1 : f.length - 1;\n          if (1 < f.length) for (h = m; 0 < h; h--) if (d = f[h] - f[h - 1], !u || d < u) u = d;\n        }), this.minRange = Math.min(5 * u, this.dataMax - this.dataMin)));\n\n        if (e - b < this.minRange) {\n          var w = this.dataMax - this.dataMin >= this.minRange;\n          var n = this.minRange;\n          var r = (n - e + b) / 2;\n          r = [b - r, F(a.min, b - r)];\n          w && (r[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          b = l(r);\n          e = [b + n, F(a.max, b + n)];\n          w && (e[2] = g ? g.log2lin(this.dataMax) : this.dataMax);\n          e = E(e);\n          e - b < n && (r[0] = e - n, r[1] = F(a.min, e - n), b = l(r));\n        }\n\n        this.min = b;\n        this.max = e;\n      };\n\n      f.prototype.getClosest = function () {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (b) {\n          var e = b.closestPointRange,\n              p = b.visible || !b.chart.options.chart.ignoreHiddenSeries;\n          !b.noSharedTooltip && c(e) && p && (a = c(a) ? Math.min(a, e) : e);\n        });\n        return a;\n      };\n\n      f.prototype.nameToX = function (a) {\n        var b = e(this.categories),\n            p = b ? this.categories : this.names,\n            g = a.options.x;\n        a.series.requireSorting = !1;\n        c(g) || (g = !1 === this.options.uniqueNames ? a.series.autoIncrement() : b ? p.indexOf(a.name) : F(p.keys[a.name], -1));\n\n        if (-1 === g) {\n          if (!b) var u = p.length;\n        } else u = g;\n\n        \"undefined\" !== typeof u && (this.names[u] = a.name, this.names.keys[a.name] = u);\n        return u;\n      };\n\n      f.prototype.updateNames = function () {\n        var a = this,\n            b = this.names;\n        0 < b.length && (Object.keys(b.keys).forEach(function (a) {\n          delete b.keys[a];\n        }), b.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (b) {\n          b.xIncrement = null;\n          if (!b.points || b.isDirtyData) a.max = Math.max(a.max, b.xData.length - 1), b.processData(), b.generatePoints();\n          b.data.forEach(function (e, c) {\n            if (e && e.options && \"undefined\" !== typeof e.name) {\n              var p = a.nameToX(e);\n              \"undefined\" !== typeof p && p !== e.x && (e.x = p, b.xData[c] = p);\n            }\n          });\n        }));\n      };\n\n      f.prototype.setAxisTranslation = function () {\n        var a = this,\n            e = a.max - a.min,\n            c = a.axisPointRange || 0,\n            g = 0,\n            u = 0,\n            h = a.linkedParent,\n            d = !!a.categories,\n            f = a.transA,\n            m = a.isXAxis;\n\n        if (m || d || c) {\n          var w = a.getClosest();\n          h ? (g = h.minPointOffset, u = h.pointRangePadding) : a.series.forEach(function (e) {\n            var p = d ? 1 : m ? F(e.options.pointRange, w, 0) : a.axisPointRange || 0,\n                h = e.options.pointPlacement;\n            c = Math.max(c, p);\n            if (!a.single || d) e = e.is(\"xrange\") ? !m : m, g = Math.max(g, e && b(h) ? 0 : p / 2), u = Math.max(u, e && \"on\" === h ? 0 : p);\n          });\n          h = a.ordinal && a.ordinal.slope && w ? a.ordinal.slope / w : 1;\n          a.minPointOffset = g *= h;\n          a.pointRangePadding = u *= h;\n          a.pointRange = Math.min(c, a.single && d ? 1 : e);\n          m && (a.closestPointRange = w);\n        }\n\n        a.translationSlope = a.transA = f = a.staticScale || a.len / (e + u || 1);\n        a.transB = a.horiz ? a.left : a.bottom;\n        a.minPixelPadding = f * g;\n        z(this, \"afterSetAxisTranslation\");\n      };\n\n      f.prototype.minFromRange = function () {\n        return this.max - this.range;\n      };\n\n      f.prototype.setTickInterval = function (b) {\n        var e = this,\n            p = e.chart,\n            g = e.logarithmic,\n            u = e.options,\n            h = e.isXAxis,\n            d = e.isLinked,\n            f = u.maxPadding,\n            m = u.minPadding,\n            w = u.tickInterval,\n            n = u.tickPixelInterval,\n            q = e.categories,\n            l = a(e.threshold) ? e.threshold : null,\n            v = e.softThreshold;\n        e.dateTime || q || d || this.getTickAmount();\n        var N = F(e.userMin, u.min);\n        var O = F(e.userMax, u.max);\n\n        if (d) {\n          e.linkedParent = p[e.coll][u.linkedTo];\n          var V = e.linkedParent.getExtremes();\n          e.min = F(V.min, V.dataMin);\n          e.max = F(V.max, V.dataMax);\n          u.type !== e.linkedParent.options.type && A(11, 1, p);\n        } else {\n          if (v && c(l)) if (e.dataMin >= l) V = l, m = 0;else if (e.dataMax <= l) {\n            var Z = l;\n            f = 0;\n          }\n          e.min = F(N, V, e.dataMin);\n          e.max = F(O, Z, e.dataMax);\n        }\n\n        g && (e.positiveValuesOnly && !b && 0 >= Math.min(e.min, F(e.dataMin, e.min)) && A(10, 1, p), e.min = y(g.log2lin(e.min), 16), e.max = y(g.log2lin(e.max), 16));\n        e.range && c(e.max) && (e.userMin = e.min = N = Math.max(e.dataMin, e.minFromRange()), e.userMax = O = e.max, e.range = null);\n        z(e, \"foundExtremes\");\n        e.beforePadding && e.beforePadding();\n        e.adjustForMinRange();\n        !(q || e.axisPointRange || e.stacking && e.stacking.usePercentage || d) && c(e.min) && c(e.max) && (p = e.max - e.min) && (!c(N) && m && (e.min -= p * m), !c(O) && f && (e.max += p * f));\n        a(e.userMin) || (a(u.softMin) && u.softMin < e.min && (e.min = N = u.softMin), a(u.floor) && (e.min = Math.max(e.min, u.floor)));\n        a(e.userMax) || (a(u.softMax) && u.softMax > e.max && (e.max = O = u.softMax), a(u.ceiling) && (e.max = Math.min(e.max, u.ceiling)));\n        v && c(e.dataMin) && (l = l || 0, !c(N) && e.min < l && e.dataMin >= l ? e.min = e.options.minRange ? Math.min(l, e.max - e.minRange) : l : !c(O) && e.max > l && e.dataMax <= l && (e.max = e.options.minRange ? Math.max(l, e.min + e.minRange) : l));\n        a(e.min) && a(e.max) && !this.chart.polar && e.min > e.max && (c(e.options.min) ? e.max = e.min : c(e.options.max) && (e.min = e.max));\n        e.tickInterval = e.min === e.max || \"undefined\" === typeof e.min || \"undefined\" === typeof e.max ? 1 : d && !w && n === e.linkedParent.options.tickPixelInterval ? w = e.linkedParent.tickInterval : F(w, this.tickAmount ? (e.max - e.min) / Math.max(this.tickAmount - 1, 1) : void 0, q ? 1 : (e.max - e.min) * n / Math.max(e.len, n));\n        h && !b && e.series.forEach(function (a) {\n          var b, c;\n          a.processData(e.min !== (null === (b = e.old) || void 0 === b ? void 0 : b.min) || e.max !== (null === (c = e.old) || void 0 === c ? void 0 : c.max));\n        });\n        e.setAxisTranslation();\n        z(this, \"initialAxisTranslation\");\n        e.pointRange && !w && (e.tickInterval = Math.max(e.pointRange, e.tickInterval));\n        b = F(u.minTickInterval, e.dateTime && !e.series.some(function (a) {\n          return a.noSharedTooltip;\n        }) ? e.closestPointRange : 0);\n        !w && e.tickInterval < b && (e.tickInterval = b);\n        e.dateTime || e.logarithmic || w || (e.tickInterval = J(e.tickInterval, void 0, r(e.tickInterval), F(u.allowDecimals, .5 > e.tickInterval || void 0 !== this.tickAmount), !!this.tickAmount));\n        this.tickAmount || (e.tickInterval = e.unsquish());\n        this.setTickPositions();\n      };\n\n      f.prototype.setTickPositions = function () {\n        var a = this.options,\n            b = a.tickPositions;\n        var e = this.getMinorTickInterval();\n        var g = a.tickPositioner,\n            h = this.hasVerticalPanning(),\n            d = \"colorAxis\" === this.coll,\n            f = (d || !h) && a.startOnTick;\n        h = (d || !h) && a.endOnTick;\n        this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === e && this.tickInterval ? this.tickInterval / 5 : e;\n        this.single = this.min === this.max && c(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);\n        this.tickPositions = e = b && b.slice();\n        !e && (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200)) ? e = this.dateTime ? this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0) : this.logarithmic ? this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max) : (e = [this.min, this.max], A(19, !1, this.chart)), e.length > this.len && (e = [e[0], e.pop()], e[0] === e[1] && (e.length = 1)), this.tickPositions = e, g && (g = g.apply(this, [this.min, this.max]))) && (this.tickPositions = e = g);\n        this.paddedTicks = e.slice(0);\n        this.trimTicks(e, f, h);\n        this.isLinked || (this.single && 2 > e.length && !this.categories && !this.series.some(function (a) {\n          return a.is(\"heatmap\") && \"between\" === a.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), b || g || this.adjustTickAmount());\n        z(this, \"afterSetTickPositions\");\n      };\n\n      f.prototype.trimTicks = function (a, b, e) {\n        var g = a[0],\n            p = a[a.length - 1],\n            h = !this.isOrdinal && this.minPointOffset || 0;\n        z(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (b && -Infinity !== g) this.min = g;else for (; this.min - h > a[0];) a.shift();\n          if (e) this.max = p;else for (; this.max + h < a[a.length - 1];) a.pop();\n          0 === a.length && c(g) && !this.options.tickPositions && a.push((p + g) / 2);\n        }\n      };\n\n      f.prototype.alignToOthers = function () {\n        var a = {},\n            b,\n            e = this.options;\n        !1 === this.chart.options.chart.alignTicks || !1 === e.alignTicks || !1 === e.startOnTick || !1 === e.endOnTick || this.logarithmic || this.chart[this.coll].forEach(function (e) {\n          var c = e.options;\n          c = [e.horiz ? c.left : c.top, c.width, c.height, c.pane].join();\n          e.series.length && (a[c] ? b = !0 : a[c] = 1);\n        });\n        return b;\n      };\n\n      f.prototype.getTickAmount = function () {\n        var a = this.options,\n            b = a.tickAmount,\n            e = a.tickPixelInterval;\n        !c(a.tickInterval) && !b && this.len < e && !this.isRadial && !this.logarithmic && a.startOnTick && a.endOnTick && (b = 2);\n        !b && this.alignToOthers() && (b = Math.ceil(this.len / e) + 1);\n        4 > b && (this.finalTickAmt = b, b = 5);\n        this.tickAmount = b;\n      };\n\n      f.prototype.adjustTickAmount = function () {\n        var b = this.options,\n            e = this.tickInterval,\n            g = this.tickPositions,\n            h = this.tickAmount,\n            u = this.finalTickAmt,\n            d = g && g.length,\n            f = F(this.threshold, this.softThreshold ? 0 : null);\n\n        if (this.hasData() && a(this.min) && a(this.max)) {\n          if (d < h) {\n            for (; g.length < h;) g.length % 2 || this.min === f ? g.push(y(g[g.length - 1] + e)) : g.unshift(y(g[0] - e));\n\n            this.transA *= (d - 1) / (h - 1);\n            this.min = b.startOnTick ? g[0] : Math.min(this.min, g[0]);\n            this.max = b.endOnTick ? g[g.length - 1] : Math.max(this.max, g[g.length - 1]);\n          } else d > h && (this.tickInterval *= 2, this.setTickPositions());\n\n          if (c(u)) {\n            for (e = b = g.length; e--;) (3 === u && 1 === e % 2 || 2 >= u && 0 < e && e < b - 1) && g.splice(e, 1);\n\n            this.finalTickAmt = void 0;\n          }\n        }\n      };\n\n      f.prototype.setScale = function () {\n        var a,\n            b,\n            e,\n            c,\n            g,\n            h,\n            d = !1,\n            f = !1;\n        this.series.forEach(function (a) {\n          var b;\n          d = d || a.isDirtyData || a.isDirty;\n          f = f || (null === (b = a.xAxis) || void 0 === b ? void 0 : b.isDirty) || !1;\n        });\n        this.setAxisSize();\n        (h = this.len !== (null === (a = this.old) || void 0 === a ? void 0 : a.len)) || d || f || this.isLinked || this.forceRedraw || this.userMin !== (null === (b = this.old) || void 0 === b ? void 0 : b.userMin) || this.userMax !== (null === (e = this.old) || void 0 === e ? void 0 : e.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = h || this.min !== (null === (c = this.old) || void 0 === c ? void 0 : c.min) || this.max !== (null === (g = this.old) || void 0 === g ? void 0 : g.max))) : this.stacking && this.stacking.cleanStacks();\n        d && this.panningState && (this.panningState.isDirty = !0);\n        z(this, \"afterSetScale\");\n      };\n\n      f.prototype.setExtremes = function (a, b, e, c, g) {\n        var h = this,\n            p = h.chart;\n        e = F(e, !0);\n        h.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        g = M(g, {\n          min: a,\n          max: b\n        });\n        z(h, \"setExtremes\", g, function () {\n          h.userMin = a;\n          h.userMax = b;\n          h.eventArgs = g;\n          e && p.redraw(c);\n        });\n      };\n\n      f.prototype.zoom = function (a, b) {\n        var e = this,\n            g = this.dataMin,\n            h = this.dataMax,\n            p = this.options,\n            d = Math.min(g, F(p.min, g)),\n            f = Math.max(h, F(p.max, h));\n        a = {\n          newMin: a,\n          newMax: b\n        };\n        z(this, \"zoom\", a, function (a) {\n          var b = a.newMin,\n              p = a.newMax;\n          if (b !== e.min || p !== e.max) e.allowZoomOutside || (c(g) && (b < d && (b = d), b > f && (b = f)), c(h) && (p < d && (p = d), p > f && (p = f))), e.displayBtn = \"undefined\" !== typeof b || \"undefined\" !== typeof p, e.setExtremes(b, p, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      };\n\n      f.prototype.setAxisSize = function () {\n        var a = this.chart,\n            b = this.options,\n            e = b.offsets || [0, 0, 0, 0],\n            c = this.horiz,\n            g = this.width = Math.round(N(F(b.width, a.plotWidth - e[3] + e[1]), a.plotWidth)),\n            h = this.height = Math.round(N(F(b.height, a.plotHeight - e[0] + e[2]), a.plotHeight)),\n            d = this.top = Math.round(N(F(b.top, a.plotTop + e[0]), a.plotHeight, a.plotTop));\n        b = this.left = Math.round(N(F(b.left, a.plotLeft + e[3]), a.plotWidth, a.plotLeft));\n        this.bottom = a.chartHeight - h - d;\n        this.right = a.chartWidth - g - b;\n        this.len = Math.max(c ? g : h, 0);\n        this.pos = c ? b : d;\n      };\n\n      f.prototype.getExtremes = function () {\n        var a = this.logarithmic;\n        return {\n          min: a ? y(a.lin2log(this.min)) : this.min,\n          max: a ? y(a.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      };\n\n      f.prototype.getThreshold = function (a) {\n        var b = this.logarithmic,\n            e = b ? b.lin2log(this.min) : this.min;\n        b = b ? b.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = e : Infinity === a ? a = b : e > a ? a = e : b < a && (a = b);\n        return this.translate(a, 0, 1, 0, 1);\n      };\n\n      f.prototype.autoLabelAlign = function (a) {\n        var b = (F(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        z(this, \"autoLabelAlign\", a, function (a) {\n          15 < b && 165 > b ? a.align = \"right\" : 195 < b && 345 > b && (a.align = \"left\");\n        });\n        return a.align;\n      };\n\n      f.prototype.tickSize = function (a) {\n        var b = this.options,\n            e = b[\"tick\" === a ? \"tickLength\" : \"minorTickLength\"],\n            c = F(b[\"tick\" === a ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === a && this.isXAxis && !this.categories ? 1 : 0);\n\n        if (c && e) {\n          \"inside\" === b[a + \"Position\"] && (e = -e);\n          var g = [e, c];\n        }\n\n        a = {\n          tickSize: g\n        };\n        z(this, \"afterTickSize\", a);\n        return a.tickSize;\n      };\n\n      f.prototype.labelMetrics = function () {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style && this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      };\n\n      f.prototype.unsquish = function () {\n        var a = this.options.labels,\n            b = this.horiz,\n            e = this.tickInterval,\n            g = e,\n            h = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / e),\n            d,\n            f = a.rotation,\n            m = this.labelMetrics(),\n            w,\n            n = Number.MAX_VALUE,\n            r,\n            l = Math.max(this.max - this.min, 0),\n            q = function (a) {\n          var b = a / (h || 1);\n          b = 1 < b ? Math.ceil(b) : 1;\n          b * e > l && Infinity !== a && Infinity !== h && l && (b = Math.ceil(l / e));\n          return y(b * e);\n        };\n\n        b ? (r = !a.staggerLines && !a.step && (c(f) ? [f] : h < F(a.autoRotationLimit, 80) && a.autoRotation)) && r.forEach(function (a) {\n          if (a === f || a && -90 <= a && 90 >= a) {\n            w = q(Math.abs(m.h / Math.sin(v * a)));\n            var b = w + Math.abs(a / 360);\n            b < n && (n = b, d = a, g = w);\n          }\n        }) : a.step || (g = q(m.h));\n        this.autoRotation = r;\n        this.labelRotation = F(d, f);\n        return g;\n      };\n\n      f.prototype.getSlotWidth = function (b) {\n        var e,\n            c = this.chart,\n            g = this.horiz,\n            h = this.options.labels,\n            d = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            p = c.margin[3];\n        if (b && a(b.slotWidth)) return b.slotWidth;\n        if (g && h && 2 > (h.step || 0)) return h.rotation ? 0 : (this.staggerLines || 1) * this.len / d;\n\n        if (!g) {\n          b = null === (e = null === h || void 0 === h ? void 0 : h.style) || void 0 === e ? void 0 : e.width;\n          if (void 0 !== b) return parseInt(b, 10);\n          if (p) return p - c.spacing[3];\n        }\n\n        return .33 * c.chartWidth;\n      };\n\n      f.prototype.renderUnsquish = function () {\n        var a = this.chart,\n            e = a.renderer,\n            c = this.tickPositions,\n            g = this.ticks,\n            h = this.options.labels,\n            d = h && h.style || {},\n            f = this.horiz,\n            m = this.getSlotWidth(),\n            w = Math.max(1, Math.round(m - 2 * (h.padding || 5))),\n            n = {},\n            r = this.labelMetrics(),\n            l = h.style && h.style.textOverflow,\n            q = 0;\n        b(h.rotation) || (n.rotation = h.rotation || 0);\n        c.forEach(function (a) {\n          a = g[a];\n          a.movedLabel && a.replaceMovedLabel();\n          a && a.label && a.label.textPxLength > q && (q = a.label.textPxLength);\n        });\n        this.maxLabelLength = q;\n        if (this.autoRotation) q > w && q > r.h ? n.rotation = this.labelRotation : this.labelRotation = 0;else if (m) {\n          var J = w;\n\n          if (!l) {\n            var F = \"clip\";\n\n            for (w = c.length; !f && w--;) {\n              var v = c[w];\n              if (v = g[v].label) v.styles && \"ellipsis\" === v.styles.textOverflow ? v.css({\n                textOverflow: \"clip\"\n              }) : v.textPxLength > m && v.css({\n                width: m + \"px\"\n              }), v.getBBox().height > this.len / c.length - (r.h - r.f) && (v.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        n.rotation && (J = q > .5 * a.chartHeight ? .33 * a.chartHeight : q, l || (F = \"ellipsis\"));\n        if (this.labelAlign = h.align || this.autoLabelAlign(this.labelRotation)) n.align = this.labelAlign;\n        c.forEach(function (a) {\n          var b = (a = g[a]) && a.label,\n              e = d.width,\n              c = {};\n          b && (b.attr(n), a.shortenLabel ? a.shortenLabel() : J && !e && \"nowrap\" !== d.whiteSpace && (J < b.textPxLength || \"SPAN\" === b.element.tagName) ? (c.width = J + \"px\", l || (c.textOverflow = b.specificTextOverflow || F), b.css(c)) : b.styles && b.styles.width && !c.width && !e && b.css({\n            width: null\n          }), delete b.specificTextOverflow, a.rotation = n.rotation);\n        }, this);\n        this.tickRotCorr = e.rotCorr(r.b, this.labelRotation || 0, 0 !== this.side);\n      };\n\n      f.prototype.hasData = function () {\n        return this.series.some(function (a) {\n          return a.hasData();\n        }) || this.options.showEmpty && c(this.min) && c(this.max);\n      };\n\n      f.prototype.addTitle = function (a) {\n        var b = this.chart.renderer,\n            e = this.horiz,\n            c = this.opposite,\n            g = this.options.title,\n            h,\n            d = this.chart.styledMode;\n        this.axisTitle || ((h = g.textAlign) || (h = (e ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: c ? \"right\" : \"left\",\n          middle: \"center\",\n          high: c ? \"left\" : \"right\"\n        })[g.align]), this.axisTitle = b.text(g.text, 0, 0, g.useHTML).attr({\n          zIndex: 7,\n          rotation: g.rotation || 0,\n          align: h\n        }).addClass(\"highcharts-axis-title\"), d || this.axisTitle.css(w(g.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        d || g.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](a);\n      };\n\n      f.prototype.generateTick = function (a) {\n        var b = this.ticks;\n        b[a] ? b[a].addLabel() : b[a] = new G(this, a);\n      };\n\n      f.prototype.getOffset = function () {\n        var a = this,\n            b = this,\n            e = b.chart,\n            g = e.renderer,\n            h = b.options,\n            d = b.tickPositions,\n            f = b.ticks,\n            m = b.horiz,\n            w = b.side,\n            n = e.inverted && !b.isZAxis ? [1, 0, 3, 2][w] : w,\n            r,\n            l = 0,\n            q = 0,\n            J = h.title,\n            v = h.labels,\n            N = 0,\n            V = e.axisOffset;\n        e = e.clipOffset;\n        var Z = [-1, 1, 1, -1][w],\n            k = h.className,\n            t = b.axisParent;\n        var y = b.hasData();\n        b.showAxis = r = y || F(h.showEmpty, !0);\n        b.staggerLines = b.horiz && v.staggerLines;\n\n        if (!b.axisGroup) {\n          var A = function (b, e, c) {\n            return g.g(b).attr({\n              zIndex: c\n            }).addClass(\"highcharts-\" + a.coll.toLowerCase() + e + \" \" + (a.isRadial ? \"highcharts-radial-axis\" + e + \" \" : \"\") + (k || \"\")).add(t);\n          };\n\n          b.gridGroup = A(\"grid\", \"-grid\", h.gridZIndex || 1);\n          b.axisGroup = A(\"axis\", \"\", h.zIndex || 2);\n          b.labelGroup = A(\"axis-labels\", \"-labels\", v.zIndex || 7);\n        }\n\n        y || b.isLinked ? (d.forEach(function (a, e) {\n          b.generateTick(a, e);\n        }), b.renderUnsquish(), b.reserveSpaceDefault = 0 === w || 2 === w || {\n          1: \"left\",\n          3: \"right\"\n        }[w] === b.labelAlign, F(v.reserveSpace, \"center\" === b.labelAlign ? !0 : null, b.reserveSpaceDefault) && d.forEach(function (a) {\n          N = Math.max(f[a].getLabelSize(), N);\n        }), b.staggerLines && (N *= b.staggerLines), b.labelOffset = N * (b.opposite ? -1 : 1)) : O(f, function (a, b) {\n          a.destroy();\n          delete f[b];\n        });\n\n        if (J && J.text && !1 !== J.enabled && (b.addTitle(r), r && !1 !== J.reserveSpace)) {\n          b.titleOffset = l = b.axisTitle.getBBox()[m ? \"height\" : \"width\"];\n          var R = J.offset;\n          q = c(R) ? 0 : F(J.margin, m ? 5 : 10);\n        }\n\n        b.renderLine();\n        b.offset = Z * F(h.offset, V[w] ? V[w] + (h.margin || 0) : 0);\n        b.tickRotCorr = b.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        J = 0 === w ? -b.labelMetrics().h : 2 === w ? b.tickRotCorr.y : 0;\n        q = Math.abs(N) + q;\n        N && (q = q - J + Z * (m ? F(v.y, b.tickRotCorr.y + 8 * Z) : v.x));\n        b.axisTitleMargin = F(R, q);\n        b.getMaxLabelDimensions && (b.maxLabelDimensions = b.getMaxLabelDimensions(f, d));\n        m = this.tickSize(\"tick\");\n        V[w] = Math.max(V[w], b.axisTitleMargin + l + Z * b.offset, q, d && d.length && m ? m[0] + Z * b.offset : 0);\n        h = h.offset ? 0 : 2 * Math.floor(b.axisLine.strokeWidth() / 2);\n        e[n] = Math.max(e[n], h);\n        z(this, \"afterGetOffset\");\n      };\n\n      f.prototype.getLinePath = function (a) {\n        var b = this.chart,\n            e = this.opposite,\n            c = this.offset,\n            g = this.horiz,\n            h = this.left + (e ? this.width : 0) + c;\n        c = b.chartHeight - this.bottom - (e ? this.height : 0) + c;\n        e && (a *= -1);\n        return b.renderer.crispLine([[\"M\", g ? this.left : h, g ? c : this.top], [\"L\", g ? b.chartWidth - this.right : h, g ? c : b.chartHeight - this.bottom]], a);\n      };\n\n      f.prototype.renderLine = function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      };\n\n      f.prototype.getTitlePosition = function () {\n        var a = this.horiz,\n            b = this.left,\n            e = this.top,\n            c = this.len,\n            g = this.options.title,\n            h = a ? b : e,\n            d = this.opposite,\n            f = this.offset,\n            m = g.x || 0,\n            w = g.y || 0,\n            n = this.axisTitle,\n            r = this.chart.renderer.fontMetrics(g.style && g.style.fontSize, n);\n        n = Math.max(n.getBBox(null, 0).height - r.h - 1, 0);\n        c = {\n          low: h + (a ? 0 : c),\n          middle: h + c / 2,\n          high: h + (a ? c : 0)\n        }[g.align];\n        b = (a ? e + this.height : b) + (a ? 1 : -1) * (d ? -1 : 1) * this.axisTitleMargin + [-n, n, r.f, -n][this.side];\n        a = {\n          x: a ? c + m : b + (d ? this.width : 0) + f + m,\n          y: a ? b + w - (d ? this.height : 0) + f : c + w\n        };\n        z(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      };\n\n      f.prototype.renderMinorTick = function (a) {\n        var b = this.chart.hasRendered && this.old,\n            e = this.minorTicks;\n        e[a] || (e[a] = new G(this, a, \"minor\"));\n        b && e[a].isNew && e[a].render(null, !0);\n        e[a].render(null, !1, 1);\n      };\n\n      f.prototype.renderTick = function (a, b) {\n        var e,\n            c = this.ticks,\n            g = this.chart.hasRendered && this.old;\n        if (!this.isLinked || a >= this.min && a <= this.max || (null === (e = this.grid) || void 0 === e ? 0 : e.isColumn)) c[a] || (c[a] = new G(this, a)), g && c[a].isNew && c[a].render(b, !0, -1), c[a].render(b);\n      };\n\n      f.prototype.render = function () {\n        var b = this,\n            e = b.chart,\n            c = b.logarithmic,\n            g = b.options,\n            h = b.isLinked,\n            d = b.tickPositions,\n            f = b.axisTitle,\n            m = b.ticks,\n            w = b.minorTicks,\n            n = b.alternateBands,\n            r = g.stackLabels,\n            q = g.alternateGridColor,\n            l = b.tickmarkOffset,\n            J = b.axisLine,\n            F = b.showAxis,\n            v = H(e.renderer.globalAnimation),\n            V,\n            N;\n        b.labelEdge.length = 0;\n        b.overlap = !1;\n        [m, w, n].forEach(function (a) {\n          O(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n        if (b.hasData() || h) b.minorTickInterval && !b.categories && b.getMinorTickPositions().forEach(function (a) {\n          b.renderMinorTick(a);\n        }), d.length && (d.forEach(function (a, e) {\n          b.renderTick(a, e);\n        }), l && (0 === b.min || b.single) && (m[-1] || (m[-1] = new G(b, -1, null, !0)), m[-1].render(-1))), q && d.forEach(function (a, g) {\n          N = \"undefined\" !== typeof d[g + 1] ? d[g + 1] + l : b.max - l;\n          0 === g % 2 && a < b.max && N <= b.max + (e.polar ? -l : l) && (n[a] || (n[a] = new k.PlotLineOrBand(b)), V = a + l, n[a].options = {\n            from: c ? c.lin2log(V) : V,\n            to: c ? c.lin2log(N) : N,\n            color: q,\n            className: \"highcharts-alternate-grid\"\n          }, n[a].render(), n[a].isActive = !0);\n        }), b._addedPlotLB || (b._addedPlotLB = !0, (g.plotLines || []).concat(g.plotBands || []).forEach(function (a) {\n          b.addPlotBandOrLine(a);\n        }));\n        [m, w, n].forEach(function (a) {\n          var b,\n              c = [],\n              g = v.duration;\n          O(a, function (a, b) {\n            a.isActive || (a.render(b, !1, 0), a.isActive = !1, c.push(b));\n          });\n          T(function () {\n            for (b = c.length; b--;) a[c[b]] && !a[c[b]].isActive && (a[c[b]].destroy(), delete a[c[b]]);\n          }, a !== n && e.hasRendered && g ? g : 0);\n        });\n        J && (J[J.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(J.strokeWidth())\n        }), J.isPlaced = !0, J[F ? \"show\" : \"hide\"](F));\n        f && F && (g = b.getTitlePosition(), a(g.y) ? (f[f.isNew ? \"attr\" : \"animate\"](g), f.isNew = !1) : (f.attr(\"y\", -9999), f.isNew = !0));\n        r && r.enabled && b.stacking && b.stacking.renderStackTotals();\n        b.old = {\n          len: b.len,\n          max: b.max,\n          min: b.min,\n          transA: b.transA,\n          userMax: b.userMax,\n          userMin: b.userMin\n        };\n        b.isDirty = !1;\n        z(this, \"afterRender\");\n      };\n\n      f.prototype.redraw = function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      };\n\n      f.prototype.getKeepProps = function () {\n        return this.keepProps || f.keepProps;\n      };\n\n      f.prototype.destroy = function (a) {\n        var b = this,\n            e = b.plotLinesAndBands,\n            c;\n        z(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || R(b);\n        [b.ticks, b.minorTicks, b.alternateBands].forEach(function (a) {\n          q(a);\n        });\n        if (e) for (a = e.length; a--;) e[a].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          b[a] && (b[a] = b[a].destroy());\n        });\n\n        for (c in b.plotLinesAndBandsGroups) b.plotLinesAndBandsGroups[c] = b.plotLinesAndBandsGroups[c].destroy();\n\n        O(b, function (a, e) {\n          -1 === b.getKeepProps().indexOf(e) && delete b[e];\n        });\n      };\n\n      f.prototype.drawCrosshair = function (a, b) {\n        var e = this.crosshair,\n            g = F(e.snap, !0),\n            h,\n            f = this.cross,\n            m = this.chart;\n        z(this, \"drawCrosshair\", {\n          e: a,\n          point: b\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (this.crosshair && !1 !== (c(b) || !g)) {\n          g ? c(b) && (h = F(\"colorAxis\" !== this.coll ? b.crosshairPos : null, this.isXAxis ? b.plotX : this.len - b.plotY)) : h = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n\n          if (c(h)) {\n            var p = {\n              value: b && (this.isXAxis ? b.x : F(b.stackY, b.y)),\n              translatedValue: h\n            };\n            m.polar && M(p, {\n              isCrosshair: !0,\n              chartX: a && a.chartX,\n              chartY: a && a.chartY,\n              point: b\n            });\n            p = this.getPlotLinePath(p) || null;\n          }\n\n          if (!c(p)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          g = this.categories && !this.isRadial;\n          f || (this.cross = f = m.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (g ? \"category \" : \"thin \") + e.className).attr({\n            zIndex: F(e.zIndex, 2)\n          }).add(), m.styledMode || (f.attr({\n            stroke: e.color || (g ? d.parse(x.highlightColor20).setOpacity(.25).get() : x.neutralColor20),\n            \"stroke-width\": F(e.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), e.dashStyle && f.attr({\n            dashstyle: e.dashStyle\n          })));\n          f.show().attr({\n            d: p\n          });\n          g && !e.width && f.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        z(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: b\n        });\n      };\n\n      f.prototype.hideCrosshair = function () {\n        this.cross && this.cross.hide();\n        z(this, \"afterHideCrosshair\");\n      };\n\n      f.prototype.hasVerticalPanning = function () {\n        var a,\n            b = null === (a = this.chart.options.chart) || void 0 === a ? void 0 : a.panning;\n        return !!(b && b.enabled && /y/.test(b.type));\n      };\n\n      f.prototype.validatePositiveValue = function (b) {\n        return a(b) && 0 < b;\n      };\n\n      f.prototype.update = function (a, b) {\n        var e = this.chart,\n            c = a && a.events || {};\n        a = w(this.userOptions, a);\n        e.options[this.coll].indexOf && (e.options[this.coll][e.options[this.coll].indexOf(this.userOptions)] = a);\n        O(e.options[this.coll].events, function (a, b) {\n          \"undefined\" === typeof c[b] && (c[b] = void 0);\n        });\n        this.destroy(!0);\n        this.init(e, M(a, {\n          events: c\n        }));\n        e.isDirtyBox = !0;\n        F(b, !0) && e.redraw();\n      };\n\n      f.prototype.remove = function (a) {\n        for (var b = this.chart, c = this.coll, g = this.series, h = g.length; h--;) g[h] && g[h].remove(!1);\n\n        n(b.axes, this);\n        n(b[c], this);\n        e(b.options[c]) ? b.options[c].splice(this.options.index, 1) : delete b.options[c];\n        b[c].forEach(function (a, b) {\n          a.options.index = a.userOptions.index = b;\n        });\n        this.destroy();\n        b.isDirtyBox = !0;\n        F(a, !0) && b.redraw();\n      };\n\n      f.prototype.setTitle = function (a, b) {\n        this.update({\n          title: a\n        }, b);\n      };\n\n      f.prototype.setCategories = function (a, b) {\n        this.update({\n          categories: a\n        }, b);\n      };\n\n      f.defaultOptions = {\n        dateTimeLabelFormats: {\n          millisecond: {\n            main: \"%H:%M:%S.%L\",\n            range: !1\n          },\n          second: {\n            main: \"%H:%M:%S\",\n            range: !1\n          },\n          minute: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          hour: {\n            main: \"%H:%M\",\n            range: !1\n          },\n          day: {\n            main: \"%e. %b\"\n          },\n          week: {\n            main: \"%e. %b\"\n          },\n          month: {\n            main: \"%b '%y\"\n          },\n          year: {\n            main: \"%Y\"\n          }\n        },\n        endOnTick: !1,\n        labels: {\n          enabled: !0,\n          indentation: 10,\n          x: 0,\n          style: {\n            color: x.neutralColor60,\n            cursor: \"default\",\n            fontSize: \"11px\"\n          }\n        },\n        maxPadding: .01,\n        minorTickLength: 2,\n        minorTickPosition: \"outside\",\n        minPadding: .01,\n        showEmpty: !0,\n        startOfWeek: 1,\n        startOnTick: !1,\n        tickLength: 10,\n        tickPixelInterval: 100,\n        tickmarkPlacement: \"between\",\n        tickPosition: \"outside\",\n        title: {\n          align: \"middle\",\n          style: {\n            color: x.neutralColor60\n          }\n        },\n        type: \"linear\",\n        minorGridLineColor: x.neutralColor5,\n        minorGridLineWidth: 1,\n        minorTickColor: x.neutralColor40,\n        lineColor: x.highlightColor20,\n        lineWidth: 1,\n        gridLineColor: x.neutralColor10,\n        tickColor: x.highlightColor20\n      };\n      f.defaultYAxisOptions = {\n        endOnTick: !0,\n        maxPadding: .05,\n        minPadding: .05,\n        tickPixelInterval: 72,\n        showLastLabel: !0,\n        labels: {\n          x: -8\n        },\n        startOnTick: !0,\n        title: {\n          rotation: 270,\n          text: \"Values\"\n        },\n        stackLabels: {\n          animation: {},\n          allowOverlap: !1,\n          enabled: !1,\n          crop: !0,\n          overflow: \"justify\",\n          formatter: function () {\n            var a = this.axis.chart.numberFormatter;\n            return a(this.total, -1);\n          },\n          style: {\n            color: x.neutralColor100,\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            textOutline: \"1px contrast\"\n          }\n        },\n        gridLineWidth: 1,\n        lineWidth: 0\n      };\n      f.defaultLeftAxisOptions = {\n        labels: {\n          x: -15\n        },\n        title: {\n          rotation: 270\n        }\n      };\n      f.defaultRightAxisOptions = {\n        labels: {\n          x: 15\n        },\n        title: {\n          rotation: 90\n        }\n      };\n      f.defaultBottomAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      f.defaultTopAxisOptions = {\n        labels: {\n          autoRotation: [-45],\n          x: 0\n        },\n        margin: 15,\n        title: {\n          rotation: 0\n        }\n      };\n      f.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n      return f;\n    }();\n\n    k.Axis = f;\n    return k.Axis;\n  });\n  P(k, \"Core/Axis/DateTimeAxis.js\", [k[\"Core/Axis/Axis.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = d.addEvent,\n        x = d.getMagnitude,\n        B = d.normalizeTickInterval,\n        G = d.timeUnits,\n        D = function () {\n      function d(d) {\n        this.axis = d;\n      }\n\n      d.prototype.normalizeTimeTickInterval = function (d, f) {\n        var l = f || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n        f = l[l.length - 1];\n        var k = G[f[0]],\n            g = f[1],\n            t;\n\n        for (t = 0; t < l.length && !(f = l[t], k = G[f[0]], g = f[1], l[t + 1] && d <= (k * g[g.length - 1] + G[l[t + 1][0]]) / 2); t++);\n\n        k === G.year && d < 5 * k && (g = [1, 2, 5]);\n        d = B(d / k, g, \"year\" === f[0] ? Math.max(x(d / k), 1) : 1);\n        return {\n          unitRange: k,\n          count: d,\n          unitName: f[0]\n        };\n      };\n\n      return d;\n    }();\n\n    d = function () {\n      function d() {}\n\n      d.compose = function (d) {\n        d.keepProps.push(\"dateTime\");\n\n        d.prototype.getTimeTicks = function () {\n          return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n        };\n\n        k(d, \"init\", function (d) {\n          \"datetime\" !== d.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new D(this));\n        });\n      };\n\n      d.AdditionsClass = D;\n      return d;\n    }();\n\n    d.compose(f);\n    return d;\n  });\n  P(k, \"Core/Axis/LogarithmicAxis.js\", [k[\"Core/Axis/Axis.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = d.addEvent,\n        x = d.getMagnitude,\n        B = d.normalizeTickInterval,\n        G = d.pick,\n        D = function () {\n      function d(d) {\n        this.axis = d;\n      }\n\n      d.prototype.getLogTickPositions = function (d, f, l, k) {\n        var g = this.axis,\n            y = g.len,\n            c = g.options,\n            q = [];\n        k || (this.minorAutoInterval = void 0);\n        if (.5 <= d) d = Math.round(d), q = g.getLinearTickPositions(d, f, l);else if (.08 <= d) {\n          c = Math.floor(f);\n          var n, A;\n\n          for (y = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; c < l + 1 && !A; c++) {\n            var t = y.length;\n\n            for (n = 0; n < t && !A; n++) {\n              var z = this.log2lin(this.lin2log(c) * y[n]);\n              z > f && (!k || m <= l) && \"undefined\" !== typeof m && q.push(m);\n              m > l && (A = !0);\n              var m = z;\n            }\n          }\n        } else f = this.lin2log(f), l = this.lin2log(l), d = k ? g.getMinorTickInterval() : c.tickInterval, d = G(\"auto\" === d ? null : d, this.minorAutoInterval, c.tickPixelInterval / (k ? 5 : 1) * (l - f) / ((k ? y / g.tickPositions.length : y) || 1)), d = B(d, void 0, x(d)), q = g.getLinearTickPositions(d, f, l).map(this.log2lin), k || (this.minorAutoInterval = d / 5);\n        k || (g.tickInterval = d);\n        return q;\n      };\n\n      d.prototype.lin2log = function (d) {\n        return Math.pow(10, d);\n      };\n\n      d.prototype.log2lin = function (d) {\n        return Math.log(d) / Math.LN10;\n      };\n\n      return d;\n    }();\n\n    d = function () {\n      function d() {}\n\n      d.compose = function (d) {\n        d.keepProps.push(\"logarithmic\");\n        k(d, \"init\", function (d) {\n          var f = this.logarithmic;\n          \"logarithmic\" !== d.userOptions.type ? this.logarithmic = void 0 : f || (this.logarithmic = new D(this));\n        });\n        k(d, \"afterInit\", function () {\n          var d = this.logarithmic;\n          d && (this.lin2val = function (f) {\n            return d.lin2log(f);\n          }, this.val2lin = function (f) {\n            return d.log2lin(f);\n          });\n        });\n      };\n\n      return d;\n    }();\n\n    d.compose(f);\n    return d;\n  });\n  P(k, \"Core/Axis/PlotLineOrBand.js\", [k[\"Core/Axis/Axis.js\"], k[\"Core/Globals.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x) {\n    var B = x.arrayMax,\n        G = x.arrayMin,\n        D = x.defined,\n        H = x.destroyObjectProperties,\n        t = x.erase,\n        C = x.extend,\n        l = x.fireEvent,\n        E = x.merge,\n        g = x.objectEach,\n        y = x.pick;\n\n    x = function () {\n      function c(c, g) {\n        this.axis = c;\n        g && (this.options = g, this.id = g.id);\n      }\n\n      c.prototype.render = function () {\n        l(this, \"render\");\n        var c = this,\n            d = c.axis,\n            f = d.horiz,\n            t = d.logarithmic,\n            z = c.options,\n            m = z.label,\n            r = c.label,\n            e = z.to,\n            h = z.from,\n            a = z.value,\n            b = D(h) && D(e),\n            w = D(a),\n            J = c.svgElem,\n            O = !J,\n            F = [],\n            N = z.color,\n            R = y(z.zIndex, 0),\n            Q = z.events;\n        F = {\n          \"class\": \"highcharts-plot-\" + (b ? \"band \" : \"line \") + (z.className || \"\")\n        };\n        var C = {},\n            v = d.chart.renderer,\n            x = b ? \"bands\" : \"lines\";\n        t && (h = t.log2lin(h), e = t.log2lin(e), a = t.log2lin(a));\n        d.chart.styledMode || (w ? (F.stroke = N || k.neutralColor40, F[\"stroke-width\"] = y(z.width, 1), z.dashStyle && (F.dashstyle = z.dashStyle)) : b && (F.fill = N || k.highlightColor10, z.borderWidth && (F.stroke = z.borderColor, F[\"stroke-width\"] = z.borderWidth)));\n        C.zIndex = R;\n        x += \"-\" + R;\n        (t = d.plotLinesAndBandsGroups[x]) || (d.plotLinesAndBandsGroups[x] = t = v.g(\"plot-\" + x).attr(C).add());\n        O && (c.svgElem = J = v.path().attr(F).add(t));\n        if (w) F = d.getPlotLinePath({\n          value: a,\n          lineWidth: J.strokeWidth(),\n          acrossPanes: z.acrossPanes\n        });else if (b) F = d.getPlotBandPath(h, e, z);else return;\n        !c.eventsAdded && Q && (g(Q, function (a, b) {\n          J.on(b, function (a) {\n            Q[b].apply(c, [a]);\n          });\n        }), c.eventsAdded = !0);\n        (O || !J.d) && F && F.length ? J.attr({\n          d: F\n        }) : J && (F ? (J.show(!0), J.animate({\n          d: F\n        })) : J.d && (J.hide(), r && (c.label = r = r.destroy())));\n        m && (D(m.text) || D(m.formatter)) && F && F.length && 0 < d.width && 0 < d.height && !F.isFlat ? (m = E({\n          align: f && b && \"center\",\n          x: f ? !b && 4 : 10,\n          verticalAlign: !f && b && \"middle\",\n          y: f ? b ? 16 : 10 : b ? 6 : -4,\n          rotation: f && !b && 90\n        }, m), this.renderLabel(m, F, b, R)) : r && r.hide();\n        return c;\n      };\n\n      c.prototype.renderLabel = function (c, g, d, f) {\n        var n = this.label,\n            m = this.axis.chart.renderer;\n        n || (n = {\n          align: c.textAlign || c.align,\n          rotation: c.rotation,\n          \"class\": \"highcharts-plot-\" + (d ? \"band\" : \"line\") + \"-label \" + (c.className || \"\")\n        }, n.zIndex = f, f = this.getLabelText(c), this.label = n = m.text(f, 0, 0, c.useHTML).attr(n).add(), this.axis.chart.styledMode || n.css(c.style));\n        m = g.xBounds || [g[0][1], g[1][1], d ? g[2][1] : g[0][1]];\n        g = g.yBounds || [g[0][2], g[1][2], d ? g[2][2] : g[0][2]];\n        d = G(m);\n        f = G(g);\n        n.align(c, !1, {\n          x: d,\n          y: f,\n          width: B(m) - d,\n          height: B(g) - f\n        });\n        n.show(!0);\n      };\n\n      c.prototype.getLabelText = function (c) {\n        return D(c.formatter) ? c.formatter.call(this) : c.text;\n      };\n\n      c.prototype.destroy = function () {\n        t(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        H(this);\n      };\n\n      return c;\n    }();\n\n    C(f.prototype, {\n      getPlotBandPath: function (c, g, d) {\n        void 0 === d && (d = this.options);\n        var f = this.getPlotLinePath({\n          value: g,\n          force: !0,\n          acrossPanes: d.acrossPanes\n        });\n        d = this.getPlotLinePath({\n          value: c,\n          force: !0,\n          acrossPanes: d.acrossPanes\n        });\n        var n = [],\n            l = this.horiz,\n            m = 1;\n        c = c < this.min && g < this.min || c > this.max && g > this.max;\n\n        if (d && f) {\n          if (c) {\n            var r = d.toString() === f.toString();\n            m = 0;\n          }\n\n          for (c = 0; c < d.length; c += 2) {\n            g = d[c];\n            var e = d[c + 1],\n                h = f[c],\n                a = f[c + 1];\n            \"M\" !== g[0] && \"L\" !== g[0] || \"M\" !== e[0] && \"L\" !== e[0] || \"M\" !== h[0] && \"L\" !== h[0] || \"M\" !== a[0] && \"L\" !== a[0] || (l && h[1] === g[1] ? (h[1] += m, a[1] += m) : l || h[2] !== g[2] || (h[2] += m, a[2] += m), n.push([\"M\", g[1], g[2]], [\"L\", e[1], e[2]], [\"L\", a[1], a[2]], [\"L\", h[1], h[2]], [\"Z\"]));\n            n.isFlat = r;\n          }\n        }\n\n        return n;\n      },\n      addPlotBand: function (c) {\n        return this.addPlotBandOrLine(c, \"plotBands\");\n      },\n      addPlotLine: function (c) {\n        return this.addPlotBandOrLine(c, \"plotLines\");\n      },\n      addPlotBandOrLine: function (c, g) {\n        var f = this,\n            l = new d.PlotLineOrBand(this, c),\n            q = this.userOptions;\n        this.visible && (l = l.render());\n\n        if (l) {\n          this._addedPlotLB || (this._addedPlotLB = !0, (q.plotLines || []).concat(q.plotBands || []).forEach(function (c) {\n            f.addPlotBandOrLine(c);\n          }));\n\n          if (g) {\n            var k = q[g] || [];\n            k.push(c);\n            q[g] = k;\n          }\n\n          this.plotLinesAndBands.push(l);\n        }\n\n        return l;\n      },\n      removePlotBandOrLine: function (c) {\n        for (var g = this.plotLinesAndBands, d = this.options, f = this.userOptions, l = g.length; l--;) g[l].id === c && g[l].destroy();\n\n        [d.plotLines || [], f.plotLines || [], d.plotBands || [], f.plotBands || []].forEach(function (g) {\n          for (l = g.length; l--;) (g[l] || {}).id === c && t(g, g[l]);\n        });\n      },\n      removePlotBand: function (c) {\n        this.removePlotBandOrLine(c);\n      },\n      removePlotLine: function (c) {\n        this.removePlotBandOrLine(c);\n      }\n    });\n    d.PlotLineOrBand = x;\n    return d.PlotLineOrBand;\n  });\n  P(k, \"Core/Tooltip.js\", [k[\"Core/Globals.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Utilities.js\"]], function (f, d, k) {\n    var x = f.doc,\n        B = k.clamp,\n        G = k.css,\n        D = k.defined,\n        H = k.discardElement,\n        t = k.extend,\n        C = k.fireEvent,\n        l = k.format,\n        E = k.isNumber,\n        g = k.isString,\n        y = k.merge,\n        c = k.pick,\n        q = k.splat,\n        n = k.syncTimeout,\n        A = k.timeUnits;\n    \"\";\n\n    var M = function () {\n      function z(c, g) {\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = c;\n        this.init(c, g);\n      }\n\n      z.prototype.applyFilter = function () {\n        var c = this.chart;\n        c.renderer.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: \"drop-shadow-\" + c.index,\n            opacity: .5\n          },\n          children: [{\n            tagName: \"feGaussianBlur\",\n            attributes: {\n              \"in\": \"SourceAlpha\",\n              stdDeviation: 1\n            }\n          }, {\n            tagName: \"feOffset\",\n            attributes: {\n              dx: 1,\n              dy: 1\n            }\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              attributes: {\n                type: \"linear\",\n                slope: .3\n              }\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              attributes: {\n                \"in\": \"SourceGraphic\"\n              }\n            }]\n          }]\n        });\n        c.renderer.definition({\n          tagName: \"style\",\n          textContent: \".highcharts-tooltip-\" + c.index + \"{filter:url(#drop-shadow-\" + c.index + \")}\"\n        });\n      };\n\n      z.prototype.bodyFormatter = function (c) {\n        return c.map(function (c) {\n          var e = c.series.tooltipOptions;\n          return (e[(c.point.formatPrefix || \"point\") + \"Formatter\"] || c.point.tooltipFormatter).call(c.point, e[(c.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      z.prototype.cleanSplit = function (c) {\n        this.chart.series.forEach(function (g) {\n          var e = g && g.tt;\n          e && (!e.isActive || c ? g.tt = e.destroy() : e.isActive = !1);\n        });\n      };\n\n      z.prototype.defaultFormatter = function (c) {\n        var g = this.points || q(this);\n        var e = [c.tooltipFooterHeaderFormatter(g[0])];\n        e = e.concat(c.bodyFormatter(g));\n        e.push(c.tooltipFooterHeaderFormatter(g[0], !0));\n        return e;\n      };\n\n      z.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(this.chart, !0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), H(this.container));\n        k.clearTimeout(this.hideTimer);\n        k.clearTimeout(this.tooltipTimeout);\n      };\n\n      z.prototype.getAnchor = function (c, g) {\n        var e = this.chart;\n        var d = e.pointer;\n        var a = e.inverted,\n            b = e.plotTop,\n            f = e.plotLeft,\n            m = 0,\n            n = 0,\n            l,\n            r;\n        c = q(c);\n        this.followPointer && g ? (\"undefined\" === typeof g.chartX && (g = d.normalize(g)), d = [g.chartX - f, g.chartY - b]) : c[0].tooltipPos ? d = c[0].tooltipPos : (c.forEach(function (c) {\n          l = c.series.yAxis;\n          r = c.series.xAxis;\n          m += c.plotX || 0;\n          n += c.plotLow ? (c.plotLow + (c.plotHigh || 0)) / 2 : c.plotY || 0;\n          r && l && (a ? (m += b + e.plotHeight - r.len - r.pos, n += f + e.plotWidth - l.len - l.pos) : (m += r.pos - f, n += l.pos - b));\n        }), m /= c.length, n /= c.length, d = [a ? e.plotWidth - n : m, a ? e.plotHeight - m : n], this.shared && 1 < c.length && g && (a ? d[0] = g.chartX - f : d[1] = g.chartY - b));\n        return d.map(Math.round);\n      };\n\n      z.prototype.getDateFormat = function (c, g, e, d) {\n        var a = this.chart.time,\n            b = a.dateFormat(\"%m-%d %H:%M:%S.%L\", g),\n            h = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            f = \"millisecond\";\n\n        for (m in A) {\n          if (c === A.week && +a.dateFormat(\"%w\", g) === e && \"00:00:00.000\" === b.substr(6)) {\n            var m = \"week\";\n            break;\n          }\n\n          if (A[m] > c) {\n            m = f;\n            break;\n          }\n\n          if (h[m] && b.substr(h[m]) !== \"01-01 00:00:00.000\".substr(h[m])) break;\n          \"week\" !== m && (f = m);\n        }\n\n        if (m) var n = a.resolveDTLFormat(d[m]).main;\n        return n;\n      };\n\n      z.prototype.getLabel = function () {\n        var c,\n            g,\n            e,\n            d = this,\n            a = this.chart.renderer,\n            b = this.chart.styledMode,\n            w = this.options,\n            n = \"tooltip\" + (D(w.className) ? \" \" + w.className : \"\"),\n            l = (null === (c = w.style) || void 0 === c ? void 0 : c.pointerEvents) || (!this.followPointer && w.stickOnContact ? \"auto\" : \"none\"),\n            q;\n\n        c = function () {\n          d.inContact = !0;\n        };\n\n        var k = function () {\n          var a = d.chart.hoverSeries;\n          d.inContact = !1;\n          if (a && a.onMouseOut) a.onMouseOut();\n        };\n\n        if (!this.label) {\n          if (this.outside) {\n            var t = null === (g = this.chart.options.chart) || void 0 === g ? void 0 : g.style;\n            this.container = q = f.doc.createElement(\"div\");\n            q.className = \"highcharts-tooltip-container\";\n            G(q, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: l,\n              zIndex: Math.max((null === (e = this.options.style) || void 0 === e ? void 0 : e.zIndex) || 0, ((null === t || void 0 === t ? void 0 : t.zIndex) || 0) + 3)\n            });\n            f.doc.body.appendChild(q);\n            this.renderer = a = new f.Renderer(q, 0, 0, t, void 0, void 0, a.styledMode);\n          }\n\n          this.split ? this.label = a.g(n) : (this.label = a.label(\"\", 0, 0, w.shape || \"callout\", null, null, w.useHTML, null, n).attr({\n            padding: w.padding,\n            r: w.borderRadius\n          }), b || this.label.attr({\n            fill: w.backgroundColor,\n            \"stroke-width\": w.borderWidth\n          }).css(w.style).css({\n            pointerEvents: l\n          }).shadow(w.shadow));\n          b && (this.applyFilter(), this.label.addClass(\"highcharts-tooltip-\" + this.chart.index));\n\n          if (d.outside && !d.split) {\n            var y = this.label,\n                z = y.xSetter,\n                v = y.ySetter;\n\n            y.xSetter = function (a) {\n              z.call(y, d.distance);\n              q.style.left = a + \"px\";\n            };\n\n            y.ySetter = function (a) {\n              v.call(y, d.distance);\n              q.style.top = a + \"px\";\n            };\n          }\n\n          this.label.on(\"mouseenter\", c).on(\"mouseleave\", k).attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      z.prototype.getPosition = function (g, d, e) {\n        var h = this.chart,\n            a = this.distance,\n            b = {},\n            f = h.inverted && e.h || 0,\n            m,\n            n = this.outside,\n            l = n ? x.documentElement.clientWidth - 2 * a : h.chartWidth,\n            r = n ? Math.max(x.body.scrollHeight, x.documentElement.scrollHeight, x.body.offsetHeight, x.documentElement.offsetHeight, x.documentElement.clientHeight) : h.chartHeight,\n            q = h.pointer.getChartPosition(),\n            k = function (b) {\n          var c = \"x\" === b;\n          return [b, c ? l : r, c ? g : d].concat(n ? [c ? g * q.scaleX : d * q.scaleY, c ? q.left - a + (e.plotX + h.plotLeft) * q.scaleX : q.top - a + (e.plotY + h.plotTop) * q.scaleY, 0, c ? l : r] : [c ? g : d, c ? e.plotX + h.plotLeft : e.plotY + h.plotTop, c ? h.plotLeft : h.plotTop, c ? h.plotLeft + h.plotWidth : h.plotTop + h.plotHeight]);\n        },\n            y = k(\"y\"),\n            v = k(\"x\"),\n            t = !this.followPointer && c(e.ttBelow, !h.inverted === !!e.negative),\n            p = function (e, c, g, d, h, m, p) {\n          var u = n ? \"y\" === e ? a * q.scaleY : a * q.scaleX : a,\n              w = (g - d) / 2,\n              l = d < h - a,\n              r = h + a + d < c,\n              J = h - u - g + w;\n          h = h + u - w;\n          if (t && r) b[e] = h;else if (!t && l) b[e] = J;else if (l) b[e] = Math.min(p - d, 0 > J - f ? J : J - f);else if (r) b[e] = Math.max(m, h + f + g > c ? h : h + f);else return !1;\n        },\n            z = function (e, c, g, d, h) {\n          var f;\n          h < a || h > c - a ? f = !1 : b[e] = h < g / 2 ? 1 : h > c - d / 2 ? c - d - 2 : h - g / 2;\n          return f;\n        },\n            A = function (a) {\n          var b = y;\n          y = v;\n          v = b;\n          m = a;\n        },\n            E = function () {\n          !1 !== p.apply(0, y) ? !1 !== z.apply(0, v) || m || (A(!0), E()) : m ? b.x = b.y = 0 : (A(!0), E());\n        };\n\n        (h.inverted || 1 < this.len) && A();\n        E();\n        return b;\n      };\n\n      z.prototype.getXDateFormat = function (c, g, e) {\n        g = g.dateTimeLabelFormats;\n        var d = e && e.closestPointRange;\n        return (d ? this.getDateFormat(d, c.x, e.options.startOfWeek, g) : g.day) || g.year;\n      };\n\n      z.prototype.hide = function (g) {\n        var d = this;\n        k.clearTimeout(this.hideTimer);\n        g = c(g, this.options.hideDelay, 500);\n        this.isHidden || (this.hideTimer = n(function () {\n          d.getLabel().fadeOut(g ? void 0 : g);\n          d.isHidden = !0;\n        }, g));\n      };\n\n      z.prototype.init = function (g, d) {\n        this.chart = g;\n        this.options = d;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = d.split && !g.inverted && !g.polar;\n        this.shared = d.shared || this.split;\n        this.outside = c(d.outside, !(!g.scrollablePixelsX && !g.scrollablePixelsY));\n      };\n\n      z.prototype.isStickyOnContact = function () {\n        return !(this.followPointer || !this.options.stickOnContact || !this.inContact);\n      };\n\n      z.prototype.move = function (c, g, e, d) {\n        var a = this,\n            b = a.now,\n            h = !1 !== a.options.animation && !a.isHidden && (1 < Math.abs(c - b.x) || 1 < Math.abs(g - b.y)),\n            f = a.followPointer || 1 < a.len;\n        t(b, {\n          x: h ? (2 * b.x + c) / 3 : c,\n          y: h ? (b.y + g) / 2 : g,\n          anchorX: f ? void 0 : h ? (2 * b.anchorX + e) / 3 : e,\n          anchorY: f ? void 0 : h ? (b.anchorY + d) / 2 : d\n        });\n        a.getLabel().attr(b);\n        a.drawTracker();\n        h && (k.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          a && a.move(c, g, e, d);\n        }, 32));\n      };\n\n      z.prototype.refresh = function (g, f) {\n        var e = this.chart,\n            h = this.options,\n            a = g,\n            b = {},\n            m = [],\n            n = h.formatter || this.defaultFormatter;\n        b = this.shared;\n        var l = e.styledMode;\n\n        if (h.enabled) {\n          k.clearTimeout(this.hideTimer);\n          this.followPointer = q(a)[0].series.tooltipOptions.followPointer;\n          var r = this.getAnchor(a, f);\n          f = r[0];\n          var N = r[1];\n          !b || a.series && a.series.noSharedTooltip ? b = a.getLabelConfig() : (e.pointer.applyInactiveState(a), a.forEach(function (a) {\n            a.setState(\"hover\");\n            m.push(a.getLabelConfig());\n          }), b = {\n            x: a[0].category,\n            y: a[0].y\n          }, b.points = m, a = a[0]);\n          this.len = m.length;\n          e = n.call(b, this);\n          n = a.series;\n          this.distance = c(n.tooltipOptions.distance, 16);\n          !1 === e ? this.hide() : (this.split ? this.renderSplit(e, q(g)) : (g = this.getLabel(), h.style.width && !l || g.css({\n            width: this.chart.spacingBox.width + \"px\"\n          }), g.attr({\n            text: e && e.join ? e.join(\"\") : e\n          }), g.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + c(a.colorIndex, n.colorIndex)), l || g.attr({\n            stroke: h.borderColor || a.color || n.color || d.neutralColor60\n          }), this.updatePosition({\n            plotX: f,\n            plotY: N,\n            negative: a.negative,\n            ttBelow: a.ttBelow,\n            h: r[2] || 0\n          })), this.isHidden && this.label && this.label.attr({\n            opacity: 1\n          }).show(), this.isHidden = !1);\n          C(this, \"refresh\");\n        }\n      };\n\n      z.prototype.renderSplit = function (m, n) {\n        function e(a, b, e, c, g) {\n          void 0 === g && (g = !0);\n          e ? (b = aa ? 0 : U, a = B(a - c / 2, x.left, x.right - c)) : (b -= I, a = g ? a - c - p : a + p, a = B(a, g ? a : x.left, x.right));\n          return {\n            x: a,\n            y: b\n          };\n        }\n\n        var h = this,\n            a = h.chart,\n            b = h.chart,\n            w = b.plotHeight,\n            l = b.plotLeft,\n            q = b.plotTop,\n            r = b.pointer,\n            k = b.renderer,\n            y = b.scrollablePixelsY,\n            z = void 0 === y ? 0 : y;\n        y = b.scrollingContainer;\n        y = void 0 === y ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : y;\n        var A = y.scrollLeft,\n            v = y.scrollTop,\n            E = b.styledMode,\n            p = h.distance,\n            C = h.options,\n            M = h.options.positioner,\n            x = {\n          left: A,\n          right: A + b.chartWidth,\n          top: v,\n          bottom: v + b.chartHeight\n        },\n            u = h.getLabel(),\n            aa = !(!a.xAxis[0] || !a.xAxis[0].opposite),\n            I = q + v,\n            X = 0,\n            U = w - z;\n        g(m) && (m = [!1, m]);\n        m = m.slice(0, n.length + 1).reduce(function (a, b, g) {\n          if (!1 !== b && \"\" !== b) {\n            g = n[g - 1] || {\n              isHeader: !0,\n              plotX: n[0].plotX,\n              plotY: w,\n              series: {}\n            };\n            var f = g.isHeader,\n                m = f ? h : g.series,\n                r = m.tt,\n                J = g.isHeader;\n            var F = g.series;\n            var N = \"highcharts-color-\" + c(g.colorIndex, F.colorIndex, \"none\");\n            r || (r = {\n              padding: C.padding,\n              r: C.borderRadius\n            }, E || (r.fill = C.backgroundColor, r[\"stroke-width\"] = C.borderWidth), r = k.label(\"\", 0, 0, C[J ? \"headerShape\" : \"shape\"] || \"callout\", void 0, void 0, C.useHTML).addClass((J ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + N).attr(r).add(u));\n            r.isActive = !0;\n            r.attr({\n              text: b\n            });\n            E || r.css(C.style).shadow(C.shadow).attr({\n              stroke: C.borderColor || g.color || F.color || d.neutralColor80\n            });\n            b = m.tt = r;\n            J = b.getBBox();\n            m = J.width + b.strokeWidth();\n            f && (X = J.height, U += X, aa && (I -= X));\n            F = g.plotX;\n            F = void 0 === F ? 0 : F;\n            N = g.plotY;\n            N = void 0 === N ? 0 : N;\n            var O = g.series;\n\n            if (g.isHeader) {\n              F = l + F;\n              var y = q + w / 2;\n            } else r = O.xAxis, O = O.yAxis, F = r.pos + B(F, -p, r.len + p), O.pos + N >= v + q && O.pos + N <= v + q + w - z && (y = O.pos + N);\n\n            F = B(F, x.left - p, x.right + p);\n            \"number\" === typeof y ? (J = J.height + 1, N = M ? M.call(h, m, J, g) : e(F, y, f, m), a.push({\n              align: M ? 0 : void 0,\n              anchorX: F,\n              anchorY: y,\n              boxWidth: m,\n              point: g,\n              rank: c(N.rank, f ? 1 : 0),\n              size: J,\n              target: N.y,\n              tt: b,\n              x: N.x\n            })) : b.isActive = !1;\n          }\n\n          return a;\n        }, []);\n        !M && m.some(function (a) {\n          return a.x < x.left;\n        }) && (m = m.map(function (a) {\n          var b = e(a.anchorX, a.anchorY, a.point.isHeader, a.boxWidth, !1);\n          return t(a, {\n            target: b.y,\n            x: b.x\n          });\n        }));\n        h.cleanSplit();\n        f.distribute(m, U);\n        m.forEach(function (a) {\n          var b = a.pos;\n          a.tt.attr({\n            visibility: \"undefined\" === typeof b ? \"hidden\" : \"inherit\",\n            x: a.x,\n            y: b + I,\n            anchorX: a.anchorX,\n            anchorY: a.anchorY\n          });\n        });\n        m = h.container;\n        a = h.renderer;\n        h.outside && m && a && (b = u.getBBox(), a.setSize(b.width + b.x, b.height + b.y, !1), r = r.getChartPosition(), m.style.left = r.left + \"px\", m.style.top = r.top + \"px\");\n      };\n\n      z.prototype.drawTracker = function () {\n        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {\n          var c = this.chart,\n              g = this.label,\n              e = c.hoverPoint;\n\n          if (g && e) {\n            var d = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            e = this.getAnchor(e);\n            var a = g.getBBox();\n            e[0] += c.plotLeft - g.translateX;\n            e[1] += c.plotTop - g.translateY;\n            d.x = Math.min(0, e[0]);\n            d.y = Math.min(0, e[1]);\n            d.width = 0 > e[0] ? Math.max(Math.abs(e[0]), a.width - e[0]) : Math.max(Math.abs(e[0]), a.width);\n            d.height = 0 > e[1] ? Math.max(Math.abs(e[1]), a.height - Math.abs(e[1])) : Math.max(Math.abs(e[1]), a.height);\n            this.tracker ? this.tracker.attr(d) : (this.tracker = g.renderer.rect(d).addClass(\"highcharts-tracker\").add(g), c.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        }\n      };\n\n      z.prototype.styledModeFormat = function (c) {\n        return c.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      z.prototype.tooltipFooterHeaderFormatter = function (c, g) {\n        var e = g ? \"footer\" : \"header\",\n            d = c.series,\n            a = d.tooltipOptions,\n            b = a.xDateFormat,\n            f = d.xAxis,\n            m = f && \"datetime\" === f.options.type && E(c.key),\n            n = a[e + \"Format\"];\n        g = {\n          isFooter: g,\n          labelConfig: c\n        };\n        C(this, \"headerFormatter\", g, function (e) {\n          m && !b && (b = this.getXDateFormat(c, a, f));\n          m && b && (c.point && c.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            n = n.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + b + \"}\");\n          });\n          d.chart.styledMode && (n = this.styledModeFormat(n));\n          e.text = l(n, {\n            point: c,\n            series: d\n          }, this.chart);\n        });\n        return g.text;\n      };\n\n      z.prototype.update = function (c) {\n        this.destroy();\n        y(!0, this.chart.options.tooltip.userOptions, c);\n        this.init(this.chart, y(!0, this.options, c));\n      };\n\n      z.prototype.updatePosition = function (c) {\n        var g = this.chart,\n            e = g.pointer,\n            d = this.getLabel(),\n            a = c.plotX + g.plotLeft;\n        g = c.plotY + g.plotTop;\n        e = e.getChartPosition();\n        c = (this.options.positioner || this.getPosition).call(this, d.width, d.height, c);\n\n        if (this.outside) {\n          var b = (this.options.borderWidth || 0) + 2 * this.distance;\n          this.renderer.setSize(d.width + b, d.height + b, !1);\n          if (1 !== e.scaleX || 1 !== e.scaleY) G(this.container, {\n            transform: \"scale(\" + e.scaleX + \", \" + e.scaleY + \")\"\n          }), a *= e.scaleX, g *= e.scaleY;\n          a += e.left - c.x;\n          g += e.top - c.y;\n        }\n\n        this.move(Math.round(c.x), Math.round(c.y || 0), a, g);\n      };\n\n      return z;\n    }();\n\n    f.Tooltip = M;\n    return f.Tooltip;\n  });\n  P(k, \"Core/Pointer.js\", [k[\"Core/Color/Color.js\"], k[\"Core/Globals.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Tooltip.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B) {\n    var G = f.parse,\n        D = d.charts,\n        H = d.noop,\n        t = B.addEvent,\n        C = B.attr,\n        l = B.css,\n        E = B.defined,\n        g = B.extend,\n        y = B.find,\n        c = B.fireEvent,\n        q = B.isNumber,\n        n = B.isObject,\n        A = B.objectEach,\n        M = B.offset,\n        z = B.pick,\n        m = B.splat;\n    \"\";\n\n    f = function () {\n      function f(e, c) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.chart = e;\n        this.hasDragged = !1;\n        this.options = c;\n\n        this.unbindContainerMouseLeave = function () {};\n\n        this.unbindContainerMouseEnter = function () {};\n\n        this.init(e, c);\n      }\n\n      f.prototype.applyInactiveState = function (e) {\n        var c = [],\n            a;\n        (e || []).forEach(function (b) {\n          a = b.series;\n          c.push(a);\n          a.linkedParent && c.push(a.linkedParent);\n          a.linkedSeries && (c = c.concat(a.linkedSeries));\n          a.navigatorSeries && c.push(a.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === c.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      f.prototype.destroy = function () {\n        var e = this;\n        \"undefined\" !== typeof e.unDocMouseMove && e.unDocMouseMove();\n        this.unbindContainerMouseLeave();\n        d.chartCount || (d.unbindDocumentMouseUp && (d.unbindDocumentMouseUp = d.unbindDocumentMouseUp()), d.unbindDocumentTouchEnd && (d.unbindDocumentTouchEnd = d.unbindDocumentTouchEnd()));\n        clearInterval(e.tooltipTimeout);\n        A(e, function (c, a) {\n          e[a] = void 0;\n        });\n      };\n\n      f.prototype.drag = function (e) {\n        var c = this.chart,\n            a = c.options.chart,\n            b = e.chartX,\n            g = e.chartY,\n            d = this.zoomHor,\n            f = this.zoomVert,\n            m = c.plotLeft,\n            l = c.plotTop,\n            q = c.plotWidth,\n            r = c.plotHeight,\n            y = this.selectionMarker,\n            v = this.mouseDownX || 0,\n            t = this.mouseDownY || 0,\n            p = n(a.panning) ? a.panning && a.panning.enabled : a.panning,\n            z = a.panKey && e[a.panKey + \"Key\"];\n        if (!y || !y.touch) if (b < m ? b = m : b > m + q && (b = m + q), g < l ? g = l : g > l + r && (g = l + r), this.hasDragged = Math.sqrt(Math.pow(v - b, 2) + Math.pow(t - g, 2)), 10 < this.hasDragged) {\n          var A = c.isInsidePlot(v - m, t - l);\n          c.hasCartesianSeries && (this.zoomX || this.zoomY) && A && !z && !y && (this.selectionMarker = y = c.renderer.rect(m, l, d ? 1 : q, f ? 1 : r, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), c.styledMode || y.attr({\n            fill: a.selectionMarkerFill || G(k.highlightColor80).setOpacity(.25).get()\n          }));\n          y && d && (b -= v, y.attr({\n            width: Math.abs(b),\n            x: (0 < b ? 0 : b) + v\n          }));\n          y && f && (b = g - t, y.attr({\n            height: Math.abs(b),\n            y: (0 < b ? 0 : b) + t\n          }));\n          A && !y && p && c.pan(e, a.panning);\n        }\n      };\n\n      f.prototype.dragStart = function (e) {\n        var c = this.chart;\n        c.mouseIsDown = e.type;\n        c.cancelClick = !1;\n        c.mouseDownX = this.mouseDownX = e.chartX;\n        c.mouseDownY = this.mouseDownY = e.chartY;\n      };\n\n      f.prototype.drop = function (e) {\n        var d = this,\n            a = this.chart,\n            b = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var f = {\n            originalEvent: e,\n            xAxis: [],\n            yAxis: []\n          },\n              m = this.selectionMarker,\n              n = m.attr ? m.attr(\"x\") : m.x,\n              r = m.attr ? m.attr(\"y\") : m.y,\n              k = m.attr ? m.attr(\"width\") : m.width,\n              y = m.attr ? m.attr(\"height\") : m.height,\n              t;\n          if (this.hasDragged || b) a.axes.forEach(function (a) {\n            if (a.zoomEnabled && E(a.min) && (b || d[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[a.coll]]) && q(n) && q(r)) {\n              var c = a.horiz,\n                  g = \"touchend\" === e.type ? a.minPixelPadding : 0,\n                  h = a.toValue((c ? n : r) + g);\n              c = a.toValue((c ? n + k : r + y) - g);\n              f[a.coll].push({\n                axis: a,\n                min: Math.min(h, c),\n                max: Math.max(h, c)\n              });\n              t = !0;\n            }\n          }), t && c(a, \"selection\", f, function (e) {\n            a.zoom(g(e, b ? {\n              animation: !1\n            } : null));\n          });\n          q(a.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          b && this.scaleGroups();\n        }\n\n        a && q(a.index) && (l(a.container, {\n          cursor: a._cursor\n        }), a.cancelClick = 10 < this.hasDragged, a.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      f.prototype.findNearestKDPoint = function (e, c, a) {\n        var b = this.chart,\n            g = b.hoverPoint;\n        b = b.tooltip;\n        if (g && b && b.isStickyOnContact()) return g;\n        var d;\n        e.forEach(function (b) {\n          var e = !(b.noSharedTooltip && c) && 0 > b.options.findNearestPointBy.indexOf(\"y\");\n          b = b.searchPoint(a, e);\n\n          if ((e = n(b, !0) && b.series) && !(e = !n(d, !0))) {\n            e = d.distX - b.distX;\n            var g = d.dist - b.dist,\n                f = (b.series.group && b.series.group.zIndex) - (d.series.group && d.series.group.zIndex);\n            e = 0 < (0 !== e && c ? e : 0 !== g ? g : 0 !== f ? f : d.series.index > b.series.index ? -1 : 1);\n          }\n\n          e && (d = b);\n        });\n        return d;\n      };\n\n      f.prototype.getChartCoordinatesFromPoint = function (e, c) {\n        var a = e.series,\n            b = a.xAxis;\n        a = a.yAxis;\n        var g = z(e.clientX, e.plotX),\n            d = e.shapeArgs;\n        if (b && a) return c ? {\n          chartX: b.len + b.pos - g,\n          chartY: a.len + a.pos - e.plotY\n        } : {\n          chartX: g + b.pos,\n          chartY: e.plotY + a.pos\n        };\n        if (d && d.x && d.y) return {\n          chartX: d.x,\n          chartY: d.y\n        };\n      };\n\n      f.prototype.getChartPosition = function () {\n        if (this.chartPosition) return this.chartPosition;\n        var e = this.chart.container,\n            c = M(e);\n        this.chartPosition = {\n          left: c.left,\n          top: c.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        var a = e.offsetWidth;\n        e = e.offsetHeight;\n        2 < a && 2 < e && (this.chartPosition.scaleX = c.width / a, this.chartPosition.scaleY = c.height / e);\n        return this.chartPosition;\n      };\n\n      f.prototype.getCoordinates = function (e) {\n        var c = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (a) {\n          c[a.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.toValue(e[a.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return c;\n      };\n\n      f.prototype.getHoverData = function (e, g, a, b, d, f) {\n        var h,\n            m = [];\n        b = !(!b || !e);\n        var w = g && !g.stickyTracking,\n            l = {\n          chartX: f ? f.chartX : void 0,\n          chartY: f ? f.chartY : void 0,\n          shared: d\n        };\n        c(this, \"beforeGetHoverData\", l);\n        w = w ? [g] : a.filter(function (a) {\n          return l.filter ? l.filter(a) : a.visible && !(!d && a.directTouch) && z(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        g = (h = b || !f ? e : this.findNearestKDPoint(w, d, f)) && h.series;\n        h && (d && !g.noSharedTooltip ? (w = a.filter(function (a) {\n          return l.filter ? l.filter(a) : a.visible && !(!d && a.directTouch) && z(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), w.forEach(function (a) {\n          var b = y(a.points, function (a) {\n            return a.x === h.x && !a.isNull;\n          });\n          n(b) && (a.chart.isBoosting && (b = a.getPoint(b)), m.push(b));\n        })) : m.push(h));\n        l = {\n          hoverPoint: h\n        };\n        c(this, \"afterGetHoverData\", l);\n        return {\n          hoverPoint: l.hoverPoint,\n          hoverSeries: g,\n          hoverPoints: m\n        };\n      };\n\n      f.prototype.getPointFromEvent = function (e) {\n        e = e.target;\n\n        for (var c; e && !c;) c = e.point, e = e.parentNode;\n\n        return c;\n      };\n\n      f.prototype.onTrackerMouseOut = function (e) {\n        e = e.relatedTarget || e.toElement;\n        var c = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!c || !e || c.stickyTracking || this.inClass(e, \"highcharts-tooltip\") || this.inClass(e, \"highcharts-series-\" + c.index) && this.inClass(e, \"highcharts-tracker\"))) c.onMouseOut();\n      };\n\n      f.prototype.inClass = function (e, c) {\n        for (var a; e;) {\n          if (a = C(e, \"class\")) {\n            if (-1 !== a.indexOf(c)) return !0;\n            if (-1 !== a.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          e = e.parentNode;\n        }\n      };\n\n      f.prototype.init = function (e, c) {\n        this.options = c;\n        this.chart = e;\n        this.runChartClick = c.chart.events && !!c.chart.events.click;\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        x && (e.tooltip = new x(e, c.tooltip), this.followTouchMove = z(c.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      f.prototype.normalize = function (e, c) {\n        var a = e.touches,\n            b = a ? a.length ? a.item(0) : z(a.changedTouches, e.changedTouches)[0] : e;\n        c || (c = this.getChartPosition());\n        a = b.pageX - c.left;\n        b = b.pageY - c.top;\n        a /= c.scaleX;\n        b /= c.scaleY;\n        return g(e, {\n          chartX: Math.round(a),\n          chartY: Math.round(b)\n        });\n      };\n\n      f.prototype.onContainerClick = function (e) {\n        var d = this.chart,\n            a = d.hoverPoint;\n        e = this.normalize(e);\n        var b = d.plotLeft,\n            f = d.plotTop;\n        d.cancelClick || (a && this.inClass(e.target, \"highcharts-tracker\") ? (c(a.series, \"click\", g(e, {\n          point: a\n        })), d.hoverPoint && a.firePointEvent(\"click\", e)) : (g(e, this.getCoordinates(e)), d.isInsidePlot(e.chartX - b, e.chartY - f) && c(d, \"click\", e)));\n      };\n\n      f.prototype.onContainerMouseDown = function (e) {\n        var c = 1 === ((e.buttons || e.button) & 1);\n        e = this.normalize(e);\n        if (d.isFirefox && 0 !== e.button) this.onContainerMouseMove(e);\n        if (\"undefined\" === typeof e.button || c) this.zoomOption(e), c && e.preventDefault && e.preventDefault(), this.dragStart(e);\n      };\n\n      f.prototype.onContainerMouseLeave = function (e) {\n        var c = D[z(d.hoverChartIndex, -1)],\n            a = this.chart.tooltip;\n        e = this.normalize(e);\n        c && (e.relatedTarget || e.toElement) && (c.pointer.reset(), c.pointer.chartPosition = void 0);\n        a && !a.isHidden && this.reset();\n      };\n\n      f.prototype.onContainerMouseEnter = function (e) {\n        delete this.chartPosition;\n      };\n\n      f.prototype.onContainerMouseMove = function (e) {\n        var c = this.chart;\n        e = this.normalize(e);\n        this.setHoverChartIndex();\n        e.preventDefault || (e.returnValue = !1);\n        (\"mousedown\" === c.mouseIsDown || this.touchSelect(e)) && this.drag(e);\n        c.openMenu || !this.inClass(e.target, \"highcharts-tracker\") && !c.isInsidePlot(e.chartX - c.plotLeft, e.chartY - c.plotTop) || this.runPointActions(e);\n      };\n\n      f.prototype.onDocumentTouchEnd = function (e) {\n        D[d.hoverChartIndex] && D[d.hoverChartIndex].pointer.drop(e);\n      };\n\n      f.prototype.onContainerTouchMove = function (e) {\n        if (this.touchSelect(e)) this.onContainerMouseMove(e);else this.touch(e);\n      };\n\n      f.prototype.onContainerTouchStart = function (e) {\n        if (this.touchSelect(e)) this.onContainerMouseDown(e);else this.zoomOption(e), this.touch(e, !0);\n      };\n\n      f.prototype.onDocumentMouseMove = function (e) {\n        var c = this.chart,\n            a = this.chartPosition;\n        e = this.normalize(e, a);\n        var b = c.tooltip;\n        !a || b && b.isStickyOnContact() || c.isInsidePlot(e.chartX - c.plotLeft, e.chartY - c.plotTop) || this.inClass(e.target, \"highcharts-tracker\") || this.reset();\n      };\n\n      f.prototype.onDocumentMouseUp = function (e) {\n        var c = D[z(d.hoverChartIndex, -1)];\n        c && c.pointer.drop(e);\n      };\n\n      f.prototype.pinch = function (e) {\n        var c = this,\n            a = c.chart,\n            b = c.pinchDown,\n            d = e.touches || [],\n            f = d.length,\n            m = c.lastValidTouch,\n            n = c.hasZoom,\n            l = c.selectionMarker,\n            q = {},\n            r = 1 === f && (c.inClass(e.target, \"highcharts-tracker\") && a.runTrackerClick || c.runChartClick),\n            k = {};\n        1 < f && (c.initiated = !0);\n        n && c.initiated && !r && !1 !== e.cancelable && e.preventDefault();\n        [].map.call(d, function (a) {\n          return c.normalize(a);\n        });\n        \"touchstart\" === e.type ? ([].forEach.call(d, function (a, e) {\n          b[e] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), m.x = [b[0].chartX, b[1] && b[1].chartX], m.y = [b[0].chartY, b[1] && b[1].chartY], a.axes.forEach(function (b) {\n          if (b.zoomEnabled) {\n            var e = a.bounds[b.horiz ? \"h\" : \"v\"],\n                c = b.minPixelPadding,\n                g = b.toPixels(Math.min(z(b.options.min, b.dataMin), b.dataMin)),\n                d = b.toPixels(Math.max(z(b.options.max, b.dataMax), b.dataMax)),\n                f = Math.max(g, d);\n            e.min = Math.min(b.pos, Math.min(g, d) - c);\n            e.max = Math.max(b.pos + b.len, f + c);\n          }\n        }), c.res = !0) : c.followTouchMove && 1 === f ? this.runPointActions(c.normalize(e)) : b.length && (l || (c.selectionMarker = l = g({\n          destroy: H,\n          touch: !0\n        }, a.plotBox)), c.pinchTranslate(b, d, q, l, k, m), c.hasPinched = n, c.scaleGroups(q, k), c.res && (c.res = !1, this.reset(!1, 0)));\n      };\n\n      f.prototype.pinchTranslate = function (e, c, a, b, g, d) {\n        this.zoomHor && this.pinchTranslateDirection(!0, e, c, a, b, g, d);\n        this.zoomVert && this.pinchTranslateDirection(!1, e, c, a, b, g, d);\n      };\n\n      f.prototype.pinchTranslateDirection = function (e, c, a, b, g, d, f, m) {\n        var h = this.chart,\n            n = e ? \"x\" : \"y\",\n            l = e ? \"X\" : \"Y\",\n            w = \"chart\" + l,\n            q = e ? \"width\" : \"height\",\n            r = h[\"plot\" + (e ? \"Left\" : \"Top\")],\n            p,\n            J,\n            F = m || 1,\n            k = h.inverted,\n            u = h.bounds[e ? \"h\" : \"v\"],\n            y = 1 === c.length,\n            I = c[0][w],\n            t = a[0][w],\n            z = !y && c[1][w],\n            O = !y && a[1][w];\n\n        a = function () {\n          \"number\" === typeof O && 20 < Math.abs(I - z) && (F = m || Math.abs(t - O) / Math.abs(I - z));\n          J = (r - t) / F + I;\n          p = h[\"plot\" + (e ? \"Width\" : \"Height\")] / F;\n        };\n\n        a();\n        c = J;\n\n        if (c < u.min) {\n          c = u.min;\n          var A = !0;\n        } else c + p > u.max && (c = u.max - p, A = !0);\n\n        A ? (t -= .8 * (t - f[n][0]), \"number\" === typeof O && (O -= .8 * (O - f[n][1])), a()) : f[n] = [t, O];\n        k || (d[n] = J - r, d[q] = p);\n        d = k ? 1 / F : F;\n        g[q] = p;\n        g[n] = c;\n        b[k ? e ? \"scaleY\" : \"scaleX\" : \"scale\" + l] = F;\n        b[\"translate\" + l] = d * r + (t - d * I);\n      };\n\n      f.prototype.reset = function (e, c) {\n        var a = this.chart,\n            b = a.hoverSeries,\n            g = a.hoverPoint,\n            d = a.hoverPoints,\n            f = a.tooltip,\n            h = f && f.shared ? d : g;\n        e && h && m(h).forEach(function (a) {\n          a.series.isCartesian && \"undefined\" === typeof a.plotX && (e = !1);\n        });\n        if (e) f && h && m(h).length && (f.refresh(h), f.shared && d ? d.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : g && (g.setState(g.state, !0), a.axes.forEach(function (a) {\n          a.crosshair && g.series[a.coll] === a && a.drawCrosshair(null, g);\n        })));else {\n          if (g) g.onMouseOut();\n          d && d.forEach(function (a) {\n            a.setState();\n          });\n          if (b) b.onMouseOut();\n          f && f.hide(c);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          a.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = a.hoverPoints = a.hoverPoint = null;\n        }\n      };\n\n      f.prototype.runPointActions = function (e, c) {\n        var a = this.chart,\n            b = a.tooltip && a.tooltip.options.enabled ? a.tooltip : void 0,\n            g = b ? b.shared : !1,\n            f = c || a.hoverPoint,\n            h = f && f.series || a.hoverSeries;\n        h = this.getHoverData(f, h, a.series, (!e || \"touchmove\" !== e.type) && (!!c || h && h.directTouch && this.isDirectTouch), g, e);\n        f = h.hoverPoint;\n        var m = h.hoverPoints;\n        c = (h = h.hoverSeries) && h.tooltipOptions.followPointer;\n        g = g && h && !h.noSharedTooltip;\n\n        if (f && (f !== a.hoverPoint || b && b.isHidden)) {\n          (a.hoverPoints || []).forEach(function (a) {\n            -1 === m.indexOf(a) && a.setState();\n          });\n          if (a.hoverSeries !== h) h.onMouseOver();\n          this.applyInactiveState(m);\n          (m || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          a.hoverPoint && a.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!f.series) return;\n          a.hoverPoints = m;\n          a.hoverPoint = f;\n          f.firePointEvent(\"mouseOver\");\n          b && b.refresh(g ? m : f, e);\n        } else c && b && !b.isHidden && (f = b.getAnchor([{}], e), b.updatePosition({\n          plotX: f[0],\n          plotY: f[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = t(a.container.ownerDocument, \"mousemove\", function (a) {\n          var b = D[d.hoverChartIndex];\n          if (b) b.pointer.onDocumentMouseMove(a);\n        }));\n        a.axes.forEach(function (b) {\n          var c = z((b.crosshair || {}).snap, !0),\n              g;\n          c && ((g = a.hoverPoint) && g.series[b.coll] === b || (g = y(m, function (a) {\n            return a.series[b.coll] === b;\n          })));\n          g || !c ? b.drawCrosshair(e, g) : b.hideCrosshair();\n        });\n      };\n\n      f.prototype.scaleGroups = function (e, c) {\n        var a = this.chart,\n            b;\n        a.series.forEach(function (g) {\n          b = e || g.getPlotBox();\n          g.xAxis && g.xAxis.zoomEnabled && g.group && (g.group.attr(b), g.markerGroup && (g.markerGroup.attr(b), g.markerGroup.clip(c ? a.clipRect : null)), g.dataLabelsGroup && g.dataLabelsGroup.attr(b));\n        });\n        a.clipRect.attr(c || a.clipBox);\n      };\n\n      f.prototype.setDOMEvents = function () {\n        var e = this,\n            c = this.chart.container,\n            a = c.ownerDocument;\n        c.onmousedown = this.onContainerMouseDown.bind(this);\n        c.onmousemove = this.onContainerMouseMove.bind(this);\n        c.onclick = this.onContainerClick.bind(this);\n        this.unbindContainerMouseEnter = t(c, \"mouseenter\", this.onContainerMouseEnter.bind(this));\n        this.unbindContainerMouseLeave = t(c, \"mouseleave\", this.onContainerMouseLeave.bind(this));\n        d.unbindDocumentMouseUp || (d.unbindDocumentMouseUp = t(a, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n\n        for (var b = this.chart.renderTo.parentElement; b && \"BODY\" !== b.tagName;) t(b, \"scroll\", function () {\n          delete e.chartPosition;\n        }), b = b.parentElement;\n\n        d.hasTouch && (t(c, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        }), t(c, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        }), d.unbindDocumentTouchEnd || (d.unbindDocumentTouchEnd = t(a, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      };\n\n      f.prototype.setHoverChartIndex = function () {\n        var e = this.chart,\n            c = d.charts[z(d.hoverChartIndex, -1)];\n        if (c && c !== e) c.pointer.onContainerMouseLeave({\n          relatedTarget: !0\n        });\n        c && c.mouseIsDown || (d.hoverChartIndex = e.index);\n      };\n\n      f.prototype.touch = function (e, c) {\n        var a = this.chart,\n            b;\n        this.setHoverChartIndex();\n        if (1 === e.touches.length) {\n          if (e = this.normalize(e), (b = a.isInsidePlot(e.chartX - a.plotLeft, e.chartY - a.plotTop)) && !a.openMenu) {\n            c && this.runPointActions(e);\n\n            if (\"touchmove\" === e.type) {\n              c = this.pinchDown;\n              var g = c[0] ? 4 <= Math.sqrt(Math.pow(c[0].chartX - e.chartX, 2) + Math.pow(c[0].chartY - e.chartY, 2)) : !1;\n            }\n\n            z(g, !0) && this.pinch(e);\n          } else c && this.reset();\n        } else 2 === e.touches.length && this.pinch(e);\n      };\n\n      f.prototype.touchSelect = function (e) {\n        return !(!this.chart.options.chart.zoomBySingleTouch || !e.touches || 1 !== e.touches.length);\n      };\n\n      f.prototype.zoomOption = function (e) {\n        var c = this.chart,\n            a = c.options.chart,\n            b = a.zoomType || \"\";\n        c = c.inverted;\n        /touch/.test(e.type) && (b = z(a.pinchType, b));\n        this.zoomX = e = /x/.test(b);\n        this.zoomY = b = /y/.test(b);\n        this.zoomHor = e && !c || b && c;\n        this.zoomVert = b && !c || e && c;\n        this.hasZoom = e || b;\n      };\n\n      return f;\n    }();\n\n    return d.Pointer = f;\n  });\n  P(k, \"Core/MSPointer.js\", [k[\"Core/Globals.js\"], k[\"Core/Pointer.js\"], k[\"Core/Utilities.js\"]], function (f, d, k) {\n    function x() {\n      var c = [];\n\n      c.item = function (c) {\n        return this[c];\n      };\n\n      E(y, function (g) {\n        c.push({\n          pageX: g.pageX,\n          pageY: g.pageY,\n          target: g.target\n        });\n      });\n      return c;\n    }\n\n    function B(c, g, d, l) {\n      \"touch\" !== c.pointerType && c.pointerType !== c.MSPOINTER_TYPE_TOUCH || !D[f.hoverChartIndex] || (l(c), l = D[f.hoverChartIndex].pointer, l[g]({\n        type: d,\n        target: c.currentTarget,\n        preventDefault: t,\n        touches: x()\n      }));\n    }\n\n    var G = this && this.__extends || function () {\n      var c = function (g, d) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, g) {\n          c.__proto__ = g;\n        } || function (c, g) {\n          for (var d in g) g.hasOwnProperty(d) && (c[d] = g[d]);\n        };\n\n        return c(g, d);\n      };\n\n      return function (g, d) {\n        function f() {\n          this.constructor = g;\n        }\n\n        c(g, d);\n        g.prototype = null === d ? Object.create(d) : (f.prototype = d.prototype, new f());\n      };\n    }(),\n        D = f.charts,\n        H = f.doc,\n        t = f.noop,\n        C = k.addEvent,\n        l = k.css,\n        E = k.objectEach,\n        g = k.removeEvent,\n        y = {},\n        c = !!f.win.PointerEvent;\n\n    return function (d) {\n      function f() {\n        return null !== d && d.apply(this, arguments) || this;\n      }\n\n      G(f, d);\n\n      f.prototype.batchMSEvents = function (g) {\n        g(this.chart.container, c ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        g(this.chart.container, c ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        g(H, c ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      f.prototype.destroy = function () {\n        this.batchMSEvents(g);\n        d.prototype.destroy.call(this);\n      };\n\n      f.prototype.init = function (c, g) {\n        d.prototype.init.call(this, c, g);\n        this.hasZoom && l(c.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      f.prototype.onContainerPointerDown = function (c) {\n        B(c, \"onContainerTouchStart\", \"touchstart\", function (c) {\n          y[c.pointerId] = {\n            pageX: c.pageX,\n            pageY: c.pageY,\n            target: c.currentTarget\n          };\n        });\n      };\n\n      f.prototype.onContainerPointerMove = function (c) {\n        B(c, \"onContainerTouchMove\", \"touchmove\", function (c) {\n          y[c.pointerId] = {\n            pageX: c.pageX,\n            pageY: c.pageY\n          };\n          y[c.pointerId].target || (y[c.pointerId].target = c.currentTarget);\n        });\n      };\n\n      f.prototype.onDocumentPointerUp = function (c) {\n        B(c, \"onDocumentTouchEnd\", \"touchend\", function (c) {\n          delete y[c.pointerId];\n        });\n      };\n\n      f.prototype.setDOMEvents = function () {\n        d.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(C);\n      };\n\n      return f;\n    }(d);\n  });\n  P(k, \"Core/Series/Point.js\", [k[\"Core/Renderer/HTML/AST.js\"], k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Globals.js\"], k[\"Core/Options.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B) {\n    var G = d.animObject,\n        D = x.defaultOptions,\n        H = B.addEvent,\n        t = B.defined,\n        C = B.erase,\n        l = B.extend,\n        E = B.fireEvent,\n        g = B.format,\n        y = B.getNestedProperty,\n        c = B.isArray,\n        q = B.isFunction,\n        n = B.isNumber,\n        A = B.isObject,\n        M = B.merge,\n        z = B.objectEach,\n        m = B.pick,\n        r = B.syncTimeout,\n        e = B.removeEvent,\n        h = B.uniqueKey;\n    \"\";\n\n    d = function () {\n      function a() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      a.prototype.animateBeforeDestroy = function () {\n        var a = this,\n            c = {\n          x: a.startXPos,\n          opacity: 0\n        },\n            e,\n            g = a.getGraphicalProps();\n        g.singular.forEach(function (b) {\n          e = \"dataLabel\" === b;\n          a[b] = a[b].animate(e ? {\n            x: a[b].startXPos,\n            y: a[b].startYPos,\n            opacity: 0\n          } : c);\n        });\n        g.plural.forEach(function (b) {\n          a[b].forEach(function (b) {\n            b.element && b.animate(l({\n              x: a.startXPos\n            }, b.startYPos ? {\n              x: b.startXPos,\n              y: b.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      a.prototype.applyOptions = function (b, c) {\n        var e = this.series,\n            g = e.options.pointValKey || e.pointValKey;\n        b = a.prototype.optionsToObject.call(this, b);\n        l(this, b);\n        this.options = this.options ? l(this.options, b) : b;\n        b.group && delete this.group;\n        b.dataLabels && delete this.dataLabels;\n        g && (this.y = a.prototype.getNestedProperty.call(this, g));\n        this.formatPrefix = (this.isNull = m(this.isValid && !this.isValid(), null === this.x || !n(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof c && e.xAxis && e.xAxis.hasNames && (this.x = e.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && e && (this.x = \"undefined\" === typeof c ? e.autoIncrement(this) : c);\n        return this;\n      };\n\n      a.prototype.destroy = function () {\n        function a() {\n          if (c.graphic || c.dataLabel || c.dataLabels) e(c), c.destroyElements();\n\n          for (m in c) c[m] = null;\n        }\n\n        var c = this,\n            g = c.series,\n            d = g.chart;\n        g = g.options.dataSorting;\n        var f = d.hoverPoints,\n            h = G(c.series.chart.renderer.globalAnimation),\n            m;\n        c.legendItem && d.legend.destroyItem(c);\n        f && (c.setState(), C(f, c), f.length || (d.hoverPoints = null));\n        if (c === d.hoverPoint) c.onMouseOut();\n        g && g.enabled ? (this.animateBeforeDestroy(), r(a, h.duration)) : a();\n        d.pointCount--;\n      };\n\n      a.prototype.destroyElements = function (a) {\n        var b = this;\n        a = b.getGraphicalProps(a);\n        a.singular.forEach(function (a) {\n          b[a] = b[a].destroy();\n        });\n        a.plural.forEach(function (a) {\n          b[a].forEach(function (a) {\n            a.element && a.destroy();\n          });\n          delete b[a];\n        });\n      };\n\n      a.prototype.firePointEvent = function (a, c, e) {\n        var b = this,\n            g = this.series.options;\n        (g.point.events[a] || b.options && b.options.events && b.options.events[a]) && b.importEvents();\n        \"click\" === a && g.allowPointSelect && (e = function (a) {\n          b.select && b.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        E(b, a, c, e);\n      };\n\n      a.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      a.prototype.getGraphicalProps = function (a) {\n        var b = this,\n            c = [],\n            e,\n            g = {\n          singular: [],\n          plural: []\n        };\n        a = a || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        a.graphic && c.push(\"graphic\", \"upperGraphic\", \"shadowGroup\");\n        a.dataLabel && c.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (e = c.length; e--;) {\n          var d = c[e];\n          b[d] && g.singular.push(d);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (c) {\n          var e = c + \"s\";\n          a[c] && b[e] && g.plural.push(e);\n        });\n        return g;\n      };\n\n      a.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      a.prototype.getNestedProperty = function (a) {\n        if (a) return 0 === a.indexOf(\"custom.\") ? y(a, this.options) : this[a];\n      };\n\n      a.prototype.getZone = function () {\n        var a = this.series,\n            c = a.zones;\n        a = a.zoneAxis || \"y\";\n        var e = 0,\n            g;\n\n        for (g = c[e]; this[a] >= g.value;) g = c[++e];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = g && g.color && !this.options.color ? g.color : this.nonZonedColor;\n        return g;\n      };\n\n      a.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      a.prototype.init = function (a, c, e) {\n        this.series = a;\n        this.applyOptions(c, e);\n        this.id = t(this.id) ? this.id : h();\n        this.resolveColor();\n        a.chart.pointCount++;\n        E(this, \"afterInit\");\n        return this;\n      };\n\n      a.prototype.optionsToObject = function (b) {\n        var e = {},\n            g = this.series,\n            d = g.options.keys,\n            f = d || g.pointArrayMap || [\"y\"],\n            h = f.length,\n            m = 0,\n            l = 0;\n        if (n(b) || null === b) e[f[0]] = b;else if (c(b)) for (!d && b.length > h && (g = typeof b[0], \"string\" === g ? e.name = b[0] : \"number\" === g && (e.x = b[0]), m++); l < h;) d && \"undefined\" === typeof b[m] || (0 < f[l].indexOf(\".\") ? a.prototype.setNestedProperty(e, b[m], f[l]) : e[f[l]] = b[m]), m++, l++;else \"object\" === typeof b && (e = b, b.dataLabels && (g._hasPointLabels = !0), b.marker && (g._hasPointMarkers = !0));\n        return e;\n      };\n\n      a.prototype.resolveColor = function () {\n        var a = this.series;\n        var c = a.chart.options.chart.colorCount;\n        var e = a.chart.styledMode;\n        delete this.nonZonedColor;\n        e || this.options.color || (this.color = a.color);\n        a.options.colorByPoint ? (e || (c = a.options.colors || a.chart.options.colors, this.color = this.color || c[a.colorCounter], c = c.length), e = a.colorCounter, a.colorCounter++, a.colorCounter === c && (a.colorCounter = 0)) : e = a.colorIndex;\n        this.colorIndex = m(this.options.colorIndex, e);\n      };\n\n      a.prototype.setNestedProperty = function (a, c, e) {\n        e.split(\".\").reduce(function (a, b, e, g) {\n          a[b] = g.length - 1 === e ? c : A(a[b], !0) ? a[b] : {};\n          return a[b];\n        }, a);\n        return a;\n      };\n\n      a.prototype.tooltipFormatter = function (a) {\n        var b = this.series,\n            c = b.tooltipOptions,\n            e = m(c.valueDecimals, \"\"),\n            d = c.valuePrefix || \"\",\n            f = c.valueSuffix || \"\";\n        b.chart.styledMode && (a = b.chart.tooltip.styledModeFormat(a));\n        (b.pointArrayMap || [\"y\"]).forEach(function (b) {\n          b = \"{point.\" + b;\n          if (d || f) a = a.replace(RegExp(b + \"}\", \"g\"), d + b + \"}\" + f);\n          a = a.replace(RegExp(b + \"}\", \"g\"), b + \":,.\" + e + \"f}\");\n        });\n        return g(a, {\n          point: this,\n          series: this.series\n        }, b.chart);\n      };\n\n      a.prototype.update = function (a, c, e, g) {\n        function b() {\n          d.applyOptions(a);\n          var b = h && d.hasDummyGraphic;\n          b = null === d.y ? !b : b;\n          h && b && (d.graphic = h.destroy(), delete d.hasDummyGraphic);\n          A(a, !0) && (h && h.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (d.graphic = h.destroy()), a && a.dataLabels && d.dataLabel && (d.dataLabel = d.dataLabel.destroy()), d.connector && (d.connector = d.connector.destroy()));\n          l = d.index;\n          f.updateParallelArrays(d, l);\n          q.data[l] = A(q.data[l], !0) || A(a, !0) ? d.options : m(a, q.data[l]);\n          f.isDirty = f.isDirtyData = !0;\n          !f.fixedBox && f.hasCartesianSeries && (n.isDirtyBox = !0);\n          \"point\" === q.legendType && (n.isDirtyLegend = !0);\n          c && n.redraw(e);\n        }\n\n        var d = this,\n            f = d.series,\n            h = d.graphic,\n            l,\n            n = f.chart,\n            q = f.options;\n        c = m(c, !0);\n        !1 === g ? b() : d.firePointEvent(\"update\", {\n          options: a\n        }, b);\n      };\n\n      a.prototype.remove = function (a, c) {\n        this.series.removePoint(this.series.data.indexOf(this), a, c);\n      };\n\n      a.prototype.select = function (a, c) {\n        var b = this,\n            e = b.series,\n            g = e.chart;\n        this.selectedStaging = a = m(a, !b.selected);\n        b.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: c\n        }, function () {\n          b.selected = b.options.selected = a;\n          e.options.data[e.data.indexOf(b)] = b.options;\n          b.setState(a && \"select\");\n          c || g.getSelectedPoints().forEach(function (a) {\n            var c = a.series;\n            a.selected && a !== b && (a.selected = a.options.selected = !1, c.options.data[c.data.indexOf(a)] = a.options, a.setState(g.hoverPoints && c.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      };\n\n      a.prototype.onMouseOver = function (a) {\n        var b = this.series.chart,\n            c = b.pointer;\n        a = a ? c.normalize(a) : c.getChartCoordinatesFromPoint(this, b.inverted);\n        c.runPointActions(a, this);\n      };\n\n      a.prototype.onMouseOut = function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      };\n\n      a.prototype.importEvents = function () {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              c = M(a.series.options.point, a.options).events;\n          a.events = c;\n          z(c, function (b, c) {\n            q(b) && H(a, c, b);\n          });\n          this.hasImportedEvents = !0;\n        }\n      };\n\n      a.prototype.setState = function (a, c) {\n        var b = this.series,\n            e = this.state,\n            g = b.options.states[a || \"normal\"] || {},\n            d = D.plotOptions[b.type].marker && b.options.marker,\n            h = d && !1 === d.enabled,\n            n = d && d.states && d.states[a || \"normal\"] || {},\n            q = !1 === n.enabled,\n            r = b.stateMarkerGraphic,\n            w = this.marker || {},\n            p = b.chart,\n            k = b.halo,\n            y,\n            t = d && b.markerAttribs;\n        a = a || \"\";\n\n        if (!(a === this.state && !c || this.selected && \"select\" !== a || !1 === g.enabled || a && (q || h && !1 === n.enabled) || a && w.states && w.states[a] && !1 === w.states[a].enabled)) {\n          this.state = a;\n          t && (y = b.markerAttribs(this, a));\n\n          if (this.graphic) {\n            e && this.graphic.removeClass(\"highcharts-point-\" + e);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!p.styledMode) {\n              var u = b.pointAttribs(this, a);\n              var z = m(p.options.chart.animation, g.animation);\n              b.options.inactiveOtherPoints && u.opacity && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: u.opacity\n                }, z);\n              }), this.connector && this.connector.animate({\n                opacity: u.opacity\n              }, z));\n              this.graphic.animate(u, z);\n            }\n\n            y && this.graphic.animate(y, m(p.options.chart.animation, n.animation, d.animation));\n            r && r.hide();\n          } else {\n            if (a && n) {\n              e = w.symbol || b.symbol;\n              r && r.currentSymbol !== e && (r = r.destroy());\n              if (y) if (r) r[c ? \"animate\" : \"attr\"]({\n                x: y.x,\n                y: y.y\n              });else e && (b.stateMarkerGraphic = r = p.renderer.symbol(e, y.x, y.y, y.width, y.height).add(b.markerGroup), r.currentSymbol = e);\n              !p.styledMode && r && r.attr(b.pointAttribs(this, a));\n            }\n\n            r && (r[a && this.isInside ? \"show\" : \"hide\"](), r.element.point = this);\n          }\n\n          a = g.halo;\n          g = (r = this.graphic || r) && r.visibility || \"inherit\";\n          a && a.size && r && \"hidden\" !== g && !this.isCluster ? (k || (b.halo = k = p.renderer.path().add(r.parentGroup)), k.show()[c ? \"animate\" : \"attr\"]({\n            d: this.haloPath(a.size)\n          }), k.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + m(this.colorIndex, b.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: g,\n            zIndex: -1\n          }), k.point = this, p.styledMode || k.attr(l({\n            fill: this.color || b.color,\n            \"fill-opacity\": a.opacity\n          }, f.filterUserAttributes(a.attributes || {})))) : k && k.point && k.point.haloPath && k.animate({\n            d: k.point.haloPath(0)\n          }, null, k.hide);\n          E(this, \"afterSetState\");\n        }\n      };\n\n      a.prototype.haloPath = function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      };\n\n      return a;\n    }();\n\n    return k.Point = d;\n  });\n  P(k, \"Core/Legend.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Globals.js\"], k[\"Core/Series/Point.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x) {\n    var B = f.animObject,\n        G = f.setAnimation;\n    f = d.isFirefox;\n    var D = d.marginNames,\n        H = d.win,\n        t = x.addEvent,\n        C = x.createElement,\n        l = x.css,\n        E = x.defined,\n        g = x.discardElement,\n        y = x.find,\n        c = x.fireEvent,\n        q = x.format,\n        n = x.isNumber,\n        A = x.merge,\n        M = x.pick,\n        z = x.relativeLength,\n        m = x.stableSort,\n        r = x.syncTimeout;\n    x = x.wrap;\n\n    var e = function () {\n      function e(a, b) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = {};\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = a;\n        this.init(a, b);\n      }\n\n      e.prototype.init = function (a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), t(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = t(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      e.prototype.setOptions = function (a) {\n        var b = M(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = A(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.itemMarginBottom = a.itemMarginBottom || 0;\n        this.padding = b;\n        this.initialItemY = b - 5;\n        this.symbolWidth = M(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      e.prototype.update = function (a, b) {\n        var e = this.chart;\n        this.setOptions(A(!0, this.options, a));\n        this.destroy();\n        e.isDirtyLegend = e.isDirtyBox = !0;\n        M(b, !0) && e.redraw();\n        c(this, \"afterUpdate\");\n      };\n\n      e.prototype.colorizeItem = function (a, b) {\n        a.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var e = this.options,\n              g = a.legendItem,\n              d = a.legendLine,\n              f = a.legendSymbol,\n              h = this.itemHiddenStyle.color;\n          e = b ? e.itemStyle.color : h;\n          var m = b ? a.color || h : h,\n              l = a.options && a.options.marker,\n              n = {\n            fill: m\n          };\n          g && g.css({\n            fill: e,\n            color: e\n          });\n          d && d.attr({\n            stroke: m\n          });\n          f && (l && f.isMarker && (n = a.pointAttribs(), b || (n.stroke = n.fill = h)), f.attr(n));\n        }\n\n        c(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      };\n\n      e.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      e.prototype.positionItem = function (a) {\n        var b = this,\n            e = this.options,\n            g = e.symbolPadding,\n            d = !e.rtl,\n            f = a._legendItemPos;\n        e = f[0];\n        f = f[1];\n        var h = a.checkbox,\n            m = a.legendGroup;\n        m && m.element && (g = {\n          translateX: d ? e : this.legendWidth - e - 2 * g - 4,\n          translateY: f\n        }, d = function () {\n          c(b, \"afterPositionItem\", {\n            item: a\n          });\n        }, E(m.translateY) ? m.animate(g, void 0, d) : (m.attr(g), d()));\n        h && (h.x = e, h.y = f);\n      };\n\n      e.prototype.destroyItem = function (a) {\n        var b = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (b) {\n          a[b] && (a[b] = a[b].destroy());\n        });\n        b && g(a.checkbox);\n      };\n\n      e.prototype.destroy = function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (b) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, b);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      };\n\n      e.prototype.positionCheckboxes = function () {\n        var a = this.group && this.group.alignAttr,\n            b = this.clipHeight || this.legendHeight,\n            c = this.titleHeight;\n\n        if (a) {\n          var e = a.translateY;\n          this.allItems.forEach(function (g) {\n            var d = g.checkbox;\n\n            if (d) {\n              var f = e + c + d.y + (this.scrollOffset || 0) + 3;\n              l(d, {\n                left: a.translateX + g.checkboxOffset + d.x - 20 + \"px\",\n                top: f + \"px\",\n                display: this.proximate || f > e - 6 && f < e + b - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      e.prototype.renderTitle = function () {\n        var a = this.options,\n            b = this.padding,\n            c = a.title,\n            e = 0;\n        c.text && (this.title || (this.title = this.chart.renderer.label(c.text, b - 3, b - 4, null, null, null, a.useHTML, null, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(c.style), this.title.add(this.group)), c.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), e = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: e\n        }));\n        this.titleHeight = e;\n      };\n\n      e.prototype.setText = function (a) {\n        var b = this.options;\n        a.legendItem.attr({\n          text: b.labelFormat ? q(b.labelFormat, a, this.chart) : b.labelFormatter.call(a)\n        });\n      };\n\n      e.prototype.renderItem = function (a) {\n        var b = this.chart,\n            c = b.renderer,\n            e = this.options,\n            g = this.symbolWidth,\n            d = e.symbolPadding,\n            f = this.itemStyle,\n            h = this.itemHiddenStyle,\n            m = \"horizontal\" === e.layout ? M(e.itemDistance, 20) : 0,\n            l = !e.rtl,\n            n = a.legendItem,\n            q = !a.series,\n            p = !q && a.series.drawLegendSymbol ? a.series : a,\n            r = p.options;\n        r = this.createCheckboxForItem && r && r.showCheckbox;\n        m = g + d + m + (r ? 20 : 0);\n        var k = e.useHTML,\n            y = a.options.className;\n        n || (a.legendGroup = c.g(\"legend-item\").addClass(\"highcharts-\" + p.type + \"-series highcharts-color-\" + a.colorIndex + (y ? \" \" + y : \"\") + (q ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = n = c.text(\"\", l ? g + d : -d, this.baseline || 0, k), b.styledMode || n.css(A(a.visible ? f : h)), n.attr({\n          align: l ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = c.fontMetrics(b.styledMode ? 12 : f.fontSize, n), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, n.attr(\"y\", this.baseline)), this.symbolHeight = e.symbolHeight || this.fontMetrics.f, p.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, n, k));\n        r && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !b.styledMode && f.width || n.css({\n          width: (e.itemWidth || this.widthOption || b.spacingBox.width) - m + \"px\"\n        });\n        this.setText(a);\n        b = n.getBBox();\n        a.itemWidth = a.checkboxOffset = e.itemWidth || a.legendItemWidth || b.width + m;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || b.height || this.symbolHeight);\n      };\n\n      e.prototype.layoutItem = function (a) {\n        var b = this.options,\n            c = this.padding,\n            e = \"horizontal\" === b.layout,\n            g = a.itemHeight,\n            d = this.itemMarginBottom,\n            f = this.itemMarginTop,\n            h = e ? M(b.itemDistance, 20) : 0,\n            m = this.maxLegendWidth;\n        b = b.alignColumns && this.totalItemWidth > m ? this.maxItemWidth : a.itemWidth;\n        e && this.itemX - c + b > m && (this.itemX = c, this.lastLineHeight && (this.itemY += f + this.lastLineHeight + d), this.lastLineHeight = 0);\n        this.lastItemY = f + this.itemY + d;\n        this.lastLineHeight = Math.max(g, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        e ? this.itemX += b : (this.itemY += f + g + d, this.lastLineHeight = g);\n        this.offsetWidth = this.widthOption || Math.max((e ? this.itemX - c - (a.checkbox ? 0 : h) : b) + c, this.offsetWidth);\n      };\n\n      e.prototype.getAllItems = function () {\n        var a = [];\n        this.chart.series.forEach(function (b) {\n          var c = b && b.options;\n          b && M(c.showInLegend, E(c.linkedTo) ? !1 : void 0, !0) && (a = a.concat(b.legendItems || (\"point\" === c.legendType ? b.data : b)));\n        });\n        c(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      };\n\n      e.prototype.getAlignment = function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      };\n\n      e.prototype.adjustMargins = function (a, b) {\n        var c = this.chart,\n            e = this.options,\n            g = this.getAlignment();\n        g && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (d, f) {\n          d.test(g) && !E(a[f]) && (c[D[f]] = Math.max(c[D[f]], c.legend[(f + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][f] * e[f % 2 ? \"x\" : \"y\"] + M(e.margin, 12) + b[f] + (c.titleOffset[f] || 0)));\n        });\n      };\n\n      e.prototype.proximatePositions = function () {\n        var a = this.chart,\n            b = [],\n            c = \"left\" === this.options.align;\n        this.allItems.forEach(function (e) {\n          var g;\n          var d = c;\n\n          if (e.yAxis) {\n            e.xAxis.options.reversed && (d = !d);\n            e.points && (g = y(d ? e.points : e.points.slice(0).reverse(), function (a) {\n              return n(a.plotY);\n            }));\n            d = this.itemMarginTop + e.legendItem.getBBox().height + this.itemMarginBottom;\n            var f = e.yAxis.top - a.plotTop;\n            e.visible ? (g = g ? g.plotY : e.yAxis.height, g += f - .3 * d) : g = f + e.yAxis.height;\n            b.push({\n              target: g,\n              size: d,\n              item: e\n            });\n          }\n        }, this);\n        d.distribute(b, a.plotHeight);\n        b.forEach(function (b) {\n          b.item._legendItemPos[1] = a.plotTop - a.spacing[0] + b.pos;\n        });\n      };\n\n      e.prototype.render = function () {\n        var a = this.chart,\n            b = a.renderer,\n            e = this.group,\n            g = this.box,\n            d = this.options,\n            f = this.padding;\n        this.itemX = f;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = z(d.width, a.spacingBox.width - f);\n        var h = a.spacingBox.width - 2 * f - d.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (h /= 2);\n        this.maxLegendWidth = this.widthOption || h;\n        e || (this.group = e = b.g(\"legend\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(e), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        var n = this.getAllItems();\n        m(n, function (a, b) {\n          return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);\n        });\n        d.reversed && n.reverse();\n        this.allItems = n;\n        this.display = h = !!n.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        n.forEach(this.renderItem, this);\n        n.forEach(this.layoutItem, this);\n        n = (this.widthOption || this.offsetWidth) + f;\n        var l = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        l = this.handleOverflow(l);\n        l += f;\n        g || (this.box = g = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: d.borderRadius\n        }).add(e), g.isNew = !0);\n        a.styledMode || g.attr({\n          stroke: d.borderColor,\n          \"stroke-width\": d.borderWidth || 0,\n          fill: d.backgroundColor || \"none\"\n        }).shadow(d.shadow);\n        0 < n && 0 < l && (g[g.isNew ? \"attr\" : \"animate\"](g.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: n,\n          height: l\n        }, g.strokeWidth())), g.isNew = !1);\n        g[h ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === e.getStyle(\"display\") && (n = l = 0);\n        this.legendWidth = n;\n        this.legendHeight = l;\n        h && this.align();\n        this.proximate || this.positionItems();\n        c(this, \"afterRender\");\n      };\n\n      e.prototype.align = function (a) {\n        void 0 === a && (a = this.chart.spacingBox);\n        var b = this.chart,\n            c = this.options,\n            e = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < b.titleOffset[0] ? e += b.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < b.titleOffset[2] && (e -= b.titleOffset[2]);\n        e !== a.y && (a = A(a, {\n          y: e\n        }));\n        this.group.align(A(c, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : c.verticalAlign\n        }), !0, a);\n      };\n\n      e.prototype.handleOverflow = function (a) {\n        var b = this,\n            c = this.chart,\n            e = c.renderer,\n            g = this.options,\n            d = g.y,\n            f = this.padding;\n        d = c.spacingBox.height + (\"top\" === g.verticalAlign ? -d : d) - f;\n\n        var h = g.maxHeight,\n            m,\n            n = this.clipRect,\n            l = g.navigation,\n            q = M(l.animation, !0),\n            p = l.arrowSize || 12,\n            r = this.nav,\n            k = this.pages,\n            y,\n            u = this.allItems,\n            t = function (a) {\n          \"number\" === typeof a ? n.attr({\n            height: a\n          }) : n && (b.clipRect = n.destroy(), b.contentGroup.clip());\n          b.contentGroup.div && (b.contentGroup.div.style.clip = a ? \"rect(\" + f + \"px,9999px,\" + (f + a) + \"px,0)\" : \"auto\");\n        },\n            I = function (a) {\n          b[a] = e.circle(0, 0, 1.3 * p).translate(p / 2, p / 2).add(r);\n          c.styledMode || b[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return b[a];\n        };\n\n        \"horizontal\" !== g.layout || \"middle\" === g.verticalAlign || g.floating || (d /= 2);\n        h && (d = Math.min(d, h));\n        k.length = 0;\n        a > d && !1 !== l.enabled ? (this.clipHeight = m = Math.max(d - 20 - this.titleHeight - f, 0), this.currentPage = M(this.currentPage, 1), this.fullHeight = a, u.forEach(function (a, b) {\n          var c = a._legendItemPos[1],\n              e = Math.round(a.legendItem.getBBox().height),\n              g = k.length;\n          if (!g || c - k[g - 1] > m && (y || c) !== k[g - 1]) k.push(y || c), g++;\n          a.pageIx = g - 1;\n          y && (u[b - 1].pageIx = g - 1);\n          b === u.length - 1 && c + e - k[g - 1] > m && c !== y && (k.push(c), a.pageIx = g);\n          c !== y && (y = c);\n        }), n || (n = b.clipRect = e.clipRect(0, f, 9999, 0), b.contentGroup.clip(n)), t(m), r || (this.nav = r = e.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = e.symbol(\"triangle\", 0, 0, p, p).add(r), I(\"upTracker\").on(\"click\", function () {\n          b.scroll(-1, q);\n        }), this.pager = e.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), c.styledMode || this.pager.css(l.style), this.pager.add(r), this.down = e.symbol(\"triangle-down\", 0, 0, p, p).add(r), I(\"downTracker\").on(\"click\", function () {\n          b.scroll(1, q);\n        })), b.scroll(0), a = d) : r && (t(), this.nav = r.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      };\n\n      e.prototype.scroll = function (a, b) {\n        var e = this,\n            g = this.chart,\n            d = this.pages,\n            f = d.length,\n            h = this.currentPage + a;\n        a = this.clipHeight;\n        var m = this.options.navigation,\n            n = this.pager,\n            l = this.padding;\n        h > f && (h = f);\n        0 < h && (\"undefined\" !== typeof b && G(b, g), this.nav.attr({\n          translateX: l,\n          translateY: a + this.padding + 7 + this.titleHeight,\n          visibility: \"visible\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === h ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), n.attr({\n          text: h + \"/\" + f\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": h === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), g.styledMode || (this.up.attr({\n          fill: 1 === h ? m.inactiveColor : m.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === h ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: h === f ? m.inactiveColor : m.activeColor\n        }), this.downTracker.css({\n          cursor: h === f ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -d[h - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = h, this.positionCheckboxes(), b = B(M(b, g.renderer.globalAnimation, !0)), r(function () {\n          c(e, \"afterScroll\", {\n            currentPage: h\n          });\n        }, b.duration));\n      };\n\n      e.prototype.setItemEvents = function (a, b, e) {\n        var g = this,\n            d = g.chart.renderer.boxWrapper,\n            f = a instanceof k,\n            h = \"highcharts-legend-\" + (f ? \"point\" : \"series\") + \"-active\",\n            m = g.chart.styledMode;\n        (e ? [b, a.legendSymbol] : [a.legendGroup]).forEach(function (e) {\n          if (e) e.on(\"mouseover\", function () {\n            a.visible && g.allItems.forEach(function (b) {\n              a !== b && b.setState(\"inactive\", !f);\n            });\n            a.setState(\"hover\");\n            a.visible && d.addClass(h);\n            m || b.css(g.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            g.chart.styledMode || b.css(A(a.visible ? g.itemStyle : g.itemHiddenStyle));\n            g.allItems.forEach(function (b) {\n              a !== b && b.setState(\"\", !f);\n            });\n            d.removeClass(h);\n            a.setState();\n          }).on(\"click\", function (b) {\n            var e = function () {\n              a.setVisible && a.setVisible();\n              g.allItems.forEach(function (b) {\n                a !== b && b.setState(a.visible ? \"inactive\" : \"\", !f);\n              });\n            };\n\n            d.removeClass(h);\n            b = {\n              browserEvent: b\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", b, e) : c(a, \"legendItemClick\", b, e);\n          });\n        });\n      };\n\n      e.prototype.createCheckboxForItem = function (a) {\n        a.checkbox = C(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        t(a.checkbox, \"click\", function (b) {\n          c(a.series || a, \"checkboxClick\", {\n            checked: b.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      };\n\n      return e;\n    }();\n\n    (/Trident\\/7\\.0/.test(H.navigator && H.navigator.userAgent) || f) && x(e.prototype, \"positionItem\", function (e, a) {\n      var b = this,\n          c = function () {\n        a._legendItemPos && e.call(b, a);\n      };\n\n      c();\n      b.bubbleLegend || setTimeout(c);\n    });\n    d.Legend = e;\n    return d.Legend;\n  });\n  P(k, \"Core/Series/SeriesRegistry.js\", [k[\"Core/Globals.js\"], k[\"Core/Options.js\"], k[\"Core/Series/Point.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x) {\n    var B = d.defaultOptions,\n        G = x.error,\n        D = x.extendClass,\n        H = x.merge,\n        t;\n\n    (function (d) {\n      function f(f, g) {\n        var l = B.plotOptions || {},\n            c = g.defaultOptions;\n        g.prototype.pointClass || (g.prototype.pointClass = k);\n        g.prototype.type = f;\n        c && (l[f] = c);\n        d.seriesTypes[f] = g;\n      }\n\n      d.seriesTypes = {};\n\n      d.getSeries = function (f, g) {\n        void 0 === g && (g = {});\n        var l = f.options.chart;\n        l = g.type || l.type || l.defaultSeriesType || \"\";\n        var c = d.seriesTypes[l];\n        d || G(17, !0, f, {\n          missingModuleFor: l\n        });\n        l = new c();\n        \"function\" === typeof l.init && l.init(f, g);\n        return l;\n      };\n\n      d.registerSeriesType = f;\n\n      d.seriesType = function (l, g, y, c, q) {\n        var n = B.plotOptions || {};\n        g = g || \"\";\n        n[l] = H(n[g], y);\n        f(l, D(d.seriesTypes[g] || function () {}, c));\n        d.seriesTypes[l].prototype.type = l;\n        q && (d.seriesTypes[l].prototype.pointClass = D(k, q));\n        return d.seriesTypes[l];\n      };\n    })(t || (t = {}));\n\n    f.seriesType = t.seriesType;\n    f.seriesTypes = t.seriesTypes;\n    return t;\n  });\n  P(k, \"Core/Chart/Chart.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Axis/Axis.js\"], k[\"Core/Globals.js\"], k[\"Core/Legend.js\"], k[\"Core/MSPointer.js\"], k[\"Core/Options.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Pointer.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Time.js\"], k[\"Core/Utilities.js\"], k[\"Core/Renderer/HTML/AST.js\"]], function (f, d, k, x, B, G, D, H, t, C, l, E) {\n    var g = f.animate,\n        y = f.animObject,\n        c = f.setAnimation,\n        q = k.charts,\n        n = k.doc,\n        A = k.win,\n        M = G.defaultOptions,\n        z = G.time,\n        m = t.seriesTypes,\n        r = l.addEvent,\n        e = l.attr,\n        h = l.cleanRecursively,\n        a = l.createElement,\n        b = l.css,\n        w = l.defined,\n        J = l.discardElement,\n        O = l.erase,\n        F = l.error,\n        N = l.extend,\n        R = l.find,\n        Q = l.fireEvent,\n        T = l.getStyle,\n        v = l.isArray,\n        L = l.isFunction,\n        p = l.isNumber,\n        K = l.isObject,\n        S = l.isString,\n        ba = l.merge,\n        u = l.numberFormat,\n        aa = l.objectEach,\n        I = l.pick,\n        X = l.pInt,\n        U = l.relativeLength,\n        ea = l.removeEvent,\n        Y = l.splat,\n        da = l.syncTimeout,\n        ha = l.uniqueKey,\n        fa = k.marginNames,\n        ca = function () {\n      function f(a, b, c) {\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.getArgs(a, b, c);\n      }\n\n      f.prototype.getArgs = function (a, b, c) {\n        S(a) || a.nodeName ? (this.renderTo = a, this.init(b, c)) : this.init(a, b);\n      };\n\n      f.prototype.init = function (a, b) {\n        var c,\n            e = a.series,\n            g = a.plotOptions || {};\n        Q(this, \"init\", {\n          args: arguments\n        }, function () {\n          a.series = null;\n          c = ba(M, a);\n          var d = c.chart || {};\n          aa(c.plotOptions, function (a, b) {\n            K(a) && (a.tooltip = g[b] && ba(g[b].tooltip) || void 0);\n          });\n          c.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          c.series = a.series = e;\n          this.userOptions = a;\n          var f = d.events;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = b;\n          this.isResizing = 0;\n          this.options = c;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new C(a.time) : k.time;\n          this.numberFormatter = d.numberFormatter || u;\n          this.styledMode = d.styledMode;\n          this.hasCartesianSeries = d.showAxes;\n          var h = this;\n          h.index = q.length;\n          q.push(h);\n          k.chartCount++;\n          f && aa(f, function (a, b) {\n            L(a) && r(h, b, a);\n          });\n          h.xAxis = [];\n          h.yAxis = [];\n          h.pointCount = h.colorCounter = h.symbolCounter = 0;\n          Q(h, \"afterInit\");\n          h.firstRender();\n        });\n      };\n\n      f.prototype.initSeries = function (a) {\n        var b = this.options.chart;\n        b = a.type || b.type || b.defaultSeriesType;\n        var c = m[b];\n        c || F(17, !0, this, {\n          missingModuleFor: b\n        });\n        b = new c();\n        \"function\" === typeof b.init && b.init(this, a);\n        return b;\n      };\n\n      f.prototype.setSeriesData = function () {\n        this.getSeriesOrderByLinks().forEach(function (a) {\n          a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);\n        });\n      };\n\n      f.prototype.getSeriesOrderByLinks = function () {\n        return this.series.concat().sort(function (a, b) {\n          return a.linkedSeries.length || b.linkedSeries.length ? b.linkedSeries.length - a.linkedSeries.length : 0;\n        });\n      };\n\n      f.prototype.orderSeries = function (a) {\n        var b = this.series;\n\n        for (a = a || 0; a < b.length; a++) b[a] && (b[a].index = a, b[a].name = b[a].getName());\n      };\n\n      f.prototype.isInsidePlot = function (a, b, c) {\n        var e = c ? b : a;\n        a = c ? a : b;\n        e = {\n          x: e,\n          y: a,\n          isInsidePlot: 0 <= e && e <= this.plotWidth && 0 <= a && a <= this.plotHeight\n        };\n        Q(this, \"afterIsInsidePlot\", e);\n        return e.isInsidePlot;\n      };\n\n      f.prototype.redraw = function (a) {\n        Q(this, \"beforeRedraw\");\n        var b = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n            e = this.series,\n            g = this.pointer,\n            d = this.legend,\n            f = this.userOptions.legend,\n            h = this.isDirtyLegend,\n            m = this.isDirtyBox,\n            u = this.renderer,\n            l = u.isHidden(),\n            n = [];\n        this.setResponsive && this.setResponsive(!1);\n        c(this.hasRendered ? a : !1, this);\n        l && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (a = e.length; a--;) {\n          var p = e[a];\n\n          if (p.options.stacking || p.options.centerInCategory) {\n            var q = !0;\n\n            if (p.isDirty) {\n              var r = !0;\n              break;\n            }\n          }\n        }\n\n        if (r) for (a = e.length; a--;) p = e[a], p.options.stacking && (p.isDirty = !0);\n        e.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (\"function\" === typeof a.updateTotals && a.updateTotals(), h = !0) : f && (f.labelFormatter || f.labelFormat) && (h = !0));\n          a.isDirtyData && Q(a, \"updatedData\");\n        });\n        h && d && d.options.enabled && (d.render(), this.isDirtyLegend = !1);\n        q && this.getStacks();\n        b.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        b.forEach(function (a) {\n          a.isDirty && (m = !0);\n        });\n        b.forEach(function (a) {\n          var b = a.min + \",\" + a.max;\n          a.extKey !== b && (a.extKey = b, n.push(function () {\n            Q(a, \"afterSetExtremes\", N(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (m || q) && a.redraw();\n        });\n        m && this.drawChartBox();\n        Q(this, \"predraw\");\n        e.forEach(function (a) {\n          (m || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        g && g.reset(!0);\n        u.draw();\n        Q(this, \"redraw\");\n        Q(this, \"render\");\n        l && this.temporaryDisplay(!0);\n        n.forEach(function (a) {\n          a.call();\n        });\n      };\n\n      f.prototype.get = function (a) {\n        function b(b) {\n          return b.id === a || b.options && b.options.id === a;\n        }\n\n        var c = this.series,\n            e;\n        var g = R(this.axes, b) || R(this.series, b);\n\n        for (e = 0; !g && e < c.length; e++) g = R(c[e].points || [], b);\n\n        return g;\n      };\n\n      f.prototype.getAxes = function () {\n        var a = this,\n            b = this.options,\n            e = b.xAxis = Y(b.xAxis || {});\n        b = b.yAxis = Y(b.yAxis || {});\n        Q(this, \"getAxes\");\n        e.forEach(function (a, b) {\n          a.index = b;\n          a.isX = !0;\n        });\n        b.forEach(function (a, b) {\n          a.index = b;\n        });\n        e.concat(b).forEach(function (b) {\n          new d(a, b);\n        });\n        Q(this, \"afterGetAxes\");\n      };\n\n      f.prototype.getSelectedPoints = function () {\n        var a = [];\n        this.series.forEach(function (b) {\n          a = a.concat(b.getPointsCollection().filter(function (a) {\n            return I(a.selectedStaging, a.selected);\n          }));\n        });\n        return a;\n      };\n\n      f.prototype.getSelectedSeries = function () {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      };\n\n      f.prototype.setTitle = function (a, b, e) {\n        this.applyDescription(\"title\", a);\n        this.applyDescription(\"subtitle\", b);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(e);\n      };\n\n      f.prototype.applyDescription = function (a, b) {\n        var e = this,\n            c = \"title\" === a ? {\n          color: D.neutralColor80,\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: D.neutralColor60\n        };\n        c = this.options[a] = ba(!this.styledMode && {\n          style: c\n        }, this.options[a], b);\n        var g = this[a];\n        g && b && (this[a] = g = g.destroy());\n        c && !g && (g = this.renderer.text(c.text, 0, 0, c.useHTML).attr({\n          align: c.align,\n          \"class\": \"highcharts-\" + a,\n          zIndex: c.zIndex || 4\n        }).add(), g.update = function (b) {\n          e[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[a]](b);\n        }, this.styledMode || g.css(c.style), this[a] = g);\n      };\n\n      f.prototype.layOutTitles = function (a) {\n        var b = [0, 0, 0],\n            c = this.renderer,\n            e = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (a) {\n          var g = this[a],\n              d = this.options[a],\n              f = d.verticalAlign || \"top\";\n          a = \"title\" === a ? -3 : \"top\" === f ? b[0] + 2 : 0;\n\n          if (g) {\n            if (!this.styledMode) var h = d.style.fontSize;\n            h = c.fontMetrics(h, g).b;\n            g.css({\n              width: (d.width || e.width + (d.widthAdjust || 0)) + \"px\"\n            });\n            var m = Math.round(g.getBBox(d.useHTML).height);\n            g.align(N({\n              y: \"bottom\" === f ? h : a + h,\n              height: m\n            }, d), !1, \"spacingBox\");\n            d.floating || (\"top\" === f ? b[0] = Math.ceil(b[0] + m) : \"bottom\" === f && (b[2] = Math.ceil(b[2] + m)));\n          }\n        }, this);\n        b[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (b[0] += this.options.title.margin);\n        b[2] && \"bottom\" === this.options.caption.verticalAlign && (b[2] += this.options.caption.margin);\n        var g = !this.titleOffset || this.titleOffset.join(\",\") !== b.join(\",\");\n        this.titleOffset = b;\n        Q(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && I(a, !0) && this.isDirtyBox && this.redraw());\n      };\n\n      f.prototype.getChartSize = function () {\n        var a = this.options.chart,\n            b = a.width;\n        a = a.height;\n        var c = this.renderTo;\n        w(b) || (this.containerWidth = T(c, \"width\"));\n        w(a) || (this.containerHeight = T(c, \"height\"));\n        this.chartWidth = Math.max(0, b || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, U(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      };\n\n      f.prototype.temporaryDisplay = function (a) {\n        var c = this.renderTo;\n        if (a) for (; c && c.style;) c.hcOrigStyle && (b(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (n.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;else for (; c && c.style;) {\n          n.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, n.body.appendChild(c));\n          if (\"none\" === T(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = {\n            display: c.style.display,\n            height: c.style.height,\n            overflow: c.style.overflow\n          }, a = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, c !== this.renderTo && (a.height = 0), b(c, a), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");\n          c = c.parentNode;\n          if (c === n.body) break;\n        }\n      };\n\n      f.prototype.setClassName = function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      };\n\n      f.prototype.getContainer = function () {\n        var g = this.options,\n            d = g.chart;\n        var f = this.renderTo;\n        var h = ha(),\n            m,\n            u;\n        f || (this.renderTo = f = d.renderTo);\n        S(f) && (this.renderTo = f = n.getElementById(f));\n        f || F(13, !0, this);\n        var l = X(e(f, \"data-highcharts-chart\"));\n        p(l) && q[l] && q[l].hasRendered && q[l].destroy();\n        e(f, \"data-highcharts-chart\", this.index);\n        f.innerHTML = \"\";\n        d.skipClone || f.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        l = this.chartWidth;\n        var r = this.chartHeight;\n        b(f, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (m = N({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: l + \"px\",\n          height: r + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\"\n        }, d.style));\n        this.container = f = a(\"div\", {\n          id: h\n        }, m, f);\n        this._cursor = f.style.cursor;\n        this.renderer = new (k[d.renderer] || k.Renderer)(f, l, r, null, d.forExport, g.exporting && g.exporting.allowHTML, this.styledMode);\n        c(void 0, this);\n        this.setClassName(d.className);\n        if (this.styledMode) for (u in g.defs) this.renderer.definition(g.defs[u]);else this.renderer.setStyle(d.style);\n        this.renderer.chartIndex = this.index;\n        Q(this, \"afterGetContainer\");\n      };\n\n      f.prototype.getMargins = function (a) {\n        var b = this.spacing,\n            c = this.margin,\n            e = this.titleOffset;\n        this.resetMargins();\n        e[0] && !w(c[0]) && (this.plotTop = Math.max(this.plotTop, e[0] + b[0]));\n        e[2] && !w(c[2]) && (this.marginBottom = Math.max(this.marginBottom, e[2] + b[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(c, b);\n        Q(this, \"getMargins\");\n        a || this.getAxisMargins();\n      };\n\n      f.prototype.getAxisMargins = function () {\n        var a = this,\n            b = a.axisOffset = [0, 0, 0, 0],\n            c = a.colorAxis,\n            e = a.margin,\n            g = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.getOffset();\n          });\n        };\n\n        a.hasCartesianSeries ? g(a.axes) : c && c.length && g(c);\n        fa.forEach(function (c, g) {\n          w(e[g]) || (a[c] += b[g]);\n        });\n        a.setChartSize();\n      };\n\n      f.prototype.reflow = function (a) {\n        var b = this,\n            c = b.options.chart,\n            e = b.renderTo,\n            g = w(c.width) && w(c.height),\n            d = c.width || T(e, \"width\");\n        c = c.height || T(e, \"height\");\n        e = a ? a.target : A;\n        delete b.pointer.chartPosition;\n\n        if (!g && !b.isPrinting && d && c && (e === A || e === n)) {\n          if (d !== b.containerWidth || c !== b.containerHeight) l.clearTimeout(b.reflowTimeout), b.reflowTimeout = da(function () {\n            b.container && b.setSize(void 0, void 0, !1);\n          }, a ? 100 : 0);\n          b.containerWidth = d;\n          b.containerHeight = c;\n        }\n      };\n\n      f.prototype.setReflow = function (a) {\n        var b = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = r(A, \"resize\", function (a) {\n          b.options && b.reflow(a);\n        }), r(this, \"destroy\", this.unbindReflow));\n      };\n\n      f.prototype.setSize = function (a, e, d) {\n        var f = this,\n            h = f.renderer;\n        f.isResizing += 1;\n        c(d, f);\n        d = h.globalAnimation;\n        f.oldChartHeight = f.chartHeight;\n        f.oldChartWidth = f.chartWidth;\n        \"undefined\" !== typeof a && (f.options.chart.width = a);\n        \"undefined\" !== typeof e && (f.options.chart.height = e);\n        f.getChartSize();\n        f.styledMode || (d ? g : b)(f.container, {\n          width: f.chartWidth + \"px\",\n          height: f.chartHeight + \"px\"\n        }, d);\n        f.setChartSize(!0);\n        h.setSize(f.chartWidth, f.chartHeight, d);\n        f.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        f.isDirtyLegend = !0;\n        f.isDirtyBox = !0;\n        f.layOutTitles();\n        f.getMargins();\n        f.redraw(d);\n        f.oldChartHeight = null;\n        Q(f, \"resize\");\n        da(function () {\n          f && Q(f, \"endResize\", null, function () {\n            --f.isResizing;\n          });\n        }, y(d).duration);\n      };\n\n      f.prototype.setChartSize = function (a) {\n        var b = this.inverted,\n            c = this.renderer,\n            e = this.chartWidth,\n            g = this.chartHeight,\n            d = this.options.chart,\n            f = this.spacing,\n            h = this.clipOffset,\n            m,\n            u,\n            l,\n            n;\n        this.plotLeft = m = Math.round(this.plotLeft);\n        this.plotTop = u = Math.round(this.plotTop);\n        this.plotWidth = l = Math.max(0, Math.round(e - m - this.marginRight));\n        this.plotHeight = n = Math.max(0, Math.round(g - u - this.marginBottom));\n        this.plotSizeX = b ? n : l;\n        this.plotSizeY = b ? l : n;\n        this.plotBorderWidth = d.plotBorderWidth || 0;\n        this.spacingBox = c.spacingBox = {\n          x: f[3],\n          y: f[0],\n          width: e - f[3] - f[1],\n          height: g - f[0] - f[2]\n        };\n        this.plotBox = c.plotBox = {\n          x: m,\n          y: u,\n          width: l,\n          height: n\n        };\n        e = 2 * Math.floor(this.plotBorderWidth / 2);\n        b = Math.ceil(Math.max(e, h[3]) / 2);\n        c = Math.ceil(Math.max(e, h[0]) / 2);\n        this.clipBox = {\n          x: b,\n          y: c,\n          width: Math.floor(this.plotSizeX - Math.max(e, h[1]) / 2 - b),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(e, h[2]) / 2 - c))\n        };\n        a || this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        });\n        Q(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      };\n\n      f.prototype.resetMargins = function () {\n        Q(this, \"resetMargins\");\n        var a = this,\n            b = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (c) {\n          var e = b[c],\n              g = K(e) ? e : [e, e, e, e];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (e, d) {\n            a[c][d] = I(b[c + e], g[d]);\n          });\n        });\n        fa.forEach(function (b, c) {\n          a[b] = I(a.margin[c], a.spacing[c]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      };\n\n      f.prototype.drawChartBox = function () {\n        var a = this.options.chart,\n            b = this.renderer,\n            c = this.chartWidth,\n            e = this.chartHeight,\n            g = this.chartBackground,\n            d = this.plotBackground,\n            f = this.plotBorder,\n            h = this.styledMode,\n            m = this.plotBGImage,\n            u = a.backgroundColor,\n            l = a.plotBackgroundColor,\n            n = a.plotBackgroundImage,\n            p,\n            q = this.plotLeft,\n            r = this.plotTop,\n            k = this.plotWidth,\n            I = this.plotHeight,\n            w = this.plotBox,\n            y = this.clipRect,\n            t = this.clipBox,\n            v = \"animate\";\n        g || (this.chartBackground = g = b.rect().addClass(\"highcharts-background\").add(), v = \"attr\");\n        if (h) var z = p = g.strokeWidth();else {\n          z = a.borderWidth || 0;\n          p = z + (a.shadow ? 8 : 0);\n          u = {\n            fill: u || \"none\"\n          };\n          if (z || g[\"stroke-width\"]) u.stroke = a.borderColor, u[\"stroke-width\"] = z;\n          g.attr(u).shadow(a.shadow);\n        }\n        g[v]({\n          x: p / 2,\n          y: p / 2,\n          width: c - p - z % 2,\n          height: e - p - z % 2,\n          r: a.borderRadius\n        });\n        v = \"animate\";\n        d || (v = \"attr\", this.plotBackground = d = b.rect().addClass(\"highcharts-plot-background\").add());\n        d[v](w);\n        h || (d.attr({\n          fill: l || \"none\"\n        }).shadow(a.plotShadow), n && (m ? (n !== m.attr(\"href\") && m.attr(\"href\", n), m.animate(w)) : this.plotBGImage = b.image(n, q, r, k, I).add()));\n        y ? y.animate({\n          width: t.width,\n          height: t.height\n        }) : this.clipRect = b.clipRect(t);\n        v = \"animate\";\n        f || (v = \"attr\", this.plotBorder = f = b.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        h || f.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        f[v](f.crisp({\n          x: q,\n          y: r,\n          width: k,\n          height: I\n        }, -f.strokeWidth()));\n        this.isDirtyBox = !1;\n        Q(this, \"afterDrawChartBox\");\n      };\n\n      f.prototype.propFromSeries = function () {\n        var a = this,\n            b = a.options.chart,\n            c,\n            e = a.options.series,\n            g,\n            d;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (f) {\n          c = m[b.type || b.defaultSeriesType];\n          d = b[f] || c && c.prototype[f];\n\n          for (g = e && e.length; !d && g--;) (c = m[e[g].type]) && c.prototype[f] && (d = !0);\n\n          a[f] = d;\n        });\n      };\n\n      f.prototype.linkSeries = function () {\n        var a = this,\n            b = a.series;\n        b.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        b.forEach(function (b) {\n          var c = b.options.linkedTo;\n          S(c) && (c = \":previous\" === c ? a.series[b.index - 1] : a.get(c)) && c.linkedParent !== b && (c.linkedSeries.push(b), b.linkedParent = c, c.enabledDataSorting && b.setDataSortingOptions(), b.visible = I(b.options.visible, c.options.visible, b.visible));\n        });\n        Q(this, \"afterLinkSeries\");\n      };\n\n      f.prototype.renderSeries = function () {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      };\n\n      f.prototype.renderLabels = function () {\n        var a = this,\n            b = a.options.labels;\n        b.items && b.items.forEach(function (c) {\n          var e = N(b.style, c.style),\n              g = X(e.left) + a.plotLeft,\n              d = X(e.top) + a.plotTop + 12;\n          delete e.left;\n          delete e.top;\n          a.renderer.text(c.html, g, d).attr({\n            zIndex: 2\n          }).css(e).add();\n        });\n      };\n\n      f.prototype.render = function () {\n        var a = this.axes,\n            b = this.colorAxis,\n            c = this.renderer,\n            e = this.options,\n            g = 0,\n            d = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.render();\n          });\n        };\n\n        this.setTitle();\n        this.legend = new x(this, e.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        e = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return g = 21, !0;\n        });\n        var f = this.plotHeight = Math.max(this.plotHeight - g, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        var h = 1.1 < e / this.plotWidth;\n        var m = 1.05 < f / this.plotHeight;\n        if (h || m) a.forEach(function (a) {\n          (a.horiz && h || !a.horiz && m) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? d(a) : b && b.length && d(b);\n        this.seriesGroup || (this.seriesGroup = c.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      };\n\n      f.prototype.addCredits = function (a) {\n        var b = this,\n            c = ba(!0, this.options.credits, a);\n        c.enabled && !this.credits && (this.credits = this.renderer.text(c.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          c.href && (A.location.href = c.href);\n        }).attr({\n          align: c.position.align,\n          zIndex: 8\n        }), b.styledMode || this.credits.css(c.style), this.credits.add().align(c.position), this.credits.update = function (a) {\n          b.credits = b.credits.destroy();\n          b.addCredits(a);\n        });\n      };\n\n      f.prototype.destroy = function () {\n        var a = this,\n            b = a.axes,\n            c = a.series,\n            e = a.container,\n            g,\n            d = e && e.parentNode;\n        Q(a, \"destroy\");\n        a.renderer.forExport ? O(q, a) : q[a.index] = void 0;\n        k.chartCount--;\n        a.renderTo.removeAttribute(\"data-highcharts-chart\");\n        ea(a);\n\n        for (g = b.length; g--;) b[g] = b[g].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (g = c.length; g--;) c[g] = c[g].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (b) {\n          var c = a[b];\n          c && c.destroy && (a[b] = c.destroy());\n        });\n        e && (e.innerHTML = \"\", ea(e), d && J(e));\n        aa(a, function (b, c) {\n          delete a[c];\n        });\n      };\n\n      f.prototype.firstRender = function () {\n        var a = this,\n            b = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          (v(b.series) ? b.series : []).forEach(function (b) {\n            a.initSeries(b);\n          });\n          a.linkSeries();\n          a.setSeriesData();\n          Q(a, \"beforeRender\");\n          H && (a.pointer = k.hasTouch || !A.PointerEvent && !A.MSPointerEvent ? new H(a, b) : new B(a, b));\n          a.render();\n          a.pointer.getChartPosition();\n          if (!a.renderer.imgCount && !a.hasLoaded) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      };\n\n      f.prototype.onload = function () {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && \"undefined\" !== typeof this.index && a.apply(this, [this]);\n        }, this);\n        Q(this, \"load\");\n        Q(this, \"render\");\n        w(this.index) && this.setReflow(this.options.chart.reflow);\n        this.hasLoaded = !0;\n      };\n\n      f.prototype.addSeries = function (a, b, c) {\n        var e,\n            g = this;\n        a && (b = I(b, !0), Q(g, \"addSeries\", {\n          options: a\n        }, function () {\n          e = g.initSeries(a);\n          g.isDirtyLegend = !0;\n          g.linkSeries();\n          e.enabledDataSorting && e.setData(a.data, !1);\n          Q(g, \"afterAddSeries\", {\n            series: e\n          });\n          b && g.redraw(c);\n        }));\n        return e;\n      };\n\n      f.prototype.addAxis = function (a, b, c, e) {\n        return this.createAxis(b ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: c,\n          animation: e\n        });\n      };\n\n      f.prototype.addColorAxis = function (a, b, c) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: b,\n          animation: c\n        });\n      };\n\n      f.prototype.createAxis = function (a, b) {\n        var c = this.options,\n            e = \"colorAxis\" === a,\n            g = b.redraw,\n            f = b.animation;\n        b = ba(b.axis, {\n          index: this[a].length,\n          isX: \"xAxis\" === a\n        });\n        var h = e ? new k.ColorAxis(this, b) : new d(this, b);\n        c[a] = Y(c[a] || {});\n        c[a].push(b);\n        e && (this.isDirtyLegend = !0, this.axes.forEach(function (a) {\n          a.series = [];\n        }), this.series.forEach(function (a) {\n          a.bindAxes();\n          a.isDirtyData = !0;\n        }));\n        I(g, !0) && this.redraw(f);\n        return h;\n      };\n\n      f.prototype.showLoading = function (c) {\n        var e = this,\n            d = e.options,\n            f = e.loadingDiv,\n            h = e.loadingSpan,\n            m = d.loading,\n            u = function () {\n          f && b(f, {\n            left: e.plotLeft + \"px\",\n            top: e.plotTop + \"px\",\n            width: e.plotWidth + \"px\",\n            height: e.plotHeight + \"px\"\n          });\n        };\n\n        f || (e.loadingDiv = f = a(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, e.container));\n        h || (e.loadingSpan = h = a(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, f), r(e, \"redraw\", u));\n        f.className = \"highcharts-loading\";\n        E.setElementHTML(h, I(c, d.lang.loading, \"\"));\n        e.styledMode || (b(f, N(m.style, {\n          zIndex: 10\n        })), b(h, m.labelStyle), e.loadingShown || (b(f, {\n          opacity: 0,\n          display: \"\"\n        }), g(f, {\n          opacity: m.style.opacity || .5\n        }, {\n          duration: m.showDuration || 0\n        })));\n        e.loadingShown = !0;\n        u();\n      };\n\n      f.prototype.hideLoading = function () {\n        var a = this.options,\n            c = this.loadingDiv;\n        c && (c.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || g(c, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function () {\n            b(c, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      };\n\n      f.prototype.update = function (a, b, c, e) {\n        var g = this,\n            d = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            f,\n            m,\n            u,\n            l = a.isResponsiveOptions,\n            n = [];\n        Q(g, \"update\", {\n          options: a\n        });\n        l || g.setResponsive(!1, !0);\n        a = h(a, g.options);\n        g.userOptions = ba(g.userOptions, a);\n\n        if (f = a.chart) {\n          ba(!0, g.options.chart, f);\n          \"className\" in f && g.setClassName(f.className);\n          \"reflow\" in f && g.setReflow(f.reflow);\n\n          if (\"inverted\" in f || \"polar\" in f || \"type\" in f) {\n            g.propFromSeries();\n            var q = !0;\n          }\n\n          \"alignTicks\" in f && (q = !0);\n          aa(f, function (a, b) {\n            -1 !== g.propsRequireUpdateSeries.indexOf(\"chart.\" + b) && (m = !0);\n            -1 !== g.propsRequireDirtyBox.indexOf(b) && (g.isDirtyBox = !0);\n            -1 !== g.propsRequireReflow.indexOf(b) && (l ? g.isDirtyBox = !0 : u = !0);\n          });\n          !g.styledMode && \"style\" in f && g.renderer.setStyle(f.style);\n        }\n\n        !g.styledMode && a.colors && (this.options.colors = a.colors);\n        a.time && (this.time === z && (this.time = new C(a.time)), ba(!0, g.options.time, a.time));\n        aa(a, function (b, c) {\n          if (g[c] && \"function\" === typeof g[c].update) g[c].update(b, !1);else if (\"function\" === typeof g[d[c]]) g[d[c]](b);else \"color\" !== c && -1 === g.collectionsWithUpdate.indexOf(c) && ba(!0, g.options[c], a[c]);\n          \"chart\" !== c && -1 !== g.propsRequireUpdateSeries.indexOf(c) && (m = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (b) {\n          if (a[b]) {\n            if (\"series\" === b) {\n              var e = [];\n              g[b].forEach(function (a, b) {\n                a.options.isInternal || e.push(I(a.options.index, b));\n              });\n            }\n\n            Y(a[b]).forEach(function (a, d) {\n              var f = w(a.id),\n                  h;\n              f && (h = g.get(a.id));\n              !h && g[b] && (h = g[b][e ? e[d] : d]) && f && w(h.options.id) && (h = void 0);\n              h && h.coll === b && (h.update(a, !1), c && (h.touched = !0));\n              !h && c && g.collectionsWithInit[b] && (g.collectionsWithInit[b][0].apply(g, [a].concat(g.collectionsWithInit[b][1] || []).concat([!1])).touched = !0);\n            });\n            c && g[b].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : n.push(a);\n            });\n          }\n        });\n        n.forEach(function (a) {\n          a.chart && a.remove(!1);\n        });\n        q && g.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        m && g.getSeriesOrderByLinks().forEach(function (a) {\n          a.chart && a.update({}, !1);\n        }, this);\n        q = f && f.width;\n        f = f && f.height;\n        S(f) && (f = U(f, q || g.chartWidth));\n        u || p(q) && q !== g.chartWidth || p(f) && f !== g.chartHeight ? g.setSize(q, f, e) : I(b, !0) && g.redraw(e);\n        Q(g, \"afterUpdate\", {\n          options: a,\n          redraw: b,\n          animation: e\n        });\n      };\n\n      f.prototype.setSubtitle = function (a, b) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(b);\n      };\n\n      f.prototype.setCaption = function (a, b) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(b);\n      };\n\n      f.prototype.showResetZoom = function () {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            c = M.lang,\n            e = b.options.chart.resetZoomButton,\n            g = e.theme,\n            d = g.states,\n            f = \"chart\" === e.relativeTo || \"spaceBox\" === e.relativeTo ? null : this.scrollablePlotBox || \"plotBox\";\n        Q(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(c.resetZoom, null, null, a, g, d && d.hover).attr({\n            align: e.position.align,\n            title: c.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(e.position, !1, f);\n        });\n        Q(this, \"afterShowResetZoom\");\n      };\n\n      f.prototype.zoomOut = function () {\n        Q(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      };\n\n      f.prototype.zoom = function (a) {\n        var b = this,\n            c,\n            e = b.pointer,\n            g = !1,\n            d = b.inverted ? e.mouseDownX : e.mouseDownY;\n        !a || a.resetSelection ? (b.axes.forEach(function (a) {\n          c = a.zoom();\n        }), e.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var f = a.axis,\n              h = b.inverted ? f.left : f.top,\n              m = b.inverted ? h + f.width : h + f.height,\n              u = f.isXAxis,\n              l = !1;\n          if (!u && d >= h && d <= m || u || !w(d)) l = !0;\n          e[u ? \"zoomX\" : \"zoomY\"] && l && (c = f.zoom(a.min, a.max), f.displayBtn && (g = !0));\n        });\n        var f = b.resetZoomButton;\n        g && !f ? b.showResetZoom() : !g && K(f) && (b.resetZoomButton = f.destroy());\n        c && b.redraw(I(b.options.chart.animation, a && a.animation, 100 > b.pointCount));\n      };\n\n      f.prototype.pan = function (a, c) {\n        var e = this,\n            g = e.hoverPoints,\n            d = e.options.chart,\n            f = e.options.mapNavigation && e.options.mapNavigation.enabled,\n            h;\n        c = \"object\" === typeof c ? c : {\n          enabled: c,\n          type: \"x\"\n        };\n        d && d.panning && (d.panning = c);\n        var m = c.type;\n        Q(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          g && g.forEach(function (a) {\n            a.setState();\n          });\n          var c = [1];\n          \"xy\" === m ? c = [1, 0] : \"y\" === m && (c = [0]);\n          c.forEach(function (b) {\n            var c = e[b ? \"xAxis\" : \"yAxis\"][0],\n                g = c.horiz,\n                d = a[g ? \"chartX\" : \"chartY\"];\n            g = g ? \"mouseDownX\" : \"mouseDownY\";\n            var u = e[g],\n                l = (c.pointRange || 0) / 2,\n                n = c.reversed && !e.inverted || !c.reversed && e.inverted ? -1 : 1,\n                q = c.getExtremes(),\n                r = c.toValue(u - d, !0) + l * n;\n            n = c.toValue(u + c.len - d, !0) - l * n;\n            var k = n < r;\n            u = k ? n : r;\n            r = k ? r : n;\n            n = c.hasVerticalPanning();\n            var w = c.panningState;\n            !n || b || w && !w.isDirty || c.series.forEach(function (a) {\n              var b = a.getProcessedData(!0);\n              b = a.getExtremes(b.yData, !0);\n              w || (w = {\n                startMin: Number.MAX_VALUE,\n                startMax: -Number.MAX_VALUE\n              });\n              p(b.dataMin) && p(b.dataMax) && (w.startMin = Math.min(I(a.options.threshold, Infinity), b.dataMin, w.startMin), w.startMax = Math.max(I(a.options.threshold, -Infinity), b.dataMax, w.startMax));\n            });\n            b = Math.min(I(null === w || void 0 === w ? void 0 : w.startMin, q.dataMin), l ? q.min : c.toValue(c.toPixels(q.min) - c.minPixelPadding));\n            l = Math.max(I(null === w || void 0 === w ? void 0 : w.startMax, q.dataMax), l ? q.max : c.toValue(c.toPixels(q.max) + c.minPixelPadding));\n            c.panningState = w;\n            c.isOrdinal || (n = b - u, 0 < n && (r += n, u = b), n = r - l, 0 < n && (r = l, u -= n), c.series.length && u !== q.min && r !== q.max && u >= b && r <= l && (c.setExtremes(u, r, !1, !1, {\n              trigger: \"pan\"\n            }), e.resetZoomButton || f || u === b || r === l || !m.match(\"y\") || (e.showResetZoom(), c.displayBtn = !1), h = !0), e[g] = d);\n          });\n          h && e.redraw(!1);\n          b(e.container, {\n            cursor: \"move\"\n          });\n        });\n      };\n\n      return f;\n    }();\n\n    N(ca.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [ca.prototype.addAxis, [!0]],\n        yAxis: [ca.prototype.addAxis, [!1]],\n        series: [ca.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"zAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n\n    k.chart = function (a, b, c) {\n      return new ca(a, b, c);\n    };\n\n    k.Chart = ca;\n    \"\";\n    return ca;\n  });\n  P(k, \"Mixins/LegendSymbol.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = d.merge,\n        x = d.pick;\n    return f.LegendSymbolMixin = {\n      drawRectangle: function (d, f) {\n        var k = d.symbolHeight,\n            H = d.options.squareSymbol;\n        f.legendSymbol = this.chart.renderer.rect(H ? (d.symbolWidth - k) / 2 : 0, d.baseline - k + 1, H ? k : d.symbolWidth, k, x(d.options.symbolRadius, k / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(f.legendGroup);\n      },\n      drawLineMarker: function (d) {\n        var f = this.options,\n            D = f.marker,\n            H = d.symbolWidth,\n            t = d.symbolHeight,\n            C = t / 2,\n            l = this.chart.renderer,\n            E = this.legendGroup;\n        d = d.baseline - Math.round(.3 * d.fontMetrics.b);\n        var g = {};\n        this.chart.styledMode || (g = {\n          \"stroke-width\": f.lineWidth || 0\n        }, f.dashStyle && (g.dashstyle = f.dashStyle));\n        this.legendLine = l.path([[\"M\", 0, d], [\"L\", H, d]]).addClass(\"highcharts-graph\").attr(g).add(E);\n        D && !1 !== D.enabled && H && (f = Math.min(x(D.radius, C), C), 0 === this.symbol.indexOf(\"url\") && (D = k(D, {\n          width: t,\n          height: t\n        }), f = 0), this.legendSymbol = D = l.symbol(this.symbol, H / 2 - f, d - f, 2 * f, 2 * f, D).addClass(\"highcharts-point\").add(E), D.isMarker = !0);\n      }\n    };\n  });\n  P(k, \"Core/Series/Series.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Globals.js\"], k[\"Mixins/LegendSymbol.js\"], k[\"Core/Options.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Series/Point.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Renderer/SVG/SVGElement.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G, D, H, t) {\n    var C = f.animObject,\n        l = f.setAnimation,\n        E = d.hasTouch,\n        g = d.svg,\n        y = d.win,\n        c = x.defaultOptions,\n        q = D.seriesTypes,\n        n = t.addEvent,\n        A = t.arrayMax,\n        M = t.arrayMin,\n        z = t.clamp,\n        m = t.cleanRecursively,\n        r = t.correctFloat,\n        e = t.defined,\n        h = t.erase,\n        a = t.error,\n        b = t.extend,\n        w = t.find,\n        J = t.fireEvent,\n        O = t.getNestedProperty,\n        F = t.isArray,\n        N = t.isFunction,\n        R = t.isNumber,\n        Q = t.isString,\n        T = t.merge,\n        v = t.objectEach,\n        L = t.pick,\n        p = t.removeEvent,\n        K = t.splat,\n        S = t.syncTimeout;\n\n    f = function () {\n      function d() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n\n      d.prototype.init = function (a, c) {\n        J(this, \"init\", {\n          options: c\n        });\n        var e = this,\n            g = a.series,\n            d;\n        this.eventOptions = this.eventOptions || {};\n        this.eventsToUnbind = [];\n        e.chart = a;\n        e.options = c = e.setOptions(c);\n        e.linkedSeries = [];\n        e.bindAxes();\n        b(e, {\n          name: c.name,\n          state: \"\",\n          visible: !1 !== c.visible,\n          selected: !0 === c.selected\n        });\n        var f = c.events;\n        v(f, function (a, b) {\n          N(a) && e.eventOptions[b] !== a && (N(e.eventOptions[b]) && p(e, b, e.eventOptions[b]), e.eventOptions[b] = a, n(e, b, a));\n        });\n        if (f && f.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;\n        e.getColor();\n        e.getSymbol();\n        e.parallelArrays.forEach(function (a) {\n          e[a + \"Data\"] || (e[a + \"Data\"] = []);\n        });\n        e.isCartesian && (a.hasCartesianSeries = !0);\n        g.length && (d = g[g.length - 1]);\n        e._i = L(d && d._i, -1) + 1;\n        e.opacity = e.options.opacity;\n        a.orderSeries(this.insert(g));\n        c.dataSorting && c.dataSorting.enabled ? e.setDataSortingOptions() : e.points || e.data || e.setData(c.data, !1);\n        J(this, \"afterInit\");\n      };\n\n      d.prototype.is = function (a) {\n        return q[a] && this instanceof q[a];\n      };\n\n      d.prototype.insert = function (a) {\n        var b = this.options.index,\n            c;\n\n        if (R(b)) {\n          for (c = a.length; c--;) if (b >= L(a[c].options.index, a[c]._i)) {\n            a.splice(c + 1, 0, this);\n            break;\n          }\n\n          -1 === c && a.unshift(this);\n          c += 1;\n        } else a.push(this);\n\n        return L(c, a.length - 1);\n      };\n\n      d.prototype.bindAxes = function () {\n        var b = this,\n            c = b.options,\n            e = b.chart,\n            g;\n        J(this, \"bindAxes\", null, function () {\n          (b.axisTypes || []).forEach(function (d) {\n            e[d].forEach(function (a) {\n              g = a.options;\n              if (c[d] === g.index || \"undefined\" !== typeof c[d] && c[d] === g.id || \"undefined\" === typeof c[d] && 0 === g.index) b.insert(a.series), b[d] = a, a.isDirty = !0;\n            });\n            b[d] || b.optionalAxis === d || a(18, !0, e);\n          });\n        });\n        J(this, \"afterBindAxes\");\n      };\n\n      d.prototype.updateParallelArrays = function (a, b) {\n        var c = a.series,\n            e = arguments,\n            g = R(b) ? function (e) {\n          var g = \"y\" === e && c.toYData ? c.toYData(a) : a[e];\n          c[e + \"Data\"][b] = g;\n        } : function (a) {\n          Array.prototype[b].apply(c[a + \"Data\"], Array.prototype.slice.call(e, 2));\n        };\n        c.parallelArrays.forEach(g);\n      };\n\n      d.prototype.hasData = function () {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      };\n\n      d.prototype.autoIncrement = function () {\n        var a = this.options,\n            b = this.xIncrement,\n            c,\n            e = a.pointIntervalUnit,\n            g = this.chart.time;\n        b = L(b, a.pointStart, 0);\n        this.pointInterval = c = L(this.pointInterval, a.pointInterval, 1);\n        e && (a = new g.Date(b), \"day\" === e ? g.set(\"Date\", a, g.get(\"Date\", a) + c) : \"month\" === e ? g.set(\"Month\", a, g.get(\"Month\", a) + c) : \"year\" === e && g.set(\"FullYear\", a, g.get(\"FullYear\", a) + c), c = a.getTime() - b);\n        this.xIncrement = b + c;\n        return b;\n      };\n\n      d.prototype.setDataSortingOptions = function () {\n        var a = this.options;\n        b(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        e(a.pointRange) || (a.pointRange = 1);\n      };\n\n      d.prototype.setOptions = function (a) {\n        var b = this.chart,\n            g = b.options,\n            d = g.plotOptions,\n            f = b.userOptions || {};\n        a = T(a);\n        b = b.styledMode;\n        var h = {\n          plotOptions: d,\n          userOptions: a\n        };\n        J(this, \"setOptions\", h);\n        var m = h.plotOptions[this.type],\n            l = f.plotOptions || {};\n        this.userOptions = h.userOptions;\n        f = T(m, d.series, f.plotOptions && f.plotOptions[this.type], a);\n        this.tooltipOptions = T(c.tooltip, c.plotOptions.series && c.plotOptions.series.tooltip, c.plotOptions[this.type].tooltip, g.tooltip.userOptions, d.series && d.series.tooltip, d[this.type].tooltip, a.tooltip);\n        this.stickyTracking = L(a.stickyTracking, l[this.type] && l[this.type].stickyTracking, l.series && l.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);\n        null === m.marker && delete f.marker;\n        this.zoneAxis = f.zoneAxis;\n        g = this.zones = (f.zones || []).slice();\n        !f.negativeColor && !f.negativeFillColor || f.zones || (d = {\n          value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n          className: \"highcharts-negative\"\n        }, b || (d.color = f.negativeColor, d.fillColor = f.negativeFillColor), g.push(d));\n        g.length && e(g[g.length - 1].value) && g.push(b ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        J(this, \"afterSetOptions\", {\n          options: f\n        });\n        return f;\n      };\n\n      d.prototype.getName = function () {\n        return L(this.options.name, \"Series \" + (this.index + 1));\n      };\n\n      d.prototype.getCyclic = function (a, b, c) {\n        var g = this.chart,\n            d = this.userOptions,\n            f = a + \"Index\",\n            h = a + \"Counter\",\n            m = c ? c.length : L(g.options.chart[a + \"Count\"], g[a + \"Count\"]);\n\n        if (!b) {\n          var l = L(d[f], d[\"_\" + f]);\n          e(l) || (g.series.length || (g[h] = 0), d[\"_\" + f] = l = g[h] % m, g[h] += 1);\n          c && (b = c[l]);\n        }\n\n        \"undefined\" !== typeof l && (this[f] = l);\n        this[a] = b;\n      };\n\n      d.prototype.getColor = function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.options.color = null : this.getCyclic(\"color\", this.options.color || c.plotOptions[this.type].color, this.chart.options.colors);\n      };\n\n      d.prototype.getPointsCollection = function () {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      };\n\n      d.prototype.getSymbol = function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      };\n\n      d.prototype.findPointIndex = function (a, b) {\n        var c = a.id,\n            e = a.x,\n            g = this.points,\n            d,\n            f = this.options.dataSorting;\n        if (c) var h = this.chart.get(c);else if (this.linkedParent || this.enabledDataSorting) {\n          var m = f && f.matchByName ? \"name\" : \"index\";\n          h = w(g, function (b) {\n            return !b.touched && b[m] === a[m];\n          });\n          if (!h) return;\n        }\n\n        if (h) {\n          var l = h && h.index;\n          \"undefined\" !== typeof l && (d = !0);\n        }\n\n        \"undefined\" === typeof l && R(e) && (l = this.xData.indexOf(e, b));\n        -1 !== l && \"undefined\" !== typeof l && this.cropped && (l = l >= this.cropStart ? l - this.cropStart : l);\n        !d && g[l] && g[l].touched && (l = void 0);\n        return l;\n      };\n\n      d.prototype.updateData = function (a, b) {\n        var c = this.options,\n            g = c.dataSorting,\n            d = this.points,\n            f = [],\n            h,\n            m,\n            l,\n            n = this.requireSorting,\n            u = a.length === d.length,\n            p = !0;\n        this.xIncrement = null;\n        a.forEach(function (a, b) {\n          var m = e(a) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, a) || {};\n          var p = m.x;\n\n          if (m.id || R(p)) {\n            if (p = this.findPointIndex(m, l), -1 === p || \"undefined\" === typeof p ? f.push(a) : d[p] && a !== c.data[p] ? (d[p].update(a, !1, null, !1), d[p].touched = !0, n && (l = p + 1)) : d[p] && (d[p].touched = !0), !u || b !== p || g && g.enabled || this.hasDerivedData) h = !0;\n          } else f.push(a);\n        }, this);\n        if (h) for (a = d.length; a--;) (m = d[a]) && !m.touched && m.remove && m.remove(!1, b);else !u || g && g.enabled ? p = !1 : (a.forEach(function (a, b) {\n          d[b].update && a !== d[b].y && d[b].update(a, !1, null, !1);\n        }), f.length = 0);\n        d.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!p) return !1;\n        f.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = A(this.xData), this.autoIncrement());\n        return !0;\n      };\n\n      d.prototype.setData = function (b, c, e, g) {\n        var d = this,\n            f = d.points,\n            h = f && f.length || 0,\n            m,\n            l = d.options,\n            n = d.chart,\n            u = l.dataSorting,\n            p = null,\n            q = d.xAxis;\n        p = l.turboThreshold;\n        var r = this.xData,\n            k = this.yData,\n            w = (m = d.pointArrayMap) && m.length,\n            y = l.keys,\n            t = 0,\n            I = 1,\n            v;\n        b = b || [];\n        m = b.length;\n        c = L(c, !0);\n        u && u.enabled && (b = this.sortData(b));\n        !1 !== g && m && h && !d.cropped && !d.hasGroupedData && d.visible && !d.isSeriesBoosting && (v = this.updateData(b, e));\n\n        if (!v) {\n          d.xIncrement = null;\n          d.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            d[a + \"Data\"].length = 0;\n          });\n          if (p && m > p) {\n            if (p = d.getFirstValidPoint(b), R(p)) for (e = 0; e < m; e++) r[e] = this.autoIncrement(), k[e] = b[e];else if (F(p)) {\n              if (w) for (e = 0; e < m; e++) g = b[e], r[e] = g[0], k[e] = g.slice(1, w + 1);else for (y && (t = y.indexOf(\"x\"), I = y.indexOf(\"y\"), t = 0 <= t ? t : 0, I = 0 <= I ? I : 1), e = 0; e < m; e++) g = b[e], r[e] = g[t], k[e] = g[I];\n            } else a(12, !1, n);\n          } else for (e = 0; e < m; e++) \"undefined\" !== typeof b[e] && (g = {\n            series: d\n          }, d.pointClass.prototype.applyOptions.apply(g, [b[e]]), d.updateParallelArrays(g, e));\n          k && Q(k[0]) && a(14, !0, n);\n          d.data = [];\n          d.options.data = d.userOptions.data = b;\n\n          for (e = h; e--;) f[e] && f[e].destroy && f[e].destroy();\n\n          q && (q.minRange = q.userMinRange);\n          d.isDirty = n.isDirtyBox = !0;\n          d.isDirtyData = !!f;\n          e = !1;\n        }\n\n        \"point\" === l.legendType && (this.processData(), this.generatePoints());\n        c && n.redraw(e);\n      };\n\n      d.prototype.sortData = function (a) {\n        var b = this,\n            c = b.options.dataSorting.sortKey || \"y\",\n            g = function (a, b) {\n          return e(b) && a.pointClass.prototype.optionsToObject.call({\n            series: a\n          }, b) || {};\n        };\n\n        a.forEach(function (c, e) {\n          a[e] = g(b, c);\n          a[e].index = e;\n        }, this);\n        a.concat().sort(function (a, b) {\n          a = O(c, a);\n          b = O(c, b);\n          return b < a ? -1 : b > a ? 1 : 0;\n        }).forEach(function (a, b) {\n          a.x = b;\n        }, this);\n        b.linkedSeries && b.linkedSeries.forEach(function (b) {\n          var c = b.options,\n              e = c.data;\n          c.dataSorting && c.dataSorting.enabled || !e || (e.forEach(function (c, d) {\n            e[d] = g(b, c);\n            a[d] && (e[d].x = a[d].x, e[d].index = d);\n          }), b.setData(e, !1));\n        });\n        return a;\n      };\n\n      d.prototype.getProcessedData = function (b) {\n        var c = this.xData,\n            e = this.yData,\n            g = c.length;\n        var d = 0;\n        var f = this.xAxis,\n            h = this.options;\n        var m = h.cropThreshold;\n        var l = b || this.getExtremesFromAll || h.getExtremesFromAll,\n            n = this.isCartesian;\n        b = f && f.val2lin;\n        h = !(!f || !f.logarithmic);\n        var p = this.requireSorting;\n\n        if (f) {\n          f = f.getExtremes();\n          var u = f.min;\n          var q = f.max;\n        }\n\n        if (n && this.sorted && !l && (!m || g > m || this.forceCrop)) if (c[g - 1] < u || c[0] > q) c = [], e = [];else if (this.yData && (c[0] < u || c[g - 1] > q)) {\n          d = this.cropData(this.xData, this.yData, u, q);\n          c = d.xData;\n          e = d.yData;\n          d = d.start;\n          var r = !0;\n        }\n\n        for (m = c.length || 1; --m;) if (g = h ? b(c[m]) - b(c[m - 1]) : c[m] - c[m - 1], 0 < g && (\"undefined\" === typeof k || g < k)) var k = g;else 0 > g && p && (a(15, !1, this.chart), p = !1);\n\n        return {\n          xData: c,\n          yData: e,\n          cropped: r,\n          cropStart: d,\n          closestPointRange: k\n        };\n      };\n\n      d.prototype.processData = function (a) {\n        var b = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !b.isDirty && !this.yAxis.isDirty && !a) return !1;\n        a = this.getProcessedData();\n        this.cropped = a.cropped;\n        this.cropStart = a.cropStart;\n        this.processedXData = a.xData;\n        this.processedYData = a.yData;\n        this.closestPointRange = this.basePointRange = a.closestPointRange;\n      };\n\n      d.prototype.cropData = function (a, b, c, e, g) {\n        var d = a.length,\n            f = 0,\n            h = d,\n            m;\n        g = L(g, this.cropShoulder);\n\n        for (m = 0; m < d; m++) if (a[m] >= c) {\n          f = Math.max(0, m - g);\n          break;\n        }\n\n        for (c = m; c < d; c++) if (a[c] > e) {\n          h = c + g;\n          break;\n        }\n\n        return {\n          xData: a.slice(f, h),\n          yData: b.slice(f, h),\n          start: f,\n          end: h\n        };\n      };\n\n      d.prototype.generatePoints = function () {\n        var a = this.options,\n            c = a.data,\n            e = this.data,\n            g,\n            d = this.processedXData,\n            f = this.processedYData,\n            h = this.pointClass,\n            m = d.length,\n            l = this.cropStart || 0,\n            n = this.hasGroupedData;\n        a = a.keys;\n        var p = [],\n            q;\n        e || n || (e = [], e.length = c.length, e = this.data = e);\n        a && n && (this.options.keys = !1);\n\n        for (q = 0; q < m; q++) {\n          var r = l + q;\n\n          if (n) {\n            var k = new h().init(this, [d[q]].concat(K(f[q])));\n            k.dataGroup = this.groupMap[q];\n            k.dataGroup.options && (k.options = k.dataGroup.options, b(k, k.dataGroup.options), delete k.dataLabels);\n          } else (k = e[r]) || \"undefined\" === typeof c[r] || (e[r] = k = new h().init(this, c[r], d[q]));\n\n          k && (k.index = r, p[q] = k);\n        }\n\n        this.options.keys = a;\n        if (e && (m !== (g = e.length) || n)) for (q = 0; q < g; q++) q !== l || n || (q += m), e[q] && (e[q].destroyElements(), e[q].plotX = void 0);\n        this.data = e;\n        this.points = p;\n        J(this, \"afterGeneratePoints\");\n      };\n\n      d.prototype.getXExtremes = function (a) {\n        return {\n          min: M(a),\n          max: A(a)\n        };\n      };\n\n      d.prototype.getExtremes = function (a, b) {\n        var c = this.xAxis,\n            e = this.yAxis,\n            g = this.processedXData || this.xData,\n            d = [],\n            f = 0,\n            h = 0;\n        var m = 0;\n        var l = this.requireSorting ? this.cropShoulder : 0,\n            n = e ? e.positiveValuesOnly : !1,\n            p;\n        a = a || this.stackedYData || this.processedYData || [];\n        e = a.length;\n        c && (m = c.getExtremes(), h = m.min, m = m.max);\n\n        for (p = 0; p < e; p++) {\n          var u = g[p];\n          var q = a[p];\n          var r = (R(q) || F(q)) && (q.length || 0 < q || !n);\n          u = b || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !c || (g[p + l] || u) >= h && (g[p - l] || u) <= m;\n          if (r && u) if (r = q.length) for (; r--;) R(q[r]) && (d[f++] = q[r]);else d[f++] = q;\n        }\n\n        a = {\n          dataMin: M(d),\n          dataMax: A(d)\n        };\n        J(this, \"afterGetExtremes\", {\n          dataExtremes: a\n        });\n        return a;\n      };\n\n      d.prototype.applyExtremes = function () {\n        var a = this.getExtremes();\n        this.dataMin = a.dataMin;\n        this.dataMax = a.dataMax;\n        return a;\n      };\n\n      d.prototype.getFirstValidPoint = function (a) {\n        for (var b = null, c = a.length, e = 0; null === b && e < c;) b = a[e], e++;\n\n        return b;\n      };\n\n      d.prototype.translate = function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var a = this.options,\n            b = a.stacking,\n            c = this.xAxis,\n            g = c.categories,\n            d = this.enabledDataSorting,\n            f = this.yAxis,\n            h = this.points,\n            m = h.length,\n            l = !!this.modifyValue,\n            n,\n            p = this.pointPlacementToXValue(),\n            q = !!p,\n            k = a.threshold,\n            w = a.startFromThreshold ? k : 0,\n            y,\n            t = this.zoneAxis || \"y\",\n            v = Number.MAX_VALUE;\n\n        for (n = 0; n < m; n++) {\n          var A = h[n],\n              C = A.x,\n              E = A.y,\n              x = A.low,\n              M = b && f.stacking && f.stacking.stacks[(this.negStacks && E < (w ? 0 : k) ? \"-\" : \"\") + this.stackKey];\n          if (f.positiveValuesOnly && !f.validatePositiveValue(E) || c.positiveValuesOnly && !c.validatePositiveValue(C)) A.isNull = !0;\n          A.plotX = y = r(z(c.translate(C, 0, 0, 0, 1, p, \"flags\" === this.type), -1E5, 1E5));\n\n          if (b && this.visible && M && M[C]) {\n            var N = this.getStackIndicator(N, C, this.index);\n\n            if (!A.isNull) {\n              var H = M[C];\n              var Q = H.points[N.key];\n            }\n          }\n\n          F(Q) && (x = Q[0], E = Q[1], x === w && N.key === M[C].base && (x = L(R(k) && k, f.min)), f.positiveValuesOnly && 0 >= x && (x = null), A.total = A.stackTotal = H.total, A.percentage = H.total && A.y / H.total * 100, A.stackY = E, this.irregularWidths || H.setOffset(this.pointXOffset || 0, this.barW || 0));\n          A.yBottom = e(x) ? z(f.translate(x, 0, 1, 0, 1), -1E5, 1E5) : null;\n          l && (E = this.modifyValue(E, A));\n          A.plotY = void 0;\n          R(E) && (E = f.translate(E, !1, !0, !1, !0), \"undefined\" !== typeof E && (A.plotY = z(E, -1E5, 1E5)));\n          A.isInside = this.isPointInside(A);\n          A.clientX = q ? r(c.translate(C, 0, 0, 0, 1, p)) : y;\n          A.negative = A[t] < (a[t + \"Threshold\"] || k || 0);\n          A.category = g && \"undefined\" !== typeof g[A.x] ? g[A.x] : A.x;\n\n          if (!A.isNull && !1 !== A.visible) {\n            \"undefined\" !== typeof D && (v = Math.min(v, Math.abs(y - D)));\n            var D = y;\n          }\n\n          A.zone = this.zones.length && A.getZone();\n          !A.graphic && this.group && d && (A.isNew = !0);\n        }\n\n        this.closestPointRangePx = v;\n        J(this, \"afterTranslate\");\n      };\n\n      d.prototype.getValidPoints = function (a, b, c) {\n        var e = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return b && !e.isInsidePlot(a.plotX, a.plotY, e.inverted) ? !1 : !1 !== a.visible && (c || !a.isNull);\n        });\n      };\n\n      d.prototype.getClipBox = function (a, b) {\n        var c = this.options,\n            e = this.chart,\n            g = e.inverted,\n            d = this.xAxis,\n            f = d && this.yAxis,\n            h = e.options.chart.scrollablePlotArea || {};\n        a && !1 === c.clip && f ? a = g ? {\n          y: -e.chartWidth + f.len + f.pos,\n          height: e.chartWidth,\n          width: e.chartHeight,\n          x: -e.chartHeight + d.len + d.pos\n        } : {\n          y: -f.pos,\n          height: e.chartHeight,\n          width: e.chartWidth,\n          x: -d.pos\n        } : (a = this.clipBox || e.clipBox, b && (a.width = e.plotSizeX, a.x = (e.scrollablePixelsX || 0) * (h.scrollPositionX || 0)));\n        return b ? {\n          width: a.width,\n          x: a.x\n        } : a;\n      };\n\n      d.prototype.setClip = function (a) {\n        var b = this.chart,\n            c = this.options,\n            e = b.renderer,\n            g = b.inverted,\n            d = this.clipBox,\n            f = this.getClipBox(a),\n            h = this.sharedClipKey || [\"_sharedClip\", a && a.duration, a && a.easing, a && a.defer, f.height, c.xAxis, c.yAxis].join(),\n            m = b[h],\n            l = b[h + \"m\"];\n        a && (f.width = 0, g && (f.x = b.plotHeight + (!1 !== c.clip ? 0 : b.plotTop)));\n        m ? b.hasLoaded || m.attr(f) : (a && (b[h + \"m\"] = l = e.clipRect(g ? b.plotSizeX + 99 : -99, g ? -b.plotLeft : -b.plotTop, 99, g ? b.chartWidth : b.chartHeight)), b[h] = m = e.clipRect(f), m.count = {\n          length: 0\n        });\n        a && !m.count[this.index] && (m.count[this.index] = !0, m.count.length += 1);\n        if (!1 !== c.clip || a) this.group.clip(a || d ? m : b.clipRect), this.markerGroup.clip(l), this.sharedClipKey = h;\n        a || (m.count[this.index] && (delete m.count[this.index], --m.count.length), 0 === m.count.length && h && b[h] && (d || (b[h] = b[h].destroy()), b[h + \"m\"] && (b[h + \"m\"] = b[h + \"m\"].destroy())));\n      };\n\n      d.prototype.animate = function (a) {\n        var b = this.chart,\n            c = C(this.options.animation);\n        if (a) this.setClip(c);else {\n          var e = this.sharedClipKey;\n          a = b[e];\n          var g = this.getClipBox(c, !0);\n          a && a.animate(g, c);\n          b[e + \"m\"] && b[e + \"m\"].animate({\n            width: g.width + 99,\n            x: g.x - (b.inverted ? 0 : 99)\n          }, c);\n        }\n      };\n\n      d.prototype.afterAnimate = function () {\n        this.setClip();\n        J(this, \"afterAnimate\");\n        this.finishedAnimating = !0;\n      };\n\n      d.prototype.drawPoints = function () {\n        var a = this.points,\n            b = this.chart,\n            c,\n            e,\n            g = this.options.marker,\n            d = this[this.specialGroup] || this.markerGroup,\n            f = this.xAxis,\n            h = L(g.enabled, !f || f.isRadial ? !0 : null, this.closestPointRangePx >= g.enabledThreshold * g.radius);\n        if (!1 !== g.enabled || this._hasPointMarkers) for (c = 0; c < a.length; c++) {\n          var m = a[c];\n          var l = (e = m.graphic) ? \"animate\" : \"attr\";\n          var n = m.marker || {};\n          var p = !!m.marker;\n\n          if ((h && \"undefined\" === typeof n.enabled || n.enabled) && !m.isNull && !1 !== m.visible) {\n            var q = L(n.symbol, this.symbol);\n            var r = this.markerAttribs(m, m.selected && \"select\");\n            this.enabledDataSorting && (m.startXPos = f.reversed ? -r.width : f.width);\n            var k = !1 !== m.isInside;\n            e ? e[k ? \"show\" : \"hide\"](k).animate(r) : k && (0 < r.width || m.hasImage) && (m.graphic = e = b.renderer.symbol(q, r.x, r.y, r.width, r.height, p ? n : g).add(d), this.enabledDataSorting && b.hasRendered && (e.attr({\n              x: m.startXPos\n            }), l = \"animate\"));\n            e && \"animate\" === l && e[k ? \"show\" : \"hide\"](k).animate(r);\n            if (e && !b.styledMode) e[l](this.pointAttribs(m, m.selected && \"select\"));\n            e && e.addClass(m.getClassName(), !0);\n          } else e && (m.graphic = e.destroy());\n        }\n      };\n\n      d.prototype.markerAttribs = function (a, b) {\n        var c = this.options,\n            e = c.marker,\n            g = a.marker || {},\n            d = g.symbol || e.symbol,\n            f = L(g.radius, e.radius);\n        b && (e = e.states[b], b = g.states && g.states[b], f = L(b && b.radius, e && e.radius, f + (e && e.radiusPlus || 0)));\n        a.hasImage = d && 0 === d.indexOf(\"url\");\n        a.hasImage && (f = 0);\n        a = {\n          x: c.crisp ? Math.floor(a.plotX) - f : a.plotX - f,\n          y: a.plotY - f\n        };\n        f && (a.width = a.height = 2 * f);\n        return a;\n      };\n\n      d.prototype.pointAttribs = function (a, b) {\n        var c = this.options.marker,\n            e = a && a.options,\n            g = e && e.marker || {},\n            d = this.color,\n            f = e && e.color,\n            h = a && a.color;\n        e = L(g.lineWidth, c.lineWidth);\n        var m = a && a.zone && a.zone.color;\n        a = 1;\n        d = f || m || h || d;\n        f = g.fillColor || c.fillColor || d;\n        d = g.lineColor || c.lineColor || d;\n        b = b || \"normal\";\n        c = c.states[b];\n        b = g.states && g.states[b] || {};\n        e = L(b.lineWidth, c.lineWidth, e + L(b.lineWidthPlus, c.lineWidthPlus, 0));\n        f = b.fillColor || c.fillColor || f;\n        d = b.lineColor || c.lineColor || d;\n        a = L(b.opacity, c.opacity, a);\n        return {\n          stroke: d,\n          \"stroke-width\": e,\n          fill: f,\n          opacity: a\n        };\n      };\n\n      d.prototype.destroy = function (a) {\n        var b = this,\n            c = b.chart,\n            e = /AppleWebKit\\/533/.test(y.navigator.userAgent),\n            g,\n            d,\n            f = b.data || [],\n            m,\n            l;\n        J(b, \"destroy\");\n        this.removeEvents(a);\n        (b.axisTypes || []).forEach(function (a) {\n          (l = b[a]) && l.series && (h(l.series, b), l.isDirty = l.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (d = f.length; d--;) (m = f[d]) && m.destroy && m.destroy();\n\n        b.points = null;\n        t.clearTimeout(b.animationTimeout);\n        v(b, function (a, b) {\n          a instanceof H && !a.survive && (g = e && \"group\" === b ? \"hide\" : \"destroy\", a[g]());\n        });\n        c.hoverSeries === b && (c.hoverSeries = null);\n        h(c.series, b);\n        c.orderSeries();\n        v(b, function (c, e) {\n          a && \"hcEvents\" === e || delete b[e];\n        });\n      };\n\n      d.prototype.applyZones = function () {\n        var a = this,\n            b = this.chart,\n            c = b.renderer,\n            e = this.zones,\n            g,\n            d,\n            f = this.clips || [],\n            h,\n            m = this.graph,\n            l = this.area,\n            n = Math.max(b.chartWidth, b.chartHeight),\n            p = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            q = b.inverted,\n            r,\n            k,\n            w,\n            y = !1,\n            t,\n            v;\n\n        if (e.length && (m || l) && p && \"undefined\" !== typeof p.min) {\n          var A = p.reversed;\n          var F = p.horiz;\n          m && !this.showLine && m.hide();\n          l && l.hide();\n          var E = p.getExtremes();\n          e.forEach(function (e, u) {\n            g = A ? F ? b.plotWidth : 0 : F ? 0 : p.toPixels(E.min) || 0;\n            g = z(L(d, g), 0, n);\n            d = z(Math.round(p.toPixels(L(e.value, E.max), !0) || 0), 0, n);\n            y && (g = d = p.toPixels(E.max));\n            r = Math.abs(g - d);\n            k = Math.min(g, d);\n            w = Math.max(g, d);\n            p.isXAxis ? (h = {\n              x: q ? w : k,\n              y: 0,\n              width: r,\n              height: n\n            }, F || (h.x = b.plotHeight - h.x)) : (h = {\n              x: 0,\n              y: q ? w : k,\n              width: n,\n              height: r\n            }, F && (h.y = b.plotWidth - h.y));\n            q && c.isVML && (h = p.isXAxis ? {\n              x: 0,\n              y: A ? k : w,\n              height: h.width,\n              width: b.chartWidth\n            } : {\n              x: h.y - b.plotLeft - b.spacingBox.x,\n              y: 0,\n              width: h.height,\n              height: b.chartHeight\n            });\n            f[u] ? f[u].animate(h) : f[u] = c.clipRect(h);\n            t = a[\"zone-area-\" + u];\n            v = a[\"zone-graph-\" + u];\n            m && v && v.clip(f[u]);\n            l && t && t.clip(f[u]);\n            y = e.value > E.max;\n            a.resetZones && 0 === d && (d = void 0);\n          });\n          this.clips = f;\n        } else a.visible && (m && m.show(!0), l && l.show(!0));\n      };\n\n      d.prototype.invertGroups = function (a) {\n        function b() {\n          [\"group\", \"markerGroup\"].forEach(function (b) {\n            c[b] && (e.renderer.isVML && c[b].attr({\n              width: c.yAxis.len,\n              height: c.xAxis.len\n            }), c[b].width = c.yAxis.len, c[b].height = c.xAxis.len, c[b].invert(c.isRadialSeries ? !1 : a));\n          });\n        }\n\n        var c = this,\n            e = c.chart;\n        c.xAxis && (c.eventsToUnbind.push(n(e, \"resize\", b)), b(), c.invertGroups = b);\n      };\n\n      d.prototype.plotGroup = function (a, b, c, g, d) {\n        var f = this[a],\n            h = !f;\n        c = {\n          visibility: c,\n          zIndex: g || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (c.opacity = this.opacity);\n        h && (this[a] = f = this.chart.renderer.g().add(d));\n        f.addClass(\"highcharts-\" + b + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (e(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (f.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        f.attr(c)[h ? \"attr\" : \"animate\"](this.getPlotBox());\n        return f;\n      };\n\n      d.prototype.getPlotBox = function () {\n        var a = this.chart,\n            b = this.xAxis,\n            c = this.yAxis;\n        a.inverted && (b = c, c = this.xAxis);\n        return {\n          translateX: b ? b.left : a.plotLeft,\n          translateY: c ? c.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      };\n\n      d.prototype.removeEvents = function (a) {\n        a || p(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind.length = 0);\n      };\n\n      d.prototype.render = function () {\n        var a = this,\n            b = a.chart,\n            c = a.options,\n            e = C(c.animation),\n            g = !a.finishedAnimating && b.renderer.isSVG && e.duration,\n            d = a.visible ? \"inherit\" : \"hidden\",\n            f = c.zIndex,\n            h = a.hasRendered,\n            m = b.seriesGroup,\n            l = b.inverted;\n        J(this, \"render\");\n        var n = a.plotGroup(\"group\", \"series\", d, f, m);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", d, f, m);\n        g && a.animate && a.animate(!0);\n        n.inverted = L(a.invertible, a.isCartesian) ? l : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(l);\n        !1 === c.clip || a.sharedClipKey || h || n.clip(b.clipRect);\n        g && a.animate && a.animate();\n        h || (g && e.defer && (g += e.defer), a.animationTimeout = S(function () {\n          a.afterAnimate();\n        }, g || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        J(a, \"afterRender\");\n      };\n\n      d.prototype.redraw = function () {\n        var a = this.chart,\n            b = this.isDirty || this.isDirtyData,\n            c = this.group,\n            e = this.xAxis,\n            g = this.yAxis;\n        c && (a.inverted && c.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), c.animate({\n          translateX: L(e && e.left, a.plotLeft),\n          translateY: L(g && g.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        b && delete this.kdTree;\n      };\n\n      d.prototype.searchPoint = function (a, b) {\n        var c = this.xAxis,\n            e = this.yAxis,\n            g = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: g ? c.len - a.chartY + c.pos : a.chartX - c.pos,\n          plotY: g ? e.len - a.chartX + e.pos : a.chartY - e.pos\n        }, b, a);\n      };\n\n      d.prototype.buildKDTree = function (a) {\n        function b(a, e, g) {\n          var d;\n\n          if (d = a && a.length) {\n            var f = c.kdAxisArray[e % g];\n            a.sort(function (a, b) {\n              return a[f] - b[f];\n            });\n            d = Math.floor(d / 2);\n            return {\n              point: a[d],\n              left: b(a.slice(0, d), e + 1, g),\n              right: b(a.slice(d + 1), e + 1, g)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var c = this,\n            e = -1 < c.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete c.kdTree;\n        S(function () {\n          c.kdTree = b(c.getValidPoints(null, !c.directTouch), e, e);\n          c.buildingKdTree = !1;\n        }, c.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      };\n\n      d.prototype.searchKDTree = function (a, b, c) {\n        function g(a, b, c, l) {\n          var n = b.point,\n              p = d.kdAxisArray[c % l],\n              q = n;\n          var r = e(a[f]) && e(n[f]) ? Math.pow(a[f] - n[f], 2) : null;\n          var k = e(a[h]) && e(n[h]) ? Math.pow(a[h] - n[h], 2) : null;\n          k = (r || 0) + (k || 0);\n          n.dist = e(k) ? Math.sqrt(k) : Number.MAX_VALUE;\n          n.distX = e(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n          p = a[p] - n[p];\n          k = 0 > p ? \"left\" : \"right\";\n          r = 0 > p ? \"right\" : \"left\";\n          b[k] && (k = g(a, b[k], c + 1, l), q = k[m] < q[m] ? k : n);\n          b[r] && Math.sqrt(p * p) < q[m] && (a = g(a, b[r], c + 1, l), q = a[m] < q[m] ? a : q);\n          return q;\n        }\n\n        var d = this,\n            f = this.kdAxisArray[0],\n            h = this.kdAxisArray[1],\n            m = b ? \"distX\" : \"dist\";\n        b = -1 < d.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(c);\n        if (this.kdTree) return g(a, this.kdTree, b, b);\n      };\n\n      d.prototype.pointPlacementToXValue = function () {\n        var a = this.options,\n            b = a.pointRange,\n            c = this.xAxis;\n        a = a.pointPlacement;\n        \"between\" === a && (a = c.reversed ? -.5 : .5);\n        return R(a) ? a * (b || c.pointRange) : 0;\n      };\n\n      d.prototype.isPointInside = function (a) {\n        return \"undefined\" !== typeof a.plotY && \"undefined\" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= this.yAxis.len && 0 <= a.plotX && a.plotX <= this.xAxis.len;\n      };\n\n      d.prototype.drawTracker = function () {\n        var a = this,\n            b = a.options,\n            c = b.trackByArea,\n            e = [].concat(c ? a.areaPath : a.graphPath),\n            d = a.chart,\n            f = d.pointer,\n            h = d.renderer,\n            m = d.options.tooltip.snap,\n            l = a.tracker,\n            n = function (b) {\n          if (d.hoverSeries !== a) a.onMouseOver();\n        },\n            p = \"rgba(192,192,192,\" + (g ? .0001 : .002) + \")\";\n\n        l ? l.attr({\n          d: e\n        }) : a.graph && (a.tracker = h.path(e).attr({\n          visibility: a.visible ? \"visible\" : \"hidden\",\n          zIndex: 2\n        }).addClass(c ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), d.styledMode || a.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: p,\n          fill: c ? p : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (c ? 0 : 2 * m)\n        }), [a.tracker, a.markerGroup].forEach(function (a) {\n          a.addClass(\"highcharts-tracker\").on(\"mouseover\", n).on(\"mouseout\", function (a) {\n            f.onTrackerMouseOut(a);\n          });\n          b.cursor && !d.styledMode && a.css({\n            cursor: b.cursor\n          });\n          if (E) a.on(\"touchstart\", n);\n        }));\n        J(this, \"afterDrawTracker\");\n      };\n\n      d.prototype.addPoint = function (a, b, c, e, g) {\n        var d = this.options,\n            f = this.data,\n            h = this.chart,\n            m = this.xAxis;\n        m = m && m.hasNames && m.names;\n        var l = d.data,\n            n = this.xData,\n            p;\n        b = L(b, !0);\n        var q = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(q, [a]);\n        var r = q.x;\n        var k = n.length;\n        if (this.requireSorting && r < n[k - 1]) for (p = !0; k && n[k - 1] > r;) k--;\n        this.updateParallelArrays(q, \"splice\", k, 0, 0);\n        this.updateParallelArrays(q, k);\n        m && q.name && (m[r] = q.name);\n        l.splice(k, 0, a);\n        p && (this.data.splice(k, 0, null), this.processData());\n        \"point\" === d.legendType && this.generatePoints();\n        c && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(q, \"shift\"), l.shift()));\n        !1 !== g && J(this, \"addPoint\", {\n          point: q\n        });\n        this.isDirtyData = this.isDirty = !0;\n        b && h.redraw(e);\n      };\n\n      d.prototype.removePoint = function (a, b, c) {\n        var e = this,\n            g = e.data,\n            d = g[a],\n            f = e.points,\n            h = e.chart,\n            m = function () {\n          f && f.length === g.length && f.splice(a, 1);\n          g.splice(a, 1);\n          e.options.data.splice(a, 1);\n          e.updateParallelArrays(d || {\n            series: e\n          }, \"splice\", a, 1);\n          d && d.destroy();\n          e.isDirty = !0;\n          e.isDirtyData = !0;\n          b && h.redraw();\n        };\n\n        l(c, h);\n        b = L(b, !0);\n        d ? d.firePointEvent(\"remove\", null, m) : m();\n      };\n\n      d.prototype.remove = function (a, b, c, e) {\n        function g() {\n          d.destroy(e);\n          f.isDirtyLegend = f.isDirtyBox = !0;\n          f.linkSeries();\n          L(a, !0) && f.redraw(b);\n        }\n\n        var d = this,\n            f = d.chart;\n        !1 !== c ? J(d, \"remove\", null, g) : g();\n      };\n\n      d.prototype.update = function (c, e) {\n        c = m(c, this.userOptions);\n        J(this, \"update\", {\n          options: c\n        });\n        var g = this,\n            d = g.chart,\n            f = g.userOptions,\n            h = g.initialType || g.type,\n            l = d.options.plotOptions,\n            n = c.type || f.type || d.options.chart.type,\n            p = !(this.hasDerivedData || n && n !== this.type || \"undefined\" !== typeof c.pointStart || \"undefined\" !== typeof c.pointInterval || g.hasOptionChanged(\"dataGrouping\") || g.hasOptionChanged(\"pointStart\") || g.hasOptionChanged(\"pointInterval\") || g.hasOptionChanged(\"pointIntervalUnit\") || g.hasOptionChanged(\"keys\")),\n            r = q[h].prototype,\n            k,\n            w = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            u = g.finishedAnimating && {\n          animation: !1\n        },\n            y = {};\n        p && (w.push(\"data\", \"isDirtyData\", \"points\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"nodes\", \"layout\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== c.visible && w.push(\"area\", \"graph\"), g.parallelArrays.forEach(function (a) {\n          w.push(a + \"Data\");\n        }), c.data && (c.dataSorting && b(g.options.dataSorting, c.dataSorting), this.setData(c.data, !1)));\n        c = T(f, u, {\n          index: \"undefined\" === typeof f.index ? g.index : f.index,\n          pointStart: L(l && l.series && l.series.pointStart, f.pointStart, g.xData[0])\n        }, !p && {\n          data: g.options.data\n        }, c);\n        p && c.data && (c.data = g.options.data);\n        w = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(w);\n        w.forEach(function (a) {\n          w[a] = g[a];\n          delete g[a];\n        });\n\n        if (q[n || h]) {\n          if (f = n !== g.type, g.remove(!1, !1, !1, !0), f) if (Object.setPrototypeOf) Object.setPrototypeOf(g, q[n || h].prototype);else {\n            f = Object.hasOwnProperty.call(g, \"hcEvents\") && g.hcEvents;\n\n            for (k in r) g[k] = void 0;\n\n            b(g, q[n || h].prototype);\n            f ? g.hcEvents = f : delete g.hcEvents;\n          }\n        } else a(17, !0, d, {\n          missingModuleFor: n || h\n        });\n\n        w.forEach(function (a) {\n          g[a] = w[a];\n        });\n        g.init(d, c);\n\n        if (p && this.points) {\n          var t = g.options;\n          !1 === t.visible ? (y.graphic = 1, y.dataLabel = 1) : g._hasPointLabels || (c = t.marker, n = t.dataLabels, c && (!1 === c.enabled || \"symbol\" in c) && (y.graphic = 1), n && !1 === n.enabled && (y.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(y).length && a.destroyElements(y), !1 === t.showInLegend && a.legendItem && d.legend.destroyItem(a));\n          }, this);\n        }\n\n        g.initialType = h;\n        d.linkSeries();\n        J(this, \"afterUpdate\");\n        L(e, !0) && d.redraw(p ? void 0 : !1);\n      };\n\n      d.prototype.setName = function (a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      };\n\n      d.prototype.hasOptionChanged = function (a) {\n        var b = this.options[a],\n            c = this.chart.options.plotOptions,\n            e = this.userOptions[a];\n        return e ? b !== e : b !== L(c && c[this.type] && c[this.type][a], c && c.series && c.series[a], b);\n      };\n\n      d.prototype.onMouseOver = function () {\n        var a = this.chart,\n            b = a.hoverSeries;\n        a.pointer.setHoverChartIndex();\n        if (b && b !== this) b.onMouseOut();\n        this.options.events.mouseOver && J(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      };\n\n      d.prototype.onMouseOut = function () {\n        var a = this.options,\n            b = this.chart,\n            c = b.tooltip,\n            e = b.hoverPoint;\n        b.hoverSeries = null;\n        if (e) e.onMouseOut();\n        this && a.events.mouseOut && J(this, \"mouseOut\");\n        !c || this.stickyTracking || c.shared && !this.noSharedTooltip || c.hide();\n        b.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      };\n\n      d.prototype.setState = function (a, b) {\n        var c = this,\n            e = c.options,\n            g = c.graph,\n            d = e.inactiveOtherPoints,\n            f = e.states,\n            h = e.lineWidth,\n            m = e.opacity,\n            l = L(f[a || \"normal\"] && f[a || \"normal\"].animation, c.chart.options.chart.animation);\n        e = 0;\n        a = a || \"\";\n\n        if (c.state !== a && ([c.group, c.markerGroup, c.dataLabelsGroup].forEach(function (b) {\n          b && (c.state && b.removeClass(\"highcharts-series-\" + c.state), a && b.addClass(\"highcharts-series-\" + a));\n        }), c.state = a, !c.chart.styledMode)) {\n          if (f[a] && !1 === f[a].enabled) return;\n          a && (h = f[a].lineWidth || h + (f[a].lineWidthPlus || 0), m = L(f[a].opacity, m));\n          if (g && !g.dashstyle) for (f = {\n            \"stroke-width\": h\n          }, g.animate(f, l); c[\"zone-graph-\" + e];) c[\"zone-graph-\" + e].animate(f, l), e += 1;\n          d || [c.group, c.markerGroup, c.dataLabelsGroup, c.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: m\n            }, l);\n          });\n        }\n\n        b && d && c.points && c.setAllPointsToState(a || void 0);\n      };\n\n      d.prototype.setAllPointsToState = function (a) {\n        this.points.forEach(function (b) {\n          b.setState && b.setState(a);\n        });\n      };\n\n      d.prototype.setVisible = function (a, b) {\n        var c = this,\n            e = c.chart,\n            g = c.legendItem,\n            d = e.options.chart.ignoreHiddenSeries,\n            f = c.visible;\n        var h = (c.visible = a = c.options.visible = c.userOptions.visible = \"undefined\" === typeof a ? !f : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (c[a]) c[a][h]();\n        });\n        if (e.hoverSeries === c || (e.hoverPoint && e.hoverPoint.series) === c) c.onMouseOut();\n        g && e.legend.colorizeItem(c, a);\n        c.isDirty = !0;\n        c.options.stacking && e.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        c.linkedSeries.forEach(function (b) {\n          b.setVisible(a, !1);\n        });\n        d && (e.isDirtyBox = !0);\n        J(c, h);\n        !1 !== b && e.redraw();\n      };\n\n      d.prototype.show = function () {\n        this.setVisible(!0);\n      };\n\n      d.prototype.hide = function () {\n        this.setVisible(!1);\n      };\n\n      d.prototype.select = function (a) {\n        this.selected = a = this.options.selected = \"undefined\" === typeof a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        J(this, a ? \"select\" : \"unselect\");\n      };\n\n      d.defaultOptions = {\n        lineWidth: 2,\n        allowPointSelect: !1,\n        crisp: !0,\n        showCheckbox: !1,\n        animation: {\n          duration: 1E3\n        },\n        events: {},\n        marker: {\n          enabledThreshold: 2,\n          lineColor: B.backgroundColor,\n          lineWidth: 0,\n          radius: 4,\n          states: {\n            normal: {\n              animation: !0\n            },\n            hover: {\n              animation: {\n                duration: 50\n              },\n              enabled: !0,\n              radiusPlus: 2,\n              lineWidthPlus: 1\n            },\n            select: {\n              fillColor: B.neutralColor20,\n              lineColor: B.neutralColor100,\n              lineWidth: 2\n            }\n          }\n        },\n        point: {\n          events: {}\n        },\n        dataLabels: {\n          animation: {},\n          align: \"center\",\n          defer: !0,\n          formatter: function () {\n            var a = this.series.chart.numberFormatter;\n            return \"number\" !== typeof this.y ? \"\" : a(this.y, -1);\n          },\n          padding: 5,\n          style: {\n            fontSize: \"11px\",\n            fontWeight: \"bold\",\n            color: \"contrast\",\n            textOutline: \"1px contrast\"\n          },\n          verticalAlign: \"bottom\",\n          x: 0,\n          y: 0\n        },\n        cropThreshold: 300,\n        opacity: 1,\n        pointRange: 0,\n        softThreshold: !0,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            lineWidthPlus: 1,\n            marker: {},\n            halo: {\n              size: 10,\n              opacity: .25\n            }\n          },\n          select: {\n            animation: {\n              duration: 0\n            }\n          },\n          inactive: {\n            animation: {\n              duration: 50\n            },\n            opacity: .2\n          }\n        },\n        stickyTracking: !0,\n        turboThreshold: 1E3,\n        findNearestPointBy: \"x\"\n      };\n      return d;\n    }();\n\n    b(f.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      drawLegendSymbol: k.drawLineMarker,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: G,\n      requireSorting: !0,\n      sorted: !0\n    });\n    D.series = f;\n    \"\";\n    \"\";\n    return f;\n  });\n  P(k, \"Extensions/ScrollablePlotArea.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Axis/Axis.js\"], k[\"Core/Chart/Chart.js\"], k[\"Core/Series/Series.js\"], k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G) {\n    var D = f.stop,\n        H = G.addEvent,\n        t = G.createElement,\n        C = G.merge,\n        l = G.pick;\n    \"\";\n    H(k, \"afterSetChartSize\", function (d) {\n      var g = this.options.chart.scrollablePlotArea,\n          f = g && g.minWidth;\n      g = g && g.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (f) {\n          if (this.scrollablePixelsX = f = Math.max(0, f - this.chartWidth)) {\n            this.scrollablePlotBox = C(this.plotBox);\n            this.plotWidth += f;\n            this.inverted ? (this.clipBox.height += f, this.plotBox.height += f) : (this.clipBox.width += f, this.plotBox.width += f);\n            var c = {\n              1: {\n                name: \"right\",\n                value: f\n              }\n            };\n          }\n        } else g && (this.scrollablePixelsY = f = Math.max(0, g - this.chartHeight)) && (this.scrollablePlotBox = C(this.plotBox), this.plotHeight += f, this.inverted ? (this.clipBox.width += f, this.plotBox.width += f) : (this.clipBox.height += f, this.plotBox.height += f), c = {\n          2: {\n            name: \"bottom\",\n            value: f\n          }\n        });\n\n        c && !d.skipAxes && this.axes.forEach(function (g) {\n          c[g.side] ? g.getPlotLinePath = function () {\n            var d = c[g.side].name,\n                f = this[d];\n            this[d] = f - c[g.side].value;\n            var l = B.Axis.prototype.getPlotLinePath.apply(this, arguments);\n            this[d] = f;\n            return l;\n          } : (g.setAxisSize(), g.setAxisTranslation());\n        });\n      }\n    });\n    H(k, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    k.prototype.setUpScrolling = function () {\n      var d = this,\n          g = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (g.overflowX = \"auto\");\n      this.scrollablePixelsY && (g.overflowY = \"auto\");\n      this.scrollingParent = t(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = t(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, g, this.scrollingParent);\n      H(this.scrollingContainer, \"scroll\", function () {\n        d.pointer && delete d.pointer.chartPosition;\n      });\n      this.innerContainer = t(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    k.prototype.moveFixedElements = function () {\n      var d = this.container,\n          g = this.fixedRenderer,\n          f = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          c;\n      this.scrollablePixelsX && !this.inverted ? c = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? c = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? c = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (c = \".highcharts-yaxis\");\n      c && f.push(c + \":not(.highcharts-radial-axis)\", c + \"-labels:not(.highcharts-radial-axis-labels)\");\n      f.forEach(function (c) {\n        [].forEach.call(d.querySelectorAll(c), function (c) {\n          (c.namespaceURI === g.SVG_NS ? g.box : g.box.parentNode).appendChild(c);\n          c.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    k.prototype.applyFixed = function () {\n      var f = this,\n          g,\n          k,\n          c,\n          q = !this.fixedDiv,\n          n = this.options.chart,\n          A = n.scrollablePlotArea;\n      q ? (this.fixedDiv = t(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: ((null === (g = n.style) || void 0 === g ? void 0 : g.zIndex) || 0) + 2,\n        top: 0\n      }, null, !0), null === (k = this.scrollingContainer) || void 0 === k ? void 0 : k.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = g = new B.Renderer(this.fixedDiv, this.chartWidth, this.chartHeight, null === (c = this.options.chart) || void 0 === c ? void 0 : c.style), this.scrollableMask = g.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": l(A.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), H(this, \"afterShowResetZoom\", this.moveFixedElements), H(this, \"afterLayOutTitles\", this.moveFixedElements), H(d, \"afterInit\", function () {\n        f.scrollableDirty = !0;\n      }), H(x, \"show\", function () {\n        f.scrollableDirty = !0;\n      })) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || q) this.scrollableDirty = !1, this.moveFixedElements();\n      c = this.chartWidth + (this.scrollablePixelsX || 0);\n      g = this.chartHeight + (this.scrollablePixelsY || 0);\n      D(this.container);\n      this.container.style.width = c + \"px\";\n      this.container.style.height = g + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: c,\n        height: g,\n        viewBox: [0, 0, c, g].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: c,\n        height: g\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      q && (A.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * A.scrollPositionX), A.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * A.scrollPositionY));\n      g = this.axisOffset;\n      q = this.plotTop - g[0] - 1;\n      A = this.plotLeft - g[3] - 1;\n      c = this.plotTop + this.plotHeight + g[2] + 1;\n      g = this.plotLeft + this.plotWidth + g[1] + 1;\n      k = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0);\n      n = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      q = this.scrollablePixelsX ? [[\"M\", 0, q], [\"L\", this.plotLeft - 1, q], [\"L\", this.plotLeft - 1, c], [\"L\", 0, c], [\"Z\"], [\"M\", k, q], [\"L\", this.chartWidth, q], [\"L\", this.chartWidth, c], [\"L\", k, c], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", A, 0], [\"L\", A, this.plotTop - 1], [\"L\", g, this.plotTop - 1], [\"L\", g, 0], [\"Z\"], [\"M\", A, n], [\"L\", A, this.chartHeight], [\"L\", g, this.chartHeight], [\"L\", g, n], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: q\n      });\n    };\n  });\n  P(k, \"Core/Axis/StackingAxis.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = f.getDeferredAnimation,\n        x = d.addEvent,\n        B = d.destroyObjectProperties,\n        G = d.fireEvent,\n        D = d.objectEach,\n        H = d.pick,\n        t = function () {\n      function d(d) {\n        this.oldStacks = {};\n        this.stacks = {};\n        this.stacksTouched = 0;\n        this.axis = d;\n      }\n\n      d.prototype.buildStacks = function () {\n        var d = this.axis,\n            f = d.series,\n            g = H(d.options.reversedStacks, !0),\n            k = f.length,\n            c;\n\n        if (!d.isXAxis) {\n          this.usePercentage = !1;\n\n          for (c = k; c--;) {\n            var q = f[g ? c : k - c - 1];\n            q.setStackedPoints();\n            q.setGroupedPoints();\n          }\n\n          for (c = 0; c < k; c++) f[c].modifyStacks();\n\n          G(d, \"afterBuildStacks\");\n        }\n      };\n\n      d.prototype.cleanStacks = function () {\n        if (!this.axis.isXAxis) {\n          if (this.oldStacks) var d = this.stacks = this.oldStacks;\n          D(d, function (d) {\n            D(d, function (g) {\n              g.cumulative = g.total;\n            });\n          });\n        }\n      };\n\n      d.prototype.resetStacks = function () {\n        var d = this,\n            f = d.stacks;\n        d.axis.isXAxis || D(f, function (g) {\n          D(g, function (f, c) {\n            f.touched < d.stacksTouched ? (f.destroy(), delete g[c]) : (f.total = null, f.cumulative = null);\n          });\n        });\n      };\n\n      d.prototype.renderStackTotals = function () {\n        var d = this.axis,\n            f = d.chart,\n            g = f.renderer,\n            t = this.stacks;\n        d = k(f, d.options.stackLabels.animation);\n        var c = this.stackTotalGroup = this.stackTotalGroup || g.g(\"stack-labels\").attr({\n          visibility: \"visible\",\n          zIndex: 6,\n          opacity: 0\n        }).add();\n        c.translate(f.plotLeft, f.plotTop);\n        D(t, function (g) {\n          D(g, function (g) {\n            g.render(c);\n          });\n        });\n        c.animate({\n          opacity: 1\n        }, d);\n      };\n\n      return d;\n    }();\n\n    return function () {\n      function d() {}\n\n      d.compose = function (f) {\n        x(f, \"init\", d.onInit);\n        x(f, \"destroy\", d.onDestroy);\n      };\n\n      d.onDestroy = function () {\n        var d = this.stacking;\n\n        if (d) {\n          var f = d.stacks;\n          D(f, function (g, d) {\n            B(g);\n            f[d] = null;\n          });\n          d && d.stackTotalGroup && d.stackTotalGroup.destroy();\n        }\n      };\n\n      d.onInit = function () {\n        this.stacking || (this.stacking = new t(this));\n      };\n\n      return d;\n    }();\n  });\n  P(k, \"Extensions/Stacking.js\", [k[\"Core/Axis/Axis.js\"], k[\"Core/Chart/Chart.js\"], k[\"Core/Globals.js\"], k[\"Core/Series/Series.js\"], k[\"Core/Axis/StackingAxis.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G) {\n    var D = G.correctFloat,\n        H = G.defined,\n        t = G.destroyObjectProperties,\n        C = G.format,\n        l = G.isArray,\n        E = G.isNumber,\n        g = G.pick;\n    \"\";\n\n    var y = function () {\n      function c(c, g, d, f, l) {\n        var m = c.chart.inverted;\n        this.axis = c;\n        this.isNegative = d;\n        this.options = g = g || {};\n        this.x = f;\n        this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = l;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: g.align || (m ? d ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: g.verticalAlign || (m ? \"middle\" : d ? \"bottom\" : \"top\"),\n          y: g.y,\n          x: g.x\n        };\n        this.textAlign = g.textAlign || (m ? d ? \"right\" : \"left\" : \"center\");\n      }\n\n      c.prototype.destroy = function () {\n        t(this, this.axis);\n      };\n\n      c.prototype.render = function (c) {\n        var d = this.axis.chart,\n            f = this.options,\n            l = f.format;\n        l = l ? C(l, this, d) : f.formatter.call(this);\n        this.label ? this.label.attr({\n          text: l,\n          visibility: \"hidden\"\n        }) : (this.label = d.renderer.label(l, null, null, f.shape, null, null, f.useHTML, !1, \"stack-labels\"), l = {\n          r: f.borderRadius || 0,\n          text: l,\n          rotation: f.rotation,\n          padding: g(f.padding, 5),\n          visibility: \"hidden\"\n        }, d.styledMode || (l.fill = f.backgroundColor, l.stroke = f.borderColor, l[\"stroke-width\"] = f.borderWidth, this.label.css(f.style)), this.label.attr(l), this.label.added || this.label.add(c));\n        this.label.labelrank = d.plotSizeY;\n      };\n\n      c.prototype.setOffset = function (c, d, f, l, k) {\n        var m = this.axis,\n            n = m.chart;\n        l = m.translate(m.stacking.usePercentage ? 100 : l ? l : this.total, 0, 0, 0, 1);\n        f = m.translate(f ? f : 0);\n        f = H(l) && Math.abs(l - f);\n        c = g(k, n.xAxis[0].translate(this.x)) + c;\n        m = H(l) && this.getStackBox(n, this, c, l, d, f, m);\n        d = this.label;\n        f = this.isNegative;\n        c = \"justify\" === g(this.options.overflow, \"justify\");\n        var e = this.textAlign;\n        d && m && (k = d.getBBox(), l = d.padding, e = \"left\" === e ? n.inverted ? -l : l : \"right\" === e ? k.width : n.inverted && \"center\" === e ? k.width / 2 : n.inverted ? f ? k.width + l : -l : k.width / 2, f = n.inverted ? k.height / 2 : f ? -l : k.height, this.alignOptions.x = g(this.options.x, 0), this.alignOptions.y = g(this.options.y, 0), m.x -= e, m.y -= f, d.align(this.alignOptions, null, m), n.isInsidePlot(d.alignAttr.x + e - this.alignOptions.x, d.alignAttr.y + f - this.alignOptions.y) ? d.show() : (d.alignAttr.y = -9999, c = !1), c && x.prototype.justifyDataLabel.call(this.axis, d, this.alignOptions, d.alignAttr, k, m), d.attr({\n          x: d.alignAttr.x,\n          y: d.alignAttr.y\n        }), g(!c && this.options.crop, !0) && ((n = E(d.x) && E(d.y) && n.isInsidePlot(d.x - l + d.width, d.y) && n.isInsidePlot(d.x + l, d.y)) || d.hide()));\n      };\n\n      c.prototype.getStackBox = function (c, g, d, f, l, m, k) {\n        var e = g.axis.reversed,\n            h = c.inverted,\n            a = k.height + k.pos - (h ? c.plotLeft : c.plotTop);\n        g = g.isNegative && !e || !g.isNegative && e;\n        return {\n          x: h ? g ? f - k.right : f - m + k.pos - c.plotLeft : d + c.xAxis[0].transB - c.plotLeft,\n          y: h ? k.height - d - l : g ? a - f - m : a - f,\n          width: h ? m : l,\n          height: h ? l : m\n        };\n      };\n\n      return c;\n    }();\n\n    d.prototype.getStacks = function () {\n      var c = this,\n          d = c.inverted;\n      c.yAxis.forEach(function (c) {\n        c.stacking && c.stacking.stacks && c.hasVisibleSeries && (c.stacking.oldStacks = c.stacking.stacks);\n      });\n      c.series.forEach(function (f) {\n        var l = f.xAxis && f.xAxis.options || {};\n        !f.options.stacking || !0 !== f.visible && !1 !== c.options.chart.ignoreHiddenSeries || (f.stackKey = [f.type, g(f.options.stack, \"\"), d ? l.top : l.left, d ? l.height : l.width].join());\n      });\n    };\n\n    B.compose(f);\n\n    x.prototype.setGroupedPoints = function () {\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length && x.prototype.setStackedPoints.call(this, \"group\");\n    };\n\n    x.prototype.setStackedPoints = function (c) {\n      var d = c || this.options.stacking;\n\n      if (d && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var f = this.processedXData,\n            k = this.processedYData,\n            t = [],\n            z = k.length,\n            m = this.options,\n            r = m.threshold,\n            e = g(m.startFromThreshold && r, 0);\n        m = m.stack;\n        c = c ? this.type + \",\" + d : this.stackKey;\n        var h = \"-\" + c,\n            a = this.negStacks,\n            b = this.yAxis,\n            w = b.stacking.stacks,\n            C = b.stacking.oldStacks,\n            E,\n            F;\n        b.stacking.stacksTouched += 1;\n\n        for (F = 0; F < z; F++) {\n          var x = f[F];\n          var R = k[F];\n          var Q = this.getStackIndicator(Q, x, this.index);\n          var B = Q.key;\n          var v = (E = a && R < (e ? 0 : r)) ? h : c;\n          w[v] || (w[v] = {});\n          w[v][x] || (C[v] && C[v][x] ? (w[v][x] = C[v][x], w[v][x].total = null) : w[v][x] = new y(b, b.options.stackLabels, E, x, m));\n          v = w[v][x];\n          null !== R ? (v.points[B] = v.points[this.index] = [g(v.cumulative, e)], H(v.cumulative) || (v.base = B), v.touched = b.stacking.stacksTouched, 0 < Q.index && !1 === this.singleStacks && (v.points[B][0] = v.points[this.index + \",\" + x + \",0\"][0])) : v.points[B] = v.points[this.index] = null;\n          \"percent\" === d ? (E = E ? c : h, a && w[E] && w[E][x] ? (E = w[E][x], v.total = E.total = Math.max(E.total, v.total) + Math.abs(R) || 0) : v.total = D(v.total + (Math.abs(R) || 0))) : \"group\" === d ? (l(R) && (R = R[0]), null !== R && (v.total = (v.total || 0) + 1)) : v.total = D(v.total + (R || 0));\n          v.cumulative = \"group\" === d ? (v.total || 1) - 1 : g(v.cumulative, e) + (R || 0);\n          null !== R && (v.points[B].push(v.cumulative), t[F] = v.cumulative, v.hasValidPoints = !0);\n        }\n\n        \"percent\" === d && (b.stacking.usePercentage = !0);\n        \"group\" !== d && (this.stackedYData = t);\n        b.stacking.oldStacks = {};\n      }\n    };\n\n    x.prototype.modifyStacks = function () {\n      var c = this,\n          g = c.stackKey,\n          d = c.yAxis.stacking.stacks,\n          f = c.processedXData,\n          l,\n          k = c.options.stacking;\n      c[k + \"Stacker\"] && [g, \"-\" + g].forEach(function (g) {\n        for (var m = f.length, e, h; m--;) if (e = f[m], l = c.getStackIndicator(l, e, c.index, g), h = (e = d[g] && d[g][e]) && e.points[l.key]) c[k + \"Stacker\"](h, e, m);\n      });\n    };\n\n    x.prototype.percentStacker = function (c, g, d) {\n      g = g.total ? 100 / g.total : 0;\n      c[0] = D(c[0] * g);\n      c[1] = D(c[1] * g);\n      this.stackedYData[d] = c[1];\n    };\n\n    x.prototype.getStackIndicator = function (c, g, d, f) {\n      !H(c) || c.x !== g || f && c.key !== f ? c = {\n        x: g,\n        index: 0,\n        key: f\n      } : c.index++;\n      c.key = [d, g, c.index].join();\n      return c;\n    };\n\n    k.StackItem = y;\n    return k.StackItem;\n  });\n  P(k, \"Series/Line/LineSeries.js\", [k[\"Core/Color/Palette.js\"], k[\"Core/Series/Series.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x) {\n    var B = this && this.__extends || function () {\n      var d = function (f, k) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, f) {\n          d.__proto__ = f;\n        } || function (d, f) {\n          for (var g in f) f.hasOwnProperty(g) && (d[g] = f[g]);\n        };\n\n        return d(f, k);\n      };\n\n      return function (f, k) {\n        function l() {\n          this.constructor = f;\n        }\n\n        d(f, k);\n        f.prototype = null === k ? Object.create(k) : (l.prototype = k.prototype, new l());\n      };\n    }(),\n        G = x.defined,\n        D = x.merge;\n\n    x = function (k) {\n      function t() {\n        var d = null !== k && k.apply(this, arguments) || this;\n        d.data = void 0;\n        d.options = void 0;\n        d.points = void 0;\n        return d;\n      }\n\n      B(t, k);\n\n      t.prototype.drawGraph = function () {\n        var d = this,\n            l = this.options,\n            k = (this.gappedPath || this.getGraphPath).call(this),\n            g = this.chart.styledMode,\n            t = [[\"graph\", \"highcharts-graph\"]];\n        g || t[0].push(l.lineColor || this.color || f.neutralColor20, l.dashStyle);\n        t = d.getZonesGraphs(t);\n        t.forEach(function (c, f) {\n          var n = c[0],\n              q = d[n],\n              t = q ? \"animate\" : \"attr\";\n          q ? (q.endX = d.preventGraphAnimation ? null : k.xMap, q.animate({\n            d: k\n          })) : k.length && (d[n] = q = d.chart.renderer.path(k).addClass(c[1]).attr({\n            zIndex: 1\n          }).add(d.group));\n          q && !g && (n = {\n            stroke: c[2],\n            \"stroke-width\": l.lineWidth,\n            fill: d.fillGraph && d.color || \"none\"\n          }, c[3] ? n.dashstyle = c[3] : \"square\" !== l.linecap && (n[\"stroke-linecap\"] = n[\"stroke-linejoin\"] = \"round\"), q[t](n).shadow(2 > f && l.shadow));\n          q && (q.startX = k.xMap, q.isArea = k.isArea);\n        });\n      };\n\n      t.prototype.getGraphPath = function (d, f, k) {\n        var g = this,\n            l = g.options,\n            c = l.step,\n            q,\n            n = [],\n            t = [],\n            E;\n        d = d || g.points;\n        (q = d.reversed) && d.reverse();\n        (c = {\n          right: 1,\n          center: 2\n        }[c] || c && 3) && q && (c = 4 - c);\n        d = this.getValidPoints(d, !1, !(l.connectNulls && !f && !k));\n        d.forEach(function (q, m) {\n          var r = q.plotX,\n              e = q.plotY,\n              h = d[m - 1];\n          (q.leftCliff || h && h.rightCliff) && !k && (E = !0);\n          q.isNull && !G(f) && 0 < m ? E = !l.connectNulls : q.isNull && !f ? E = !0 : (0 === m || E ? m = [[\"M\", q.plotX, q.plotY]] : g.getPointSpline ? m = [g.getPointSpline(d, q, m)] : c ? (m = 1 === c ? [[\"L\", h.plotX, e]] : 2 === c ? [[\"L\", (h.plotX + r) / 2, h.plotY], [\"L\", (h.plotX + r) / 2, e]] : [[\"L\", r, h.plotY]], m.push([\"L\", r, e])) : m = [[\"L\", r, e]], t.push(q.x), c && (t.push(q.x), 2 === c && t.push(q.x)), n.push.apply(n, m), E = !1);\n        });\n        n.xMap = t;\n        return g.graphPath = n;\n      };\n\n      t.prototype.getZonesGraphs = function (d) {\n        this.zones.forEach(function (f, k) {\n          k = [\"zone-graph-\" + k, \"highcharts-graph highcharts-zone-graph-\" + k + \" \" + (f.className || \"\")];\n          this.chart.styledMode || k.push(f.color || this.color, f.dashStyle || this.options.dashStyle);\n          d.push(k);\n        }, this);\n        return d;\n      };\n\n      t.defaultOptions = D(d.defaultOptions, {});\n      return t;\n    }(d);\n\n    k.registerSeriesType(\"line\", x);\n    \"\";\n    return x;\n  });\n  P(k, \"Series/Area/AreaSeries.js\", [k[\"Core/Color/Color.js\"], k[\"Mixins/LegendSymbol.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x) {\n    var B = this && this.__extends || function () {\n      var d = function (f, g) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (g, c) {\n          g.__proto__ = c;\n        } || function (g, c) {\n          for (var d in c) c.hasOwnProperty(d) && (g[d] = c[d]);\n        };\n\n        return d(f, g);\n      };\n\n      return function (f, g) {\n        function l() {\n          this.constructor = f;\n        }\n\n        d(f, g);\n        f.prototype = null === g ? Object.create(g) : (l.prototype = g.prototype, new l());\n      };\n    }(),\n        G = f.parse,\n        D = k.seriesTypes.line;\n\n    f = x.extend;\n    var H = x.merge,\n        t = x.objectEach,\n        C = x.pick;\n\n    x = function (d) {\n      function f() {\n        var g = null !== d && d.apply(this, arguments) || this;\n        g.data = void 0;\n        g.options = void 0;\n        g.points = void 0;\n        return g;\n      }\n\n      B(f, d);\n\n      f.prototype.drawGraph = function () {\n        this.areaPath = [];\n        d.prototype.drawGraph.apply(this);\n        var g = this,\n            f = this.areaPath,\n            c = this.options,\n            l = [[\"area\", \"highcharts-area\", this.color, c.fillColor]];\n        this.zones.forEach(function (d, f) {\n          l.push([\"zone-area-\" + f, \"highcharts-area highcharts-zone-area-\" + f + \" \" + d.className, d.color || g.color, d.fillColor || c.fillColor]);\n        });\n        l.forEach(function (d) {\n          var l = d[0],\n              n = g[l],\n              k = n ? \"animate\" : \"attr\",\n              m = {};\n          n ? (n.endX = g.preventGraphAnimation ? null : f.xMap, n.animate({\n            d: f\n          })) : (m.zIndex = 0, n = g[l] = g.chart.renderer.path(f).addClass(d[1]).add(g.group), n.isArea = !0);\n          g.chart.styledMode || (m.fill = C(d[3], G(d[2]).setOpacity(C(c.fillOpacity, .75)).get()));\n          n[k](m);\n          n.startX = f.xMap;\n          n.shiftUnit = c.step ? 2 : 1;\n        });\n      };\n\n      f.prototype.getGraphPath = function (g) {\n        var d = D.prototype.getGraphPath,\n            c = this.options,\n            f = c.stacking,\n            l = this.yAxis,\n            k,\n            t = [],\n            z = [],\n            m = this.index,\n            r = l.stacking.stacks[this.stackKey],\n            e = c.threshold,\n            h = Math.round(l.getThreshold(c.threshold));\n        c = C(c.connectNulls, \"percent\" === f);\n\n        var a = function (a, b, c) {\n          var d = g[a];\n          a = f && r[d.x].points[m];\n          var k = d[c + \"Null\"] || 0;\n          c = d[c + \"Cliff\"] || 0;\n          d = !0;\n\n          if (c || k) {\n            var n = (k ? a[0] : a[1]) + c;\n            var q = a[0] + c;\n            d = !!k;\n          } else !f && g[b] && g[b].isNull && (n = q = e);\n\n          \"undefined\" !== typeof n && (z.push({\n            plotX: w,\n            plotY: null === n ? h : l.getThreshold(n),\n            isNull: d,\n            isCliff: !0\n          }), t.push({\n            plotX: w,\n            plotY: null === q ? h : l.getThreshold(q),\n            doCurve: !1\n          }));\n        };\n\n        g = g || this.points;\n        f && (g = this.getStackPoints(g));\n\n        for (k = 0; k < g.length; k++) {\n          f || (g[k].leftCliff = g[k].rightCliff = g[k].leftNull = g[k].rightNull = void 0);\n          var b = g[k].isNull;\n          var w = C(g[k].rectPlotX, g[k].plotX);\n          var E = f ? C(g[k].yBottom, h) : h;\n          if (!b || c) c || a(k, k - 1, \"left\"), b && !f && c || (z.push(g[k]), t.push({\n            x: k,\n            plotX: w,\n            plotY: E\n          })), c || a(k, k + 1, \"right\");\n        }\n\n        k = d.call(this, z, !0, !0);\n        t.reversed = !0;\n        b = d.call(this, t, !0, !0);\n        (E = b[0]) && \"M\" === E[0] && (b[0] = [\"L\", E[1], E[2]]);\n        b = k.concat(b);\n        d = d.call(this, z, !1, c);\n        b.xMap = k.xMap;\n        this.areaPath = b;\n        return d;\n      };\n\n      f.prototype.getStackPoints = function (d) {\n        var g = [],\n            c = [],\n            f = this.xAxis,\n            l = this.yAxis,\n            k = l.stacking.stacks[this.stackKey],\n            E = {},\n            z = this.index,\n            m = l.series,\n            r = m.length,\n            e = C(l.options.reversedStacks, !0) ? 1 : -1,\n            h;\n        d = d || this.points;\n\n        if (this.options.stacking) {\n          for (h = 0; h < d.length; h++) d[h].leftNull = d[h].rightNull = void 0, E[d[h].x] = d[h];\n\n          t(k, function (a, e) {\n            null !== a.total && c.push(e);\n          });\n          c.sort(function (a, c) {\n            return a - c;\n          });\n          var a = m.map(function (a) {\n            return a.visible;\n          });\n          c.forEach(function (b, d) {\n            var m = 0,\n                n,\n                q;\n            if (E[b] && !E[b].isNull) g.push(E[b]), [-1, 1].forEach(function (g) {\n              var f = 1 === g ? \"rightNull\" : \"leftNull\",\n                  m = 0,\n                  l = k[c[d + g]];\n              if (l) for (h = z; 0 <= h && h < r;) n = l.points[h], n || (h === z ? E[b][f] = !0 : a[h] && (q = k[b].points[h]) && (m -= q[1] - q[0])), h += e;\n              E[b][1 === g ? \"rightCliff\" : \"leftCliff\"] = m;\n            });else {\n              for (h = z; 0 <= h && h < r;) {\n                if (n = k[b].points[h]) {\n                  m = n[1];\n                  break;\n                }\n\n                h += e;\n              }\n\n              m = l.translate(m, 0, 1, 0, 1);\n              g.push({\n                isNull: !0,\n                plotX: f.translate(b, 0, 0, 0, 1),\n                x: b,\n                plotY: m,\n                yBottom: m\n              });\n            }\n          });\n        }\n\n        return g;\n      };\n\n      f.defaultOptions = H(D.defaultOptions, {\n        threshold: 0\n      });\n      return f;\n    }(D);\n\n    f(x.prototype, {\n      singleStacks: !1,\n      drawLegendSymbol: d.drawRectangle\n    });\n    k.registerSeriesType(\"area\", x);\n    \"\";\n    return x;\n  });\n  P(k, \"Series/Spline/SplineSeries.js\", [k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = this && this.__extends || function () {\n      var d = function (f, k) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, f) {\n          d.__proto__ = f;\n        } || function (d, f) {\n          for (var l in f) f.hasOwnProperty(l) && (d[l] = f[l]);\n        };\n\n        return d(f, k);\n      };\n\n      return function (f, k) {\n        function t() {\n          this.constructor = f;\n        }\n\n        d(f, k);\n        f.prototype = null === k ? Object.create(k) : (t.prototype = k.prototype, new t());\n      };\n    }(),\n        x = f.seriesTypes.line,\n        B = d.merge,\n        G = d.pick;\n\n    d = function (d) {\n      function f() {\n        var f = null !== d && d.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      k(f, d);\n\n      f.prototype.getPointSpline = function (d, f, l) {\n        var k = f.plotX || 0,\n            g = f.plotY || 0,\n            t = d[l - 1];\n        l = d[l + 1];\n\n        if (t && !t.isNull && !1 !== t.doCurve && !f.isCliff && l && !l.isNull && !1 !== l.doCurve && !f.isCliff) {\n          d = t.plotY || 0;\n          var c = l.plotX || 0;\n          l = l.plotY || 0;\n          var q = 0;\n          var n = (1.5 * k + (t.plotX || 0)) / 2.5;\n          var x = (1.5 * g + d) / 2.5;\n          c = (1.5 * k + c) / 2.5;\n          var C = (1.5 * g + l) / 2.5;\n          c !== n && (q = (C - x) * (c - k) / (c - n) + g - C);\n          x += q;\n          C += q;\n          x > d && x > g ? (x = Math.max(d, g), C = 2 * g - x) : x < d && x < g && (x = Math.min(d, g), C = 2 * g - x);\n          C > l && C > g ? (C = Math.max(l, g), x = 2 * g - C) : C < l && C < g && (C = Math.min(l, g), x = 2 * g - C);\n          f.rightContX = c;\n          f.rightContY = C;\n        }\n\n        f = [\"C\", G(t.rightContX, t.plotX, 0), G(t.rightContY, t.plotY, 0), G(n, k, 0), G(x, g, 0), k, g];\n        t.rightContX = t.rightContY = void 0;\n        return f;\n      };\n\n      f.defaultOptions = B(x.defaultOptions);\n      return f;\n    }(x);\n\n    f.registerSeriesType(\"spline\", d);\n    \"\";\n    return d;\n  });\n  P(k, \"Series/AreaSpline/AreaSplineSeries.js\", [k[\"Series/Area/AreaSeries.js\"], k[\"Series/Spline/SplineSeries.js\"], k[\"Mixins/LegendSymbol.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B) {\n    var G = this && this.__extends || function () {\n      var d = function (f, k) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, f) {\n          d.__proto__ = f;\n        } || function (d, f) {\n          for (var c in f) f.hasOwnProperty(c) && (d[c] = f[c]);\n        };\n\n        return d(f, k);\n      };\n\n      return function (f, k) {\n        function g() {\n          this.constructor = f;\n        }\n\n        d(f, k);\n        f.prototype = null === k ? Object.create(k) : (g.prototype = k.prototype, new g());\n      };\n    }(),\n        D = f.prototype,\n        H = B.extend,\n        t = B.merge;\n\n    B = function (k) {\n      function l() {\n        var d = null !== k && k.apply(this, arguments) || this;\n        d.data = void 0;\n        d.points = void 0;\n        d.options = void 0;\n        return d;\n      }\n\n      G(l, k);\n      l.defaultOptions = t(d.defaultOptions, f.defaultOptions);\n      return l;\n    }(d);\n\n    H(B.prototype, {\n      getGraphPath: D.getGraphPath,\n      getStackPoints: D.getStackPoints,\n      drawGraph: D.drawGraph,\n      drawLegendSymbol: k.drawRectangle\n    });\n    x.registerSeriesType(\"areaspline\", B);\n    \"\";\n    return B;\n  });\n  P(k, \"Series/Column/ColumnSeries.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Color/Color.js\"], k[\"Core/Globals.js\"], k[\"Mixins/LegendSymbol.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Series/Series.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G, D, H) {\n    var t = this && this.__extends || function () {\n      var c = function (e, a) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);\n        };\n\n        return c(e, a);\n      };\n\n      return function (e, a) {\n        function b() {\n          this.constructor = e;\n        }\n\n        c(e, a);\n        e.prototype = null === a ? Object.create(a) : (b.prototype = a.prototype, new b());\n      };\n    }(),\n        C = f.animObject,\n        l = d.parse,\n        E = k.hasTouch;\n\n    f = k.noop;\n    var g = H.clamp,\n        y = H.css,\n        c = H.defined,\n        q = H.extend,\n        n = H.fireEvent,\n        A = H.isArray,\n        M = H.isNumber,\n        z = H.merge,\n        m = H.pick,\n        r = H.objectEach;\n\n    H = function (e) {\n      function d() {\n        var a = null !== e && e.apply(this, arguments) || this;\n        a.borderWidth = void 0;\n        a.data = void 0;\n        a.group = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      t(d, e);\n\n      d.prototype.animate = function (a) {\n        var b = this,\n            c = this.yAxis,\n            e = b.options,\n            d = this.chart.inverted,\n            f = {},\n            h = d ? \"translateX\" : \"translateY\";\n        if (a) f.scaleY = .001, a = g(c.toPixels(e.threshold), c.pos, c.pos + c.len), d ? f.translateX = a - c.len : f.translateY = a, b.clipBox && b.setClip(), b.group.attr(f);else {\n          var m = b.group.attr(h);\n          b.group.animate({\n            scaleY: 1\n          }, q(C(b.options.animation), {\n            step: function (a, e) {\n              b.group && (f[h] = m + e.pos * (c.pos - m), b.group.attr(f));\n            }\n          }));\n        }\n      };\n\n      d.prototype.init = function (a, b) {\n        e.prototype.init.apply(this, arguments);\n        var c = this;\n        a = c.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === c.type && (a.isDirty = !0);\n        });\n      };\n\n      d.prototype.getColumnMetrics = function () {\n        var a = this,\n            b = a.options,\n            c = a.xAxis,\n            e = a.yAxis,\n            d = c.options.reversedStacks;\n        d = c.reversed && !d || !c.reversed && d;\n        var g,\n            f = {},\n            h = 0;\n        !1 === b.grouping ? h = 1 : a.chart.series.forEach(function (b) {\n          var c = b.yAxis,\n              d = b.options;\n\n          if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && e.len === c.len && e.pos === c.pos) {\n            if (d.stacking && \"group\" !== d.stacking) {\n              g = b.stackKey;\n              \"undefined\" === typeof f[g] && (f[g] = h++);\n              var m = f[g];\n            } else !1 !== d.grouping && (m = h++);\n\n            b.columnIndex = m;\n          }\n        });\n        var l = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),\n            k = l * b.groupPadding,\n            n = (l - 2 * k) / (h || 1);\n        b = Math.min(b.maxPointWidth || c.len, m(b.pointWidth, n * (1 - 2 * b.pointPadding)));\n        a.columnMetrics = {\n          width: b,\n          offset: (n - b) / 2 + (k + ((a.columnIndex || 0) + (d ? 1 : 0)) * n - l / 2) * (d ? -1 : 1),\n          paddedWidth: n,\n          columnCount: h\n        };\n        return a.columnMetrics;\n      };\n\n      d.prototype.crispCol = function (a, b, c, e) {\n        var d = this.chart,\n            g = this.borderWidth,\n            f = -(g % 2 ? .5 : 0);\n        g = g % 2 ? .5 : 1;\n        d.inverted && d.renderer.isVML && (g += 1);\n        this.options.crisp && (c = Math.round(a + c) + f, a = Math.round(a) + f, c -= a);\n        e = Math.round(b + e) + g;\n        f = .5 >= Math.abs(b) && .5 < e;\n        b = Math.round(b) + g;\n        e -= b;\n        f && e && (--b, e += 1);\n        return {\n          x: a,\n          y: b,\n          width: c,\n          height: e\n        };\n      };\n\n      d.prototype.adjustForMissingColumns = function (a, b, c, e) {\n        var d = this,\n            g = this.options.stacking;\n\n        if (!c.isNull && 1 < e.columnCount) {\n          var f = 0,\n              h = 0;\n          r(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {\n            if (\"number\" === typeof c.x && (a = a[c.x.toString()])) {\n              var b = a.points[d.index],\n                  e = a.total;\n              g ? (b && (f = h), a.hasValidPoints && h++) : A(b) && (f = b[1], h = e || 0);\n            }\n          });\n          a = (c.plotX || 0) + ((h - 1) * e.paddedWidth + b) / 2 - b - f * e.paddedWidth;\n        }\n\n        return a;\n      };\n\n      d.prototype.translate = function () {\n        var a = this,\n            b = a.chart,\n            e = a.options,\n            d = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        d = a.borderWidth = m(e.borderWidth, d ? 0 : 1);\n        var f = a.xAxis,\n            h = a.yAxis,\n            l = e.threshold,\n            k = a.translatedThreshold = h.getThreshold(l),\n            n = m(e.minPointLength, 5),\n            q = a.getColumnMetrics(),\n            r = q.width,\n            t = a.barW = Math.max(r, 1 + 2 * d),\n            p = a.pointXOffset = q.offset,\n            y = a.dataMin,\n            z = a.dataMax;\n        b.inverted && (k -= .5);\n        e.pointPadding && (t = Math.ceil(t));\n        G.prototype.translate.apply(a);\n        a.points.forEach(function (d) {\n          var w = m(d.yBottom, k),\n              v = 999 + Math.abs(w),\n              F = r,\n              x = d.plotX || 0;\n          v = g(d.plotY, -v, h.len + v);\n          var E = x + p,\n              C = t,\n              A = Math.min(v, w),\n              B = Math.max(v, w) - A;\n\n          if (n && Math.abs(B) < n) {\n            B = n;\n            var H = !h.reversed && !d.negative || h.reversed && d.negative;\n            M(l) && M(z) && d.y === l && z <= l && (h.min || 0) < l && (y !== z || (h.max || 0) <= l) && (H = !H);\n            A = Math.abs(A - k) > n ? w - n : k - (H ? n : 0);\n          }\n\n          c(d.options.pointWidth) && (F = C = Math.ceil(d.options.pointWidth), E -= Math.round((F - r) / 2));\n          e.centerInCategory && (E = a.adjustForMissingColumns(E, F, d, q));\n          d.barX = E;\n          d.pointWidth = F;\n          d.tooltipPos = b.inverted ? [g(h.len + h.pos - b.plotLeft - v, h.pos - b.plotLeft, h.len + h.pos - b.plotLeft), f.len + f.pos - b.plotTop - (x || 0) - p - C / 2, B] : [f.left - b.plotLeft + E + C / 2, g(v + h.pos - b.plotTop, h.pos - b.plotTop, h.len + h.pos - b.plotTop), B];\n          d.shapeType = a.pointClass.prototype.shapeType || \"rect\";\n          d.shapeArgs = a.crispCol.apply(a, d.isNull ? [E, k, C, 0] : [E, A, C, B]);\n        });\n      };\n\n      d.prototype.drawGraph = function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      };\n\n      d.prototype.pointAttribs = function (a, b) {\n        var c = this.options,\n            e = this.pointAttrToOptions || {};\n        var d = e.stroke || \"borderColor\";\n        var g = e[\"stroke-width\"] || \"borderWidth\",\n            f = a && a.color || this.color,\n            h = a && a[d] || c[d] || this.color || f,\n            k = a && a[g] || c[g] || this[g] || 0;\n        e = a && a.options.dashStyle || c.dashStyle;\n        var n = m(a && a.opacity, c.opacity, 1);\n\n        if (a && this.zones.length) {\n          var q = a.getZone();\n          f = a.options.color || q && (q.color || a.nonZonedColor) || this.color;\n          q && (h = q.borderColor || h, e = q.dashStyle || e, k = q.borderWidth || k);\n        }\n\n        b && a && (a = z(c.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, f = a.color || \"undefined\" !== typeof b && l(f).brighten(a.brightness).get() || f, h = a[d] || h, k = a[g] || k, e = a.dashStyle || e, n = m(a.opacity, n));\n        d = {\n          fill: f,\n          stroke: h,\n          \"stroke-width\": k,\n          opacity: n\n        };\n        e && (d.dashstyle = e);\n        return d;\n      };\n\n      d.prototype.drawPoints = function () {\n        var a = this,\n            b = this.chart,\n            c = a.options,\n            e = b.renderer,\n            d = c.animationLimit || 250,\n            g;\n        a.points.forEach(function (f) {\n          var h = f.graphic,\n              m = !!h,\n              l = h && b.pointCount < d ? \"animate\" : \"attr\";\n\n          if (M(f.plotY) && null !== f.y) {\n            g = f.shapeArgs;\n            h && f.hasNewShapeType() && (h = h.destroy());\n            a.enabledDataSorting && (f.startXPos = a.xAxis.reversed ? -(g ? g.width : 0) : a.xAxis.width);\n            h || (f.graphic = h = e[f.shapeType](g).add(f.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < d && (h.attr({\n              x: f.startXPos\n            }), m = !0, l = \"animate\");\n            if (h && m) h[l](z(g));\n            if (c.borderRadius) h[l]({\n              r: c.borderRadius\n            });\n            b.styledMode || h[l](a.pointAttribs(f, f.selected && \"select\")).shadow(!1 !== f.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);\n            h && (h.addClass(f.getClassName(), !0), h.attr({\n              visibility: f.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else h && (f.graphic = h.destroy());\n        });\n      };\n\n      d.prototype.drawTracker = function () {\n        var a = this,\n            b = a.chart,\n            c = b.pointer,\n            e = function (a) {\n          var b = c.getPointFromEvent(a);\n          \"undefined\" !== typeof b && (c.isDirectTouch = !0, b.onMouseOver(a));\n        },\n            d;\n\n        a.points.forEach(function (a) {\n          d = A(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          d.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (d) {\n          if (a[d]) {\n            a[d].addClass(\"highcharts-tracker\").on(\"mouseover\", e).on(\"mouseout\", function (a) {\n              c.onTrackerMouseOut(a);\n            });\n            if (E) a[d].on(\"touchstart\", e);\n            !b.styledMode && a.options.cursor && a[d].css(y).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        n(this, \"afterDrawTracker\");\n      };\n\n      d.prototype.remove = function () {\n        var a = this,\n            b = a.chart;\n        b.hasRendered && b.series.forEach(function (b) {\n          b.type === a.type && (b.isDirty = !0);\n        });\n        G.prototype.remove.apply(a, arguments);\n      };\n\n      d.defaultOptions = z(G.defaultOptions, {\n        borderRadius: 0,\n        centerInCategory: !1,\n        groupPadding: .2,\n        marker: null,\n        pointPadding: .1,\n        minPointLength: 0,\n        cropThreshold: 50,\n        pointRange: null,\n        states: {\n          hover: {\n            halo: !1,\n            brightness: .1\n          },\n          select: {\n            color: B.neutralColor20,\n            borderColor: B.neutralColor100\n          }\n        },\n        dataLabels: {\n          align: void 0,\n          verticalAlign: void 0,\n          y: void 0\n        },\n        startFromThreshold: !0,\n        stickyTracking: !1,\n        tooltip: {\n          distance: 6\n        },\n        threshold: 0,\n        borderColor: B.backgroundColor\n      });\n      return d;\n    }(G);\n\n    q(H.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      drawLegendSymbol: x.drawRectangle,\n      getSymbol: f,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    D.registerSeriesType(\"column\", H);\n    \"\";\n    \"\";\n    return H;\n  });\n  P(k, \"Series/Bar/BarSeries.js\", [k[\"Series/Column/ColumnSeries.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d, k) {\n    var x = this && this.__extends || function () {\n      var d = function (f, k) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, f) {\n          d.__proto__ = f;\n        } || function (d, f) {\n          for (var l in f) f.hasOwnProperty(l) && (d[l] = f[l]);\n        };\n\n        return d(f, k);\n      };\n\n      return function (f, k) {\n        function t() {\n          this.constructor = f;\n        }\n\n        d(f, k);\n        f.prototype = null === k ? Object.create(k) : (t.prototype = k.prototype, new t());\n      };\n    }(),\n        B = k.extend,\n        G = k.merge;\n\n    k = function (d) {\n      function k() {\n        var f = null !== d && d.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      x(k, d);\n      k.defaultOptions = G(f.defaultOptions, {});\n      return k;\n    }(f);\n\n    B(k.prototype, {\n      inverted: !0\n    });\n    d.registerSeriesType(\"bar\", k);\n    \"\";\n    return k;\n  });\n  P(k, \"Series/Scatter/ScatterSeries.js\", [k[\"Series/Column/ColumnSeries.js\"], k[\"Series/Line/LineSeries.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x) {\n    var B = this && this.__extends || function () {\n      var d = function (f, l) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, g) {\n          d.__proto__ = g;\n        } || function (d, g) {\n          for (var f in g) g.hasOwnProperty(f) && (d[f] = g[f]);\n        };\n\n        return d(f, l);\n      };\n\n      return function (f, l) {\n        function k() {\n          this.constructor = f;\n        }\n\n        d(f, l);\n        f.prototype = null === l ? Object.create(l) : (k.prototype = l.prototype, new k());\n      };\n    }(),\n        G = x.addEvent,\n        D = x.extend,\n        H = x.merge;\n\n    x = function (f) {\n      function k() {\n        var d = null !== f && f.apply(this, arguments) || this;\n        d.data = void 0;\n        d.options = void 0;\n        d.points = void 0;\n        return d;\n      }\n\n      B(k, f);\n\n      k.prototype.applyJitter = function () {\n        var d = this,\n            f = this.options.jitter,\n            g = this.points.length;\n        f && this.points.forEach(function (l, c) {\n          [\"x\", \"y\"].forEach(function (k, n) {\n            var q = \"plot\" + k.toUpperCase();\n\n            if (f[k] && !l.isNull) {\n              var t = d[k + \"Axis\"];\n              var z = f[k] * t.transA;\n\n              if (t && !t.isLog) {\n                var m = Math.max(0, l[q] - z);\n                t = Math.min(t.len, l[q] + z);\n                n = 1E4 * Math.sin(c + n * g);\n                l[q] = m + (t - m) * (n - Math.floor(n));\n                \"x\" === k && (l.clientX = l.plotX);\n              }\n            }\n          });\n        });\n      };\n\n      k.prototype.drawGraph = function () {\n        (this.options.lineWidth || 0 === this.options.lineWidth && this.graph && this.graph.strokeWidth()) && f.prototype.drawGraph.call(this);\n      };\n\n      k.defaultOptions = H(d.defaultOptions, {\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        jitter: {\n          x: 0,\n          y: 0\n        },\n        marker: {\n          enabled: !0\n        },\n        tooltip: {\n          headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n          pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n        }\n      });\n      return k;\n    }(d);\n\n    D(x.prototype, {\n      drawTracker: f.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    G(x, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    k.registerSeriesType(\"scatter\", x);\n    \"\";\n    return x;\n  });\n  P(k, \"Mixins/CenteredSeries.js\", [k[\"Core/Globals.js\"], k[\"Core/Series/Series.js\"], k[\"Core/Utilities.js\"]], function (f, d, k) {\n    var x = k.isNumber,\n        B = k.pick,\n        G = k.relativeLength,\n        D = f.deg2rad;\n    return f.CenteredSeriesMixin = {\n      getCenter: function () {\n        var f = this.options,\n            k = this.chart,\n            x = 2 * (f.slicedOffset || 0),\n            l = k.plotWidth - 2 * x,\n            E = k.plotHeight - 2 * x,\n            g = f.center,\n            y = Math.min(l, E),\n            c = f.size,\n            q = f.innerSize || 0;\n        \"string\" === typeof c && (c = parseFloat(c));\n        \"string\" === typeof q && (q = parseFloat(q));\n        f = [B(g[0], \"50%\"), B(g[1], \"50%\"), B(c && 0 > c ? void 0 : f.size, \"100%\"), B(q && 0 > q ? void 0 : f.innerSize || 0, \"0%\")];\n        !k.angular || this instanceof d || (f[3] = 0);\n\n        for (g = 0; 4 > g; ++g) c = f[g], k = 2 > g || 2 === g && /%$/.test(c), f[g] = G(c, [l, E, y, f[2]][g]) + (k ? x : 0);\n\n        f[3] > f[2] && (f[3] = f[2]);\n        return f;\n      },\n      getStartAndEndRadians: function (d, f) {\n        d = x(d) ? d : 0;\n        f = x(f) && f > d && 360 > f - d ? f : d + 360;\n        return {\n          start: D * (d + -90),\n          end: D * (f + -90)\n        };\n      }\n    };\n  });\n  P(k, \"Series/Pie/PiePoint.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Series/Point.js\"], k[\"Core/Utilities.js\"]], function (f, d, k) {\n    var x = this && this.__extends || function () {\n      var d = function (f, g) {\n        d = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, c) {\n          d.__proto__ = c;\n        } || function (d, c) {\n          for (var g in c) c.hasOwnProperty(g) && (d[g] = c[g]);\n        };\n\n        return d(f, g);\n      };\n\n      return function (f, g) {\n        function l() {\n          this.constructor = f;\n        }\n\n        d(f, g);\n        f.prototype = null === g ? Object.create(g) : (l.prototype = g.prototype, new l());\n      };\n    }(),\n        B = f.setAnimation,\n        G = k.addEvent,\n        D = k.defined;\n\n    f = k.extend;\n    var H = k.isNumber,\n        t = k.pick,\n        C = k.relativeLength;\n\n    k = function (f) {\n      function l() {\n        var d = null !== f && f.apply(this, arguments) || this;\n        d.labelDistance = void 0;\n        d.options = void 0;\n        d.series = void 0;\n        return d;\n      }\n\n      x(l, f);\n\n      l.prototype.getConnectorPath = function () {\n        var d = this.labelPosition,\n            f = this.series.options.dataLabels,\n            c = f.connectorShape,\n            l = this.connectorShapes;\n        l[c] && (c = l[c]);\n        return c.call(this, {\n          x: d.final.x,\n          y: d.final.y,\n          alignment: d.alignment\n        }, d.connectorPosition, f);\n      };\n\n      l.prototype.getTranslate = function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      };\n\n      l.prototype.haloPath = function (d) {\n        var f = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(f.x, f.y, f.r + d, f.r + d, {\n          innerR: f.r - 1,\n          start: f.start,\n          end: f.end\n        });\n      };\n\n      l.prototype.init = function () {\n        d.prototype.init.apply(this, arguments);\n        var f = this;\n        f.name = t(f.name, \"Slice\");\n\n        var l = function (c) {\n          f.slice(\"select\" === c.type);\n        };\n\n        G(f, \"select\", l);\n        G(f, \"unselect\", l);\n        return f;\n      };\n\n      l.prototype.isValid = function () {\n        return H(this.y) && 0 <= this.y;\n      };\n\n      l.prototype.setVisible = function (d, f) {\n        var c = this,\n            g = c.series,\n            l = g.chart,\n            k = g.options.ignoreHiddenPoint;\n        f = t(f, k);\n        d !== c.visible && (c.visible = c.options.visible = d = \"undefined\" === typeof d ? !c.visible : d, g.options.data[g.data.indexOf(c)] = c.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (f) {\n          if (c[f]) c[f][d ? \"show\" : \"hide\"](d);\n        }), c.legendItem && l.legend.colorizeItem(c, d), d || \"hover\" !== c.state || c.setState(\"\"), k && (g.isDirty = !0), f && l.redraw());\n      };\n\n      l.prototype.slice = function (d, f, c) {\n        var g = this.series;\n        B(c, g.chart);\n        t(f, !0);\n        this.sliced = this.options.sliced = D(d) ? d : !this.sliced;\n        g.options.data[g.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      };\n\n      return l;\n    }(d);\n\n    f(k.prototype, {\n      connectorShapes: {\n        fixedOffset: function (d, f, g) {\n          var l = f.breakAt;\n          f = f.touchingSliceAt;\n          return [[\"M\", d.x, d.y], g.softConnector ? [\"C\", d.x + (\"left\" === d.alignment ? -5 : 5), d.y, 2 * l.x - f.x, 2 * l.y - f.y, l.x, l.y] : [\"L\", l.x, l.y], [\"L\", f.x, f.y]];\n        },\n        straight: function (d, f) {\n          f = f.touchingSliceAt;\n          return [[\"M\", d.x, d.y], [\"L\", f.x, f.y]];\n        },\n        crookedLine: function (d, f, g) {\n          f = f.touchingSliceAt;\n          var l = this.series,\n              c = l.center[0],\n              k = l.chart.plotWidth,\n              n = l.chart.plotLeft;\n          l = d.alignment;\n          var t = this.shapeArgs.r;\n          g = C(g.crookDistance, 1);\n          k = \"left\" === l ? c + t + (k + n - c - t) * (1 - g) : n + (c - t) * g;\n          g = [\"L\", k, d.y];\n          c = !0;\n          if (\"left\" === l ? k > d.x || k < f.x : k < d.x || k > f.x) c = !1;\n          d = [[\"M\", d.x, d.y]];\n          c && d.push(g);\n          d.push([\"L\", f.x, f.y]);\n          return d;\n        }\n      }\n    });\n    return k;\n  });\n  P(k, \"Series/Pie/PieSeries.js\", [k[\"Mixins/CenteredSeries.js\"], k[\"Series/Column/ColumnSeries.js\"], k[\"Core/Globals.js\"], k[\"Mixins/LegendSymbol.js\"], k[\"Core/Color/Palette.js\"], k[\"Series/Pie/PiePoint.js\"], k[\"Core/Series/Series.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Renderer/SVG/SVGRenderer.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G, D, H, t, C) {\n    var l = this && this.__extends || function () {\n      var c = function (d, f) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (c, e) {\n          c.__proto__ = e;\n        } || function (c, e) {\n          for (var d in e) e.hasOwnProperty(d) && (c[d] = e[d]);\n        };\n\n        return c(d, f);\n      };\n\n      return function (d, f) {\n        function g() {\n          this.constructor = d;\n        }\n\n        c(d, f);\n        d.prototype = null === f ? Object.create(f) : (g.prototype = f.prototype, new g());\n      };\n    }(),\n        E = f.getStartAndEndRadians;\n\n    k = k.noop;\n    var g = C.clamp,\n        y = C.extend,\n        c = C.fireEvent,\n        q = C.merge,\n        n = C.pick,\n        A = C.relativeLength;\n\n    C = function (d) {\n      function f() {\n        var c = null !== d && d.apply(this, arguments) || this;\n        c.center = void 0;\n        c.data = void 0;\n        c.maxLabelDistance = void 0;\n        c.options = void 0;\n        c.points = void 0;\n        return c;\n      }\n\n      l(f, d);\n\n      f.prototype.animate = function (c) {\n        var d = this,\n            e = d.points,\n            f = d.startAngleRad;\n        c || e.forEach(function (a) {\n          var b = a.graphic,\n              c = a.shapeArgs;\n          b && c && (b.attr({\n            r: n(a.startR, d.center && d.center[3] / 2),\n            start: f,\n            end: f\n          }), b.animate({\n            r: c.r,\n            start: c.start,\n            end: c.end\n          }, d.options.animation));\n        });\n      };\n\n      f.prototype.drawEmpty = function () {\n        var c = this.startAngleRad,\n            d = this.endAngleRad,\n            e = this.options;\n\n        if (0 === this.total && this.center) {\n          var f = this.center[0];\n          var a = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.arc(f, a, this.center[1] / 2, 0, c, d).addClass(\"highcharts-empty-series\").add(this.group));\n          this.graph.attr({\n            d: t.prototype.symbols.arc(f, a, this.center[2] / 2, 0, {\n              start: c,\n              end: d,\n              innerR: this.center[3] / 2\n            })\n          });\n          this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": e.borderWidth,\n            fill: e.fillColor || \"none\",\n            stroke: e.color || B.neutralColor20\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      };\n\n      f.prototype.drawPoints = function () {\n        var c = this.chart.renderer;\n        this.points.forEach(function (d) {\n          d.graphic && d.hasNewShapeType() && (d.graphic = d.graphic.destroy());\n          d.graphic || (d.graphic = c[d.shapeType](d.shapeArgs).add(d.series.group), d.delayedRendering = !0);\n        });\n      };\n\n      f.prototype.generatePoints = function () {\n        d.prototype.generatePoints.call(this);\n        this.updateTotals();\n      };\n\n      f.prototype.getX = function (c, d, e) {\n        var f = this.center,\n            a = this.radii ? this.radii[e.index] || 0 : f[2] / 2;\n        c = Math.asin(g((c - f[1]) / (a + e.labelDistance), -1, 1));\n        return f[0] + (d ? -1 : 1) * Math.cos(c) * (a + e.labelDistance) + (0 < e.labelDistance ? (d ? -1 : 1) * this.options.dataLabels.padding : 0);\n      };\n\n      f.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      f.prototype.redrawPoints = function () {\n        var c = this,\n            d = c.chart,\n            e = d.renderer,\n            f,\n            a,\n            b,\n            g,\n            l = c.options.shadow;\n        this.drawEmpty();\n        !l || c.shadowGroup || d.styledMode || (c.shadowGroup = e.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(c.group));\n        c.points.forEach(function (h) {\n          var m = {};\n          a = h.graphic;\n\n          if (!h.isNull && a) {\n            g = h.shapeArgs;\n            f = h.getTranslate();\n\n            if (!d.styledMode) {\n              var k = h.shadowGroup;\n              l && !k && (k = h.shadowGroup = e.g(\"shadow\").add(c.shadowGroup));\n              k && k.attr(f);\n              b = c.pointAttribs(h, h.selected && \"select\");\n            }\n\n            h.delayedRendering ? (a.setRadialReference(c.center).attr(g).attr(f), d.styledMode || a.attr(b).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(l, k), h.delayedRendering = !1) : (a.setRadialReference(c.center), d.styledMode || q(!0, m, b), q(!0, m, g, f), a.animate(m));\n            a.attr({\n              visibility: h.visible ? \"inherit\" : \"hidden\"\n            });\n            a.addClass(h.getClassName(), !0);\n          } else a && (h.graphic = a.destroy());\n        });\n      };\n\n      f.prototype.sortByAngle = function (c, d) {\n        c.sort(function (c, f) {\n          return \"undefined\" !== typeof c.angle && (f.angle - c.angle) * d;\n        });\n      };\n\n      f.prototype.translate = function (d) {\n        this.generatePoints();\n        var f = 0,\n            e = this.options,\n            g = e.slicedOffset,\n            a = g + (e.borderWidth || 0),\n            b = E(e.startAngle, e.endAngle),\n            m = this.startAngleRad = b.start;\n        b = (this.endAngleRad = b.end) - m;\n        var l = this.points,\n            k = e.dataLabels.distance;\n        e = e.ignoreHiddenPoint;\n        var q,\n            t = l.length;\n        d || (this.center = d = this.getCenter());\n\n        for (q = 0; q < t; q++) {\n          var z = l[q];\n          var x = m + f * b;\n          !z.isValid() || e && !z.visible || (f += z.percentage / 100);\n          var y = m + f * b;\n          z.shapeType = \"arc\";\n          z.shapeArgs = {\n            x: d[0],\n            y: d[1],\n            r: d[2] / 2,\n            innerR: d[3] / 2,\n            start: Math.round(1E3 * x) / 1E3,\n            end: Math.round(1E3 * y) / 1E3\n          };\n          z.labelDistance = n(z.options.dataLabels && z.options.dataLabels.distance, k);\n          z.labelDistance = A(z.labelDistance, z.shapeArgs.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, z.labelDistance);\n          y = (y + x) / 2;\n          y > 1.5 * Math.PI ? y -= 2 * Math.PI : y < -Math.PI / 2 && (y += 2 * Math.PI);\n          z.slicedTranslation = {\n            translateX: Math.round(Math.cos(y) * g),\n            translateY: Math.round(Math.sin(y) * g)\n          };\n          var v = Math.cos(y) * d[2] / 2;\n          var C = Math.sin(y) * d[2] / 2;\n          z.tooltipPos = [d[0] + .7 * v, d[1] + .7 * C];\n          z.half = y < -Math.PI / 2 || y > Math.PI / 2 ? 1 : 0;\n          z.angle = y;\n          x = Math.min(a, z.labelDistance / 5);\n          z.labelPosition = {\n            natural: {\n              x: d[0] + v + Math.cos(y) * z.labelDistance,\n              y: d[1] + C + Math.sin(y) * z.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > z.labelDistance ? \"center\" : z.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: d[0] + v + Math.cos(y) * x,\n                y: d[1] + C + Math.sin(y) * x\n              },\n              touchingSliceAt: {\n                x: d[0] + v,\n                y: d[1] + C\n              }\n            }\n          };\n        }\n\n        c(this, \"afterTranslate\");\n      };\n\n      f.prototype.updateTotals = function () {\n        var c,\n            d = 0,\n            e = this.points,\n            f = e.length,\n            a = this.options.ignoreHiddenPoint;\n\n        for (c = 0; c < f; c++) {\n          var b = e[c];\n          !b.isValid() || a && !b.visible || (d += b.y);\n        }\n\n        this.total = d;\n\n        for (c = 0; c < f; c++) b = e[c], b.percentage = 0 < d && (b.visible || !a) ? b.y / d * 100 : 0, b.total = d;\n      };\n\n      f.defaultOptions = q(D.defaultOptions, {\n        center: [null, null],\n        clip: !1,\n        colorByPoint: !0,\n        dataLabels: {\n          allowOverlap: !0,\n          connectorPadding: 5,\n          connectorShape: \"fixedOffset\",\n          crookDistance: \"70%\",\n          distance: 30,\n          enabled: !0,\n          formatter: function () {\n            return this.point.isNull ? void 0 : this.point.name;\n          },\n          softConnector: !0,\n          x: 0\n        },\n        fillColor: void 0,\n        ignoreHiddenPoint: !0,\n        inactiveOtherPoints: !0,\n        legendType: \"point\",\n        marker: null,\n        size: null,\n        showInLegend: !1,\n        slicedOffset: 10,\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0\n        },\n        borderColor: B.backgroundColor,\n        borderWidth: 1,\n        lineWidth: void 0,\n        states: {\n          hover: {\n            brightness: .1\n          }\n        }\n      });\n      return f;\n    }(D);\n\n    y(C.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: null,\n      drawLegendSymbol: x.drawRectangle,\n      drawTracker: d.prototype.drawTracker,\n      getCenter: f.getCenter,\n      getSymbol: k,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: d.prototype.pointAttribs,\n      pointClass: G,\n      requireSorting: !1,\n      searchPoint: k,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    H.registerSeriesType(\"pie\", C);\n    \"\";\n    return C;\n  });\n  P(k, \"Core/Series/DataLabels.js\", [k[\"Core/Animation/AnimationUtilities.js\"], k[\"Core/Globals.js\"], k[\"Core/Color/Palette.js\"], k[\"Core/Series/Series.js\"], k[\"Core/Series/SeriesRegistry.js\"], k[\"Core/Utilities.js\"]], function (f, d, k, x, B, G) {\n    var D = f.getDeferredAnimation;\n    f = d.noop;\n    B = B.seriesTypes;\n    var H = G.arrayMax,\n        t = G.clamp,\n        C = G.defined,\n        l = G.extend,\n        E = G.fireEvent,\n        g = G.format,\n        y = G.isArray,\n        c = G.merge,\n        q = G.objectEach,\n        n = G.pick,\n        A = G.relativeLength,\n        M = G.splat,\n        z = G.stableSort;\n    \"\";\n\n    d.distribute = function (c, f, e) {\n      function g(a, b) {\n        return a.target - b.target;\n      }\n\n      var a,\n          b = !0,\n          m = c,\n          l = [];\n      var k = 0;\n      var q = m.reducedLen || f;\n\n      for (a = c.length; a--;) k += c[a].size;\n\n      if (k > q) {\n        z(c, function (a, b) {\n          return (b.rank || 0) - (a.rank || 0);\n        });\n\n        for (k = a = 0; k <= q;) k += c[a].size, a++;\n\n        l = c.splice(a - 1, c.length);\n      }\n\n      z(c, g);\n\n      for (c = c.map(function (a) {\n        return {\n          size: a.size,\n          targets: [a.target],\n          align: n(a.align, .5)\n        };\n      }); b;) {\n        for (a = c.length; a--;) b = c[a], k = (Math.min.apply(0, b.targets) + Math.max.apply(0, b.targets)) / 2, b.pos = t(k - b.size * b.align, 0, f - b.size);\n\n        a = c.length;\n\n        for (b = !1; a--;) 0 < a && c[a - 1].pos + c[a - 1].size > c[a].pos && (c[a - 1].size += c[a].size, c[a - 1].targets = c[a - 1].targets.concat(c[a].targets), c[a - 1].align = .5, c[a - 1].pos + c[a - 1].size > f && (c[a - 1].pos = f - c[a - 1].size), c.splice(a, 1), b = !0);\n      }\n\n      m.push.apply(m, l);\n      a = 0;\n      c.some(function (b) {\n        var c = 0;\n        if (b.targets.some(function () {\n          m[a].pos = b.pos + c;\n          if (\"undefined\" !== typeof e && Math.abs(m[a].pos - m[a].target) > e) return m.slice(0, a + 1).forEach(function (a) {\n            delete a.pos;\n          }), m.reducedLen = (m.reducedLen || f) - .1 * f, m.reducedLen > .1 * f && d.distribute(m, f, e), !0;\n          c += m[a].size;\n          a++;\n        })) return !0;\n      });\n      z(m, g);\n    };\n\n    x.prototype.drawDataLabels = function () {\n      function d(a, b) {\n        var c = b.filter;\n        return c ? (b = c.operator, a = a[c.property], c = c.value, \">\" === b && a > c || \"<\" === b && a < c || \">=\" === b && a >= c || \"<=\" === b && a <= c || \"==\" === b && a == c || \"===\" === b && a === c ? !0 : !1) : !0;\n      }\n\n      function f(a, b) {\n        var d = [],\n            e;\n        if (y(a) && !y(b)) d = a.map(function (a) {\n          return c(a, b);\n        });else if (y(b) && !y(a)) d = b.map(function (b) {\n          return c(a, b);\n        });else if (y(a) || y(b)) for (e = Math.max(a.length, b.length); e--;) d[e] = c(a[e], b[e]);else d = c(a, b);\n        return d;\n      }\n\n      var e = this,\n          h = e.chart,\n          a = e.options,\n          b = a.dataLabels,\n          l = e.points,\n          t,\n          z = e.hasRendered || 0,\n          x = b.animation;\n      x = b.defer ? D(h, x, e) : {\n        defer: 0,\n        duration: 0\n      };\n      var A = h.renderer;\n      b = f(f(h.options.plotOptions && h.options.plotOptions.series && h.options.plotOptions.series.dataLabels, h.options.plotOptions && h.options.plotOptions[e.type] && h.options.plotOptions[e.type].dataLabels), b);\n      E(this, \"drawDataLabels\");\n\n      if (y(b) || b.enabled || e._hasPointLabels) {\n        var B = e.plotGroup(\"dataLabelsGroup\", \"data-labels\", z ? \"inherit\" : \"hidden\", b.zIndex || 6);\n        B.attr({\n          opacity: +z\n        });\n        !z && (z = e.dataLabelsGroup) && (e.visible && B.show(!0), z[a.animation ? \"animate\" : \"attr\"]({\n          opacity: 1\n        }, x));\n        l.forEach(function (c) {\n          t = M(f(b, c.dlOptions || c.options && c.options.dataLabels));\n          t.forEach(function (b, f) {\n            var m = b.enabled && (!c.isNull || c.dataLabelOnNull) && d(c, b),\n                l = c.dataLabels ? c.dataLabels[f] : c.dataLabel,\n                r = c.connectors ? c.connectors[f] : c.connector,\n                t = n(b.distance, c.labelDistance),\n                w = !l;\n\n            if (m) {\n              var u = c.getLabelConfig();\n              var v = n(b[c.formatPrefix + \"Format\"], b.format);\n              u = C(v) ? g(v, u, h) : (b[c.formatPrefix + \"Formatter\"] || b.formatter).call(u, b);\n              v = b.style;\n              var z = b.rotation;\n              h.styledMode || (v.color = n(b.color, v.color, e.color, k.neutralColor100), \"contrast\" === v.color ? (c.contrastColor = A.getContrast(c.color || e.color), v.color = !C(t) && b.inside || 0 > t || a.stacking ? c.contrastColor : k.neutralColor100) : delete c.contrastColor, a.cursor && (v.cursor = a.cursor));\n              var x = {\n                r: b.borderRadius || 0,\n                rotation: z,\n                padding: b.padding,\n                zIndex: 1\n              };\n              h.styledMode || (x.fill = b.backgroundColor, x.stroke = b.borderColor, x[\"stroke-width\"] = b.borderWidth);\n              q(x, function (a, b) {\n                \"undefined\" === typeof a && delete x[b];\n              });\n            }\n\n            !l || m && C(u) ? m && C(u) && (l ? x.text = u : (c.dataLabels = c.dataLabels || [], l = c.dataLabels[f] = z ? A.text(u, 0, -9999, b.useHTML).addClass(\"highcharts-data-label\") : A.label(u, 0, -9999, b.shape, null, null, b.useHTML, null, \"data-label\"), f || (c.dataLabel = l), l.addClass(\" highcharts-data-label-color-\" + c.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\"))), l.options = b, l.attr(x), h.styledMode || l.css(v).shadow(b.shadow), l.added || l.add(B), b.textPath && !b.useHTML && (l.setTextPath(c.getDataLabelPath && c.getDataLabelPath(l) || c.graphic, b.textPath), c.dataLabelPath && !b.textPath.enabled && (c.dataLabelPath = c.dataLabelPath.destroy())), e.alignDataLabel(c, l, b, null, w)) : (c.dataLabel = c.dataLabel && c.dataLabel.destroy(), c.dataLabels && (1 === c.dataLabels.length ? delete c.dataLabels : delete c.dataLabels[f]), f || delete c.dataLabel, r && (c.connector = c.connector.destroy(), c.connectors && (1 === c.connectors.length ? delete c.connectors : delete c.connectors[f])));\n          });\n        });\n      }\n\n      E(this, \"afterDrawDataLabels\");\n    };\n\n    x.prototype.alignDataLabel = function (c, d, e, f, a) {\n      var b = this,\n          g = this.chart,\n          h = this.isCartesian && g.inverted,\n          m = this.enabledDataSorting,\n          k = n(c.dlBox && c.dlBox.centerX, c.plotX, -9999),\n          q = n(c.plotY, -9999),\n          r = d.getBBox(),\n          t = e.rotation,\n          z = e.align,\n          v = g.isInsidePlot(k, Math.round(q), h),\n          x = \"justify\" === n(e.overflow, m ? \"none\" : \"justify\"),\n          p = this.visible && !1 !== c.visible && (c.series.forceDL || m && !x || v || e.inside && f && g.isInsidePlot(k, h ? f.x + 1 : f.y + f.height - 1, h));\n\n      var y = function (e) {\n        m && b.xAxis && !x && b.setDataLabelStartPos(c, d, a, v, e);\n      };\n\n      if (p) {\n        var C = g.renderer.fontMetrics(g.styledMode ? void 0 : e.style.fontSize, d).b;\n        f = l({\n          x: h ? this.yAxis.len - q : k,\n          y: Math.round(h ? this.xAxis.len - k : q),\n          width: 0,\n          height: 0\n        }, f);\n        l(e, {\n          width: r.width,\n          height: r.height\n        });\n        t ? (x = !1, k = g.renderer.rotCorr(C, t), k = {\n          x: f.x + (e.x || 0) + f.width / 2 + k.x,\n          y: f.y + (e.y || 0) + {\n            top: 0,\n            middle: .5,\n            bottom: 1\n          }[e.verticalAlign] * f.height\n        }, y(k), d[a ? \"attr\" : \"animate\"](k).attr({\n          align: z\n        }), y = (t + 720) % 360, y = 180 < y && 360 > y, \"left\" === z ? k.y -= y ? r.height : 0 : \"center\" === z ? (k.x -= r.width / 2, k.y -= r.height / 2) : \"right\" === z && (k.x -= r.width, k.y -= y ? 0 : r.height), d.placed = !0, d.alignAttr = k) : (y(f), d.align(e, null, f), k = d.alignAttr);\n        x && 0 <= f.height ? this.justifyDataLabel(d, e, k, r, f, a) : n(e.crop, !0) && (p = g.isInsidePlot(k.x, k.y) && g.isInsidePlot(k.x + r.width, k.y + r.height));\n        if (e.shape && !t) d[a ? \"attr\" : \"animate\"]({\n          anchorX: h ? g.plotWidth - c.plotY : c.plotX,\n          anchorY: h ? g.plotHeight - c.plotX : c.plotY\n        });\n      }\n\n      a && m && (d.placed = !1);\n      p || m && !x || (d.hide(!0), d.placed = !1);\n    };\n\n    x.prototype.setDataLabelStartPos = function (c, d, e, f, a) {\n      var b = this.chart,\n          g = b.inverted,\n          h = this.xAxis,\n          k = h.reversed,\n          l = g ? d.height / 2 : d.width / 2;\n      c = (c = c.pointWidth) ? c / 2 : 0;\n      h = g ? a.x : k ? -l - c : h.width - l + c;\n      a = g ? k ? this.yAxis.height - l + c : -l - c : a.y;\n      d.startXPos = h;\n      d.startYPos = a;\n      f ? \"hidden\" === d.visibility && (d.show(), d.attr({\n        opacity: 0\n      }).animate({\n        opacity: 1\n      })) : d.attr({\n        opacity: 1\n      }).animate({\n        opacity: 0\n      }, void 0, d.hide);\n      b.hasRendered && (e && d.attr({\n        x: d.startXPos,\n        y: d.startYPos\n      }), d.placed = !0);\n    };\n\n    x.prototype.justifyDataLabel = function (c, d, e, f, a, b) {\n      var g = this.chart,\n          h = d.align,\n          k = d.verticalAlign,\n          l = c.box ? 0 : c.padding || 0,\n          m = d.x;\n      m = void 0 === m ? 0 : m;\n      var n = d.y;\n      var q = void 0 === n ? 0 : n;\n      n = e.x + l;\n\n      if (0 > n) {\n        \"right\" === h && 0 <= m ? (d.align = \"left\", d.inside = !0) : m -= n;\n        var r = !0;\n      }\n\n      n = e.x + f.width - l;\n      n > g.plotWidth && (\"left\" === h && 0 >= m ? (d.align = \"right\", d.inside = !0) : m += g.plotWidth - n, r = !0);\n      n = e.y + l;\n      0 > n && (\"bottom\" === k && 0 <= q ? (d.verticalAlign = \"top\", d.inside = !0) : q -= n, r = !0);\n      n = e.y + f.height - l;\n      n > g.plotHeight && (\"top\" === k && 0 >= q ? (d.verticalAlign = \"bottom\", d.inside = !0) : q += g.plotHeight - n, r = !0);\n      r && (d.x = m, d.y = q, c.placed = !b, c.align(d, void 0, a));\n      return r;\n    };\n\n    B.pie && (B.pie.prototype.dataLabelPositioners = {\n      radialDistributionY: function (c) {\n        return c.top + c.distributeBox.pos;\n      },\n      radialDistributionX: function (c, d, e, f) {\n        return c.getX(e < d.top + 2 || e > d.bottom - 2 ? f : e, d.half, d);\n      },\n      justify: function (c, d, e) {\n        return e[0] + (c.half ? -1 : 1) * (d + c.labelDistance);\n      },\n      alignToPlotEdges: function (c, d, e, f) {\n        c = c.getBBox().width;\n        return d ? c + f : e - c - f;\n      },\n      alignToConnectors: function (c, d, e, f) {\n        var a = 0,\n            b;\n        c.forEach(function (c) {\n          b = c.dataLabel.getBBox().width;\n          b > a && (a = b);\n        });\n        return d ? a + f : e - a - f;\n      }\n    }, B.pie.prototype.drawDataLabels = function () {\n      var f = this,\n          g = f.data,\n          e,\n          h = f.chart,\n          a = f.options.dataLabels || {},\n          b = a.connectorPadding,\n          l,\n          q = h.plotWidth,\n          t = h.plotHeight,\n          z = h.plotLeft,\n          y = Math.round(h.chartWidth / 3),\n          A,\n          B = f.center,\n          E = B[2] / 2,\n          v = B[1],\n          D,\n          p,\n          G,\n          M,\n          P = [[], []],\n          u,\n          S,\n          I,\n          X,\n          U = [0, 0, 0, 0],\n          W = f.dataLabelPositioners,\n          Y;\n      f.visible && (a.enabled || f._hasPointLabels) && (g.forEach(function (a) {\n        a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n          width: \"auto\"\n        }).css({\n          width: \"auto\",\n          textOverflow: \"clip\"\n        }), a.dataLabel.shortened = !1);\n      }), x.prototype.drawDataLabels.apply(f), g.forEach(function (b) {\n        b.dataLabel && (b.visible ? (P[b.half].push(b), b.dataLabel._pos = null, !C(a.style.width) && !C(b.options.dataLabels && b.options.dataLabels.style && b.options.dataLabels.style.width) && b.dataLabel.getBBox().width > y && (b.dataLabel.css({\n          width: Math.round(.7 * y) + \"px\"\n        }), b.dataLabel.shortened = !0)) : (b.dataLabel = b.dataLabel.destroy(), b.dataLabels && 1 === b.dataLabels.length && delete b.dataLabels));\n      }), P.forEach(function (c, g) {\n        var k = c.length,\n            l = [],\n            m;\n\n        if (k) {\n          f.sortByAngle(c, g - .5);\n\n          if (0 < f.maxLabelDistance) {\n            var r = Math.max(0, v - E - f.maxLabelDistance);\n            var w = Math.min(v + E + f.maxLabelDistance, h.plotHeight);\n            c.forEach(function (a) {\n              0 < a.labelDistance && a.dataLabel && (a.top = Math.max(0, v - E - a.labelDistance), a.bottom = Math.min(v + E + a.labelDistance, h.plotHeight), m = a.dataLabel.getBBox().height || 21, a.distributeBox = {\n                target: a.labelPosition.natural.y - a.top + m / 2,\n                size: m,\n                rank: a.y\n              }, l.push(a.distributeBox));\n            });\n            r = w + m - r;\n            d.distribute(l, r, r / 5);\n          }\n\n          for (X = 0; X < k; X++) {\n            e = c[X];\n            G = e.labelPosition;\n            D = e.dataLabel;\n            I = !1 === e.visible ? \"hidden\" : \"inherit\";\n            S = r = G.natural.y;\n            l && C(e.distributeBox) && (\"undefined\" === typeof e.distributeBox.pos ? I = \"hidden\" : (M = e.distributeBox.size, S = W.radialDistributionY(e)));\n            delete e.positionIndex;\n            if (a.justify) u = W.justify(e, E, B);else switch (a.alignTo) {\n              case \"connectors\":\n                u = W.alignToConnectors(c, g, q, z);\n                break;\n\n              case \"plotEdges\":\n                u = W.alignToPlotEdges(D, g, q, z);\n                break;\n\n              default:\n                u = W.radialDistributionX(f, e, S, r);\n            }\n            D._attr = {\n              visibility: I,\n              align: G.alignment\n            };\n            Y = e.options.dataLabels || {};\n            D._pos = {\n              x: u + n(Y.x, a.x) + ({\n                left: b,\n                right: -b\n              }[G.alignment] || 0),\n              y: S + n(Y.y, a.y) - 10\n            };\n            G.final.x = u;\n            G.final.y = S;\n            n(a.crop, !0) && (p = D.getBBox().width, r = null, u - p < b && 1 === g ? (r = Math.round(p - u + b), U[3] = Math.max(r, U[3])) : u + p > q - b && 0 === g && (r = Math.round(u + p - q + b), U[1] = Math.max(r, U[1])), 0 > S - M / 2 ? U[0] = Math.max(Math.round(-S + M / 2), U[0]) : S + M / 2 > t && (U[2] = Math.max(Math.round(S + M / 2 - t), U[2])), D.sideOverflow = r);\n          }\n        }\n      }), 0 === H(U) || this.verifyDataLabelOverflow(U)) && (this.placeDataLabels(), this.points.forEach(function (b) {\n        Y = c(a, b.options.dataLabels);\n\n        if (l = n(Y.connectorWidth, 1)) {\n          var d;\n          A = b.connector;\n\n          if ((D = b.dataLabel) && D._pos && b.visible && 0 < b.labelDistance) {\n            I = D._attr.visibility;\n            if (d = !A) b.connector = A = h.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + b.colorIndex + (b.className ? \" \" + b.className : \"\")).add(f.dataLabelsGroup), h.styledMode || A.attr({\n              \"stroke-width\": l,\n              stroke: Y.connectorColor || b.color || k.neutralColor60\n            });\n            A[d ? \"attr\" : \"animate\"]({\n              d: b.getConnectorPath()\n            });\n            A.attr(\"visibility\", I);\n          } else A && (b.connector = A.destroy());\n        }\n      }));\n    }, B.pie.prototype.placeDataLabels = function () {\n      this.points.forEach(function (c) {\n        var d = c.dataLabel,\n            e;\n        d && c.visible && ((e = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({\n          width: d._attr.width + \"px\",\n          textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n        }), d.shortened = !0), d.attr(d._attr), d[d.moved ? \"animate\" : \"attr\"](e), d.moved = !0) : d && d.attr({\n          y: -9999\n        }));\n        delete c.distributeBox;\n      }, this);\n    }, B.pie.prototype.alignDataLabel = f, B.pie.prototype.verifyDataLabelOverflow = function (c) {\n      var d = this.center,\n          e = this.options,\n          f = e.center,\n          a = e.minSize || 80,\n          b = null !== e.size;\n\n      if (!b) {\n        if (null !== f[0]) var g = Math.max(d[2] - Math.max(c[1], c[3]), a);else g = Math.max(d[2] - c[1] - c[3], a), d[0] += (c[3] - c[1]) / 2;\n        null !== f[1] ? g = t(g, a, d[2] - Math.max(c[0], c[2])) : (g = t(g, a, d[2] - c[0] - c[2]), d[1] += (c[0] - c[2]) / 2);\n        g < d[2] ? (d[2] = g, d[3] = Math.min(A(e.innerSize || 0, g), g), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : b = !0;\n      }\n\n      return b;\n    });\n    B.column && (B.column.prototype.alignDataLabel = function (d, f, e, g, a) {\n      var b = this.chart.inverted,\n          h = d.series,\n          k = d.dlBox || d.shapeArgs,\n          l = n(d.below, d.plotY > n(this.translatedThreshold, h.yAxis.len)),\n          m = n(e.inside, !!this.options.stacking);\n      k && (g = c(k), 0 > g.y && (g.height += g.y, g.y = 0), k = g.y + g.height - h.yAxis.len, 0 < k && k < g.height && (g.height -= k), b && (g = {\n        x: h.yAxis.len - g.y - g.height,\n        y: h.xAxis.len - g.x - g.width,\n        width: g.height,\n        height: g.width\n      }), m || (b ? (g.x += l ? 0 : g.width, g.width = 0) : (g.y += l ? g.height : 0, g.height = 0)));\n      e.align = n(e.align, !b || m ? \"center\" : l ? \"right\" : \"left\");\n      e.verticalAlign = n(e.verticalAlign, b || m ? \"middle\" : l ? \"top\" : \"bottom\");\n      x.prototype.alignDataLabel.call(this, d, f, e, g, a);\n      e.inside && d.contrastColor && f.css({\n        color: d.contrastColor\n      });\n    });\n  });\n  P(k, \"Extensions/OverlappingDataLabels.js\", [k[\"Core/Chart/Chart.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = d.addEvent,\n        x = d.fireEvent,\n        B = d.isArray,\n        G = d.isNumber,\n        D = d.objectEach,\n        H = d.pick;\n    k(f, \"render\", function () {\n      var d = [];\n      (this.labelCollectors || []).forEach(function (f) {\n        d = d.concat(f());\n      });\n      (this.yAxis || []).forEach(function (f) {\n        f.stacking && f.options.stackLabels && !f.options.stackLabels.allowOverlap && D(f.stacking.stacks, function (f) {\n          D(f, function (f) {\n            d.push(f.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (f) {\n        var k = f.options.dataLabels;\n        f.visible && (!1 !== k.enabled || f._hasPointLabels) && (k = function (f) {\n          return f.forEach(function (f) {\n            f.visible && (B(f.dataLabels) ? f.dataLabels : f.dataLabel ? [f.dataLabel] : []).forEach(function (g) {\n              var c = g.options;\n              g.labelrank = H(c.labelrank, f.labelrank, f.shapeArgs && f.shapeArgs.height);\n              c.allowOverlap || d.push(g);\n            });\n          });\n        }, k(f.nodes || []), k(f.points));\n      });\n      this.hideOverlappingLabels(d);\n    });\n\n    f.prototype.hideOverlappingLabels = function (d) {\n      var f = this,\n          k = d.length,\n          t = f.renderer,\n          g,\n          y,\n          c,\n          q = !1;\n\n      var n = function (c) {\n        var d,\n            f = c.box ? 0 : c.padding || 0,\n            e = d = 0,\n            g;\n\n        if (c && (!c.alignAttr || c.placed)) {\n          var a = c.alignAttr || {\n            x: c.attr(\"x\"),\n            y: c.attr(\"y\")\n          };\n          var b = c.parentGroup;\n          c.width || (d = c.getBBox(), c.width = d.width, c.height = d.height, d = t.fontMetrics(null, c.element).h);\n          var k = c.width - 2 * f;\n          (g = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[c.alignValue]) ? e = +g * k : G(c.x) && Math.round(c.x) !== c.translateX && (e = c.x - c.translateX);\n          return {\n            x: a.x + (b.translateX || 0) + f - (e || 0),\n            y: a.y + (b.translateY || 0) + f - d,\n            width: c.width - 2 * f,\n            height: c.height - 2 * f\n          };\n        }\n      };\n\n      for (y = 0; y < k; y++) if (g = d[y]) g.oldOpacity = g.opacity, g.newOpacity = 1, g.absoluteBox = n(g);\n\n      d.sort(function (c, d) {\n        return (d.labelrank || 0) - (c.labelrank || 0);\n      });\n\n      for (y = 0; y < k; y++) {\n        var A = (n = d[y]) && n.absoluteBox;\n\n        for (g = y + 1; g < k; ++g) {\n          var B = (c = d[g]) && c.absoluteBox;\n          !A || !B || n === c || 0 === n.newOpacity || 0 === c.newOpacity || B.x >= A.x + A.width || B.x + B.width <= A.x || B.y >= A.y + A.height || B.y + B.height <= A.y || ((n.labelrank < c.labelrank ? n : c).newOpacity = 0);\n        }\n      }\n\n      d.forEach(function (c) {\n        if (c) {\n          var d = c.newOpacity;\n          c.oldOpacity !== d && (c.alignAttr && c.placed ? (c[d ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), q = !0, c.alignAttr.opacity = d, c[c.isOld ? \"animate\" : \"attr\"](c.alignAttr, null, function () {\n            f.styledMode || c.css({\n              pointerEvents: d ? \"auto\" : \"none\"\n            });\n            c.visibility = d ? \"inherit\" : \"hidden\";\n          }), x(f, \"afterHideOverlappingLabel\")) : c.attr({\n            opacity: d\n          }));\n          c.isOld = !0;\n        }\n      });\n      q && x(f, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  P(k, \"Core/Responsive.js\", [k[\"Core/Chart/Chart.js\"], k[\"Core/Utilities.js\"]], function (f, d) {\n    var k = d.find,\n        x = d.isArray,\n        B = d.isObject,\n        G = d.merge,\n        D = d.objectEach,\n        H = d.pick,\n        t = d.splat,\n        C = d.uniqueKey;\n\n    f.prototype.setResponsive = function (d, f) {\n      var g = this.options.responsive,\n          l = [],\n          c = this.currentResponsive;\n      !f && g && g.rules && g.rules.forEach(function (c) {\n        \"undefined\" === typeof c._id && (c._id = C());\n        this.matchResponsiveRule(c, l);\n      }, this);\n      f = G.apply(0, l.map(function (c) {\n        return k(g.rules, function (d) {\n          return d._id === c;\n        }).chartOptions;\n      }));\n      f.isResponsiveOptions = !0;\n      l = l.toString() || void 0;\n      l !== (c && c.ruleIds) && (c && this.update(c.undoOptions, d, !0), l ? (c = this.currentOptions(f), c.isResponsiveOptions = !0, this.currentResponsive = {\n        ruleIds: l,\n        mergedOptions: f,\n        undoOptions: c\n      }, this.update(f, d, !0)) : this.currentResponsive = void 0);\n    };\n\n    f.prototype.matchResponsiveRule = function (d, f) {\n      var g = d.condition;\n      (g.callback || function () {\n        return this.chartWidth <= H(g.maxWidth, Number.MAX_VALUE) && this.chartHeight <= H(g.maxHeight, Number.MAX_VALUE) && this.chartWidth >= H(g.minWidth, 0) && this.chartHeight >= H(g.minHeight, 0);\n      }).call(this) && f.push(d._id);\n    };\n\n    f.prototype.currentOptions = function (d) {\n      function f(c, d, k, l) {\n        var n;\n        D(c, function (c, m) {\n          if (!l && -1 < g.collectionsWithUpdate.indexOf(m) && d[m]) for (c = t(c), k[m] = [], n = 0; n < Math.max(c.length, d[m].length); n++) d[m][n] && (void 0 === c[n] ? k[m][n] = d[m][n] : (k[m][n] = {}, f(c[n], d[m][n], k[m][n], l + 1)));else B(c) ? (k[m] = x(c) ? [] : {}, f(c, d[m] || {}, k[m], l + 1)) : k[m] = \"undefined\" === typeof d[m] ? null : d[m];\n        });\n      }\n\n      var g = this,\n          k = {};\n      f(d, this.options, k, 0);\n      return k;\n    };\n  });\n  P(k, \"masters/highcharts.src.js\", [k[\"Core/Globals.js\"], k[\"Core/Utilities.js\"], k[\"Core/Renderer/HTML/AST.js\"], k[\"Core/Series/Series.js\"]], function (f, d, k, x) {\n    f.addEvent = d.addEvent;\n    f.arrayMax = d.arrayMax;\n    f.arrayMin = d.arrayMin;\n    f.attr = d.attr;\n    f.clearTimeout = d.clearTimeout;\n    f.correctFloat = d.correctFloat;\n    f.createElement = d.createElement;\n    f.css = d.css;\n    f.defined = d.defined;\n    f.destroyObjectProperties = d.destroyObjectProperties;\n    f.discardElement = d.discardElement;\n    f.erase = d.erase;\n    f.error = d.error;\n    f.extend = d.extend;\n    f.extendClass = d.extendClass;\n    f.find = d.find;\n    f.fireEvent = d.fireEvent;\n    f.format = d.format;\n    f.getMagnitude = d.getMagnitude;\n    f.getStyle = d.getStyle;\n    f.inArray = d.inArray;\n    f.isArray = d.isArray;\n    f.isClass = d.isClass;\n    f.isDOMElement = d.isDOMElement;\n    f.isFunction = d.isFunction;\n    f.isNumber = d.isNumber;\n    f.isObject = d.isObject;\n    f.isString = d.isString;\n    f.keys = d.keys;\n    f.merge = d.merge;\n    f.normalizeTickInterval = d.normalizeTickInterval;\n    f.numberFormat = d.numberFormat;\n    f.objectEach = d.objectEach;\n    f.offset = d.offset;\n    f.pad = d.pad;\n    f.pick = d.pick;\n    f.pInt = d.pInt;\n    f.relativeLength = d.relativeLength;\n    f.removeEvent = d.removeEvent;\n    f.splat = d.splat;\n    f.stableSort = d.stableSort;\n    f.syncTimeout = d.syncTimeout;\n    f.timeUnits = d.timeUnits;\n    f.uniqueKey = d.uniqueKey;\n    f.useSerialIds = d.useSerialIds;\n    f.wrap = d.wrap;\n    f.AST = k;\n    f.Series = x;\n    return f;\n  });\n  k[\"masters/highcharts.src.js\"]._modules = k;\n  return k[\"masters/highcharts.src.js\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaGlnaGNoYXJ0cy5zcmMuanM/MGJiYiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJmYWN0b3J5Iiwicm9vdCIsImRlZmluZSIsIl9yZWdpc3Rlck1vZHVsZSIsIm9iaiIsImZuIiwiX21vZHVsZXMiLCJnbG9iIiwiZG9jIiwidXNlckFnZW50Iiwic3ZnIiwiU1ZHX05TIiwiaXNNUyIsImlzRmlyZWZveCIsImlzQ2hyb21lIiwiaGFzQmlkaUJ1ZyIsInBhcnNlSW50Iiwibm9vcCIsIkgiLCJwcm9kdWN0IiwidmVyc2lvbiIsImRlZzJyYWQiLCJNYXRoIiwiaGFzVG91Y2giLCJpc1dlYktpdCIsImlzU2FmYXJpIiwiaXNUb3VjaERldmljZSIsImNoYXJ0Q291bnQiLCJzZXJpZXNUeXBlcyIsInN1cHBvcnRzUGFzc2l2ZUV2ZW50cyIsImNoZWNrUGFzc2l2ZUV2ZW50cyIsInN1cHBvcnRzUGFzc2l2ZSIsIm9wdHMiLCJPYmplY3QiLCJnZXQiLCJzeW1ib2xTaXplcyIsIndpbiIsIm1hcmdpbk5hbWVzIiwiY2hhcnRzIiwiZGF0ZUZvcm1hdHMiLCJlcnJvciIsInNldmVyaXR5Iiwic3RvcCIsImNvZGUiLCJpc0NvZGUiLCJpc051bWJlciIsIm1lc3NhZ2UiLCJkZWZhdWx0SGFuZGxlciIsIkVycm9yIiwiY29uc29sZSIsImFkZGl0aW9uYWxNZXNzYWdlc18xIiwib2JqZWN0RWFjaCIsInZhbHVlIiwiZW5jb2RlVVJJIiwiY2hhcnQiLCJmaXJlRXZlbnQiLCJwYXJhbXMiLCJtZXJnZSIsImFyZ3MiLCJyZXQiLCJkb0NvcHkiLCJjb3B5IiwiaXNDbGFzcyIsImlzRE9NRWxlbWVudCIsIm9yaWdpbmFsIiwiQXJyYXkiLCJpIiwiY2xlYW5SZWN1cnNpdmVseSIsInJlc3VsdCIsImlzT2JqZWN0IiwibmV3ZXIiLCJvbGRlciIsIm9iIiwicEludCIsIm1hZyIsImlzU3RyaW5nIiwiaXNBcnJheSIsInN0ciIsImMiLCJuYW1lIiwiaXNOYU4iLCJJbmZpbml0eSIsImRlZmluZWQiLCJhdHRyIiwiZWxlbSIsInByb3AiLCJleHRlbmQiLCJuIiwiYSIsImIiLCJwaWNrIiwibGVuZ3RoIiwiYXJnIiwiY3NzIiwic3R5bGVzIiwiZWwiLCJjcmVhdGVFbGVtZW50IiwiYXR0cmlicyIsIm5vcGFkIiwicGFkZGluZyIsImJvcmRlciIsIm1hcmdpbiIsInBhcmVudCIsImNvcnJlY3RGbG9hdCIsInBhcnNlRmxvYXQiLCJudW0iLCJwcmVjIiwibnVtYmVyRm9ybWF0IiwibnVtYmVyIiwiZGVjaW1hbHMiLCJsYW5nIiwib3JpZ0RlYyIsInNwbGl0IiwiZXhwb25lbnQiLCJmaXJzdERlY2ltYWxzIiwidG9FeHBvbmVudGlhbCIsInRvRml4ZWQiLCJzdHJpbnRlZ2VyIiwiU3RyaW5nIiwidGhvdXNhbmRzIiwiZGVjaW1hbFBvaW50IiwidGhvdXNhbmRzU2VwIiwicm91bmRlZE51bWJlciIsImdldE5lc3RlZFByb3BlcnR5IiwicGF0aEVsZW1lbnRzIiwicGF0aCIsInN1YlByb3BlcnR5IiwicGF0aEVsZW1lbnQiLCJrZXkiLCJjdHgiLCJyZW1vdmVFdmVudCIsInJlbW92ZU9uZUV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUFsbEV2ZW50cyIsImxlbiIsInR5cGVzIiwiZXZlbnRDb2xsZWN0aW9uIiwib3duZXIiLCJldmVudHMiLCJ0eXBlIiwidHlwZUV2ZW50cyIsImV2ZW50QXJndW1lbnRzIiwiZSIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0Iiwib2JqZWN0IiwibXVsdGlsZXZlbCIsImRlZmF1bHRGdW5jdGlvbiIsIm1lc3NhZ2VzIiwiZ2FyYmFnZUJpbiIsIk1hdGguZWFzZUluT3V0U2luZSIsImZpbmQiLCJhcnIiLCJjYWxsYmFjayIsIm1hcCIsImVhY2giLCJncmVwIiwicmVkdWNlIiwic29tZSIsIl9hIiwidW5pcXVlS2V5IiwiaGFzaCIsImlkIiwic2VyaWFsTW9kZSIsImdldE9wdGlvbnMiLCJILmdldE9wdGlvbnMiLCJzZXRPcHRpb25zIiwiSC5zZXRPcHRpb25zIiwib3B0aW9ucyIsImpRdWVyeSIsIndpbi5qUXVlcnkuZm4uaGlnaGNoYXJ0cyIsInV0aWxpdGllc01vZHVsZSIsImFkZEV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJjYXB0dXJlIiwiZXZlbnRPYmplY3QiLCJvcmRlciIsImFycmF5TWF4IiwiZGF0YSIsIm1heCIsImFycmF5TWluIiwibWluIiwiY2xhbXAiLCJjbGVhclRpbWVvdXQiLCJpbnRlcm5hbENsZWFyVGltZW91dCIsImRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzIiwidmFsIiwiZGlzY2FyZEVsZW1lbnQiLCJlbGVtZW50IiwiZXJhc2UiLCJleHRlbmRDbGFzcyIsImZvcm1hdCIsInNwbGl0dGVyIiwiaXNJbnNpZGUiLCJmbG9hdFJlZ2V4IiwiZGVjUmVnZXgiLCJ0aW1lIiwibnVtYmVyRm9ybWF0dGVyIiwidmFsdWVBbmRGb3JtYXQiLCJzZWdtZW50IiwiaW5kZXgiLCJnZXRNYWduaXR1ZGUiLCJnZXRTdHlsZSIsIm9mZnNldFdpZHRoIiwiYm91bmRpbmdDbGllbnRSZWN0V2lkdGgiLCJzdHlsZSIsInVuZGVmaW5lZCIsImluQXJyYXkiLCJpc0Z1bmN0aW9uIiwia2V5cyIsIm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCIsInJldEludGVydmFsIiwiaW50ZXJ2YWwiLCJtYWduaXR1ZGUiLCJtdWx0aXBsZXMiLCJoYXNUaWNrQW1vdW50Iiwibm9ybWFsaXplZCIsIm9mZnNldCIsImRvY0VsZW0iLCJib3giLCJ0b3AiLCJsZWZ0Iiwid2lkdGgiLCJoZWlnaHQiLCJwYWQiLCJwYWRkZXIiLCJyZWxhdGl2ZUxlbmd0aCIsInRlc3QiLCJiYXNlIiwic3BsYXQiLCJzdGFibGVTb3J0Iiwic29ydFZhbHVlIiwic29ydEZ1bmN0aW9uIiwic3luY1RpbWVvdXQiLCJzZXRUaW1lb3V0IiwidGltZVVuaXRzIiwibWlsbGlzZWNvbmQiLCJzZWNvbmQiLCJtaW51dGUiLCJob3VyIiwiZGF5Iiwid2VlayIsIm1vbnRoIiwieWVhciIsInVzZVNlcmlhbElkcyIsIndyYXAiLCJwcm9jZWVkIiwib3V0ZXJBcmdzIiwiY3R4LnByb2NlZWQiLCJhcmd1bWVudHMiLCJmdW5jIiwiVSIsImhhc1ZhbGlkRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiQVNUIiwiQVNULmZpbHRlclVzZXJBdHRyaWJ1dGVzIiwidmFsaWQiLCJhdHRyaWJ1dGVzIiwiQVNULnNldEVsZW1lbnRIVE1MIiwiaHRtbCIsImFzdCIsImFkZFRvRE9NIiwiQVNULnByb3RvdHlwZS5hZGRUb0RPTSIsInJlY3Vyc2UiLCJ0YWdOYW1lIiwiaXRlbSIsInRleHROb2RlIiwiTlMiLCJzdWJQYXJlbnQiLCJhdHRyaWJ1dGVzXzEiLCJub2RlIiwiQVNULnByb3RvdHlwZS5wYXJzZU1hcmt1cCIsIm5vZGVzIiwiYm9keSIsIm1hcmt1cCIsImFwcGVuZENoaWxkTm9kZXMiLCJhc3ROb2RlIiwidGV4dENvbnRlbnQiLCJwYXJzZWRBdHRyaWJ1dGVzIiwiYXR0cmlidXRlc18yIiwiYXR0cmliIiwiY2hpbGRyZW5fMSIsImFkZFRvIiwiYWxsb3dlZEF0dHJpYnV0ZXMiLCJhbGxvd2VkUmVmZXJlbmNlcyIsIkNvbG9yIiwicmVnZXgiLCJwYXJzZSIsIkNvbG9yLnBhcnNlIiwiQ29sb3IucHJvdG90eXBlLmluaXQiLCJpbnB1dCIsInJnYmEiLCJwYXJzZXIiLCJDb2xvci5wcm90b3R5cGUuZ2V0IiwiQ29sb3IucHJvdG90eXBlLmJyaWdodGVuIiwiQ29sb3IucHJvdG90eXBlLnNldE9wYWNpdHkiLCJhbHBoYSIsIkNvbG9yLnByb3RvdHlwZS50d2VlblRvIiwiZnJvbVJnYmEiLCJ0b1JnYmEiLCJ0byIsImhhc0FscGhhIiwid2hpdGUiLCJibGFjayIsInBhbGV0dGUiLCJjb2xvcnMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJuZXV0cmFsQ29sb3IxMDAiLCJuZXV0cmFsQ29sb3I4MCIsIm5ldXRyYWxDb2xvcjYwIiwibmV1dHJhbENvbG9yNDAiLCJuZXV0cmFsQ29sb3IyMCIsIm5ldXRyYWxDb2xvcjEwIiwibmV1dHJhbENvbG9yNSIsIm5ldXRyYWxDb2xvcjMiLCJoaWdobGlnaHRDb2xvcjEwMCIsImhpZ2hsaWdodENvbG9yODAiLCJoaWdobGlnaHRDb2xvcjYwIiwiaGlnaGxpZ2h0Q29sb3IyMCIsImhpZ2hsaWdodENvbG9yMTAiLCJpbmRpY2F0b3JQb3NpdGl2ZUxpbmUiLCJpbmRpY2F0b3JOZWdhdGl2ZUxpbmUiLCJGeCIsIk5hTiIsIkZ4LnByb3RvdHlwZS5kU2V0dGVyIiwicGF0aHMiLCJzdGFydCIsImVuZCIsIm5vdyIsInN0YXJ0U2VnIiwiZW5kU2VnIiwidHdlZW5TZWciLCJqIiwic3RhcnRJdGVtIiwiZW5kSXRlbSIsIkZ4LnByb3RvdHlwZS51cGRhdGUiLCJzdGVwIiwiRngucHJvdG90eXBlLnJ1biIsInNlbGYiLCJ0aW1lciIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImZyb20iLCJEYXRlIiwidW5pdCIsIkZ4LnByb3RvdHlwZS5zdGVwIiwidCIsImNvbXBsZXRlIiwiZHVyYXRpb24iLCJjdXJBbmltIiwiZ290b0VuZCIsImRvbmUiLCJGeC5wcm90b3R5cGUuaW5pdFBhdGgiLCJwcmVwZW5kIiwibW92ZVNlZ21lbnQiLCJvdGhlclNlZ21lbnQiLCJvdGhlciIsImZ1bGxMZW5ndGgiLCJpc0FyZWEiLCJhcHBlbmQiLCJzZWdtZW50VG9BZGQiLCJsb3dlclNlZ21lbnRUb0FkZCIsInN0YXJ0WCIsImVuZFgiLCJmcm9tRCIsInRvRCIsInBvc2l0aW9uRmFjdG9yIiwic2hpZnQiLCJyZXZlcnNlIiwiRngucHJvdG90eXBlLmZpbGxTZXR0ZXIiLCJGeC5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyIiwic2V0QW5pbWF0aW9uIiwiSC5zZXRBbmltYXRpb24iLCJhbmltT2JqZWN0IiwiSC5hbmltT2JqZWN0IiwiZGVmZXIiLCJhbmltYXRpb24iLCJnZXREZWZlcnJlZEFuaW1hdGlvbiIsIkguZ2V0RGVmZXJyZWRBbmltYXRpb24iLCJsYWJlbEFuaW1hdGlvbiIsInNlcmllcyIsInNlcmllc0FuaW0iLCJhbmltIiwiSC5zdG9wIiwiYW5pbWF0aW9uRXhwb3J0cyIsImFuaW1hdGUiLCJmeCIsIm9wdCIsImVhc2luZyIsIkEiLCJTVkdFbGVtZW50Iiwic3ltYm9sQ3VzdG9tQXR0cmlicyIsIlNWR0VsZW1lbnQucHJvdG90eXBlLl9kZWZhdWx0R2V0dGVyIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuX2RlZmF1bHRTZXR0ZXIiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5hZGQiLCJyZW5kZXJlciIsImluc2VydGVkIiwiYXBwZW5kQ2hpbGQiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5hZGRDbGFzcyIsImN1cnJlbnRDbGFzc05hbWUiLCJyZXBsYWNlIiwiY2xhc3NOYW1lIiwibmV3Q2xhc3NOYW1lIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuYWZ0ZXJTZXR0ZXJzIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuYWxpZ24iLCJhbGlnbmVkT2JqZWN0cyIsInZBbGlnbkZhY3RvciIsImFsaWduT3B0aW9ucyIsImFsaWduQnlUcmFuc2xhdGUiLCJhbGlnblRvIiwiYWxpZ24iLCJ2QWxpZ24iLCJ4IiwiYWxpZ25GYWN0b3IiLCJ5IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuYWxpZ25TZXR0ZXIiLCJjb252ZXJ0IiwiY2VudGVyIiwicmlnaHQiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5hbmltYXRlIiwiX3RoaXMiLCJhbmltT3B0aW9ucyIsImRlZmVyVGltZSIsInBvcyIsIlNWR0VsZW1lbnQucHJvdG90eXBlLmFwcGx5VGV4dE91dGxpbmUiLCJ0ZXh0T3V0bGluZSIsInBhcnRzIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsIk51bWJlciIsIm91dGxpbmVfMSIsImZpbGwiLCJzdHJva2UiLCJjbG9uZSIsImNoaWxkTm9kZSIsImJyIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuYXR0ciIsImNhbGwiLCJlYWNoQXR0cmlidXRlIiwic2tpcEF0dHIiLCJjb250aW51ZUFuaW1hdGlvbiIsImhhc1NldFN5bWJvbFNpemUiLCJyb3RhdGlvbiIsInNldHRlciIsIlNWR0VsZW1lbnQucHJvdG90eXBlLmNsaXAiLCJjbGlwUmVjdCIsIlNWR0VsZW1lbnQucHJvdG90eXBlLmNyaXNwIiwicmVjdCIsIndyYXBwZXIiLCJub3JtYWxpemVyIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuY29tcGxleENvbG9yIiwiY29sb3JPcHRpb25zIiwiZ3JhZE5hbWUiLCJncmFkQXR0ciIsImdyYWRpZW50cyIsInN0b3BzIiwicmFkaWFsUmVmZXJlbmNlIiwieDEiLCJ5MSIsIngyIiwieTIiLCJncmFkaWVudFVuaXRzIiwicmFkQXR0ciIsImdyYWRpZW50T2JqZWN0XzEiLCJjb2xvck9iamVjdCIsInN0b3BDb2xvciIsInN0b3BPYmplY3QiLCJjb2xvck9wdGlvbnMudG9TdHJpbmciLCJTVkdFbGVtZW50LnByb3RvdHlwZS5jc3MiLCJvbGRTdHlsZXMiLCJuZXdTdHlsZXMiLCJzZXJpYWxpemVkQ3NzIiwiaGFzTmV3Iiwic3ZnUHNldWRvUHJvcHMiLCJ0ZXh0V2lkdGgiLCJoeXBoZW5hdGUiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5kYXNoc3R5bGVTZXR0ZXIiLCJ2IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSIsInBhcmVudFRvQ2xlYW4iLCJvd25lclNWR0VsZW1lbnQiLCJjbGlwUGF0aF8xIiwiaW5kZXhPZiIsImdyYW5kUGFyZW50IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveVNoYWRvd3MiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95VGV4dFBhdGgiLCJ0ZXh0RWxlbWVudCIsImNoaWxkTm9kZXMiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5kU2V0dGVyIiwic2VnIiwiYWNjIiwidG9TdHJpbmciLCJTVkdFbGVtZW50LnByb3RvdHlwZS5mYWRlT3V0IiwiZWxlbVdyYXBwZXIiLCJvcGFjaXR5IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuZmlsbFNldHRlciIsIlNWR0VsZW1lbnQucHJvdG90eXBlLmdldEJCb3giLCJ0ZXh0U3RyIiwiY2FjaGUiLCJjYWNoZUtleXMiLCJpc1NWRyIsImNhY2hlS2V5IiwiYkJveCIsIm91dGxpbmUiLCJkaXNwbGF5IiwidG9nZ2xlVGV4dFNoYWRvd1NoaW0iLCJodG1sR2V0QkJveCIsInJhZCIsIlNWR0VsZW1lbnQucHJvdG90eXBlLmdldFN0eWxlIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuaGFzQ2xhc3MiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5oaWRlIiwiaGlkZUJ5VHJhbnNsYXRpb24iLCJ2aXNpYmlsaXR5IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuaHRtbEdldEJCb3giLCJTVkdFbGVtZW50LnByb3RvdHlwZS5pbml0IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuaW52ZXJ0IiwiaW52ZXJ0ZWQiLCJ1cGRhdGVUcmFuc2Zvcm0iLCJTVkdFbGVtZW50LnByb3RvdHlwZS5vbiIsInN2Z0VsZW1lbnQiLCJ0b3VjaEV2ZW50RmlyZWQiLCJlbGVtZW50Lm9udG91Y2hzdGFydCIsImVsZW1lbnQub250b3VjaGVuZCIsImNsaWVudFgiLCJjbGllbnRZIiwiaGFuZGxlciIsImVsZW1lbnQub25jbGljayIsIlNWR0VsZW1lbnQucHJvdG90eXBlLm9wYWNpdHlTZXR0ZXIiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDbGFzcyIsIlNWR0VsZW1lbnQucHJvdG90eXBlLnJlbW92ZVRleHRPdXRsaW5lIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuc2FmZVJlbW92ZUNoaWxkIiwicGFyZW50Tm9kZSIsIlNWR0VsZW1lbnQucHJvdG90eXBlLnNldFJhZGlhbFJlZmVyZW5jZSIsImV4aXN0aW5nR3JhZGllbnQiLCJjb29yZGluYXRlcyIsIlNWR0VsZW1lbnQucHJvdG90eXBlLnNldFRleHRQYXRoIiwiYXR0cmlic01hcCIsInRleHRBbmNob3IiLCJhZGRlciIsInRleHRQYXRoV3JhcHBlciIsImZpcnN0VGltZSIsInRleHRQYXRoT3B0aW9ucyIsImVuYWJsZWQiLCJkeSIsInN0YXJ0T2Zmc2V0IiwiYXR0cnMiLCJ0ZXh0UGF0aElkIiwiTm9kZSIsInRleHRQYXRoRWxlbWVudCIsIlNWR0VsZW1lbnQucHJvdG90eXBlLnNoYWRvdyIsInNoYWRvd3MiLCJ1cGRhdGUiLCJvbGRTaGFkb3dPcHRpb25zIiwiZGVmYXVsdFNoYWRvd09wdGlvbnMiLCJvZmZzZXRYIiwib2Zmc2V0WSIsInNoYWRvd09wdGlvbnMiLCJzaGFkb3dFbGVtZW50T3BhY2l0eSIsInRyYW5zZm9ybSIsInNoYWRvdyIsImN1dE9mZiIsImdyb3VwIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuc2hvdyIsImluaGVyaXQiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5zdHJva2VTZXR0ZXIiLCJTVkdFbGVtZW50LnByb3RvdHlwZS5zdHJva2VXaWR0aCIsImR1bW15IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUuc3ltYm9sQXR0ciIsImQiLCJTVkdFbGVtZW50LnByb3RvdHlwZS50ZXh0U2V0dGVyIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUudGl0bGVTZXR0ZXIiLCJ0aXRsZU5vZGUiLCJTVkdFbGVtZW50LnByb3RvdHlwZS50b0Zyb250IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUudHJhbnNsYXRlIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJTVkdFbGVtZW50LnByb3RvdHlwZS51cGRhdGVTaGFkb3dzIiwiU1ZHRWxlbWVudC5wcm90b3R5cGUudXBkYXRlVHJhbnNmb3JtIiwic2NhbGVYIiwic2NhbGVZIiwibWF0cml4IiwiU1ZHRWxlbWVudC5wcm90b3R5cGUudmlzaWJpbGl0eVNldHRlciIsIlNWR0VsZW1lbnQucHJvdG90eXBlLnhHZXR0ZXIiLCJTVkdFbGVtZW50LnByb3RvdHlwZS56SW5kZXhTZXR0ZXIiLCJwYXJlbnRHcm91cCIsInN2Z1BhcmVudCIsInJ1biIsIm90aGVyRWxlbWVudCIsIm90aGVyWkluZGV4IiwidW5kZWZpbmVkT3RoZXJaSW5kZXgiLCJTVkdFbGVtZW50LnByb3RvdHlwZS52ZXJ0aWNhbEFsaWduU2V0dGVyIiwicGFkZGluZ1NldHRlciIsIl9fZXh0ZW5kcyIsImV4dGVuZFN0YXRpY3MiLCJfX3Byb3RvX18iLCJwIiwiX18iLCJTVkdMYWJlbCIsIl9zdXBlciIsImFuY2hvclgiLCJhbmNob3JZIiwiYmFzZWxpbmUiLCJ6SW5kZXgiLCJoYXNCR0ltYWdlIiwiU1ZHTGFiZWwucHJvdG90eXBlLmFsaWduU2V0dGVyIiwiU1ZHTGFiZWwucHJvdG90eXBlLmFuY2hvclhTZXR0ZXIiLCJTVkdMYWJlbC5wcm90b3R5cGUuYW5jaG9yWVNldHRlciIsIlNWR0xhYmVsLnByb3RvdHlwZS5ib3hBdHRyIiwiU1ZHTGFiZWwucHJvdG90eXBlLmNzcyIsInRleHRTdHlsZXMiLCJpc1dpZHRoIiwiU1ZHTGFiZWwucHJvdG90eXBlLmRlc3Ryb3kiLCJTVkdMYWJlbC5wcm90b3R5cGUuZmlsbFNldHRlciIsIlNWR0xhYmVsLnByb3RvdHlwZS5nZXRCQm94IiwicGFkZGluZ0xlZnQiLCJTVkdMYWJlbC5wcm90b3R5cGUuZ2V0Q3Jpc3BBZGp1c3QiLCJTVkdMYWJlbC5wcm90b3R5cGUuaGVpZ2h0U2V0dGVyIiwiU1ZHTGFiZWwucHJvdG90eXBlLm9uIiwibGFiZWwiLCJ0ZXh0Iiwic3BhbiIsInNlbGVjdGl2ZUhhbmRsZXIiLCJTVkdMYWJlbC5wcm90b3R5cGUub25BZGQiLCJTVkdMYWJlbC5wcm90b3R5cGUuclNldHRlciIsIlNWR0xhYmVsLnByb3RvdHlwZS5zaGFkb3ciLCJTVkdMYWJlbC5wcm90b3R5cGUuc3Ryb2tlU2V0dGVyIiwiU1ZHTGFiZWwucHJvdG90eXBlLnRleHRTZXR0ZXIiLCJTVkdMYWJlbC5wcm90b3R5cGUudXBkYXRlQm94U2l6ZSIsInRleHRBbGlnbiIsImNyaXNwQWRqdXN0IiwiU1ZHTGFiZWwucHJvdG90eXBlLnVwZGF0ZVRleHRQYWRkaW5nIiwidGV4dFkiLCJ0ZXh0WCIsIlNWR0xhYmVsLnByb3RvdHlwZS53aWR0aFNldHRlciIsIlNWR0xhYmVsLnByb3RvdHlwZS5nZXRQYWRkZWRXaWR0aCIsInBhZGRpbmdSaWdodCIsIlNWR0xhYmVsLnByb3RvdHlwZS54U2V0dGVyIiwiU1ZHTGFiZWwucHJvdG90eXBlLnlTZXR0ZXIiLCJUZXh0QnVpbGRlciIsIlRleHRCdWlsZGVyLnByb3RvdHlwZS5idWlsZFNWRyIsImhhc01hcmt1cCIsInRlbXBQYXJlbnQiLCJyZWdleE1hdGNoQnJlYWtzIiwidGV4dENhY2hlIiwibm9XcmFwIiwiVGV4dEJ1aWxkZXIucHJvdG90eXBlLm1vZGlmeURPTSIsIm1vZGlmeVRleHROb2RlIiwid29yZHMiLCJoYXNXaGl0ZVNwYWNlIiwibGluZU5vIiwic3RhcnRBdCIsImxpbmVzIiwicHJlY2VkaW5nU2libGluZ3MiLCJwYXJlbnRFbGVtZW50IiwibW9kaWZ5Q2hpbGRyZW4iLCJUZXh0QnVpbGRlci5wcm90b3R5cGUuZ2V0TGluZUhlaWdodCIsImZvbnRTaXplU3R5bGUiLCJUZXh0QnVpbGRlci5wcm90b3R5cGUubW9kaWZ5VHJlZSIsIm1vZGlmeUNoaWxkIiwic3R5bGVkTW9kZSIsIm5leHROb2RlIiwiY2hpbGRyZW4iLCJUZXh0QnVpbGRlci5wcm90b3R5cGUudHJ1bmNhdGUiLCJsZW5ndGhzIiwibWluSW5kZXgiLCJtYXhJbmRleCIsImN1cnJlbnRJbmRleCIsImdldFN1YlN0cmluZ0xlbmd0aCIsImNvbmNhdGVuYXRlZEVuZCIsImNoYXJFbmQiLCJnZXRTdHJpbmciLCJhY3R1YWxXaWR0aCIsIlRleHRCdWlsZGVyLnByb3RvdHlwZS51bmVzY2FwZUVudGl0aWVzIiwiZXhjZXB0IiwiaW5wdXRTdHIiLCJTVkdSZW5kZXJlciIsIlNWR1JlbmRlcmVyLnByb3RvdHlwZS5pbml0IiwiYm94V3JhcHBlciIsImNvbnRhaW5lciIsImRlZnMiLCJhbGxvd0hUTUwiLCJmb3JFeHBvcnQiLCJpbWdDb3VudCIsInNldFNpemUiLCJzdWJQaXhlbEZpeCIsIlNWR1JlbmRlcmVyLnByb3RvdHlwZS5kZWZpbml0aW9uIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmdldFJlZmVyZW5jZVVSTCIsInBvc2l0aW9uIiwiaGl0RWxlbWVudCIsImhhc0ludGVybmFsUmVmZXJlbmNlQnVnIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmdldFN0eWxlIiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLnNldFN0eWxlIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmlzSGlkZGVuIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmRlc3Ryb3kiLCJyZW5kZXJlckRlZnMiLCJ1blN1YlBpeGVsRml4IiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQiLCJTVkdSZW5kZXJlci5wcm90b3R5cGUuZ2V0UmFkaWFsQXR0ciIsImN4IiwiY3kiLCJyIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkVGV4dCIsImJ1aWxkU1ZHIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmdldENvbnRyYXN0IiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmJ1dHRvbiIsImN1clN0YXRlIiwibm9ybWFsU3RhdGUiLCJ0aGVtZSIsInVzZXJOb3JtYWxTdHlsZSIsImN1cnNvciIsImZvbnRXZWlnaHQiLCJob3ZlclN0YXRlIiwicHJlc3NlZFN0YXRlIiwiZGlzYWJsZWRTdGF0ZSIsImxhYmVsLnNldFN0YXRlIiwic3RhdGUiLCJTVkdSZW5kZXJlci5wcm90b3R5cGUuY3Jpc3BMaW5lIiwicm91bmRpbmdGdW5jdGlvbiIsInBvaW50cyIsIlNWR1JlbmRlcmVyLnByb3RvdHlwZS5wYXRoIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNpcmNsZSIsIndyYXBwZXIueVNldHRlciIsIlNWR1JlbmRlcmVyLnByb3RvdHlwZS5hcmMiLCJpbm5lclIiLCJhcmMiLCJTVkdSZW5kZXJlci5wcm90b3R5cGUucmVjdCIsIndyYXBwZXIuclNldHRlciIsInJ4IiwicnkiLCJ3cmFwcGVyLnJHZXR0ZXIiLCJTVkdSZW5kZXJlci5wcm90b3R5cGUuc2V0U2l6ZSIsInZpZXdCb3giLCJTVkdSZW5kZXJlci5wcm90b3R5cGUuZyIsIlNWR1JlbmRlcmVyLnByb3RvdHlwZS5pbWFnZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJzZXRTVkdJbWFnZVNvdXJjZSIsIm9uRHVtbXlMb2FkIiwib25sb2FkIiwic3JjIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLnN5bWJvbCIsInJlbiIsImltYWdlUmVnZXgiLCJpc0ltYWdlIiwic3ltIiwic3ltYm9sRm4iLCJzeW1ib2xOYW1lIiwic3ltYm9sIiwiY2VudGVySW1hZ2UiLCJpbWdTaXplIiwidHJhbnMiLCJTVkdSZW5kZXJlci5wcm90b3R5cGUuY2xpcFJlY3QiLCJjbGlwUGF0aCIsIlNWR1JlbmRlcmVyLnByb3RvdHlwZS50ZXh0IiwidXNlSFRNTCIsIndyYXBwZXIueFNldHRlciIsInRzcGFucyIsInBhcmVudFZhbCIsInRzcGFuIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmZvbnRNZXRyaWNzIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImxpbmVIZWlnaHQiLCJoIiwiZiIsIlNWR1JlbmRlcmVyLnByb3RvdHlwZS5yb3RDb3JyIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLnBhdGhUb1NlZ21lbnRzIiwiY29tbWFuZExlbmd0aCIsIkMiLCJMIiwiTSIsIlEiLCJTIiwiVCIsIlYiLCJwdXNoIiwiU1ZHUmVuZGVyZXIucHJvdG90eXBlLmxhYmVsIiwiY2lyY2xlIiwidyIsIm9wZW4iLCJzcXVhcmUiLCJ0cmlhbmdsZSIsInRyaWFuZ2xlLWRvd24iLCJkaWFtb25kIiwiZnVsbENpcmNsZSIsInByb3hpbWl0eSIsImlubmVyUmFkaXVzIiwiY29zU3RhcnQiLCJzaW5TdGFydCIsImNvc0VuZCIsInNpbkVuZCIsImxvbmdBcmMiLCJjYWxsb3V0Iiwic2FmZURpc3RhbmNlIiwiaGFsZkRpc3RhbmNlIiwiYXJyb3dMZW5ndGgiLCJwcm90b3R5cGUiLCJodG1sQ3NzIiwiaXNTZXR0aW5nV2lkdGgiLCJkb1RyYW5zZm9ybSIsImh0bWxVcGRhdGVUcmFuc2Zvcm0iLCJhbGlnbkNvcnJlY3Rpb24iLCJ3aGl0ZVNwYWNlIiwibWFyZ2luTGVmdCIsIm1hcmdpblRvcCIsImN1cnJlbnRUZXh0VHJhbnNmb3JtIiwib2xkVGV4dFdpZHRoIiwib2xkUm90YXRpb24iLCJvbGRBbGlnbiIsInNldFNwYW5Sb3RhdGlvbiIsImNUVCIsInJvdGF0aW9uU3R5bGUiLCJjc3NUcmFuc2Zvcm1LZXkiLCJnZXRTcGFuQ29ycmVjdGlvbiIsImdldFRyYW5zZm9ybUtleSIsImFkZFNldHRlcnMiLCJnV3JhcHBlciIsInN0eWxlT2JqZWN0Iiwid3JhcHBlci50ZXh0U2V0dGVyIiwid3JhcHBlci5yb3RhdGlvblNldHRlciIsIndyYXBwZXIuYWZ0ZXJTZXR0ZXJzIiwid3JhcHBlci5hZGQiLCJwYXJlbnRzIiwic3ZnR3JvdXBXcmFwcGVyIiwidHJhbnNsYXRlU2V0dGVyIiwiaHRtbEdyb3VwU3R5bGUiLCJjbHMiLCJwYXJlbnRHcm91cFN0eWxlcyIsImh0bWxHcm91cCIsInBvaW50ZXJFdmVudHMiLCJjbGFzc1NldHRlciIsIm9uIiwidHJhbnNsYXRlWFNldHRlciIsInRyYW5zbGF0ZVlTZXR0ZXIiLCJUaW1lIiwiVGltZS5wcm90b3R5cGUuZ2V0IiwicmVhbE1zIiwiZGF0ZSIsIm1zIiwiVGltZS5wcm90b3R5cGUuc2V0IiwibmV3T2Zmc2V0IiwiVGltZS5wcm90b3R5cGUudXBkYXRlIiwidXNlVVRDIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJ0aW1lem9uZSIsIlRpbWUucHJvdG90eXBlLm1ha2VUaW1lIiwiZ2V0VGltZSIsIlRpbWUucHJvdG90eXBlLnRpbWV6b25lT2Zmc2V0RnVuY3Rpb24iLCJtb21lbnQiLCJ0aW1lc3RhbXAiLCJUaW1lLnByb3RvdHlwZS5kYXRlRm9ybWF0IiwiaG91cnMiLCJkYXlPZk1vbnRoIiwiZnVsbFllYXIiLCJsYW5nV2Vla2RheXMiLCJzaG9ydFdlZWtkYXlzIiwicmVwbGFjZW1lbnRzIiwiQiIsIm0iLCJvIiwiWSIsImsiLCJJIiwibCIsIlAiLCJjYXBpdGFsaXplIiwiVGltZS5wcm90b3R5cGUucmVzb2x2ZURUTEZvcm1hdCIsIm1haW4iLCJUaW1lLnByb3RvdHlwZS5nZXRUaW1lVGlja3MiLCJ0aWNrUG9zaXRpb25zIiwiaGlnaGVyUmFua3MiLCJtaW5EYXRlIiwibm9ybWFsaXplZEludGVydmFsIiwiY291bnQiLCJ2YXJpYWJsZURheUxlbmd0aCIsInN0YXJ0T2ZXZWVrIiwibWluWWVhciIsIm1pbkRheSIsIm1pbk1vbnRoIiwibWluRGF0ZURhdGUiLCJtaW5Ib3VycyIsInZhcmlhYmxlVGltZXpvbmUiLCJ0b3RhbFJhbmdlIiwic3ltYm9scyIsImxvYWRpbmciLCJtb250aHMiLCJzaG9ydE1vbnRocyIsIndlZWtkYXlzIiwibnVtZXJpY1N5bWJvbHMiLCJyZXNldFpvb20iLCJyZXNldFpvb21UaXRsZSIsImdsb2JhbCIsInRpbWV6b25lT2Zmc2V0IiwiYm9yZGVyUmFkaXVzIiwiY29sb3JDb3VudCIsImRlZmF1bHRTZXJpZXNUeXBlIiwiaWdub3JlSGlkZGVuU2VyaWVzIiwic3BhY2luZyIsInJlc2V0Wm9vbUJ1dHRvbiIsInpvb21CeVNpbmdsZVRvdWNoIiwiYm9yZGVyQ29sb3IiLCJwbG90Qm9yZGVyQ29sb3IiLCJ0aXRsZSIsIndpZHRoQWRqdXN0Iiwic3VidGl0bGUiLCJjYXB0aW9uIiwidmVydGljYWxBbGlnbiIsInBsb3RPcHRpb25zIiwibGFiZWxzIiwibGVnZW5kIiwiYWxpZ25Db2x1bW5zIiwibGF5b3V0IiwibGFiZWxGb3JtYXR0ZXIiLCJuYXZpZ2F0aW9uIiwiYWN0aXZlQ29sb3IiLCJpbmFjdGl2ZUNvbG9yIiwiaXRlbVN0eWxlIiwidGV4dE92ZXJmbG93IiwiaXRlbUhvdmVyU3R5bGUiLCJpdGVtSGlkZGVuU3R5bGUiLCJpdGVtQ2hlY2tib3hTdHlsZSIsInNxdWFyZVN5bWJvbCIsInN5bWJvbFBhZGRpbmciLCJsYWJlbFN0eWxlIiwidG9vbHRpcCIsImRhdGVUaW1lTGFiZWxGb3JtYXRzIiwiZm9vdGVyRm9ybWF0Iiwic25hcCIsImhlYWRlckZvcm1hdCIsInBvaW50Rm9ybWF0IiwiYm9yZGVyV2lkdGgiLCJjcmVkaXRzIiwiaHJlZiIsIkguZGF0ZUZvcm1hdCIsIm9wdGlvbnNNb2R1bGUiLCJkYXRlRm9ybWF0IiwiZGVmYXVsdE9wdGlvbnMiLCJUaWNrIiwiYXhpcyIsInBhcmFtZXRlcnMiLCJUaWNrLnByb3RvdHlwZS5hZGRMYWJlbCIsInRpY2siLCJjYXRlZ29yaWVzIiwibG9nIiwibmFtZXMiLCJsYWJlbE9wdGlvbnMiLCJpc0ZpcnN0IiwiaXNMYXN0IiwiYW5pbWF0ZUxhYmVscyIsInRpY2tQb3NpdGlvbkluZm8iLCJsaXN0IiwiZGF0ZVRpbWVMYWJlbEZvcm1hdCIsInRpY2suc2hvcnRlbkxhYmVsIiwiVGljay5wcm90b3R5cGUuY3JlYXRlTGFiZWwiLCJ4eSIsIlRpY2sucHJvdG90eXBlLmRlc3Ryb3kiLCJUaWNrLnByb3RvdHlwZS5nZXRQb3NpdGlvbiIsImNIZWlnaHQiLCJvbGQiLCJob3JpeiIsInRpY2tQb3MiLCJUaWNrLnByb3RvdHlwZS5nZXRMYWJlbFBvc2l0aW9uIiwidHJhbnNBIiwicmV2ZXJzZWQiLCJzdGFnZ2VyTGluZXMiLCJyb3RDb3JyIiwieU9mZnNldCIsImxhYmVsT2Zmc2V0Q29ycmVjdGlvbiIsInRpY2ttYXJrT2Zmc2V0IiwibGluZSIsIlRpY2sucHJvdG90eXBlLmdldExhYmVsU2l6ZSIsIlRpY2sucHJvdG90eXBlLmdldE1hcmtQYXRoIiwiVGljay5wcm90b3R5cGUuaGFuZGxlT3ZlcmZsb3ciLCJweFBvcyIsImNoYXJ0V2lkdGgiLCJsZWZ0Qm91bmQiLCJyaWdodEJvdW5kIiwiZmFjdG9yIiwibGFiZWxXaWR0aCIsInNsb3RXaWR0aCIsIm1vZGlmaWVkU2xvdFdpZHRoIiwiZ29SaWdodCIsInJpZ2h0UG9zIiwiVGljay5wcm90b3R5cGUubW92ZUxhYmVsIiwibW92ZWQiLCJjdXJyZW50VGljayIsInhQb3MiLCJsYWJlbFBvcyIsInlQb3MiLCJUaWNrLnByb3RvdHlwZS5yZW5kZXIiLCJnZXRQb3NpdGlvbiIsInJldmVyc2VDcmlzcCIsInJlbmRlckdyaWRMaW5lIiwiaXNOZXciLCJUaWNrLnByb3RvdHlwZS5yZW5kZXJHcmlkTGluZSIsImdyaWRMaW5lIiwiZ3JpZFByZWZpeCIsImdyaWRMaW5lV2lkdGgiLCJncmlkTGluZUNvbG9yIiwiZGFzaFN0eWxlIiwiZ3JpZExpbmVQYXRoIiwibGluZVdpZHRoIiwiZm9yY2UiLCJUaWNrLnByb3RvdHlwZS5yZW5kZXJNYXJrIiwidGlja1ByZWZpeCIsInRpY2tTaXplIiwibWFyayIsImlzTmV3TWFyayIsInRpY2tXaWR0aCIsInRpY2tDb2xvciIsImdldE1hcmtQYXRoIiwiVGljay5wcm90b3R5cGUucmVuZGVyTGFiZWwiLCJzaG93IiwiZ2V0TGFiZWxQb3NpdGlvbiIsImhhbmRsZU92ZXJmbG93IiwiaXNOZXdMYWJlbCIsIlRpY2sucHJvdG90eXBlLnJlcGxhY2VNb3ZlZExhYmVsIiwibW92ZWRMYWJlbCIsIk8iLCJBeGlzIiwiQXhpcy5wcm90b3R5cGUuaW5pdCIsImlzWEF4aXMiLCJ1c2VyT3B0aW9ucyIsIkF4aXMucHJvdG90eXBlLnNldE9wdGlvbnMiLCJBeGlzLnByb3RvdHlwZS5kZWZhdWx0TGFiZWxGb3JtYXR0ZXIiLCJudW1TeW1NYWduaXR1ZGUiLCJmb3JtYXRPcHRpb24iLCJudW1lcmljU3ltYm9sRGV0ZWN0b3IiLCJtdWx0aSIsIkF4aXMucHJvdG90eXBlLmdldFNlcmllc0V4dHJlbWVzIiwieEV4dHJlbWVzIiwic2VyaWVzT3B0aW9ucyIsInRocmVzaG9sZCIsInhEYXRhIiwic2VyaWVzRGF0YU1pbiIsImRhdGFFeHRyZW1lcyIsInNlcmllc0RhdGFNYXgiLCJBeGlzLnByb3RvdHlwZS50cmFuc2xhdGUiLCJzaWduIiwiY3ZzT2Zmc2V0IiwibG9jYWxBIiwibG9jYWxNaW4iLCJtaW5QaXhlbFBhZGRpbmciLCJkb1Bvc3RUcmFuc2xhdGUiLCJjdnNDb29yZCIsImJhY2t3YXJkcyIsInJldHVyblZhbHVlIiwiQXhpcy5wcm90b3R5cGUudG9QaXhlbHMiLCJwYW5lQ29vcmRpbmF0ZXMiLCJBeGlzLnByb3RvdHlwZS50b1ZhbHVlIiwicGl4ZWwiLCJBeGlzLnByb3RvdHlwZS5nZXRQbG90TGluZVBhdGgiLCJiZXR3ZWVuIiwic2tpcCIsImF4aXNMZWZ0IiwiYXhpc1RvcCIsInRyYW5zbGF0ZWRWYWx1ZSIsImNXaWR0aCIsInRyYW5zQiIsImV2dCIsImFjcm9zc1BhbmVzIiwiQXhpcy5wcm90b3R5cGUuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyIsInJvdW5kZWRNaW4iLCJyb3VuZGVkTWF4IiwicHJlY2lzaW9uIiwiQXhpcy5wcm90b3R5cGUuZ2V0TWlub3JUaWNrSW50ZXJ2YWwiLCJBeGlzLnByb3RvdHlwZS5nZXRNaW5vclRpY2tQb3NpdGlvbnMiLCJtaW5vclRpY2tJbnRlcnZhbCIsIm1pbm9yVGlja1Bvc2l0aW9ucyIsInBvaW50UmFuZ2VQYWRkaW5nIiwicmFuZ2UiLCJsb2dhcml0aG1pY18xIiwibG9nYXJpdGhtaWMiLCJwYWRkZWRUaWNrcyIsImdldFRpbWVUaWNrcyIsImRhdGVUaW1lIiwidHJpbVRpY2tzIiwiQXhpcy5wcm90b3R5cGUuYWRqdXN0Rm9yTWluUmFuZ2UiLCJjbG9zZXN0RGF0YVJhbmdlIiwibG9vcExlbmd0aCIsImRpc3RhbmNlIiwibWluUmFuZ2UiLCJtaW5BcmdzIiwic3BhY2VBdmFpbGFibGUiLCJtYXhBcmdzIiwiQXhpcy5wcm90b3R5cGUuZ2V0Q2xvc2VzdCIsInNlcmllc0Nsb3Nlc3QiLCJ2aXNpYmxlIiwiQXhpcy5wcm90b3R5cGUubmFtZVRvWCIsImV4cGxpY2l0Q2F0ZWdvcmllcyIsIm5hbWVYIiwicG9pbnQiLCJBeGlzLnByb3RvdHlwZS51cGRhdGVOYW1lcyIsIkF4aXMucHJvdG90eXBlLnNldEF4aXNUcmFuc2xhdGlvbiIsInBvaW50UmFuZ2UiLCJtaW5Qb2ludE9mZnNldCIsImxpbmtlZFBhcmVudCIsImhhc0NhdGVnb3JpZXMiLCJzZXJpZXNQb2ludFJhbmdlIiwicG9pbnRQbGFjZW1lbnQiLCJpc1BvaW50UGxhY2VtZW50QXhpcyIsIm9yZGluYWxDb3JyZWN0aW9uIiwiQXhpcy5wcm90b3R5cGUubWluRnJvbVJhbmdlIiwiQXhpcy5wcm90b3R5cGUuc2V0VGlja0ludGVydmFsIiwiaXNMaW5rZWQiLCJtYXhQYWRkaW5nIiwibWluUGFkZGluZyIsInRpY2tJbnRlcnZhbE9wdGlvbiIsInRpY2tQaXhlbEludGVydmFsT3B0aW9uIiwic29mdFRocmVzaG9sZCIsImxpbmtlZFBhcmVudEV4dHJlbWVzIiwidGhyZXNob2xkTWluIiwic2Vjb25kUGFzcyIsImhhcmRNaW4iLCJoYXJkTWF4IiwiX2IiLCJtaW5UaWNrSW50ZXJ2YWwiLCJzIiwiQXhpcy5wcm90b3R5cGUuc2V0VGlja1Bvc2l0aW9ucyIsInRpY2tQb3NpdGlvbnNPcHRpb24iLCJtaW5vclRpY2tJbnRlcnZhbE9wdGlvbiIsInRpY2tQb3NpdGlvbmVyIiwiaGFzVmVydGljYWxQYW5uaW5nIiwiaXNDb2xvckF4aXMiLCJzdGFydE9uVGljayIsImVuZE9uVGljayIsIm9yZGluYWwiLCJBeGlzLnByb3RvdHlwZS50cmltVGlja3MiLCJBeGlzLnByb3RvdHlwZS5hbGlnblRvT3RoZXJzIiwib3RoZXJzIiwib3RoZXJPcHRpb25zIiwiaGFzT3RoZXIiLCJBeGlzLnByb3RvdHlwZS5nZXRUaWNrQW1vdW50IiwidGlja0Ftb3VudCIsInRpY2tQaXhlbEludGVydmFsIiwiQXhpcy5wcm90b3R5cGUuYWRqdXN0VGlja0Ftb3VudCIsImF4aXNPcHRpb25zIiwidGlja0ludGVydmFsIiwiZmluYWxUaWNrQW10IiwiY3VycmVudFRpY2tBbW91bnQiLCJBeGlzLnByb3RvdHlwZS5zZXRTY2FsZSIsImlzRGlydHlEYXRhIiwiaXNYQXhpc0RpcnR5Iiwic2V0QXhpc1NpemUiLCJpc0RpcnR5QXhpc0xlbmd0aCIsIl9jIiwic3RhY2tpbmciLCJmb3JjZVJlZHJhdyIsImdldFNlcmllc0V4dHJlbWVzIiwic2V0VGlja0ludGVydmFsIiwiX2QiLCJfZSIsInBhbm5pbmdTdGF0ZSIsIkF4aXMucHJvdG90eXBlLnNldEV4dHJlbWVzIiwicmVkcmF3Iiwic2VyaWUiLCJuZXdNaW4iLCJuZXdNYXgiLCJBeGlzLnByb3RvdHlwZS56b29tIiwiZGF0YU1pbiIsImRhdGFNYXgiLCJ0cmlnZ2VyIiwiQXhpcy5wcm90b3R5cGUuc2V0QXhpc1NpemUiLCJvZmZzZXRzIiwiQXhpcy5wcm90b3R5cGUuZ2V0RXh0cmVtZXMiLCJ1c2VyTWluIiwidXNlck1heCIsIkF4aXMucHJvdG90eXBlLmdldFRocmVzaG9sZCIsInJlYWxNaW4iLCJyZWFsTWF4IiwidHJhbnNsYXRlIiwiQXhpcy5wcm90b3R5cGUuYXV0b0xhYmVsQWxpZ24iLCJhbmdsZSIsIkF4aXMucHJvdG90eXBlLnRpY2tTaXplIiwidGlja0xlbmd0aCIsInByZWZpeCIsIkF4aXMucHJvdG90eXBlLmxhYmVsTWV0cmljcyIsIkF4aXMucHJvdG90eXBlLnVuc3F1aXNoIiwibmV3VGlja0ludGVydmFsIiwic2xvdFNpemUiLCJyb3RhdGlvbk9wdGlvbiIsImxhYmVsTWV0cmljcyIsImJlc3RTY29yZSIsImdldFN0ZXAiLCJzcGFjZU5lZWRlZCIsImF1dG9Sb3RhdGlvbiIsInJvdCIsInNjb3JlIiwiQXhpcy5wcm90b3R5cGUuZ2V0U2xvdFdpZHRoIiwic2xvdENvdW50IiwiY3NzV2lkdGgiLCJBeGlzLnByb3RvdHlwZS5yZW5kZXJVbnNxdWlzaCIsInRpY2tzIiwibGFiZWxTdHlsZU9wdGlvbnMiLCJpbm5lcldpZHRoIiwidGV4dE92ZXJmbG93T3B0aW9uIiwibWF4TGFiZWxMZW5ndGgiLCJjb21tb25XaWR0aCIsImNvbW1vblRleHRPdmVyZmxvdyIsIndpZHRoT3B0aW9uIiwiQXhpcy5wcm90b3R5cGUuaGFzRGF0YSIsIkF4aXMucHJvdG90eXBlLmFkZFRpdGxlIiwib3Bwb3NpdGUiLCJheGlzVGl0bGVPcHRpb25zIiwibG93IiwibWlkZGxlIiwiaGlnaCIsImF4aXNUaXRsZSIsIkF4aXMucHJvdG90eXBlLmdlbmVyYXRlVGljayIsIkF4aXMucHJvdG90eXBlLmdldE9mZnNldCIsInNpZGUiLCJpbnZlcnRlZFNpZGUiLCJ0aXRsZU9mZnNldCIsInRpdGxlTWFyZ2luIiwibGFiZWxPZmZzZXQiLCJheGlzT2Zmc2V0IiwiY2xpcE9mZnNldCIsImRpcmVjdGlvbkZhY3RvciIsImF4aXNQYXJlbnQiLCJzaG93QXhpcyIsImhhc0RhdGEiLCJjcmVhdGVHcm91cCIsImxpbmVIZWlnaHRDb3JyZWN0aW9uIiwibGFiZWxPZmZzZXRQYWRkZWQiLCJjbGlwIiwiQXhpcy5wcm90b3R5cGUuZ2V0TGluZVBhdGgiLCJsaW5lTGVmdCIsImxpbmVUb3AiLCJBeGlzLnByb3RvdHlwZS5yZW5kZXJMaW5lIiwiQXhpcy5wcm90b3R5cGUuZ2V0VGl0bGVQb3NpdGlvbiIsImF4aXNMZW5ndGgiLCJ4T3B0aW9uIiwieU9wdGlvbiIsImZvbnRNZXRyaWNzIiwidGV4dEhlaWdodE92ZXJzaG9vdCIsImFsb25nQXhpcyIsIm9mZkF4aXMiLCJ0aXRsZVBvc2l0aW9uIiwiQXhpcy5wcm90b3R5cGUucmVuZGVyTWlub3JUaWNrIiwic2xpZGVJblRpY2tzIiwibWlub3JUaWNrcyIsIkF4aXMucHJvdG90eXBlLnJlbmRlclRpY2siLCJBeGlzLnByb3RvdHlwZS5yZW5kZXIiLCJhbHRlcm5hdGVCYW5kcyIsInN0YWNrTGFiZWxPcHRpb25zIiwiYWx0ZXJuYXRlR3JpZENvbG9yIiwiYXhpc0xpbmUiLCJmb3JEZXN0cnVjdGlvbiIsImRlbGF5IiwiZGVzdHJveUluYWN0aXZlSXRlbXMiLCJjb2xsIiwidGl0bGVYeSIsIkF4aXMucHJvdG90eXBlLnJlZHJhdyIsInBsb3RMaW5lIiwiQXhpcy5wcm90b3R5cGUuZ2V0S2VlcFByb3BzIiwiQXhpcy5wcm90b3R5cGUuZGVzdHJveSIsInBsb3RMaW5lc0FuZEJhbmRzIiwicGxvdEdyb3VwIiwia2VlcEV2ZW50cyIsIkF4aXMucHJvdG90eXBlLmRyYXdDcm9zc2hhaXIiLCJncmFwaGljIiwiaXNDcm9zc2hhaXIiLCJjaGFydFgiLCJjaGFydFkiLCJjYXRlZ29yaXplZCIsImRhc2hzdHlsZSIsIkF4aXMucHJvdG90eXBlLmhpZGVDcm9zc2hhaXIiLCJBeGlzLnByb3RvdHlwZS5oYXNWZXJ0aWNhbFBhbm5pbmciLCJwYW5uaW5nT3B0aW9ucyIsIkF4aXMucHJvdG90eXBlLnZhbGlkYXRlUG9zaXRpdmVWYWx1ZSIsIkF4aXMucHJvdG90eXBlLnVwZGF0ZSIsIm5ld0V2ZW50cyIsIkF4aXMucHJvdG90eXBlLnJlbW92ZSIsImF4aXNTZXJpZXMiLCJBeGlzLnByb3RvdHlwZS5zZXRUaXRsZSIsIkF4aXMucHJvdG90eXBlLnNldENhdGVnb3JpZXMiLCJpbmRlbnRhdGlvbiIsIm1pbm9yVGlja0xlbmd0aCIsIm1pbm9yVGlja1Bvc2l0aW9uIiwic2hvd0VtcHR5IiwidGlja21hcmtQbGFjZW1lbnQiLCJ0aWNrUG9zaXRpb24iLCJtaW5vckdyaWRMaW5lQ29sb3IiLCJtaW5vckdyaWRMaW5lV2lkdGgiLCJtaW5vclRpY2tDb2xvciIsImxpbmVDb2xvciIsInNob3dMYXN0TGFiZWwiLCJzdGFja0xhYmVscyIsImFsbG93T3ZlcmxhcCIsImNyb3AiLCJvdmVyZmxvdyIsImZvcm1hdHRlciIsIkRhdGVUaW1lQXhpc0FkZGl0aW9ucyIsIkRhdGVUaW1lQXhpc0FkZGl0aW9ucy5wcm90b3R5cGUubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCIsInVuaXRzIiwidW5pdHNPcHRpb24iLCJ1bml0UmFuZ2UiLCJ1bml0TmFtZSIsIkRhdGVUaW1lQXhpcyIsIkRhdGVUaW1lQXhpcy5jb21wb3NlIiwiQXhpc0NsYXNzIiwiYXhpc1Byb3RvLmdldFRpbWVUaWNrcyIsIkxvZ2FyaXRobWljQXhpc0FkZGl0aW9ucyIsIkxvZ2FyaXRobWljQXhpc0FkZGl0aW9ucy5wcm90b3R5cGUuZ2V0TG9nVGlja1Bvc2l0aW9ucyIsInBvc2l0aW9ucyIsIm1pbm9yIiwiYnJlYWsyIiwiaW50ZXJtZWRpYXRlIiwibGluMmxvZyIsImxhc3RQb3MiLCJmaWx0ZXJlZFRpY2tJbnRlcnZhbE9wdGlvbiIsIkxvZ2FyaXRobWljQXhpc0FkZGl0aW9ucy5wcm90b3R5cGUubGluMmxvZyIsIkxvZ2FyaXRobWljQXhpc0FkZGl0aW9ucy5wcm90b3R5cGUubG9nMmxpbiIsIkxvZ2FyaXRobWljQXhpcyIsIkxvZ2FyaXRobWljQXhpcy5jb21wb3NlIiwibGluMnZhbCIsImF4aXMubGluMnZhbCIsImF4aXMudmFsMmxpbiIsIlBsb3RMaW5lT3JCYW5kIiwiUGxvdExpbmVPckJhbmQucHJvdG90eXBlLnJlbmRlciIsIm9wdGlvbnNMYWJlbCIsImlzQmFuZCIsImlzTGluZSIsInN2Z0VsZW0iLCJncm91cEF0dHJpYnMiLCJncm91cE5hbWUiLCJQbG90TGluZU9yQmFuZC5wcm90b3R5cGUucmVuZGVyTGFiZWwiLCJsYWJlbFRleHQiLCJ4Qm91bmRzIiwieUJvdW5kcyIsIlBsb3RMaW5lT3JCYW5kLnByb3RvdHlwZS5nZXRMYWJlbFRleHQiLCJQbG90TGluZU9yQmFuZC5wcm90b3R5cGUuZGVzdHJveSIsImdldFBsb3RCYW5kUGF0aCIsInRvUGF0aCIsInBsdXMiLCJvdXRzaWRlIiwicGF0aFN0YXJ0IiwicGF0aEVuZCIsInRvUGF0aFN0YXJ0IiwidG9QYXRoRW5kIiwiaXNGbGF0IiwiYWRkUGxvdEJhbmQiLCJhZGRQbG90TGluZSIsImFkZFBsb3RCYW5kT3JMaW5lIiwidXBkYXRlZE9wdGlvbnMiLCJyZW1vdmVQbG90QmFuZE9yTGluZSIsImZvckVhY2giLCJyZW1vdmVQbG90QmFuZCIsInJlbW92ZVBsb3RMaW5lIiwiVG9vbHRpcCIsIlRvb2x0aXAucHJvdG90eXBlLmFwcGx5RmlsdGVyIiwic3RkRGV2aWF0aW9uIiwiZHgiLCJzbG9wZSIsIlRvb2x0aXAucHJvdG90eXBlLmJvZHlGb3JtYXR0ZXIiLCJpdGVtcyIsInRvb2x0aXBPcHRpb25zIiwiVG9vbHRpcC5wcm90b3R5cGUuY2xlYW5TcGxpdCIsInR0IiwiVG9vbHRpcC5wcm90b3R5cGUuZGVmYXVsdEZvcm1hdHRlciIsIlRvb2x0aXAucHJvdG90eXBlLmRlc3Ryb3kiLCJUb29sdGlwLnByb3RvdHlwZS5nZXRBbmNob3IiLCJwb2ludGVyIiwicGxvdFRvcCIsInBsb3RMZWZ0IiwicGxvdFgiLCJwbG90WSIsInhBeGlzIiwibW91c2VFdmVudCIsInlBeGlzIiwiVG9vbHRpcC5wcm90b3R5cGUuZ2V0RGF0ZUZvcm1hdCIsImRhdGVTdHIiLCJzdHJwb3MiLCJsYXN0TiIsImJsYW5rIiwic3Vic3RyIiwiVG9vbHRpcC5wcm90b3R5cGUuZ2V0TGFiZWwiLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlTGVhdmUiLCJjaGFydFN0eWxlIiwibGFiZWxfMSIsInhTZXR0ZXJfMSIsInlTZXR0ZXJfMSIsImxhYmVsXzEueFNldHRlciIsImxhYmVsXzEueVNldHRlciIsIlRvb2x0aXAucHJvdG90eXBlLmdldFBvc2l0aW9uIiwib3V0ZXJXaWR0aCIsIm91dGVySGVpZ2h0IiwiY2hhcnRQb3NpdGlvbiIsImJ1aWxkRGltZW5zaW9uQXJyYXkiLCJpc1giLCJkaW0iLCJib3hXaWR0aCIsImJveEhlaWdodCIsImZpcnN0IiwicHJlZmVyRmFyU2lkZSIsImZpcnN0RGltZW5zaW9uIiwic2NhbGVkRGlzdCIsInNjYWxlRGlmZiIsImlubmVyU2l6ZSIsInJvb21MZWZ0Iiwic2NhbGVkSW5uZXJTaXplIiwicm9vbVJpZ2h0IiwiYWxpZ25lZExlZnQiLCJhbGlnbmVkUmlnaHQiLCJzZWNvbmREaW1lbnNpb24iLCJyZXRWYWwiLCJvdXRlclNpemUiLCJzd2FwIiwidGVtcCIsInN3YXBwZWQiLCJUb29sdGlwLnByb3RvdHlwZS5nZXRYRGF0ZUZvcm1hdCIsImNsb3Nlc3RQb2ludFJhbmdlIiwieERhdGVGb3JtYXQiLCJUb29sdGlwLnByb3RvdHlwZS5oaWRlIiwiVG9vbHRpcC5wcm90b3R5cGUuaW5pdCIsInNjcm9sbGFibGVQaXhlbHNYIiwic2Nyb2xsYWJsZVBpeGVsc1kiLCJUb29sdGlwLnByb3RvdHlwZS5pc1N0aWNreU9uQ29udGFjdCIsInN0aWNrT25Db250YWN0IiwiaW5Db250YWN0IiwiVG9vbHRpcC5wcm90b3R5cGUubW92ZSIsInNraXBBbmNob3IiLCJUb29sdGlwLnByb3RvdHlwZS5yZWZyZXNoIiwidGV4dENvbmZpZyIsInBvaW50Q29uZmlnIiwiZGVmYXVsdEZvcm1hdHRlciIsInNoYXJlZCIsImZvbGxvd1BvaW50ZXIiLCJnZXRBbmNob3IiLCJhbmNob3IiLCJjdXJyZW50U2VyaWVzIiwiZ2V0TGFiZWwiLCJuZWdhdGl2ZSIsInR0QmVsb3ciLCJpc0hpZGRlbiIsIlRvb2x0aXAucHJvdG90eXBlLnJlbmRlclNwbGl0IiwiZGVmYXVsdFBvc2l0aW9uZXIiLCJpc0hlYWRlciIsImhlYWRlclRvcCIsImFkanVzdGVkUGxvdEhlaWdodCIsImJvdW5kcyIsImRpc3RyaWJ1dGlvbkJveFRvcCIsInBsb3RIZWlnaHQiLCJzY3JvbGxMZWZ0Iiwic2Nyb2xsVG9wIiwicG9zaXRpb25lciIsImJvdHRvbSIsInRvb2x0aXBMYWJlbCIsImhlYWRlckhlaWdodCIsImJveGVzIiwiY29sb3JDbGFzcyIsImNvbG9ySW5kZXgiLCJzaXplIiwiYm94UG9zaXRpb24iLCJyYW5rIiwiVG9vbHRpcC5wcm90b3R5cGUuZHJhd1RyYWNrZXIiLCJ0cmFja2VyIiwiYW5jaG9yUG9zIiwibGFiZWxCQm94IiwiVG9vbHRpcC5wcm90b3R5cGUuc3R5bGVkTW9kZUZvcm1hdCIsImZvcm1hdFN0cmluZyIsIlRvb2x0aXAucHJvdG90eXBlLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIiLCJmb290T3JIZWFkIiwiaXNGb290ZXIiLCJsYWJlbENvbmZpZyIsImlzRGF0ZVRpbWUiLCJUb29sdGlwLnByb3RvdHlwZS51cGRhdGUiLCJUb29sdGlwLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiIsIlBvaW50ZXIiLCJ0aGlzLnVuYmluZENvbnRhaW5lck1vdXNlTGVhdmUiLCJ0aGlzLnVuYmluZENvbnRhaW5lck1vdXNlRW50ZXIiLCJQb2ludGVyLnByb3RvdHlwZS5hcHBseUluYWN0aXZlU3RhdGUiLCJhY3RpdmVTZXJpZXMiLCJpbmFjdGl2ZVNlcmllcyIsIlBvaW50ZXIucHJvdG90eXBlLmRlc3Ryb3kiLCJjbGVhckludGVydmFsIiwiUG9pbnRlci5wcm90b3R5cGUuZHJhZyIsImNoYXJ0T3B0aW9ucyIsInpvb21Ib3IiLCJ6b29tVmVydCIsInBsb3RXaWR0aCIsInNlbGVjdGlvbk1hcmtlciIsIm1vdXNlRG93blgiLCJtb3VzZURvd25ZIiwicGFubmluZ0VuYWJsZWQiLCJwYW5LZXkiLCJ0b3VjaCIsImNsaWNrZWRJbnNpZGUiLCJQb2ludGVyLnByb3RvdHlwZS5kcmFnU3RhcnQiLCJQb2ludGVyLnByb3RvdHlwZS5kcm9wIiwiaGFzUGluY2hlZCIsInNlbGVjdGlvbkRhdGEiLCJvcmlnaW5hbEV2ZW50Iiwic2VsZWN0aW9uQm94Iiwic2VsZWN0aW9uTGVmdCIsInNlbGVjdGlvblRvcCIsInNlbGVjdGlvbldpZHRoIiwic2VsZWN0aW9uSGVpZ2h0IiwicnVuWm9vbSIsInNlbGVjdGlvbk1pbiIsInNlbGVjdGlvbk1heCIsIlBvaW50ZXIucHJvdG90eXBlLmZpbmROZWFyZXN0S0RQb2ludCIsImhvdmVyUG9pbnQiLCJjbG9zZXN0IiwiY29tcGFyZVgiLCJpc0Nsb3NlclgiLCJkaXN0WCIsImlzQ2xvc2VyIiwiZGlzdCIsImlzQWJvdmUiLCJQb2ludGVyLnByb3RvdHlwZS5nZXRDaGFydENvb3JkaW5hdGVzRnJvbVBvaW50Iiwic2hhcGVBcmdzIiwiUG9pbnRlci5wcm90b3R5cGUuZ2V0Q2hhcnRQb3NpdGlvbiIsIm9mZnNldEhlaWdodCIsIlBvaW50ZXIucHJvdG90eXBlLmdldENvb3JkaW5hdGVzIiwiUG9pbnRlci5wcm90b3R5cGUuZ2V0SG92ZXJEYXRhIiwiaG92ZXJQb2ludHMiLCJ1c2VFeGlzdGluZyIsImlzRGlyZWN0VG91Y2giLCJleGlzdGluZ0hvdmVyUG9pbnQiLCJub3RTdGlja3kiLCJob3ZlclNlcmllcyIsImV2ZW50QXJncyIsInNlYXJjaFNlcmllcyIsImRpcmVjdFRvdWNoIiwiUG9pbnRlci5wcm90b3R5cGUuZ2V0UG9pbnRGcm9tRXZlbnQiLCJQb2ludGVyLnByb3RvdHlwZS5vblRyYWNrZXJNb3VzZU91dCIsInJlbGF0ZWRUYXJnZXQiLCJQb2ludGVyLnByb3RvdHlwZS5pbkNsYXNzIiwiZWxlbUNsYXNzTmFtZSIsIlBvaW50ZXIucHJvdG90eXBlLmluaXQiLCJQb2ludGVyLnByb3RvdHlwZS5ub3JtYWxpemUiLCJ0b3VjaGVzIiwiZVBvcyIsIlBvaW50ZXIucHJvdG90eXBlLm9uQ29udGFpbmVyQ2xpY2siLCJwRXZ0IiwiUG9pbnRlci5wcm90b3R5cGUub25Db250YWluZXJNb3VzZURvd24iLCJpc1ByaW1hcnlCdXR0b24iLCJQb2ludGVyLnByb3RvdHlwZS5vbkNvbnRhaW5lck1vdXNlTGVhdmUiLCJQb2ludGVyLnByb3RvdHlwZS5vbkNvbnRhaW5lck1vdXNlRW50ZXIiLCJQb2ludGVyLnByb3RvdHlwZS5vbkNvbnRhaW5lck1vdXNlTW92ZSIsIlBvaW50ZXIucHJvdG90eXBlLm9uRG9jdW1lbnRUb3VjaEVuZCIsIlBvaW50ZXIucHJvdG90eXBlLm9uQ29udGFpbmVyVG91Y2hNb3ZlIiwiUG9pbnRlci5wcm90b3R5cGUub25Db250YWluZXJUb3VjaFN0YXJ0IiwiUG9pbnRlci5wcm90b3R5cGUub25Eb2N1bWVudE1vdXNlTW92ZSIsIlBvaW50ZXIucHJvdG90eXBlLm9uRG9jdW1lbnRNb3VzZVVwIiwiUG9pbnRlci5wcm90b3R5cGUucGluY2giLCJwaW5jaERvd24iLCJ0b3VjaGVzTGVuZ3RoIiwibGFzdFZhbGlkVG91Y2giLCJoYXNab29tIiwiZmlyZUNsaWNrRXZlbnQiLCJhYnNNYXgiLCJkZXN0cm95IiwiUG9pbnRlci5wcm90b3R5cGUucGluY2hUcmFuc2xhdGUiLCJQb2ludGVyLnByb3RvdHlwZS5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbiIsIlhZIiwic0NoYXJ0WFkiLCJ3aCIsInBsb3RMZWZ0VG9wIiwic2NhbGUiLCJmb3JjZWRTY2FsZSIsInNpbmdsZVRvdWNoIiwidG91Y2gwU3RhcnQiLCJ0b3VjaDBOb3ciLCJ0b3VjaDFTdGFydCIsInRvdWNoMU5vdyIsInNldFNjYWxlIiwiY2xpcFhZIiwic2VsZWN0aW9uV0giLCJzZWxlY3Rpb25YWSIsIm91dE9mQm91bmRzIiwidHJhbnNmb3JtU2NhbGUiLCJQb2ludGVyLnByb3RvdHlwZS5yZXNldCIsInRvb2x0aXBQb2ludHMiLCJhbGxvd01vdmUiLCJob3ZlclgiLCJQb2ludGVyLnByb3RvdHlwZS5ydW5Qb2ludEFjdGlvbnMiLCJob3ZlckRhdGEiLCJ1c2VTaGFyZWRUb29sdGlwIiwiYXBwbHlJbmFjdGl2ZVN0YXRlIiwiZHJhd0F4aXNDcm9zc2hhaXIiLCJQb2ludGVyLnByb3RvdHlwZS5zY2FsZUdyb3VwcyIsInNlcmllc0F0dHJpYnMiLCJQb2ludGVyLnByb3RvdHlwZS5zZXRET01FdmVudHMiLCJvd25lckRvYyIsIm9uY2xpY2siLCJQb2ludGVyLnByb3RvdHlwZS5zZXRIb3ZlckNoYXJ0SW5kZXgiLCJob3ZlckNoYXJ0IiwiUG9pbnRlci5wcm90b3R5cGUudG91Y2giLCJQb2ludGVyLnByb3RvdHlwZS50b3VjaFNlbGVjdCIsIlBvaW50ZXIucHJvdG90eXBlLnpvb21PcHRpb24iLCJ6b29tVHlwZSIsInpvb21YIiwiem9vbVkiLCJnZXRXZWJraXRUb3VjaGVzIiwiZmFrZSIsImZha2UuaXRlbSIsInBhZ2VYIiwicGFnZVkiLCJ0cmFuc2xhdGVNU1BvaW50ZXIiLCJoYXNQb2ludGVyRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXIiLCJNU1BvaW50ZXIucHJvdG90eXBlLmJhdGNoTVNFdmVudHMiLCJNU1BvaW50ZXIucHJvdG90eXBlLmRlc3Ryb3kiLCJNU1BvaW50ZXIucHJvdG90eXBlLmluaXQiLCJNU1BvaW50ZXIucHJvdG90eXBlLm9uQ29udGFpbmVyUG9pbnRlckRvd24iLCJNU1BvaW50ZXIucHJvdG90eXBlLm9uQ29udGFpbmVyUG9pbnRlck1vdmUiLCJNU1BvaW50ZXIucHJvdG90eXBlLm9uRG9jdW1lbnRQb2ludGVyVXAiLCJNU1BvaW50ZXIucHJvdG90eXBlLnNldERPTUV2ZW50cyIsIlBvaW50IiwiUG9pbnQucHJvdG90eXBlLmFuaW1hdGVCZWZvcmVEZXN0cm95IiwiYW5pbWF0ZVBhcmFtcyIsImdyYXBoaWNhbFByb3BzIiwiaXNEYXRhTGFiZWwiLCJQb2ludC5wcm90b3R5cGUuYXBwbHlPcHRpb25zIiwicG9pbnRWYWxLZXkiLCJkYXRhTGFiZWxzIiwiZm9ybWF0UHJlZml4IiwiaXNOdWxsIiwiUG9pbnQucHJvdG90eXBlLmRlc3Ryb3kiLCJkZXN0cm95UG9pbnQiLCJkYXRhU29ydGluZyIsIlBvaW50LnByb3RvdHlwZS5kZXN0cm95RWxlbWVudHMiLCJwcm9wcyIsIlBvaW50LnByb3RvdHlwZS5maXJlUG9pbnRFdmVudCIsImV2ZW50IiwiUG9pbnQucHJvdG90eXBlLmdldENsYXNzTmFtZSIsInNlbGVjdGVkIiwiem9uZSIsIlBvaW50LnByb3RvdHlwZS5nZXRHcmFwaGljYWxQcm9wcyIsInNpbmd1bGFyIiwicGx1cmFsIiwia2luZHMiLCJkYXRhTGFiZWwiLCJQb2ludC5wcm90b3R5cGUuZ2V0TGFiZWxDb25maWciLCJwZXJjZW50YWdlIiwidG90YWwiLCJQb2ludC5wcm90b3R5cGUuZ2V0TmVzdGVkUHJvcGVydHkiLCJQb2ludC5wcm90b3R5cGUuZ2V0Wm9uZSIsInpvbmVzIiwiem9uZUF4aXMiLCJQb2ludC5wcm90b3R5cGUuaGFzTmV3U2hhcGVUeXBlIiwiUG9pbnQucHJvdG90eXBlLmluaXQiLCJQb2ludC5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0IiwicG9pbnRBcnJheU1hcCIsInZhbHVlQ291bnQiLCJmaXJzdEl0ZW1UeXBlIiwiUG9pbnQucHJvdG90eXBlLnJlc29sdmVDb2xvciIsIlBvaW50LnByb3RvdHlwZS5zZXROZXN0ZWRQcm9wZXJ0eSIsIlBvaW50LnByb3RvdHlwZS50b29sdGlwRm9ybWF0dGVyIiwic2VyaWVzVG9vbHRpcE9wdGlvbnMiLCJ2YWx1ZURlY2ltYWxzIiwidmFsdWVQcmVmaXgiLCJ2YWx1ZVN1ZmZpeCIsIlJlZ0V4cCIsIlBvaW50LnByb3RvdHlwZS51cGRhdGUiLCJoYXNEdW1teUdyYXBoaWMiLCJzaG91bGREZXN0cm95R3JhcGhpYyIsIlBvaW50LnByb3RvdHlwZS5yZW1vdmUiLCJQb2ludC5wcm90b3R5cGUuc2VsZWN0IiwiYWNjdW11bGF0ZSIsImxvb3BTZXJpZXMiLCJsb29wUG9pbnQiLCJQb2ludC5wcm90b3R5cGUub25Nb3VzZU92ZXIiLCJQb2ludC5wcm90b3R5cGUub25Nb3VzZU91dCIsImZpcmVQb2ludEV2ZW50IiwiUG9pbnQucHJvdG90eXBlLmltcG9ydEV2ZW50cyIsIlBvaW50LnByb3RvdHlwZS5zZXRTdGF0ZSIsInByZXZpb3VzU3RhdGUiLCJzdGF0ZU9wdGlvbnMiLCJtYXJrZXJPcHRpb25zIiwibm9ybWFsRGlzYWJsZWQiLCJtYXJrZXJTdGF0ZU9wdGlvbnMiLCJzdGF0ZURpc2FibGVkIiwic3RhdGVNYXJrZXJHcmFwaGljIiwicG9pbnRNYXJrZXIiLCJoYWxvIiwiaGFzTWFya2VycyIsIm1hcmtlckF0dHJpYnMiLCJwb2ludEF0dHJpYnMiLCJuZXdTeW1ib2wiLCJtb3ZlIiwiaGFsb09wdGlvbnMiLCJtYXJrZXJWaXNpYmlsaXR5IiwibWFya2VyR3JhcGhpYyIsImhhbG9QYXRoIiwiUG9pbnQucHJvdG90eXBlLmhhbG9QYXRoIiwiTGVnZW5kIiwiTGVnZW5kLnByb3RvdHlwZS5pbml0IiwiTGVnZW5kLnByb3RvdHlwZS5zZXRPcHRpb25zIiwiTGVnZW5kLnByb3RvdHlwZS51cGRhdGUiLCJpc0RpcnR5TGVnZW5kIiwiTGVnZW5kLnByb3RvdHlwZS5jb2xvcml6ZUl0ZW0iLCJsZWdlbmRJdGVtIiwibGVnZW5kTGluZSIsImxlZ2VuZFN5bWJvbCIsImhpZGRlbkNvbG9yIiwidGV4dENvbG9yIiwic3ltYm9sQ29sb3IiLCJzeW1ib2xBdHRyIiwiTGVnZW5kLnByb3RvdHlwZS5wb3NpdGlvbkl0ZW1zIiwiTGVnZW5kLnByb3RvdHlwZS5wb3NpdGlvbkl0ZW0iLCJsdHIiLCJsZWdlbmRJdGVtUG9zIiwiaXRlbVgiLCJpdGVtWSIsImNoZWNrYm94IiwibGVnZW5kR3JvdXAiLCJMZWdlbmQucHJvdG90eXBlLmRlc3Ryb3lJdGVtIiwiTGVnZW5kLnByb3RvdHlwZS5kZXN0cm95IiwiZGVzdHJveUl0ZW1zIiwiTGVnZW5kLnByb3RvdHlwZS5wb3NpdGlvbkNoZWNrYm94ZXMiLCJhbGlnbkF0dHIiLCJjbGlwSGVpZ2h0IiwidGl0bGVIZWlnaHQiLCJMZWdlbmQucHJvdG90eXBlLnJlbmRlclRpdGxlIiwidGl0bGVPcHRpb25zIiwiTGVnZW5kLnByb3RvdHlwZS5zZXRUZXh0IiwiTGVnZW5kLnByb3RvdHlwZS5yZW5kZXJJdGVtIiwic3ltYm9sV2lkdGgiLCJpdGVtRGlzdGFuY2UiLCJsaSIsImlzU2VyaWVzIiwic2hvd0NoZWNrYm94IiwiaXRlbUV4dHJhV2lkdGgiLCJpdGVtQ2xhc3NOYW1lIiwiaXRlbU1hcmdpblRvcCIsInN5bWJvbEhlaWdodCIsInNldEl0ZW1FdmVudHMiLCJjcmVhdGVDaGVja2JveEZvckl0ZW0iLCJjb2xvcml6ZUl0ZW0iLCJzZXRUZXh0IiwibWF4SXRlbVdpZHRoIiwidG90YWxJdGVtV2lkdGgiLCJpdGVtSGVpZ2h0IiwiTGVnZW5kLnByb3RvdHlwZS5sYXlvdXRJdGVtIiwiaG9yaXpvbnRhbCIsIml0ZW1NYXJnaW5Cb3R0b20iLCJtYXhMZWdlbmRXaWR0aCIsIml0ZW1XaWR0aCIsIkxlZ2VuZC5wcm90b3R5cGUuZ2V0QWxsSXRlbXMiLCJhbGxJdGVtcyIsIkxlZ2VuZC5wcm90b3R5cGUuZ2V0QWxpZ25tZW50IiwiTGVnZW5kLnByb3RvdHlwZS5hZGp1c3RNYXJnaW5zIiwiYWxpZ25tZW50IiwiYWxpZ25tZW50cyIsIkxlZ2VuZC5wcm90b3R5cGUucHJveGltYXRlUG9zaXRpb25zIiwiYWxpZ25MZWZ0IiwibGFzdFBvaW50IiwidXNlRmlyc3RQb2ludCIsIkxlZ2VuZC5wcm90b3R5cGUucmVuZGVyIiwibGFzdEl0ZW1ZIiwiZ2V0QWxpZ25tZW50IiwiYWxsb3dlZFdpZHRoIiwiY29udGVudEdyb3VwIiwicmVuZGVyVGl0bGUiLCJnZXRBbGxJdGVtcyIsImxhc3RMaW5lSGVpZ2h0IiwibGVnZW5kV2lkdGgiLCJsZWdlbmRIZWlnaHQiLCJMZWdlbmQucHJvdG90eXBlLmFsaWduIiwiTGVnZW5kLnByb3RvdHlwZS5oYW5kbGVPdmVyZmxvdyIsIm9wdGlvbnNZIiwic3BhY2VIZWlnaHQiLCJtYXhIZWlnaHQiLCJuYXZPcHRpb25zIiwiYXJyb3dTaXplIiwibmF2IiwicGFnZXMiLCJjbGlwVG9IZWlnaHQiLCJhZGRUcmFja2VyIiwibGFzdFkiLCJMZWdlbmQucHJvdG90eXBlLnNjcm9sbCIsInBhZ2VDb3VudCIsImN1cnJlbnRQYWdlIiwic2Nyb2xsQnkiLCJwYWdlciIsIkxlZ2VuZC5wcm90b3R5cGUuc2V0SXRlbUV2ZW50cyIsImlzUG9pbnQiLCJhY3RpdmVDbGFzcyIsImluYWN0aXZlSXRlbSIsImZuTGVnZW5kSXRlbUNsaWNrIiwiYnJvd3NlckV2ZW50Iiwic3RyTGVnZW5kSXRlbUNsaWNrIiwiTGVnZW5kLnByb3RvdHlwZS5jcmVhdGVDaGVja2JveEZvckl0ZW0iLCJjaGVja2VkIiwiZGVmYXVsdENoZWNrZWQiLCJydW5Qb3NpdGlvbkl0ZW0iLCJTZXJpZXNSZWdpc3RyeSIsInJlZ2lzdGVyU2VyaWVzVHlwZSIsImRlZmF1bHRQbG90T3B0aW9ucyIsInNlcmllc0NsYXNzIiwic2VyaWVzVHlwZSIsImdldFNlcmllcyIsIm9wdGlvbnNDaGFydCIsIlNlcmllc0NsYXNzIiwibWlzc2luZ01vZHVsZUZvciIsInBvaW50UHJvdG8iLCJDaGFydCIsIkNoYXJ0LnByb3RvdHlwZS5nZXRBcmdzIiwiQ2hhcnQucHJvdG90eXBlLmluaXQiLCJ1c2VyUGxvdE9wdGlvbnMiLCJ0eXBlT3B0aW9ucyIsImNoYXJ0RXZlbnRzIiwiQ2hhcnQucHJvdG90eXBlLmluaXRTZXJpZXMiLCJDaGFydC5wcm90b3R5cGUuc2V0U2VyaWVzRGF0YSIsImVuYWJsZWREYXRhU29ydGluZyIsIkNoYXJ0LnByb3RvdHlwZS5nZXRTZXJpZXNPcmRlckJ5TGlua3MiLCJDaGFydC5wcm90b3R5cGUub3JkZXJTZXJpZXMiLCJmcm9tSW5kZXgiLCJDaGFydC5wcm90b3R5cGUuaXNJbnNpZGVQbG90IiwiaXNJbnNpZGVQbG90IiwiQ2hhcnQucHJvdG90eXBlLnJlZHJhdyIsImF4ZXMiLCJoYXNDYXJ0ZXNpYW5TZXJpZXMiLCJsZWdlbmRVc2VyT3B0aW9ucyIsInJlZHJhd0xlZ2VuZCIsImlzRGlydHlCb3giLCJpc0hpZGRlbkNoYXJ0IiwiYWZ0ZXJSZWRyYXciLCJzZXRSZXNwb25zaXZlIiwiaGFzUmVuZGVyZWQiLCJsYXlPdXRUaXRsZXMiLCJoYXNTdGFja2VkU2VyaWVzIiwiZ2V0U3RhY2tzIiwiZ2V0TWFyZ2lucyIsImRyYXdDaGFydEJveCIsInRlbXBvcmFyeURpc3BsYXkiLCJDaGFydC5wcm90b3R5cGUuZ2V0IiwiaXRlbUJ5SWQiLCJDaGFydC5wcm90b3R5cGUuZ2V0QXhlcyIsInhBeGlzT3B0aW9ucyIsInlBeGlzT3B0aW9ucyIsIkNoYXJ0LnByb3RvdHlwZS5nZXRTZWxlY3RlZFBvaW50cyIsIkNoYXJ0LnByb3RvdHlwZS5nZXRTZWxlY3RlZFNlcmllcyIsIkNoYXJ0LnByb3RvdHlwZS5zZXRUaXRsZSIsIkNoYXJ0LnByb3RvdHlwZS5hcHBseURlc2NyaXB0aW9uIiwiZWxlbS51cGRhdGUiLCJDaGFydC5wcm90b3R5cGUubGF5T3V0VGl0bGVzIiwic3BhY2luZ0JveCIsInRpdGxlU2l6ZSIsInJlcXVpcmVzRGlydHlCb3giLCJDaGFydC5wcm90b3R5cGUuZ2V0Q2hhcnRTaXplIiwiaGVpZ2h0T3B0aW9uIiwicmVuZGVyVG8iLCJjaGFydEhlaWdodCIsIkNoYXJ0LnByb3RvdHlwZS50ZW1wb3JhcnlEaXNwbGF5IiwidGVtcFN0eWxlIiwiQ2hhcnQucHJvdG90eXBlLnNldENsYXNzTmFtZSIsIkNoYXJ0LnByb3RvdHlwZS5nZXRDb250YWluZXIiLCJjb250YWluZXJJZCIsImluZGV4QXR0ck5hbWUiLCJnZXRDaGFydFNpemUiLCJjb250YWluZXJTdHlsZSIsInVzZXJTZWxlY3QiLCJfY3Vyc29yIiwic2V0Q2xhc3NOYW1lIiwiQ2hhcnQucHJvdG90eXBlLmdldE1hcmdpbnMiLCJDaGFydC5wcm90b3R5cGUuZ2V0QXhpc01hcmdpbnMiLCJjb2xvckF4aXMiLCJnZXRPZmZzZXQiLCJDaGFydC5wcm90b3R5cGUucmVmbG93IiwiaGFzVXNlclNpemUiLCJDaGFydC5wcm90b3R5cGUuc2V0UmVmbG93IiwiQ2hhcnQucHJvdG90eXBlLnNldFNpemUiLCJnbG9iYWxBbmltYXRpb24iLCJDaGFydC5wcm90b3R5cGUuc2V0Q2hhcnRTaXplIiwicGxvdFNpemVYIiwicGxvdFNpemVZIiwicGxvdEJvcmRlcldpZHRoIiwicGxvdEJveCIsImNsaXBYIiwiY2xpcFkiLCJjbGlwQm94Iiwic2tpcEF4ZXMiLCJzZXRBeGlzVHJhbnNsYXRpb24iLCJDaGFydC5wcm90b3R5cGUucmVzZXRNYXJnaW5zIiwic3BsYXNoQXJyYXlzIiwidmFsdWVzIiwiQ2hhcnQucHJvdG90eXBlLmRyYXdDaGFydEJveCIsImNoYXJ0QmFja2dyb3VuZCIsInBsb3RCYWNrZ3JvdW5kIiwicGxvdEJvcmRlciIsInBsb3RCR0ltYWdlIiwiY2hhcnRCYWNrZ3JvdW5kQ29sb3IiLCJwbG90QmFja2dyb3VuZENvbG9yIiwicGxvdEJhY2tncm91bmRJbWFnZSIsInZlcmIiLCJtZ24iLCJjaGFydEJvcmRlcldpZHRoIiwiYmdBdHRyIiwiQ2hhcnQucHJvdG90eXBlLnByb3BGcm9tU2VyaWVzIiwia2xhc3MiLCJDaGFydC5wcm90b3R5cGUubGlua1NlcmllcyIsImNoYXJ0U2VyaWVzIiwibGlua2VkVG8iLCJDaGFydC5wcm90b3R5cGUucmVuZGVyU2VyaWVzIiwicmVuZGVyIiwiQ2hhcnQucHJvdG90eXBlLnJlbmRlckxhYmVscyIsIkNoYXJ0LnByb3RvdHlwZS5yZW5kZXIiLCJjb3JyZWN0aW9uIiwicmVuZGVyQXhlcyIsInNldENoYXJ0U2l6ZSIsInRlbXBXaWR0aCIsImdldEF4aXNNYXJnaW5zIiwidGVtcEhlaWdodCIsInJlZG9Ib3Jpem9udGFsIiwiQ2hhcnQucHJvdG90eXBlLmFkZENyZWRpdHMiLCJjcmVkcyIsInRoaXMuY3JlZGl0cy51cGRhdGUiLCJDaGFydC5wcm90b3R5cGUuZGVzdHJveSIsIkNoYXJ0LnByb3RvdHlwZS5maXJzdFJlbmRlciIsImlzUmVhZHlUb1JlbmRlciIsIk1TUG9pbnRlckV2ZW50IiwiQ2hhcnQucHJvdG90eXBlLm9ubG9hZCIsIkNoYXJ0LnByb3RvdHlwZS5hZGRTZXJpZXMiLCJDaGFydC5wcm90b3R5cGUuYWRkQXhpcyIsIkNoYXJ0LnByb3RvdHlwZS5hZGRDb2xvckF4aXMiLCJDaGFydC5wcm90b3R5cGUuY3JlYXRlQXhpcyIsIkNoYXJ0LnByb3RvdHlwZS5zaG93TG9hZGluZyIsImxvYWRpbmdEaXYiLCJsb2FkaW5nU3BhbiIsImxvYWRpbmdPcHRpb25zIiwic2V0TG9hZGluZ1NpemUiLCJDaGFydC5wcm90b3R5cGUuaGlkZUxvYWRpbmciLCJDaGFydC5wcm90b3R5cGUudXBkYXRlIiwiYWRkZXJzIiwiaXNSZXNwb25zaXZlT3B0aW9ucyIsIml0ZW1zRm9yUmVtb3ZhbCIsInVwZGF0ZUFsbEF4ZXMiLCJ1cGRhdGVBbGxTZXJpZXMiLCJydW5TZXRTaXplIiwiaW5kZXhNYXAiLCJoYXNJZCIsIm5ld09wdGlvbnMiLCJvbmVUb09uZSIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwiQ2hhcnQucHJvdG90eXBlLnNldFN1YnRpdGxlIiwiQ2hhcnQucHJvdG90eXBlLnNldENhcHRpb24iLCJDaGFydC5wcm90b3R5cGUuc2hvd1Jlc2V0Wm9vbSIsInpvb21PdXQiLCJidG5PcHRpb25zIiwic3RhdGVzIiwiQ2hhcnQucHJvdG90eXBlLnpvb21PdXQiLCJyZXNldFNlbGVjdGlvbiIsIkNoYXJ0LnByb3RvdHlwZS56b29tIiwiZGlzcGxheUJ1dHRvbiIsIm1vdXNlRG93blBvcyIsImhhc1pvb21lZCIsImF4aXNEYXRhIiwiYXhpc1N0YXJ0UG9zIiwiYXhpc0VuZFBvcyIsImlzV2l0aGluUGFuZSIsIkNoYXJ0LnByb3RvdHlwZS5wYW4iLCJoYXNNYXBOYXZpZ2F0aW9uIiwiZG9SZWRyYXciLCJtb3VzZVBvcyIsIm1vdXNlRG93biIsInN0YXJ0UG9zIiwiaGFsZlBvaW50UmFuZ2UiLCJwb2ludFJhbmdlRGlyZWN0aW9uIiwiZXh0cmVtZXMiLCJwYW5NaW4iLCJwYW5NYXgiLCJmbGlwcGVkIiwiaXNEaXJ0eSIsInByb2Nlc3NlZERhdGEiLCJzdGFydE1pbiIsInN0YXJ0TWF4IiwicGFkZGVkTWluIiwicGFkZGVkTWF4Iiwic3BpbGwiLCJjYWxsYmFja3MiLCJjb2xsZWN0aW9uc1dpdGhJbml0IiwiY29sbGVjdGlvbnNXaXRoVXBkYXRlIiwicHJvcHNSZXF1aXJlRGlydHlCb3giLCJwcm9wc1JlcXVpcmVSZWZsb3ciLCJwcm9wc1JlcXVpcmVVcGRhdGVTZXJpZXMiLCJkcmF3UmVjdGFuZ2xlIiwiZHJhd0xpbmVNYXJrZXIiLCJnZW5lcmFsUmFkaXVzIiwibGVnZW5kSXRlbUdyb3VwIiwidmVydGljYWxDZW50ZXIiLCJyYWRpdXMiLCJTZXJpZXMiLCJTZXJpZXMucHJvdG90eXBlLmluaXQiLCJsYXN0U2VyaWVzIiwiU2VyaWVzLnByb3RvdHlwZS5pcyIsIlNlcmllcy5wcm90b3R5cGUuaW5zZXJ0IiwiaW5kZXhPcHRpb24iLCJjb2xsZWN0aW9uIiwiU2VyaWVzLnByb3RvdHlwZS5iaW5kQXhlcyIsIlNlcmllcy5wcm90b3R5cGUudXBkYXRlUGFyYWxsZWxBcnJheXMiLCJTZXJpZXMucHJvdG90eXBlLmhhc0RhdGEiLCJTZXJpZXMucHJvdG90eXBlLmF1dG9JbmNyZW1lbnQiLCJ4SW5jcmVtZW50IiwicG9pbnRJbnRlcnZhbFVuaXQiLCJwb2ludEludGVydmFsIiwiU2VyaWVzLnByb3RvdHlwZS5zZXREYXRhU29ydGluZ09wdGlvbnMiLCJyZXF1aXJlU29ydGluZyIsInNvcnRlZCIsImFsbG93REciLCJTZXJpZXMucHJvdG90eXBlLnNldE9wdGlvbnMiLCJzZXJpZXNVc2VyT3B0aW9ucyIsInNsaWNlIiwibmVnYXRpdmVDb2xvciIsIm5lZ2F0aXZlRmlsbENvbG9yIiwiZmlsbENvbG9yIiwiU2VyaWVzLnByb3RvdHlwZS5nZXROYW1lIiwiU2VyaWVzLnByb3RvdHlwZS5nZXRDeWNsaWMiLCJpbmRleE5hbWUiLCJjb3VudGVyTmFtZSIsImRlZmF1bHRzIiwiU2VyaWVzLnByb3RvdHlwZS5nZXRDb2xvciIsIlNlcmllcy5wcm90b3R5cGUuZ2V0UG9pbnRzQ29sbGVjdGlvbiIsIlNlcmllcy5wcm90b3R5cGUuZ2V0U3ltYm9sIiwiU2VyaWVzLnByb3RvdHlwZS5maW5kUG9pbnRJbmRleCIsIm9wdGlvbnNPYmplY3QiLCJvbGREYXRhIiwibWF0Y2hpbmdQb2ludCIsIm9sZFBvaW50IiwibWF0Y2hlZEJ5SWQiLCJwb2ludEluZGV4IiwiU2VyaWVzLnByb3RvdHlwZS51cGRhdGVEYXRhIiwicG9pbnRzVG9BZGQiLCJlcXVhbExlbmd0aCIsInN1Y2NlZWRlZCIsInBvaW50T3B0aW9ucyIsImxhc3RJbmRleCIsImhhc1VwZGF0ZWRCeUtleSIsIlNlcmllcy5wcm90b3R5cGUuc2V0RGF0YSIsIm9sZERhdGFMZW5ndGgiLCJmaXJzdFBvaW50IiwidHVyYm9UaHJlc2hvbGQiLCJ5RGF0YSIsImluZGV4T2ZYIiwiaW5kZXhPZlkiLCJ1cGRhdGVkRGF0YSIsImRhdGFMZW5ndGgiLCJwdCIsIlNlcmllcy5wcm90b3R5cGUuc29ydERhdGEiLCJzb3J0S2V5IiwiZ2V0UG9pbnRPcHRpb25zT2JqZWN0IiwiYVZhbHVlIiwiYlZhbHVlIiwibGlua2VkU2VyaWVzIiwic2VyaWVzRGF0YSIsIlNlcmllcy5wcm90b3R5cGUuZ2V0UHJvY2Vzc2VkRGF0YSIsInByb2Nlc3NlZFhEYXRhIiwicHJvY2Vzc2VkWURhdGEiLCJjcm9wU3RhcnQiLCJjcm9wVGhyZXNob2xkIiwiZ2V0RXh0cmVtZXNGcm9tQWxsIiwiZm9yY2VFeHRyZW1lc0Zyb21BbGwiLCJpc0NhcnRlc2lhbiIsInZhbDJsaW4iLCJpc0xvZyIsInRocm93T25VbnNvcnRlZCIsImNyb3BwZWREYXRhIiwiY3JvcHBlZCIsIlNlcmllcy5wcm90b3R5cGUucHJvY2Vzc0RhdGEiLCJTZXJpZXMucHJvdG90eXBlLmNyb3BEYXRhIiwiY3JvcEVuZCIsImNyb3BTaG91bGRlciIsIlNlcmllcy5wcm90b3R5cGUuZ2VuZXJhdGVQb2ludHMiLCJkYXRhT3B0aW9ucyIsIlBvaW50Q2xhc3MiLCJwcm9jZXNzZWREYXRhTGVuZ3RoIiwiaGFzR3JvdXBlZERhdGEiLCJpbml0IiwiZ3JvdXBNYXAiLCJTZXJpZXMucHJvdG90eXBlLmdldFhFeHRyZW1lcyIsIlNlcmllcy5wcm90b3R5cGUuZ2V0RXh0cmVtZXMiLCJhY3RpdmVZRGF0YSIsImFjdGl2ZUNvdW50ZXIiLCJ4TWluIiwieE1heCIsInNob3VsZGVyIiwicG9zaXRpdmVWYWx1ZXNPbmx5IiwieURhdGFMZW5ndGgiLCJ3aXRoaW5SYW5nZSIsInZhbGlkVmFsdWUiLCJTZXJpZXMucHJvdG90eXBlLmFwcGx5RXh0cmVtZXMiLCJTZXJpZXMucHJvdG90eXBlLmdldEZpcnN0VmFsaWRQb2ludCIsIlNlcmllcy5wcm90b3R5cGUudHJhbnNsYXRlIiwiaGFzTW9kaWZ5VmFsdWUiLCJkeW5hbWljYWxseVBsYWNlZCIsInN0YWNrVGhyZXNob2xkIiwiY2xvc2VzdFBvaW50UmFuZ2VQeCIsInhWYWx1ZSIsInlWYWx1ZSIsInlCb3R0b20iLCJzdGFjayIsIm5lZ1N0YWNrcyIsImdldFN0YWNrSW5kaWNhdG9yIiwicG9pbnRTdGFjayIsInN0YWNrSW5kaWNhdG9yIiwic3RhY2tWYWx1ZXMiLCJtb2RpZnlWYWx1ZSIsInRyYW5zbGF0ZWQiLCJTZXJpZXMucHJvdG90eXBlLmdldFZhbGlkUG9pbnRzIiwiZmlsdGVyIiwiaW5zaWRlT25seSIsImFsbG93TnVsbCIsIlNlcmllcy5wcm90b3R5cGUuZ2V0Q2xpcEJveCIsInNjcm9sbGFibGVQbG90QXJlYU9wdGlvbnMiLCJmaW5hbEJveCIsIlNlcmllcy5wcm90b3R5cGUuc2V0Q2xpcCIsInNlcmllc0NsaXBCb3giLCJzaGFyZWRDbGlwS2V5IiwibWFya2VyQ2xpcFJlY3QiLCJTZXJpZXMucHJvdG90eXBlLmFuaW1hdGUiLCJzZXRDbGlwIiwiZ2V0Q2xpcEJveCIsIlNlcmllcy5wcm90b3R5cGUuYWZ0ZXJBbmltYXRlIiwiU2VyaWVzLnByb3RvdHlwZS5kcmF3UG9pbnRzIiwic2VyaWVzTWFya2VyT3B0aW9ucyIsIm1hcmtlckdyb3VwIiwiZ2xvYmFsbHlFbmFibGVkIiwicG9pbnRNYXJrZXJPcHRpb25zIiwiaGFzUG9pbnRNYXJrZXIiLCJTZXJpZXMucHJvdG90eXBlLm1hcmtlckF0dHJpYnMiLCJzZXJpZXNTdGF0ZU9wdGlvbnMiLCJwb2ludFN0YXRlT3B0aW9ucyIsIlNlcmllcy5wcm90b3R5cGUucG9pbnRBdHRyaWJzIiwicG9pbnRDb2xvck9wdGlvbiIsInBvaW50Q29sb3IiLCJ6b25lQ29sb3IiLCJTZXJpZXMucHJvdG90eXBlLmRlc3Ryb3kiLCJpc3N1ZTEzNCIsImtlZXBFdmVudHNGb3JVcGRhdGUiLCJTZXJpZXMucHJvdG90eXBlLmFwcGx5Wm9uZXMiLCJjbGlwcyIsImdyYXBoIiwiYXJlYSIsImNoYXJ0U2l6ZU1heCIsImlnbm9yZVpvbmVzIiwiem9uZUdyYXBoIiwidHJhbnNsYXRlZEZyb20iLCJ0cmFuc2xhdGVkVG8iLCJweFJhbmdlIiwicHhQb3NNaW4iLCJweFBvc01heCIsImNsaXBBdHRyIiwiem9uZUFyZWEiLCJTZXJpZXMucHJvdG90eXBlLmludmVydEdyb3VwcyIsInNldEludmVydCIsIlNlcmllcy5wcm90b3R5cGUucGxvdEdyb3VwIiwiU2VyaWVzLnByb3RvdHlwZS5nZXRQbG90Qm94IiwiU2VyaWVzLnByb3RvdHlwZS5yZW1vdmVFdmVudHMiLCJldmVudHNUb1VuYmluZCIsInVuYmluZCIsIlNlcmllcy5wcm90b3R5cGUucmVuZGVyIiwiYW5pbUR1cmF0aW9uIiwiY2hhcnRTZXJpZXNHcm91cCIsIlNlcmllcy5wcm90b3R5cGUucmVkcmF3Iiwid2FzRGlydHkiLCJTZXJpZXMucHJvdG90eXBlLnNlYXJjaFBvaW50IiwiU2VyaWVzLnByb3RvdHlwZS5idWlsZEtEVHJlZSIsIl9rZHRyZWUiLCJtZWRpYW4iLCJkZXB0aCIsImRpbWVuc2lvbnMiLCJzdGFydFJlY3Vyc2l2ZSIsIlNlcmllcy5wcm90b3R5cGUuc2VhcmNoS0RUcmVlIiwiX3NlYXJjaCIsInRyZWUiLCJzZWFyY2giLCJ0ZGlzdCIsInNpZGVBIiwic2lkZUIiLCJuUG9pbnQxIiwiblBvaW50MiIsImtkWCIsImtkWSIsImtkQ29tcGFyZXIiLCJrZERpbWVuc2lvbnMiLCJTZXJpZXMucHJvdG90eXBlLnBvaW50UGxhY2VtZW50VG9YVmFsdWUiLCJTZXJpZXMucHJvdG90eXBlLmlzUG9pbnRJbnNpZGUiLCJTZXJpZXMucHJvdG90eXBlLmRyYXdUcmFja2VyIiwidHJhY2tCeUFyZWEiLCJ0cmFja2VyUGF0aCIsIm9uTW91c2VPdmVyIiwiVFJBQ0tFUl9GSUxMIiwiU2VyaWVzLnByb3RvdHlwZS5hZGRQb2ludCIsImlzSW5UaGVNaWRkbGUiLCJwb2ludENsYXNzIiwidXBkYXRlUGFyYWxsZWxBcnJheXMiLCJnZW5lcmF0ZVBvaW50cyIsIlNlcmllcy5wcm90b3R5cGUucmVtb3ZlUG9pbnQiLCJyZW1vdmUiLCJTZXJpZXMucHJvdG90eXBlLnJlbW92ZSIsIlNlcmllcy5wcm90b3R5cGUudXBkYXRlIiwib2xkT3B0aW9ucyIsImluaXRpYWxUeXBlIiwibmV3VHlwZSIsImtlZXBQb2ludHMiLCJpbml0aWFsU2VyaWVzUHJvdG8iLCJwcmVzZXJ2ZSIsInBvaW50U3RhcnQiLCJncm91cHMiLCJjb25jYXQiLCJjYXN0aW5nIiwib3duRXZlbnRzIiwibWFya2VyIiwiU2VyaWVzLnByb3RvdHlwZS5zZXROYW1lIiwiU2VyaWVzLnByb3RvdHlwZS5oYXNPcHRpb25DaGFuZ2VkIiwib3B0aW9uIiwib2xkT3B0aW9uIiwiU2VyaWVzLnByb3RvdHlwZS5vbk1vdXNlT3ZlciIsInNldEhvdmVyQ2hhcnRJbmRleCIsInNldFN0YXRlIiwiU2VyaWVzLnByb3RvdHlwZS5vbk1vdXNlT3V0Iiwibm9TaGFyZWRUb29sdGlwIiwiU2VyaWVzLnByb3RvdHlwZS5zZXRTdGF0ZSIsImluYWN0aXZlT3RoZXJQb2ludHMiLCJzdGF0ZUFuaW1hdGlvbiIsIlNlcmllcy5wcm90b3R5cGUuc2V0QWxsUG9pbnRzVG9TdGF0ZSIsIlNlcmllcy5wcm90b3R5cGUuc2V0VmlzaWJsZSIsIm9sZFZpc2liaWxpdHkiLCJ2aXMiLCJvdGhlclNlcmllcyIsIlNlcmllcy5wcm90b3R5cGUuc2hvdyIsIlNlcmllcy5wcm90b3R5cGUuaGlkZSIsIlNlcmllcy5wcm90b3R5cGUuc2VsZWN0IiwiYWxsb3dQb2ludFNlbGVjdCIsImNyaXNwIiwiZW5hYmxlZFRocmVzaG9sZCIsIm5vcm1hbCIsImhvdmVyIiwicmFkaXVzUGx1cyIsImxpbmVXaWR0aFBsdXMiLCJzZWxlY3QiLCJpbmFjdGl2ZSIsInN0aWNreVRyYWNraW5nIiwiZmluZE5lYXJlc3RQb2ludEJ5IiwiYXhpc1R5cGVzIiwiY29sb3JDb3VudGVyIiwiZHJhd0xlZ2VuZFN5bWJvbCIsIkxlZ2VuZFN5bWJvbE1peGluIiwia2RBeGlzQXJyYXkiLCJwYXJhbGxlbEFycmF5cyIsInNjcm9sbGFibGVQbG90QXJlYSIsInNjcm9sbGFibGVNaW5XaWR0aCIsInNjcm9sbGFibGVNaW5IZWlnaHQiLCJjb3JyZWN0aW9ucyIsImF4aXMuZ2V0UGxvdExpbmVQYXRoIiwibWFyZ2luTmFtZSIsIkNoYXJ0LnByb3RvdHlwZS5zZXRVcFNjcm9sbGluZyIsIldlYmtpdE92ZXJmbG93U2Nyb2xsaW5nIiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiQ2hhcnQucHJvdG90eXBlLm1vdmVGaXhlZEVsZW1lbnRzIiwiZml4ZWRSZW5kZXJlciIsImZpeGVkU2VsZWN0b3JzIiwiYXhpc0NsYXNzIiwiQ2hhcnQucHJvdG90eXBlLmFwcGx5Rml4ZWQiLCJzY3JvbGxhYmxlT3B0aW9ucyIsInNjcm9sbGFibGVXaWR0aCIsInNjcm9sbGFibGVIZWlnaHQiLCJtYXNrVG9wIiwibWFza0xlZnQiLCJtYXNrQm90dG9tIiwibWFza1JpZ2h0IiwibWFza1Bsb3RSaWdodCIsIm1hc2tQbG90Qm90dG9tIiwiU3RhY2tpbmdBeGlzQWRkaXRpb25zIiwiU3RhY2tpbmdBeGlzQWRkaXRpb25zLnByb3RvdHlwZS5idWlsZFN0YWNrcyIsInJldmVyc2VkU3RhY2tzIiwidXNlUGVyY2VudGFnZSIsImFjdHVhbFNlcmllcyIsIlN0YWNraW5nQXhpc0FkZGl0aW9ucy5wcm90b3R5cGUuY2xlYW5TdGFja3MiLCJvbGRTdGFja3MiLCJTdGFja2luZ0F4aXNBZGRpdGlvbnMucHJvdG90eXBlLnJlc2V0U3RhY2tzIiwic3RhY2tzIiwiU3RhY2tpbmdBeGlzQWRkaXRpb25zLnByb3RvdHlwZS5yZW5kZXJTdGFja1RvdGFscyIsImFuaW1hdGlvbkNvbmZpZyIsInN0YWNrVG90YWxHcm91cCIsIlN0YWNraW5nQXhpcyIsIlN0YWNraW5nQXhpcy5jb21wb3NlIiwiU3RhY2tpbmdBeGlzLm9uRGVzdHJveSIsIlN0YWNraW5nQXhpcy5vbkluaXQiLCJTdGFja0l0ZW0iLCJpc05lZ2F0aXZlIiwic3RhY2tPcHRpb24iLCJTdGFja0l0ZW0ucHJvdG90eXBlLmRlc3Ryb3kiLCJTdGFja0l0ZW0ucHJvdG90eXBlLnJlbmRlciIsIlN0YWNrSXRlbS5wcm90b3R5cGUuc2V0T2Zmc2V0Iiwic3RhY2tJdGVtIiwiYm94VG9wIiwieVplcm8iLCJib3hCb3R0b20iLCJ4T2Zmc2V0Iiwic3RhY2tCb3giLCJpc0p1c3RpZnkiLCJib3hPZmZzZXRYIiwiYm94T2Zmc2V0WSIsIlN0YWNrSXRlbS5wcm90b3R5cGUuZ2V0U3RhY2tCb3giLCJheGlzUG9zIiwibmVnIiwiQ2hhcnQucHJvdG90eXBlLmdldFN0YWNrcyIsImNvbXBvc2UiLCJTZXJpZXMucHJvdG90eXBlLnNldEdyb3VwZWRQb2ludHMiLCJTZXJpZXMucHJvdG90eXBlLnNldFN0YWNrZWRQb2ludHMiLCJzdGFja2luZ1BhcmFtIiwic3RhY2tlZFlEYXRhIiwic3RhY2tLZXkiLCJuZWdLZXkiLCJwb2ludEtleSIsIlNlcmllcy5wcm90b3R5cGUubW9kaWZ5U3RhY2tzIiwicG9pbnRFeHRyZW1lcyIsIlNlcmllcy5wcm90b3R5cGUucGVyY2VudFN0YWNrZXIiLCJ0b3RhbEZhY3RvciIsIlNlcmllcy5wcm90b3R5cGUuZ2V0U3RhY2tJbmRpY2F0b3IiLCJMaW5lU2VyaWVzIiwiTGluZVNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoIiwiZ3JhcGhQYXRoIiwiZ3JhcGhLZXkiLCJMaW5lU2VyaWVzLnByb3RvdHlwZS5nZXRHcmFwaFBhdGgiLCJ4TWFwIiwiZ2FwIiwicGF0aFRvUG9pbnQiLCJMaW5lU2VyaWVzLnByb3RvdHlwZS5nZXRab25lc0dyYXBocyIsInByb3BzZXQiLCJBcmVhU2VyaWVzIiwiQXJlYVNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoIiwiYXJlYVBhdGgiLCJhcmVhS2V5IiwiQXJlYVNlcmllcy5wcm90b3R5cGUuZ2V0R3JhcGhQYXRoIiwiZ2V0R3JhcGhQYXRoIiwiYm90dG9tUG9pbnRzIiwiZ3JhcGhQb2ludHMiLCJzZXJpZXNJbmRleCIsInRyYW5zbGF0ZWRUaHJlc2hvbGQiLCJjb25uZWN0TnVsbHMiLCJhZGREdW1teVBvaW50cyIsInN0YWNrZWRWYWx1ZXMiLCJudWxsVmFsIiwiY2xpZmZWYWwiLCJpc0NsaWZmIiwiZG9DdXJ2ZSIsInRvcFBhdGgiLCJib3R0b21QYXRoIiwiZmlyc3RCb3R0b21Qb2ludCIsIkFyZWFTZXJpZXMucHJvdG90eXBlLmdldFN0YWNrUG9pbnRzIiwicG9pbnRNYXAiLCJ5QXhpc1NlcmllcyIsInNlcmllc0xlbmd0aCIsInVwT3JEb3duIiwic3RhY2tYIiwibnVsbE5hbWUiLCJjbGlmZiIsIm90aGVyU3RhY2siLCJpZHgiLCJzdGFja1BvaW50IiwidmlzaWJsZVNlcmllcyIsImNsaWZmTmFtZSIsInNpbmdsZVN0YWNrcyIsIlNwbGluZVNlcmllcyIsIlNwbGluZVNlcmllcy5wcm90b3R5cGUuZ2V0UG9pbnRTcGxpbmUiLCJuZXh0UG9pbnQiLCJuZXh0WCIsIm5leHRZIiwic21vb3RoaW5nIiwiZGVub20iLCJyaWdodENvbnRYIiwicmlnaHRDb250WSIsImxlZnRDb250WSIsImFyZWFQcm90byIsIkFyZWFTcGxpbmVTZXJpZXMiLCJnZXRTdGFja1BvaW50cyIsImRyYXdHcmFwaCIsIkNvbHVtblNlcmllcyIsIkNvbHVtblNlcmllcy5wcm90b3R5cGUuYW5pbWF0ZSIsInRyYW5zbGF0ZVByb3AiLCJ0cmFuc2xhdGVTdGFydCIsIkNvbHVtblNlcmllcy5wcm90b3R5cGUuaW5pdCIsIkNvbHVtblNlcmllcy5wcm90b3R5cGUuZ2V0Q29sdW1uTWV0cmljcyIsInJldmVyc2VTdGFja3MiLCJzdGFja0dyb3VwcyIsImNvbHVtbkNvdW50Iiwib3RoZXJZQXhpcyIsImNvbHVtbkluZGV4IiwiY2F0ZWdvcnlXaWR0aCIsImdyb3VwUGFkZGluZyIsInBvaW50T2Zmc2V0V2lkdGgiLCJwb2ludFdpZHRoIiwicGFkZGVkV2lkdGgiLCJDb2x1bW5TZXJpZXMucHJvdG90eXBlLmNyaXNwQ29sIiwieENyaXNwIiwieUNyaXNwIiwiZnJvbVRvcCIsIkNvbHVtblNlcmllcy5wcm90b3R5cGUuYWRqdXN0Rm9yTWlzc2luZ0NvbHVtbnMiLCJtZXRyaWNzIiwiaW5kZXhJbkNhdGVnb3J5XzEiLCJ0b3RhbEluQ2F0ZWdvcnlfMSIsInBvaW50VmFsdWVzIiwiQ29sdW1uU2VyaWVzLnByb3RvdHlwZS50cmFuc2xhdGUiLCJkZW5zZSIsIm1pblBvaW50TGVuZ3RoIiwic2VyaWVzUG9pbnRXaWR0aCIsInNlcmllc0JhclciLCJzZXJpZXNYT2Zmc2V0IiwiYmFyWCIsImJhclciLCJiYXJZIiwiYmFySCIsInVwIiwiQ29sdW1uU2VyaWVzLnByb3RvdHlwZS5kcmF3R3JhcGgiLCJDb2x1bW5TZXJpZXMucHJvdG90eXBlLnBvaW50QXR0cmlicyIsInAybyIsInN0cm9rZU9wdGlvbiIsInN0cm9rZVdpZHRoT3B0aW9uIiwiYnJpZ2h0bmVzcyIsIkNvbHVtblNlcmllcy5wcm90b3R5cGUuZHJhd1BvaW50cyIsImFuaW1hdGlvbkxpbWl0IiwiaGFzR3JhcGhpYyIsIkNvbHVtblNlcmllcy5wcm90b3R5cGUuZHJhd1RyYWNrZXIiLCJDb2x1bW5TZXJpZXMucHJvdG90eXBlLnJlbW92ZSIsImNlbnRlckluQ2F0ZWdvcnkiLCJwb2ludFBhZGRpbmciLCJzdGFydEZyb21UaHJlc2hvbGQiLCJnZXRTeW1ib2wiLCJ0cmFja2VyR3JvdXBzIiwiQmFyU2VyaWVzIiwiU2NhdHRlclNlcmllcyIsIlNjYXR0ZXJTZXJpZXMucHJvdG90eXBlLmFwcGx5Sml0dGVyIiwiaml0dGVyIiwicGxvdFByb3AiLCJyYW5kIiwiU2NhdHRlclNlcmllcy5wcm90b3R5cGUuZHJhd0dyYXBoIiwiZHJhd1RyYWNrZXIiLCJ0YWtlT3JkaW5hbFBvc2l0aW9uIiwiZ2V0Q2VudGVyIiwic2xpY2luZ1Jvb20iLCJjZW50ZXJPcHRpb24iLCJzbWFsbGVzdFNpemUiLCJhbmd1bGFyIiwiaGFuZGxlU2xpY2luZ1Jvb20iLCJnZXRTdGFydEFuZEVuZFJhZGlhbnMiLCJzdGFydEFuZ2xlIiwiZW5kQW5nbGUiLCJQaWVQb2ludCIsIlBpZVBvaW50LnByb3RvdHlwZS5nZXRDb25uZWN0b3JQYXRoIiwibGFiZWxQb3NpdGlvbiIsImNvbm5lY3RvclNoYXBlIiwicHJlZGVmaW5lZFNoYXBlcyIsIlBpZVBvaW50LnByb3RvdHlwZS5nZXRUcmFuc2xhdGUiLCJQaWVQb2ludC5wcm90b3R5cGUuaGFsb1BhdGgiLCJQaWVQb2ludC5wcm90b3R5cGUuaW5pdCIsInRvZ2dsZVNsaWNlIiwiUGllUG9pbnQucHJvdG90eXBlLmlzVmFsaWQiLCJQaWVQb2ludC5wcm90b3R5cGUuc2V0VmlzaWJsZSIsImlnbm9yZUhpZGRlblBvaW50IiwiUGllUG9pbnQucHJvdG90eXBlLnNsaWNlIiwic2xpY2VkIiwic2hhZG93R3JvdXAiLCJjb25uZWN0b3JTaGFwZXMiLCJmaXhlZE9mZnNldCIsImJyZWFrQXQiLCJjb25uZWN0b3JQb3NpdGlvbiIsInRvdWNoaW5nU2xpY2VBdCIsImxpbmVTZWdtZW50Iiwic3RyYWlnaHQiLCJjcm9va2VkTGluZSIsInBpZUNlbnRlclgiLCJjcm9va0Rpc3RhbmNlIiwiY3Jvb2tYIiwic2VnbWVudFdpdGhDcm9vayIsInVzZUNyb29rIiwiQ2VudGVyZWRTZXJpZXNNaXhpbiIsIlBpZVNlcmllcyIsIlBpZVNlcmllcy5wcm90b3R5cGUuYW5pbWF0ZSIsInN0YXJ0QW5nbGVSYWQiLCJQaWVTZXJpZXMucHJvdG90eXBlLmRyYXdFbXB0eSIsIlBpZVNlcmllcy5wcm90b3R5cGUuZHJhd1BvaW50cyIsIlBpZVNlcmllcy5wcm90b3R5cGUuZ2VuZXJhdGVQb2ludHMiLCJQaWVTZXJpZXMucHJvdG90eXBlLmdldFgiLCJQaWVTZXJpZXMucHJvdG90eXBlLmhhc0RhdGEiLCJQaWVTZXJpZXMucHJvdG90eXBlLnJlZHJhd1BvaW50cyIsImFuaW1hdGVUbyIsImdyb3VwVHJhbnNsYXRpb24iLCJwb2ludEF0dHIiLCJQaWVTZXJpZXMucHJvdG90eXBlLnNvcnRCeUFuZ2xlIiwiUGllU2VyaWVzLnByb3RvdHlwZS50cmFuc2xhdGUiLCJjdW11bGF0aXZlIiwic2xpY2VkT2Zmc2V0IiwiY29ubmVjdG9yT2Zmc2V0IiwicmFkaWFucyIsImNpcmMiLCJlbmRBbmdsZVJhZCIsImxhYmVsRGlzdGFuY2UiLCJtYXhMYWJlbERpc3RhbmNlIiwiZmluYWxDb25uZWN0b3JPZmZzZXQiLCJuYXR1cmFsIiwiUGllU2VyaWVzLnByb3RvdHlwZS51cGRhdGVUb3RhbHMiLCJjb2xvckJ5UG9pbnQiLCJjb25uZWN0b3JQYWRkaW5nIiwic29mdENvbm5lY3RvciIsImxlZ2VuZFR5cGUiLCJzaG93SW5MZWdlbmQiLCJzZWFyY2hQb2ludCIsIkguZGlzdHJpYnV0ZSIsInNvcnRCeVRhcmdldCIsIm92ZXJsYXBwaW5nIiwib3JpZ0JveGVzIiwicmVzdEJveGVzIiwicmVkdWNlZExlbiIsInRhcmdldHMiLCJwb3NJbkNvbXBvc2l0ZUJveCIsIlNlcmllcy5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMiLCJhcHBseUZpbHRlciIsIm9wIiwibWVyZ2VBcnJheXMiLCJyZXMiLCJvbmUiLCJ0d28iLCJzZXJpZXNEbE9wdGlvbnMiLCJkYXRhTGFiZWxBbmltIiwiZGF0YUxhYmVsc0dyb3VwIiwibGFiZWxFbmFibGVkIiwiY29ubmVjdG9yIiwiU2VyaWVzLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbCIsImp1c3RpZnkiLCJzZXRTdGFydFBvcyIsIm5vcm1Sb3RhdGlvbiIsIm5lZ1JvdGF0aW9uIiwiU2VyaWVzLnByb3RvdHlwZS5zZXREYXRhTGFiZWxTdGFydFBvcyIsImxhYmVsQ2VudGVyIiwiaGFsZldpZHRoIiwic3RhcnRYUG9zIiwic3RhcnRZUG9zIiwiU2VyaWVzLnByb3RvdHlwZS5qdXN0aWZ5RGF0YUxhYmVsIiwib2ZmIiwianVzdGlmaWVkIiwicmFkaWFsRGlzdHJpYnV0aW9uWSIsInJhZGlhbERpc3RyaWJ1dGlvblgiLCJzZXJpZXNDZW50ZXIiLCJhbGlnblRvUGxvdEVkZ2VzIiwiZGF0YUxhYmVsV2lkdGgiLCJoYWxmIiwiYWxpZ25Ub0Nvbm5lY3RvcnMiLCJtYXhEYXRhTGFiZWxXaWR0aCIsInNlcmllc1R5cGVzLnBpZS5wcm90b3R5cGUuZHJhd0RhdGFMYWJlbHMiLCJtYXhXaWR0aCIsImNlbnRlclkiLCJoYWx2ZXMiLCJkYXRhTGFiZWxQb3NpdGlvbmVycyIsInBvaW50RGF0YUxhYmVsc09wdGlvbnMiLCJkaXN0cmlidXRpb25MZW5ndGgiLCJuYXR1cmFsWSIsImxhYmVsSGVpZ2h0Iiwic2lkZU92ZXJmbG93IiwiY29ubmVjdG9yV2lkdGgiLCJzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLnBsYWNlRGF0YUxhYmVscyIsIl9wb3MiLCJzZXJpZXNUeXBlcy5waWUucHJvdG90eXBlLnZlcmlmeURhdGFMYWJlbE92ZXJmbG93IiwibWluU2l6ZSIsIm5ld1NpemUiLCJzZXJpZXNUeXBlcy5jb2x1bW4ucHJvdG90eXBlLmFsaWduRGF0YUxhYmVsIiwiZGxCb3giLCJiZWxvdyIsImluc2lkZSIsIm92ZXJzaG9vdCIsImNvbGxlY3RBbmRIaWRlIiwiY29sbGVjdG9yIiwiZGxPcHRpb25zIiwiaGlkZU92ZXJsYXBwaW5nTGFiZWxzIiwiQ2hhcnQucHJvdG90eXBlLmhpZGVPdmVybGFwcGluZ0xhYmVscyIsImlzTGFiZWxBZmZlY3RlZCIsImdldEFic29sdXRlQm94IiwiYWxpZ25WYWx1ZSIsImxhYmVsMSIsImxhYmVsMiIsImJveDEiLCJib3gyIiwibmV3T3BhY2l0eSIsIkNoYXJ0LnByb3RvdHlwZS5zZXRSZXNwb25zaXZlIiwicnVsZUlkcyIsImN1cnJlbnRSZXNwb25zaXZlIiwicnVsZSIsIm1lcmdlZE9wdGlvbnMiLCJ1bmRvT3B0aW9ucyIsIkNoYXJ0LnByb3RvdHlwZS5tYXRjaFJlc3BvbnNpdmVSdWxlIiwiY29uZGl0aW9uIiwibWF0Y2hlcyIsIkNoYXJ0LnByb3RvdHlwZS5jdXJyZW50T3B0aW9ucyIsImdldEN1cnJlbnQiLCJjdXJyIiwiSGlnaGNoYXJ0cyIsIlV0aWxpdGllcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQVFDLFdBQVMsQ0FBVCxFQUFTLENBQVQsRUFBeUI7QUFDdEIsV0FBa0NBLE9BQWxDLFdBQ0lDLGVBQXFCQSxDQUFyQkEsRUFDQSxpQkFBaUJDLGFBQ2JELEVBRGFDLENBQ2JELENBRGFDLEdBRnJCLEtBS08sUUFDSEMsbUNBQWdDLFlBQVk7QUFDeEMsV0FBT0YsRUFEaUMsQ0FDakNBLENBQVA7QUFGRCxHQUNIRTtBQUFBQSxrR0FERyxJQUtDRCxDQUxELENBTFA7QUFESCxHQWdCQyx5Q0FoQkQsTUFnQmdELFVBQVMsQ0FBVCxFQUFlO0FBRTVERSxXQUFTQSxDQUFUQSxDQUF3QixDQUF4QkEsRUFBd0IsQ0FBeEJBLEVBQXdCLENBQXhCQSxFQUF3QixDQUF4QkEsRUFBOEM7QUFDckNDLHFCQUFMLENBQUtBLE1BQ0RBLEVBREosQ0FDSUEsSUFB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QXRCRDtBQUNBQSxpQkFBc0JDLFVBQXRCRDtBQUNBQSxhQUFrQkMsTUFBbEJEO0FBQ0FBLGNBQW1CQyxPQUFuQkQ7QUFDQUEsOEJBQW1DQyx1QkFBbkNEO0FBQ0FBLHFCQUEwQkMsY0FBMUJEO0FBQ0FBLG1CQUF3QkMsWUFBeEJEO0FBQ0FBLGVBQW9CQyxRQUFwQkQ7QUFDQUEsWUFBaUJDLEtBQWpCRDtBQUNBQSxhQUFrQkMsTUFBbEJEO0FBQ0FBLGFBQWtCQyxNQUFsQkQ7QUFDQUEsdUJBQTRCQyxnQkFBNUJEO0FBQ0FBLG9CQUF5QkMsYUFBekJEO0FBQ0FBLGNBQW1CQyxPQUFuQkQ7S0FDQTF6RSxXLEdBQXdCMnpFLFk7QUFDeEJELG9CQUF5QkMsYUFBekJEO0FBQ0FBLGtCQUF1QkMsV0FBdkJEO0FBQ0FBLGtCQUF1QkMsV0FBdkJEO0FBQ0FBLHFCQUEwQkMsY0FBMUJEO0FBQ0FBLGFBQWtCQyxNQUFsQkQ7QUFHQUEsWUFBaUJseUUsQ0FBakJreUU7QUFDQUEsZUFBb0I3bEIsQ0FBcEI2bEI7QUFHQSxXQXhEeU8sQ0F3RHpPO0FBeERKO0FBMERBM2hGLDRDQUFpREEsQ0FBakRBO0FBQ0EsU0FBT0EsRUE1bzZDcUQsMkJBNG82Q3JEQSxDQUFQO0FBNXA2Q0giLCJmaWxlIjoiNjAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiBIaWdoY2hhcnRzIEpTIHY5LjAuMSAoMjAyMS0wMi0xNSlcblxuIChjKSAyMDA5LTIwMjEgVG9yc3RlaW4gSG9uc2lcblxuIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4qL1xuKGZ1bmN0aW9uKFcsUCl7XCJvYmplY3RcIj09PXR5cGVvZiBtb2R1bGUmJm1vZHVsZS5leHBvcnRzPyhQW1wiZGVmYXVsdFwiXT1QLG1vZHVsZS5leHBvcnRzPVcuZG9jdW1lbnQ/UChXKTpQKTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImhpZ2hjaGFydHMvaGlnaGNoYXJ0c1wiLGZ1bmN0aW9uKCl7cmV0dXJuIFAoVyl9KTooVy5IaWdoY2hhcnRzJiZXLkhpZ2hjaGFydHMuZXJyb3IoMTYsITApLFcuSGlnaGNoYXJ0cz1QKFcpKX0pKFwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93P3dpbmRvdzp0aGlzLGZ1bmN0aW9uKFcpe2Z1bmN0aW9uIFAoZixkLGsseCl7Zi5oYXNPd25Qcm9wZXJ0eShkKXx8KGZbZF09eC5hcHBseShudWxsLGspKX12YXIgaz17fTtQKGssXCJDb3JlL0dsb2JhbHMuanNcIixbXSxmdW5jdGlvbigpe3ZhciBmPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgVz9XOlwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93P3dpbmRvdzp7fSxkPWYuZG9jdW1lbnQsXG5rPWYubmF2aWdhdG9yJiZmLm5hdmlnYXRvci51c2VyQWdlbnR8fFwiXCIseD1kJiZkLmNyZWF0ZUVsZW1lbnROUyYmISFkLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXCJzdmdcIikuY3JlYXRlU1ZHUmVjdCxCPS8oZWRnZXxtc2llfHRyaWRlbnQpL2kudGVzdChrKSYmIWYub3BlcmEsRz0tMSE9PWsuaW5kZXhPZihcIkZpcmVmb3hcIiksRD0tMSE9PWsuaW5kZXhPZihcIkNocm9tZVwiKSxIPUcmJjQ+cGFyc2VJbnQoay5zcGxpdChcIkZpcmVmb3gvXCIpWzFdLDEwKSx0PWZ1bmN0aW9uKCl7fTtyZXR1cm57cHJvZHVjdDpcIkhpZ2hjaGFydHNcIix2ZXJzaW9uOlwiOS4wLjFcIixkZWcycmFkOjIqTWF0aC5QSS8zNjAsZG9jOmQsaGFzQmlkaUJ1ZzpILGhhc1RvdWNoOiEhZi5Ub3VjaEV2ZW50LGlzTVM6Qixpc1dlYktpdDotMSE9PWsuaW5kZXhPZihcIkFwcGxlV2ViS2l0XCIpLGlzRmlyZWZveDpHLGlzQ2hyb21lOkQsaXNTYWZhcmk6IUQmJi0xIT09ay5pbmRleE9mKFwiU2FmYXJpXCIpLFxuaXNUb3VjaERldmljZTovKE1vYmlsZXxBbmRyb2lkfFdpbmRvd3MgUGhvbmUpLy50ZXN0KGspLFNWR19OUzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsY2hhcnRDb3VudDowLHNlcmllc1R5cGVzOnt9LHN1cHBvcnRzUGFzc2l2ZUV2ZW50czpmdW5jdGlvbigpe3ZhciBDPSExO2lmKCFCKXt2YXIgbD1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJwYXNzaXZlXCIse2dldDpmdW5jdGlvbigpe0M9ITB9fSk7Zi5hZGRFdmVudExpc3RlbmVyJiZmLnJlbW92ZUV2ZW50TGlzdGVuZXImJihmLmFkZEV2ZW50TGlzdGVuZXIoXCJ0ZXN0UGFzc2l2ZVwiLHQsbCksZi5yZW1vdmVFdmVudExpc3RlbmVyKFwidGVzdFBhc3NpdmVcIix0LGwpKX1yZXR1cm4gQ30oKSxzeW1ib2xTaXplczp7fSxzdmc6eCx3aW46ZixtYXJnaW5OYW1lczpbXCJwbG90VG9wXCIsXCJtYXJnaW5SaWdodFwiLFwibWFyZ2luQm90dG9tXCIsXCJwbG90TGVmdFwiXSxub29wOnQsY2hhcnRzOltdLGRhdGVGb3JtYXRzOnt9fX0pO1AoayxcIkNvcmUvVXRpbGl0aWVzLmpzXCIsXG5ba1tcIkNvcmUvR2xvYmFscy5qc1wiXV0sZnVuY3Rpb24oZil7ZnVuY3Rpb24gZChhLGMsdixMKXt2YXIgcD1jP1wiSGlnaGNoYXJ0cyBlcnJvclwiOlwiSGlnaGNoYXJ0cyB3YXJuaW5nXCI7MzI9PT1hJiYoYT1wK1wiOiBEZXByZWNhdGVkIG1lbWJlclwiKTt2YXIgSz1sKGEpLGg9Sz9wK1wiICNcIithK1wiOiB3d3cuaGlnaGNoYXJ0cy5jb20vZXJyb3JzL1wiK2ErXCIvXCI6YS50b1N0cmluZygpO3A9ZnVuY3Rpb24oKXtpZihjKXRocm93IEVycm9yKGgpO2IuY29uc29sZSYmLTE9PT1kLm1lc3NhZ2VzLmluZGV4T2YoaCkmJmNvbnNvbGUud2FybihoKX07aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBMKXt2YXIgZz1cIlwiO0smJihoKz1cIj9cIik7bShMLGZ1bmN0aW9uKHAsYSl7Zys9XCJcXG4gLSBcIithK1wiOiBcIitwO0smJihoKz1lbmNvZGVVUkkoYSkrXCI9XCIrZW5jb2RlVVJJKHApKX0pO2grPWd9dj9lKHYsXCJkaXNwbGF5RXJyb3JcIix7Y29kZTphLG1lc3NhZ2U6aCxwYXJhbXM6TH0scCk6cCgpO2QubWVzc2FnZXMucHVzaChoKX1cbmZ1bmN0aW9uIGsoKXt2YXIgYSxiPWFyZ3VtZW50cyx2PXt9LEw9ZnVuY3Rpb24ocCxhKXtcIm9iamVjdFwiIT09dHlwZW9mIHAmJihwPXt9KTttKGEsZnVuY3Rpb24oYix1KXtcIl9fcHJvdG9fX1wiIT09dSYmXCJjb25zdHJ1Y3RvclwiIT09dSYmKCFIKGIsITApfHxDKGIpfHx0KGIpP3BbdV09YVt1XTpwW3VdPUwocFt1XXx8e30sYikpfSk7cmV0dXJuIHB9OyEwPT09YlswXSYmKHY9YlsxXSxiPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGIsMikpO3ZhciBwPWIubGVuZ3RoO2ZvcihhPTA7YTxwO2ErKyl2PUwodixiW2FdKTtyZXR1cm4gdn1mdW5jdGlvbiB4KGEsYil7dmFyIHY9e307bShhLGZ1bmN0aW9uKEwscCl7aWYoSChhW3BdLCEwKSYmIWEubm9kZVR5cGUmJmJbcF0pTD14KGFbcF0sYltwXSksT2JqZWN0LmtleXMoTCkubGVuZ3RoJiYodltwXT1MKTtlbHNlIGlmKEgoYVtwXSl8fGFbcF0hPT1iW3BdKXZbcF09YVtwXX0pO3JldHVybiB2fWZ1bmN0aW9uIEIoYSxiKXtyZXR1cm4gcGFyc2VJbnQoYSxcbmJ8fDEwKX1mdW5jdGlvbiBHKGEpe3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYX1mdW5jdGlvbiBEKGEpe2E9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpO3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PWF8fFwiW29iamVjdCBBcnJheSBJdGVyYXRvcl1cIj09PWF9ZnVuY3Rpb24gSChhLGIpe3JldHVybiEhYSYmXCJvYmplY3RcIj09PXR5cGVvZiBhJiYoIWJ8fCFEKGEpKX1mdW5jdGlvbiB0KGEpe3JldHVybiBIKGEpJiZcIm51bWJlclwiPT09dHlwZW9mIGEubm9kZVR5cGV9ZnVuY3Rpb24gQyhhKXt2YXIgYj1hJiZhLmNvbnN0cnVjdG9yO3JldHVybiEoIUgoYSwhMCl8fHQoYSl8fCFifHwhYi5uYW1lfHxcIk9iamVjdFwiPT09Yi5uYW1lKX1mdW5jdGlvbiBsKGEpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgYSYmIWlzTmFOKGEpJiZJbmZpbml0eT5hJiYtSW5maW5pdHk8YX1mdW5jdGlvbiBFKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgYSYmbnVsbCE9PWF9ZnVuY3Rpb24gZyhhLFxuYix2KXt2YXIgTDtHKGIpP0Uodik/YS5zZXRBdHRyaWJ1dGUoYix2KTphJiZhLmdldEF0dHJpYnV0ZSYmKChMPWEuZ2V0QXR0cmlidXRlKGIpKXx8XCJjbGFzc1wiIT09Ynx8KEw9YS5nZXRBdHRyaWJ1dGUoYitcIk5hbWVcIikpKTptKGIsZnVuY3Rpb24ocCxiKXthLnNldEF0dHJpYnV0ZShiLHApfSk7cmV0dXJuIEx9ZnVuY3Rpb24geShhLGIpe3ZhciB2O2F8fChhPXt9KTtmb3IodiBpbiBiKWFbdl09Ylt2XTtyZXR1cm4gYX1mdW5jdGlvbiBjKCl7Zm9yKHZhciBhPWFyZ3VtZW50cyxiPWEubGVuZ3RoLHY9MDt2PGI7disrKXt2YXIgTD1hW3ZdO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgTCYmbnVsbCE9PUwpcmV0dXJuIEx9fWZ1bmN0aW9uIHEoYSxiKXtmLmlzTVMmJiFmLnN2ZyYmYiYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiLm9wYWNpdHkmJihiLmZpbHRlcj1cImFscGhhKG9wYWNpdHk9XCIrMTAwKmIub3BhY2l0eStcIilcIik7eShhLnN0eWxlLGIpfWZ1bmN0aW9uIG4oYixlLHYsTCxwKXtiPVxuYS5jcmVhdGVFbGVtZW50KGIpO2UmJnkoYixlKTtwJiZxKGIse3BhZGRpbmc6XCIwXCIsYm9yZGVyOlwibm9uZVwiLG1hcmdpbjpcIjBcIn0pO3YmJnEoYix2KTtMJiZMLmFwcGVuZENoaWxkKGIpO3JldHVybiBifWZ1bmN0aW9uIEEoYSxiKXtyZXR1cm4gcGFyc2VGbG9hdChhLnRvUHJlY2lzaW9uKGJ8fDE0KSl9ZnVuY3Rpb24gTShhLGIsdixMKXthPSthfHwwO2I9K2I7dmFyIHA9Zi5kZWZhdWx0T3B0aW9ucy5sYW5nLEs9KGEudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV18fFwiXCIpLnNwbGl0KFwiZVwiKVswXS5sZW5ndGgsZT1hLnRvU3RyaW5nKCkuc3BsaXQoXCJlXCIpLGg9YjtpZigtMT09PWIpYj1NYXRoLm1pbihLLDIwKTtlbHNlIGlmKCFsKGIpKWI9MjtlbHNlIGlmKGImJmVbMV0mJjA+ZVsxXSl7dmFyIHU9YisgK2VbMV07MDw9dT8oZVswXT0oK2VbMF0pLnRvRXhwb25lbnRpYWwodSkuc3BsaXQoXCJlXCIpWzBdLGI9dSk6KGVbMF09ZVswXS5zcGxpdChcIi5cIilbMF18fDAsYT0yMD5iPyhlWzBdKk1hdGgucG93KDEwLFxuZVsxXSkpLnRvRml4ZWQoYik6MCxlWzFdPTApfXZhciBtPShNYXRoLmFicyhlWzFdP2VbMF06YSkrTWF0aC5wb3coMTAsLU1hdGgubWF4KGIsSyktMSkpLnRvRml4ZWQoYik7Sz1TdHJpbmcoQihtKSk7dT0zPEsubGVuZ3RoP0subGVuZ3RoJTM6MDt2PWModixwLmRlY2ltYWxQb2ludCk7TD1jKEwscC50aG91c2FuZHNTZXApO2E9KDA+YT9cIi1cIjpcIlwiKSsodT9LLnN1YnN0cigwLHUpK0w6XCJcIik7YT0wPitlWzFdJiYhaD9cIjBcIjphK0suc3Vic3RyKHUpLnJlcGxhY2UoLyhcXGR7M30pKD89XFxkKS9nLFwiJDFcIitMKTtiJiYoYSs9dittLnNsaWNlKC1iKSk7ZVsxXSYmMCE9PSthJiYoYSs9XCJlXCIrZVsxXSk7cmV0dXJuIGF9ZnVuY3Rpb24geihhLGIpe2lmKCFhKXJldHVybiBiO3ZhciB2PWEuc3BsaXQoXCIuXCIpLnJldmVyc2UoKTtpZigxPT09di5sZW5ndGgpcmV0dXJuIGJbYV07Zm9yKGE9di5wb3AoKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYiYmbnVsbCE9PVxuYjspYj1iW2FdLGE9di5wb3AoKTtyZXR1cm4gYn1mdW5jdGlvbiBtKGEsYix2KXtmb3IodmFyIGUgaW4gYSlPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChhLGUpJiZiLmNhbGwodnx8YVtlXSxhW2VdLGUsYSl9ZnVuY3Rpb24gcihhLGIsdil7ZnVuY3Rpb24gZShwLGIpe3ZhciB1PWEucmVtb3ZlRXZlbnRMaXN0ZW5lcnx8Zi5yZW1vdmVFdmVudExpc3RlbmVyUG9seWZpbGw7dSYmdS5jYWxsKGEscCxiLCExKX1mdW5jdGlvbiBwKHApe3ZhciB1O2lmKGEubm9kZU5hbWUpe2lmKGIpe3ZhciB2PXt9O3ZbYl09ITB9ZWxzZSB2PXA7bSh2LGZ1bmN0aW9uKGEsYil7aWYocFtiXSlmb3IodT1wW2JdLmxlbmd0aDt1LS07KWUoYixwW2JdW3VdLmZuKX0pfX12YXIgSz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgYSYmYS5wcm90b3R5cGV8fGE7aWYoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoSyxcImhjRXZlbnRzXCIpKXt2YXIgaD1LLmhjRXZlbnRzO2I/KEs9aFtiXXx8W10sdj8oaFtiXT1LLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gdiE9PVxuYS5mbn0pLGUoYix2KSk6KHAoaCksaFtiXT1bXSkpOihwKGgpLGRlbGV0ZSBLLmhjRXZlbnRzKX19ZnVuY3Rpb24gZShiLGUsdixMKXt2PXZ8fHt9O2lmKGEuY3JlYXRlRXZlbnQmJihiLmRpc3BhdGNoRXZlbnR8fGIuZmlyZUV2ZW50KSl7dmFyIHA9YS5jcmVhdGVFdmVudChcIkV2ZW50c1wiKTtwLmluaXRFdmVudChlLCEwLCEwKTt5KHAsdik7Yi5kaXNwYXRjaEV2ZW50P2IuZGlzcGF0Y2hFdmVudChwKTpiLmZpcmVFdmVudChlLHApfWVsc2UgaWYoYi5oY0V2ZW50cyl7di50YXJnZXR8fHkodix7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt2LmRlZmF1bHRQcmV2ZW50ZWQ9ITB9LHRhcmdldDpiLHR5cGU6ZX0pO3A9W107Zm9yKHZhciBLPWIsaD0hMTtLLmhjRXZlbnRzOylPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChLLFwiaGNFdmVudHNcIikmJksuaGNFdmVudHNbZV0mJihwLmxlbmd0aCYmKGg9ITApLHAudW5zaGlmdC5hcHBseShwLEsuaGNFdmVudHNbZV0pKSxLPU9iamVjdC5nZXRQcm90b3R5cGVPZihLKTtcbmgmJnAuc29ydChmdW5jdGlvbihhLHApe3JldHVybiBhLm9yZGVyLXAub3JkZXJ9KTtwLmZvckVhY2goZnVuY3Rpb24oYSl7ITE9PT1hLmZuLmNhbGwoYix2KSYmdi5wcmV2ZW50RGVmYXVsdCgpfSl9TCYmIXYuZGVmYXVsdFByZXZlbnRlZCYmTC5jYWxsKGIsdil9dmFyIGg9Zi5jaGFydHMsYT1mLmRvYyxiPWYud2luO1wiXCI7KGR8fChkPXt9KSkubWVzc2FnZXM9W107dmFyIHc7TWF0aC5lYXNlSW5PdXRTaW5lPWZ1bmN0aW9uKGEpe3JldHVybi0uNSooTWF0aC5jb3MoTWF0aC5QSSphKS0xKX07dmFyIEo9QXJyYXkucHJvdG90eXBlLmZpbmQ/ZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5maW5kKGIpfTpmdW5jdGlvbihhLGIpe3ZhciB2LGU9YS5sZW5ndGg7Zm9yKHY9MDt2PGU7disrKWlmKGIoYVt2XSx2KSlyZXR1cm4gYVt2XX07bSh7bWFwOlwibWFwXCIsZWFjaDpcImZvckVhY2hcIixncmVwOlwiZmlsdGVyXCIscmVkdWNlOlwicmVkdWNlXCIsc29tZTpcInNvbWVcIn0sZnVuY3Rpb24oYSxiKXtmW2JdPVxuZnVuY3Rpb24odil7dmFyIGU7ZCgzMiwhMSx2b2lkIDAsKGU9e30sZVtcIkhpZ2hjaGFydHMuXCIrYl09XCJ1c2UgQXJyYXkuXCIrYSxlKSk7cmV0dXJuIEFycmF5LnByb3RvdHlwZVthXS5hcHBseSh2LFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX19KTt2YXIgTyxGPWZ1bmN0aW9uKCl7dmFyIGE9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIsOSkrXCItXCIsYj0wO3JldHVybiBmdW5jdGlvbigpe3JldHVyblwiaGlnaGNoYXJ0cy1cIisoTz9cIlwiOmEpK2IrK319KCksTj1mLmdldE9wdGlvbnM9ZnVuY3Rpb24oKXtyZXR1cm4gZi5kZWZhdWx0T3B0aW9uc30sUj1mLnNldE9wdGlvbnM9ZnVuY3Rpb24oYSl7Zi5kZWZhdWx0T3B0aW9ucz1rKCEwLGYuZGVmYXVsdE9wdGlvbnMsYSk7KGEudGltZXx8YS5nbG9iYWwpJiZmLnRpbWUudXBkYXRlKGsoZi5kZWZhdWx0T3B0aW9ucy5nbG9iYWwsZi5kZWZhdWx0T3B0aW9ucy50aW1lLGEuZ2xvYmFsLGEudGltZSkpO3JldHVybiBmLmRlZmF1bHRPcHRpb25zfTtcbmIualF1ZXJ5JiYoYi5qUXVlcnkuZm4uaGlnaGNoYXJ0cz1mdW5jdGlvbigpe3ZhciBhPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtpZih0aGlzWzBdKXJldHVybiBhWzBdPyhuZXcgKGZbRyhhWzBdKT9hLnNoaWZ0KCk6XCJDaGFydFwiXSkodGhpc1swXSxhWzBdLGFbMV0pLHRoaXMpOmhbZyh0aGlzWzBdLFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpXX0pO3JldHVybnthZGRFdmVudDpmdW5jdGlvbihhLGIsdixlKXt2b2lkIDA9PT1lJiYoZT17fSk7dmFyIHA9XCJmdW5jdGlvblwiPT09dHlwZW9mIGEmJmEucHJvdG90eXBlfHxhO09iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKHAsXCJoY0V2ZW50c1wiKXx8KHAuaGNFdmVudHM9e30pO3A9cC5oY0V2ZW50cztmLlBvaW50JiZhIGluc3RhbmNlb2YgZi5Qb2ludCYmYS5zZXJpZXMmJmEuc2VyaWVzLmNoYXJ0JiYoYS5zZXJpZXMuY2hhcnQucnVuVHJhY2tlckNsaWNrPSEwKTt2YXIgSz1hLmFkZEV2ZW50TGlzdGVuZXJ8fGYuYWRkRXZlbnRMaXN0ZW5lclBvbHlmaWxsO1xuSyYmSy5jYWxsKGEsYix2LGYuc3VwcG9ydHNQYXNzaXZlRXZlbnRzP3twYXNzaXZlOnZvaWQgMD09PWUucGFzc2l2ZT8tMSE9PWIuaW5kZXhPZihcInRvdWNoXCIpOmUucGFzc2l2ZSxjYXB0dXJlOiExfTohMSk7cFtiXXx8KHBbYl09W10pO3BbYl0ucHVzaCh7Zm46dixvcmRlcjpcIm51bWJlclwiPT09dHlwZW9mIGUub3JkZXI/ZS5vcmRlcjpJbmZpbml0eX0pO3BbYl0uc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLm9yZGVyLWIub3JkZXJ9KTtyZXR1cm4gZnVuY3Rpb24oKXtyKGEsYix2KX19LGFycmF5TWF4OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1hLmxlbmd0aCx2PWFbMF07Yi0tOylhW2JdPnYmJih2PWFbYl0pO3JldHVybiB2fSxhcnJheU1pbjpmdW5jdGlvbihhKXtmb3IodmFyIGI9YS5sZW5ndGgsdj1hWzBdO2ItLTspYVtiXTx2JiYodj1hW2JdKTtyZXR1cm4gdn0sYXR0cjpnLGNsYW1wOmZ1bmN0aW9uKGEsYix2KXtyZXR1cm4gYT5iP2E8dj9hOnY6Yn0sY2xlYW5SZWN1cnNpdmVseTp4LFxuY2xlYXJUaW1lb3V0OmZ1bmN0aW9uKGEpe0UoYSkmJmNsZWFyVGltZW91dChhKX0sY29ycmVjdEZsb2F0OkEsY3JlYXRlRWxlbWVudDpuLGNzczpxLGRlZmluZWQ6RSxkZXN0cm95T2JqZWN0UHJvcGVydGllczpmdW5jdGlvbihhLGIpe20oYSxmdW5jdGlvbih2LGUpe3YmJnYhPT1iJiZ2LmRlc3Ryb3kmJnYuZGVzdHJveSgpO2RlbGV0ZSBhW2VdfSl9LGRpc2NhcmRFbGVtZW50OmZ1bmN0aW9uKGEpe3d8fCh3PW4oXCJkaXZcIikpO2EmJncuYXBwZW5kQ2hpbGQoYSk7dy5pbm5lckhUTUw9XCJcIn0sZXJhc2U6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIHY9YS5sZW5ndGg7di0tOylpZihhW3ZdPT09Yil7YS5zcGxpY2UodiwxKTticmVha319LGVycm9yOmQsZXh0ZW5kOnksZXh0ZW5kQ2xhc3M6ZnVuY3Rpb24oYSxiKXt2YXIgdj1mdW5jdGlvbigpe307di5wcm90b3R5cGU9bmV3IGE7eSh2LnByb3RvdHlwZSxiKTtyZXR1cm4gdn0sZmluZDpKLGZpcmVFdmVudDplLGZvcm1hdDpmdW5jdGlvbihhLFxuYix2KXt2YXIgZT1cIntcIixwPSExLEs9W10saD0vZiQvLGM9L1xcLihbMC05XSkvLHU9Zi5kZWZhdWx0T3B0aW9ucy5sYW5nLG09diYmdi50aW1lfHxmLnRpbWU7Zm9yKHY9diYmdi5udW1iZXJGb3JtYXR0ZXJ8fE07YTspe3ZhciBJPWEuaW5kZXhPZihlKTtpZigtMT09PUkpYnJlYWs7dmFyIGc9YS5zbGljZSgwLEkpO2lmKHApe2c9Zy5zcGxpdChcIjpcIik7ZT16KGcuc2hpZnQoKXx8XCJcIixiKTtpZihnLmxlbmd0aCYmXCJudW1iZXJcIj09PXR5cGVvZiBlKWlmKGc9Zy5qb2luKFwiOlwiKSxoLnRlc3QoZykpe3ZhciB3PXBhcnNlSW50KChnLm1hdGNoKGMpfHxbXCJcIixcIi0xXCJdKVsxXSwxMCk7bnVsbCE9PWUmJihlPXYoZSx3LHUuZGVjaW1hbFBvaW50LC0xPGcuaW5kZXhPZihcIixcIik/dS50aG91c2FuZHNTZXA6XCJcIikpfWVsc2UgZT1tLmRhdGVGb3JtYXQoZyxlKTtLLnB1c2goZSl9ZWxzZSBLLnB1c2goZyk7YT1hLnNsaWNlKEkrMSk7ZT0ocD0hcCk/XCJ9XCI6XCJ7XCJ9Sy5wdXNoKGEpO3JldHVybiBLLmpvaW4oXCJcIil9LFxuZ2V0TWFnbml0dWRlOmZ1bmN0aW9uKGEpe3JldHVybiBNYXRoLnBvdygxMCxNYXRoLmZsb29yKE1hdGgubG9nKGEpL01hdGguTE4xMCkpfSxnZXROZXN0ZWRQcm9wZXJ0eTp6LGdldE9wdGlvbnM6TixnZXRTdHlsZTpmdW5jdGlvbihhLGUsdil7aWYoXCJ3aWR0aFwiPT09ZSlyZXR1cm4gZT1NYXRoLm1pbihhLm9mZnNldFdpZHRoLGEuc2Nyb2xsV2lkdGgpLHY9YS5nZXRCb3VuZGluZ0NsaWVudFJlY3QmJmEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsdjxlJiZ2Pj1lLTEmJihlPU1hdGguZmxvb3IodikpLE1hdGgubWF4KDAsZS1mLmdldFN0eWxlKGEsXCJwYWRkaW5nLWxlZnRcIiktZi5nZXRTdHlsZShhLFwicGFkZGluZy1yaWdodFwiKSk7aWYoXCJoZWlnaHRcIj09PWUpcmV0dXJuIE1hdGgubWF4KDAsTWF0aC5taW4oYS5vZmZzZXRIZWlnaHQsYS5zY3JvbGxIZWlnaHQpLWYuZ2V0U3R5bGUoYSxcInBhZGRpbmctdG9wXCIpLWYuZ2V0U3R5bGUoYSxcInBhZGRpbmctYm90dG9tXCIpKTtiLmdldENvbXB1dGVkU3R5bGV8fFxuZCgyNywhMCk7aWYoYT1iLmdldENvbXB1dGVkU3R5bGUoYSx2b2lkIDApKWE9YS5nZXRQcm9wZXJ0eVZhbHVlKGUpLGModixcIm9wYWNpdHlcIiE9PWUpJiYoYT1CKGEpKTtyZXR1cm4gYX0saW5BcnJheTpmdW5jdGlvbihhLGIsdil7ZCgzMiwhMSx2b2lkIDAse1wiSGlnaGNoYXJ0cy5pbkFycmF5XCI6XCJ1c2UgQXJyYXkuaW5kZXhPZlwifSk7cmV0dXJuIGIuaW5kZXhPZihhLHYpfSxpc0FycmF5OkQsaXNDbGFzczpDLGlzRE9NRWxlbWVudDp0LGlzRnVuY3Rpb246ZnVuY3Rpb24oYSl7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGF9LGlzTnVtYmVyOmwsaXNPYmplY3Q6SCxpc1N0cmluZzpHLGtleXM6ZnVuY3Rpb24oYSl7ZCgzMiwhMSx2b2lkIDAse1wiSGlnaGNoYXJ0cy5rZXlzXCI6XCJ1c2UgT2JqZWN0LmtleXNcIn0pO3JldHVybiBPYmplY3Qua2V5cyhhKX0sbWVyZ2U6ayxub3JtYWxpemVUaWNrSW50ZXJ2YWw6ZnVuY3Rpb24oYSxiLHYsZSxwKXt2YXIgSz1hO3Y9Yyh2LDEpO3ZhciBoPWEvXG52O2J8fChiPXA/WzEsMS4yLDEuNSwyLDIuNSwzLDQsNSw2LDgsMTBdOlsxLDIsMi41LDUsMTBdLCExPT09ZSYmKDE9PT12P2I9Yi5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIDA9PT1hJTF9KTouMT49diYmKGI9WzEvdl0pKSk7Zm9yKGU9MDtlPGIubGVuZ3RoJiYhKEs9YltlXSxwJiZLKnY+PWF8fCFwJiZoPD0oYltlXSsoYltlKzFdfHxiW2VdKSkvMik7ZSsrKTtyZXR1cm4gSz1BKEsqdiwtTWF0aC5yb3VuZChNYXRoLmxvZyguMDAxKS9NYXRoLkxOMTApKX0sbnVtYmVyRm9ybWF0Ok0sb2JqZWN0RWFjaDptLG9mZnNldDpmdW5jdGlvbihlKXt2YXIgaD1hLmRvY3VtZW50RWxlbWVudDtlPWUucGFyZW50RWxlbWVudHx8ZS5wYXJlbnROb2RlP2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk6e3RvcDowLGxlZnQ6MCx3aWR0aDowLGhlaWdodDowfTtyZXR1cm57dG9wOmUudG9wKyhiLnBhZ2VZT2Zmc2V0fHxoLnNjcm9sbFRvcCktKGguY2xpZW50VG9wfHwwKSxsZWZ0OmUubGVmdCsoYi5wYWdlWE9mZnNldHx8XG5oLnNjcm9sbExlZnQpLShoLmNsaWVudExlZnR8fDApLHdpZHRoOmUud2lkdGgsaGVpZ2h0OmUuaGVpZ2h0fX0scGFkOmZ1bmN0aW9uKGEsYix2KXtyZXR1cm4gQXJyYXkoKGJ8fDIpKzEtU3RyaW5nKGEpLnJlcGxhY2UoXCItXCIsXCJcIikubGVuZ3RoKS5qb2luKHZ8fFwiMFwiKSthfSxwaWNrOmMscEludDpCLHJlbGF0aXZlTGVuZ3RoOmZ1bmN0aW9uKGEsYix2KXtyZXR1cm4vJSQvLnRlc3QoYSk/YipwYXJzZUZsb2F0KGEpLzEwMCsodnx8MCk6cGFyc2VGbG9hdChhKX0scmVtb3ZlRXZlbnQ6cixzZXRPcHRpb25zOlIsc3BsYXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIEQoYSk/YTpbYV19LHN0YWJsZVNvcnQ6ZnVuY3Rpb24oYSxiKXt2YXIgdj1hLmxlbmd0aCxlLHA7Zm9yKHA9MDtwPHY7cCsrKWFbcF0uc2FmZUk9cDthLnNvcnQoZnVuY3Rpb24oYSxwKXtlPWIoYSxwKTtyZXR1cm4gMD09PWU/YS5zYWZlSS1wLnNhZmVJOmV9KTtmb3IocD0wO3A8djtwKyspZGVsZXRlIGFbcF0uc2FmZUl9LHN5bmNUaW1lb3V0OmZ1bmN0aW9uKGEsXG5iLHYpe2lmKDA8YilyZXR1cm4gc2V0VGltZW91dChhLGIsdik7YS5jYWxsKDAsdik7cmV0dXJuLTF9LHRpbWVVbml0czp7bWlsbGlzZWNvbmQ6MSxzZWNvbmQ6MUUzLG1pbnV0ZTo2RTQsaG91cjozNkU1LGRheTo4NjRFNSx3ZWVrOjYwNDhFNSxtb250aDoyNDE5MkU1LHllYXI6MzE0NDk2RTV9LHVuaXF1ZUtleTpGLHVzZVNlcmlhbElkczpmdW5jdGlvbihhKXtyZXR1cm4gTz1jKGEsTyl9LHdyYXA6ZnVuY3Rpb24oYSxiLHYpe3ZhciBlPWFbYl07YVtiXT1mdW5jdGlvbigpe3ZhciBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyksYj1hcmd1bWVudHMsaD10aGlzO2gucHJvY2VlZD1mdW5jdGlvbigpe2UuYXBwbHkoaCxhcmd1bWVudHMubGVuZ3RoP2FyZ3VtZW50czpiKX07YS51bnNoaWZ0KGUpO2E9di5hcHBseSh0aGlzLGEpO2gucHJvY2VlZD1udWxsO3JldHVybiBhfX19fSk7UChrLFwiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiLFtrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLFxua1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQpe3ZhciBrPWYuU1ZHX05TLHg9ZC5hdHRyLEI9ZC5jcmVhdGVFbGVtZW50LEc9ZC5kaXNjYXJkRWxlbWVudCxEPWQuZXJyb3IsSD1kLmlzU3RyaW5nLHQ9ZC5vYmplY3RFYWNoLEM9ZC5zcGxhdDtcIlwiO3ZhciBsPSExO3RyeXtsPSEhKG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhcIlwiLFwidGV4dC9odG1sXCIpfWNhdGNoKEUpe31yZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBFKGcpe3RoaXMubm9kZXM9XCJzdHJpbmdcIj09PXR5cGVvZiBnP3RoaXMucGFyc2VNYXJrdXAoZyk6Z31FLmZpbHRlclVzZXJBdHRyaWJ1dGVzPWZ1bmN0aW9uKGcpe3QoZyxmdW5jdGlvbih5LGMpe3ZhciBxPSEwOy0xPT09RS5hbGxvd2VkQXR0cmlidXRlcy5pbmRleE9mKGMpJiYocT0hMSk7LTEhPT1bXCJiYWNrZ3JvdW5kXCIsXCJkeW5zcmNcIixcImhyZWZcIixcImxvd3NyY1wiLFwic3JjXCJdLmluZGV4T2YoYykmJihxPUgoeSkmJkUuYWxsb3dlZFJlZmVyZW5jZXMuc29tZShmdW5jdGlvbihjKXtyZXR1cm4gMD09PVxueS5pbmRleE9mKGMpfSkpO3F8fChEKFwiSGlnaGNoYXJ0cyB3YXJuaW5nOiBJbnZhbGlkIGF0dHJpYnV0ZSAnXCIrYytcIicgaW4gY29uZmlnXCIpLGRlbGV0ZSBnW2NdKX0pO3JldHVybiBnfTtFLnNldEVsZW1lbnRIVE1MPWZ1bmN0aW9uKGcseSl7Zy5pbm5lckhUTUw9XCJcIjt5JiYobmV3IEUoeSkpLmFkZFRvRE9NKGcpfTtFLnByb3RvdHlwZS5hZGRUb0RPTT1mdW5jdGlvbihnKXtmdW5jdGlvbiB5KGMsZyl7dmFyIG47QyhjKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBxPWMudGFnTmFtZSxBPWMudGV4dENvbnRlbnQ/Zi5kb2MuY3JlYXRlVGV4dE5vZGUoYy50ZXh0Q29udGVudCk6dm9pZCAwO2lmKHEpaWYoXCIjdGV4dFwiPT09cSl2YXIgbT1BO2Vsc2UgaWYoLTEhPT1FLmFsbG93ZWRUYWdzLmluZGV4T2YocSkpe3E9Zi5kb2MuY3JlYXRlRWxlbWVudE5TKFwic3ZnXCI9PT1xP2s6Zy5uYW1lc3BhY2VVUkl8fGsscSk7dmFyIHI9Yy5hdHRyaWJ1dGVzfHx7fTt0KGMsZnVuY3Rpb24oZSxoKXtcInRhZ05hbWVcIiE9PVxuaCYmXCJhdHRyaWJ1dGVzXCIhPT1oJiZcImNoaWxkcmVuXCIhPT1oJiZcInRleHRDb250ZW50XCIhPT1oJiYocltoXT1lKX0pO3gocSxFLmZpbHRlclVzZXJBdHRyaWJ1dGVzKHIpKTtBJiZxLmFwcGVuZENoaWxkKEEpO3koYy5jaGlsZHJlbnx8W10scSk7bT1xfWVsc2UgRChcIkhpZ2hjaGFydHMgd2FybmluZzogSW52YWxpZCB0YWdOYW1lICdcIitxK1wiJyBpbiBjb25maWdcIik7bSYmZy5hcHBlbmRDaGlsZChtKTtuPW19KTtyZXR1cm4gbn1yZXR1cm4geSh0aGlzLm5vZGVzLGcpfTtFLnByb3RvdHlwZS5wYXJzZU1hcmt1cD1mdW5jdGlvbihnKXt2YXIgeT1bXTtpZihsKWc9KG5ldyBET01QYXJzZXIpLnBhcnNlRnJvbVN0cmluZyhnLFwidGV4dC9odG1sXCIpO2Vsc2V7dmFyIGM9QihcImRpdlwiKTtjLmlubmVySFRNTD1nO2c9e2JvZHk6Y319dmFyIHE9ZnVuY3Rpb24oYyxnKXt2YXIgbj1jLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksQT17dGFnTmFtZTpufTtpZihcIiN0ZXh0XCI9PT1uKXtuPWMudGV4dENvbnRlbnR8fFxuXCJcIjtpZigvXltcXHNdKiQvLnRlc3QobikpcmV0dXJuO0EudGV4dENvbnRlbnQ9bn1pZihuPWMuYXR0cmlidXRlcyl7dmFyIG09e307W10uZm9yRWFjaC5jYWxsKG4sZnVuY3Rpb24oZSl7bVtlLm5hbWVdPWUudmFsdWV9KTtBLmF0dHJpYnV0ZXM9bX1pZihjLmNoaWxkTm9kZXMubGVuZ3RoKXt2YXIgcj1bXTtbXS5mb3JFYWNoLmNhbGwoYy5jaGlsZE5vZGVzLGZ1bmN0aW9uKGUpe3EoZSxyKX0pO3IubGVuZ3RoJiYoQS5jaGlsZHJlbj1yKX1nLnB1c2goQSl9O1tdLmZvckVhY2guY2FsbChnLmJvZHkuY2hpbGROb2RlcyxmdW5jdGlvbihjKXtyZXR1cm4gcShjLHkpfSk7YyYmRyhjKTtyZXR1cm4geX07RS5hbGxvd2VkVGFncz1cImEgYiBiciBidXR0b24gY2FwdGlvbiBjaXJjbGUgY2xpcFBhdGggY29kZSBkZCBkZWZzIGRpdiBkbCBkdCBlbSBmZUNvbXBvbmVudFRyYW5zZmVyIGZlRnVuY0EgZmVGdW5jQiBmZUZ1bmNHIGZlRnVuY1IgZmVHYXVzc2lhbkJsdXIgZmVPZmZzZXQgZmVNZXJnZSBmZU1lcmdlTm9kZSBmaWx0ZXIgaDEgaDIgaDMgaDQgaDUgaDYgaHIgaSBpbWcgbGkgbGluZWFyR3JhZGllbnQgbWFya2VyIG9sIHAgcGF0aCBwYXR0ZXJuIHByZSByZWN0IHNtYWxsIHNwYW4gc3RvcCBzdHJvbmcgc3R5bGUgc3ViIHN1cCBzdmcgdGFibGUgdGV4dCB0aGVhZCB0Ym9keSB0c3BhbiB0ZCB0aCB0ciB1bCAjdGV4dFwiLnNwbGl0KFwiIFwiKTtcbkUuYWxsb3dlZEF0dHJpYnV0ZXM9XCJhcmlhLWNvbnRyb2xzIGFyaWEtZGVzY3JpYmVkYnkgYXJpYS1leHBhbmRlZCBhcmlhLWhhc3BvcHVwIGFyaWEtaGlkZGVuIGFyaWEtbGFiZWwgYXJpYS1sYWJlbGxlZGJ5IGFyaWEtbGl2ZSBhcmlhLXByZXNzZWQgYXJpYS1yZWFkb25seSBhcmlhLXJvbGVkZXNjcmlwdGlvbiBhcmlhLXNlbGVjdGVkIGNsYXNzIGNsaXAtcGF0aCBjb2xvciBjb2xzcGFuIGN4IGN5IGQgZHggZHkgZGlzYWJsZWQgZmlsbCBoZWlnaHQgaHJlZiBpZCBpbiBtYXJrZXJIZWlnaHQgbWFya2VyV2lkdGggb2Zmc2V0IG9wYWNpdHkgb3JpZW50IHBhZGRpbmcgcGFkZGluZ0xlZnQgcGF0dGVyblVuaXRzIHIgcmVmWCByZWZZIHJvbGUgc2NvcGUgc2xvcGUgc3JjIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdHJva2Ugc3Ryb2tlLWxpbmVjYXAgc3Ryb2tlLXdpZHRoIHN0eWxlIHJlc3VsdCByb3dzcGFuIHN1bW1hcnkgdGFyZ2V0IHRhYmluZGV4IHRleHQtYWxpZ24gdGV4dEFuY2hvciB0ZXh0TGVuZ3RoIHR5cGUgdmFsaWduIHdpZHRoIHggeDEgeHkgeSB5MSB5MiB6SW5kZXhcIi5zcGxpdChcIiBcIik7XG5FLmFsbG93ZWRSZWZlcmVuY2VzPVwiaHR0cHM6Ly8gaHR0cDovLyBtYWlsdG86IC8gLi4vIC4vICNcIi5zcGxpdChcIiBcIik7cmV0dXJuIEV9KCl9KTtQKGssXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCIsW2tbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQpe3ZhciBrPWQuaXNOdW1iZXIseD1kLm1lcmdlLEI9ZC5wSW50O1wiXCI7ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGQoRCl7dGhpcy5wYXJzZXJzPVt7cmVnZXg6L3JnYmFcXChcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldezEsM30pXFxzKixcXHMqKFswLTldPyg/OlxcLlswLTldKyk/KVxccypcXCkvLHBhcnNlOmZ1bmN0aW9uKGQpe3JldHVybltCKGRbMV0pLEIoZFsyXSksQihkWzNdKSxwYXJzZUZsb2F0KGRbNF0sMTApXX19LHtyZWdleDovcmdiXFwoXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccyosXFxzKihbMC05XXsxLDN9KVxccypcXCkvLHBhcnNlOmZ1bmN0aW9uKGQpe3JldHVybltCKGRbMV0pLFxuQihkWzJdKSxCKGRbM10pLDFdfX1dO3RoaXMucmdiYT1bXTtpZihmLkNvbG9yIT09ZClyZXR1cm4gbmV3IGYuQ29sb3IoRCk7aWYoISh0aGlzIGluc3RhbmNlb2YgZCkpcmV0dXJuIG5ldyBkKEQpO3RoaXMuaW5pdChEKX1kLnBhcnNlPWZ1bmN0aW9uKGYpe3JldHVybiBuZXcgZChmKX07ZC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihmKXt2YXIgayx0O2lmKCh0aGlzLmlucHV0PWY9ZC5uYW1lc1tmJiZmLnRvTG93ZXJDYXNlP2YudG9Mb3dlckNhc2UoKTpcIlwiXXx8ZikmJmYuc3RvcHMpdGhpcy5zdG9wcz1mLnN0b3BzLm1hcChmdW5jdGlvbihsKXtyZXR1cm4gbmV3IGQobFsxXSl9KTtlbHNle2lmKGYmJmYuY2hhckF0JiZcIiNcIj09PWYuY2hhckF0KCkpe3ZhciBDPWYubGVuZ3RoO2Y9cGFyc2VJbnQoZi5zdWJzdHIoMSksMTYpOzc9PT1DP2s9WyhmJjE2NzExNjgwKT4+MTYsKGYmNjUyODApPj44LGYmMjU1LDFdOjQ9PT1DJiYoaz1bKGYmMzg0MCk+PjR8KGYmMzg0MCk+PjgsKGYmMjQwKT4+XG40fGYmMjQwLChmJjE1KTw8NHxmJjE1LDFdKX1pZighaylmb3IodD10aGlzLnBhcnNlcnMubGVuZ3RoO3QtLSYmIWs7KXt2YXIgbD10aGlzLnBhcnNlcnNbdF07KEM9bC5yZWdleC5leGVjKGYpKSYmKGs9bC5wYXJzZShDKSl9fXRoaXMucmdiYT1rfHxbXX07ZC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGQpe3ZhciBmPXRoaXMuaW5wdXQsdD10aGlzLnJnYmE7aWYoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLnN0b3BzKXt2YXIgQz14KGYpO0Muc3RvcHM9W10uY29uY2F0KEMuc3RvcHMpO3RoaXMuc3RvcHMuZm9yRWFjaChmdW5jdGlvbihsLEUpe0Muc3RvcHNbRV09W0Muc3RvcHNbRV1bMF0sbC5nZXQoZCldfSl9ZWxzZSBDPXQmJmsodFswXSk/XCJyZ2JcIj09PWR8fCFkJiYxPT09dFszXT9cInJnYihcIit0WzBdK1wiLFwiK3RbMV0rXCIsXCIrdFsyXStcIilcIjpcImFcIj09PWQ/dFszXTpcInJnYmEoXCIrdC5qb2luKFwiLFwiKStcIilcIjpmO3JldHVybiBDfTtkLnByb3RvdHlwZS5icmlnaHRlbj1mdW5jdGlvbihkKXt2YXIgZixcbnQ9dGhpcy5yZ2JhO2lmKHRoaXMuc3RvcHMpdGhpcy5zdG9wcy5mb3JFYWNoKGZ1bmN0aW9uKEMpe0MuYnJpZ2h0ZW4oZCl9KTtlbHNlIGlmKGsoZCkmJjAhPT1kKWZvcihmPTA7Mz5mO2YrKyl0W2ZdKz1CKDI1NSpkKSwwPnRbZl0mJih0W2ZdPTApLDI1NTx0W2ZdJiYodFtmXT0yNTUpO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS5zZXRPcGFjaXR5PWZ1bmN0aW9uKGQpe3RoaXMucmdiYVszXT1kO3JldHVybiB0aGlzfTtkLnByb3RvdHlwZS50d2VlblRvPWZ1bmN0aW9uKGQsZil7dmFyIHQ9dGhpcy5yZ2JhLEM9ZC5yZ2JhO0MubGVuZ3RoJiZ0JiZ0Lmxlbmd0aD8oZD0xIT09Q1szXXx8MSE9PXRbM10sZj0oZD9cInJnYmEoXCI6XCJyZ2IoXCIpK01hdGgucm91bmQoQ1swXSsodFswXS1DWzBdKSooMS1mKSkrXCIsXCIrTWF0aC5yb3VuZChDWzFdKyh0WzFdLUNbMV0pKigxLWYpKStcIixcIitNYXRoLnJvdW5kKENbMl0rKHRbMl0tQ1syXSkqKDEtZikpKyhkP1wiLFwiKyhDWzNdKyh0WzNdLUNbM10pKigxLVxuZikpOlwiXCIpK1wiKVwiKTpmPWQuaW5wdXR8fFwibm9uZVwiO3JldHVybiBmfTtkLm5hbWVzPXt3aGl0ZTpcIiNmZmZmZmZcIixibGFjazpcIiMwMDAwMDBcIn07cmV0dXJuIGR9KCk7Zi5Db2xvcj1kO2YuY29sb3I9ZC5wYXJzZTtyZXR1cm4gZH0pO1AoayxcIkNvcmUvQ29sb3IvUGFsZXR0ZS5qc1wiLFtdLGZ1bmN0aW9uKCl7cmV0dXJue2NvbG9yczpcIiM3Y2I1ZWMgIzQzNDM0OCAjOTBlZDdkICNmN2EzNWMgIzgwODVlOSAjZjE1YzgwICNlNGQzNTQgIzJiOTA4ZiAjZjQ1YjViICM5MWU4ZTFcIi5zcGxpdChcIiBcIiksYmFja2dyb3VuZENvbG9yOlwiI2ZmZmZmZlwiLG5ldXRyYWxDb2xvcjEwMDpcIiMwMDAwMDBcIixuZXV0cmFsQ29sb3I4MDpcIiMzMzMzMzNcIixuZXV0cmFsQ29sb3I2MDpcIiM2NjY2NjZcIixuZXV0cmFsQ29sb3I0MDpcIiM5OTk5OTlcIixuZXV0cmFsQ29sb3IyMDpcIiNjY2NjY2NcIixuZXV0cmFsQ29sb3IxMDpcIiNlNmU2ZTZcIixuZXV0cmFsQ29sb3I1OlwiI2YyZjJmMlwiLG5ldXRyYWxDb2xvcjM6XCIjZjdmN2Y3XCIsXG5oaWdobGlnaHRDb2xvcjEwMDpcIiMwMDMzOTlcIixoaWdobGlnaHRDb2xvcjgwOlwiIzMzNWNhZFwiLGhpZ2hsaWdodENvbG9yNjA6XCIjNjY4NWMyXCIsaGlnaGxpZ2h0Q29sb3IyMDpcIiNjY2Q2ZWJcIixoaWdobGlnaHRDb2xvcjEwOlwiI2U2ZWJmNVwiLGluZGljYXRvclBvc2l0aXZlTGluZTpcIiMwNmI1MzVcIixpbmRpY2F0b3JOZWdhdGl2ZUxpbmU6XCIjZjIxMzEzXCJ9fSk7UChrLFwiQ29yZS9BbmltYXRpb24vRnguanNcIixba1tcIkNvcmUvR2xvYmFscy5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCl7dmFyIGs9Zi53aW4seD1kLmlzTnVtYmVyLEI9ZC5vYmplY3RFYWNoO2Q9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKGQsZix0KXt0aGlzLnBvcz1OYU47dGhpcy5vcHRpb25zPWY7dGhpcy5lbGVtPWQ7dGhpcy5wcm9wPXR9ZC5wcm90b3R5cGUuZFNldHRlcj1mdW5jdGlvbigpe3ZhciBkPXRoaXMucGF0aHMsZj1kJiZkWzBdO2Q9ZCYmZFsxXTt2YXIgdD1bXSxDPXRoaXMubm93fHxcbjA7aWYoMSE9PUMmJmYmJmQpaWYoZi5sZW5ndGg9PT1kLmxlbmd0aCYmMT5DKWZvcih2YXIgbD0wO2w8ZC5sZW5ndGg7bCsrKXtmb3IodmFyIEU9ZltsXSxnPWRbbF0seT1bXSxjPTA7YzxnLmxlbmd0aDtjKyspe3ZhciBxPUVbY10sbj1nW2NdO3gocSkmJngobikmJihcIkFcIiE9PWdbMF18fDQhPT1jJiY1IT09Yyk/eVtjXT1xK0MqKG4tcSk6eVtjXT1ufXQucHVzaCh5KX1lbHNlIHQ9ZDtlbHNlIHQ9dGhpcy50b0R8fFtdO3RoaXMuZWxlbS5hdHRyKFwiZFwiLHQsdm9pZCAwLCEwKX07ZC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5lbGVtLGY9dGhpcy5wcm9wLHQ9dGhpcy5ub3csQz10aGlzLm9wdGlvbnMuc3RlcDtpZih0aGlzW2YrXCJTZXR0ZXJcIl0pdGhpc1tmK1wiU2V0dGVyXCJdKCk7ZWxzZSBkLmF0dHI/ZC5lbGVtZW50JiZkLmF0dHIoZix0LG51bGwsITApOmQuc3R5bGVbZl09dCt0aGlzLnVuaXQ7QyYmQy5jYWxsKGQsdCx0aGlzKX07ZC5wcm90b3R5cGUucnVuPVxuZnVuY3Rpb24oZixILHQpe3ZhciBDPXRoaXMsbD1DLm9wdGlvbnMsRT1mdW5jdGlvbihjKXtyZXR1cm4gRS5zdG9wcGVkPyExOkMuc3RlcChjKX0sZz1rLnJlcXVlc3RBbmltYXRpb25GcmFtZXx8ZnVuY3Rpb24oYyl7c2V0VGltZW91dChjLDEzKX0seT1mdW5jdGlvbigpe2Zvcih2YXIgYz0wO2M8ZC50aW1lcnMubGVuZ3RoO2MrKylkLnRpbWVyc1tjXSgpfHxkLnRpbWVycy5zcGxpY2UoYy0tLDEpO2QudGltZXJzLmxlbmd0aCYmZyh5KX07ZiE9PUh8fHRoaXMuZWxlbVtcImZvcmNlQW5pbWF0ZTpcIit0aGlzLnByb3BdPyh0aGlzLnN0YXJ0VGltZT0rbmV3IERhdGUsdGhpcy5zdGFydD1mLHRoaXMuZW5kPUgsdGhpcy51bml0PXQsdGhpcy5ub3c9dGhpcy5zdGFydCx0aGlzLnBvcz0wLEUuZWxlbT10aGlzLmVsZW0sRS5wcm9wPXRoaXMucHJvcCxFKCkmJjE9PT1kLnRpbWVycy5wdXNoKEUpJiZnKHkpKTooZGVsZXRlIGwuY3VyQW5pbVt0aGlzLnByb3BdLGwuY29tcGxldGUmJjA9PT1PYmplY3Qua2V5cyhsLmN1ckFuaW0pLmxlbmd0aCYmXG5sLmNvbXBsZXRlLmNhbGwodGhpcy5lbGVtKSl9O2QucHJvdG90eXBlLnN0ZXA9ZnVuY3Rpb24oZCl7dmFyIGY9K25ldyBEYXRlLHQ9dGhpcy5vcHRpb25zLEM9dGhpcy5lbGVtLGw9dC5jb21wbGV0ZSxFPXQuZHVyYXRpb24sZz10LmN1ckFuaW07aWYoQy5hdHRyJiYhQy5lbGVtZW50KWQ9ITE7ZWxzZSBpZihkfHxmPj1FK3RoaXMuc3RhcnRUaW1lKXt0aGlzLm5vdz10aGlzLmVuZDt0aGlzLnBvcz0xO3RoaXMudXBkYXRlKCk7dmFyIHk9Z1t0aGlzLnByb3BdPSEwO0IoZyxmdW5jdGlvbihjKXshMCE9PWMmJih5PSExKX0pO3kmJmwmJmwuY2FsbChDKTtkPSExfWVsc2UgdGhpcy5wb3M9dC5lYXNpbmcoKGYtdGhpcy5zdGFydFRpbWUpL0UpLHRoaXMubm93PXRoaXMuc3RhcnQrKHRoaXMuZW5kLXRoaXMuc3RhcnQpKnRoaXMucG9zLHRoaXMudXBkYXRlKCksZD0hMDtyZXR1cm4gZH07ZC5wcm90b3R5cGUuaW5pdFBhdGg9ZnVuY3Rpb24oZCxmLHQpe2Z1bmN0aW9uIEMoYyxnKXtmb3IoO2MubGVuZ3RoPFxuQTspe3ZhciBtPWNbMF0sbj1nW0EtYy5sZW5ndGhdO24mJlwiTVwiPT09bVswXSYmKGNbMF09XCJDXCI9PT1uWzBdP1tcIkNcIixtWzFdLG1bMl0sbVsxXSxtWzJdLG1bMV0sbVsyXV06W1wiTFwiLG1bMV0sbVsyXV0pO2MudW5zaGlmdChtKTt5JiZjLnB1c2goY1tjLmxlbmd0aC0xXSl9fWZ1bmN0aW9uIGwoZyxuKXtmb3IoO2cubGVuZ3RoPEE7KWlmKG49Z1tnLmxlbmd0aC9jLTFdLnNsaWNlKCksXCJDXCI9PT1uWzBdJiYoblsxXT1uWzVdLG5bMl09bls2XSkseSl7dmFyIG09Z1tnLmxlbmd0aC9jXS5zbGljZSgpO2cuc3BsaWNlKGcubGVuZ3RoLzIsMCxuLG0pfWVsc2UgZy5wdXNoKG4pfXZhciBFPWQuc3RhcnRYLGc9ZC5lbmRYO2Y9ZiYmZi5zbGljZSgpO3Q9dC5zbGljZSgpO3ZhciB5PWQuaXNBcmVhLGM9eT8yOjE7aWYoIWYpcmV0dXJuW3QsdF07aWYoRSYmZyl7Zm9yKGQ9MDtkPEUubGVuZ3RoO2QrKylpZihFW2RdPT09Z1swXSl7dmFyIHE9ZDticmVha31lbHNlIGlmKEVbMF09PT1nW2cubGVuZ3RoLVxuRS5sZW5ndGgrZF0pe3E9ZDt2YXIgbj0hMDticmVha31lbHNlIGlmKEVbRS5sZW5ndGgtMV09PT1nW2cubGVuZ3RoLUUubGVuZ3RoK2RdKXtxPUUubGVuZ3RoLWQ7YnJlYWt9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBxJiYoZj1bXSl9aWYoZi5sZW5ndGgmJngocSkpe3ZhciBBPXQubGVuZ3RoK3EqYztuPyhDKGYsdCksbCh0LGYpKTooQyh0LGYpLGwoZix0KSl9cmV0dXJuW2YsdF19O2QucHJvdG90eXBlLmZpbGxTZXR0ZXI9ZnVuY3Rpb24oKXtkLnByb3RvdHlwZS5zdHJva2VTZXR0ZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpfTtkLnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9ZnVuY3Rpb24oKXt0aGlzLmVsZW0uYXR0cih0aGlzLnByb3AsZi5jb2xvcih0aGlzLnN0YXJ0KS50d2VlblRvKGYuY29sb3IodGhpcy5lbmQpLHRoaXMucG9zKSxudWxsLCEwKX07ZC50aW1lcnM9W107cmV0dXJuIGR9KCk7Zi5GeD1kO2YudGltZXJzPWQudGltZXJzO3JldHVybiBkfSk7UChrLFwiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCIsXG5ba1tcIkNvcmUvQW5pbWF0aW9uL0Z4LmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayl7dmFyIHg9ay5kZWZpbmVkLEI9ay5nZXRTdHlsZSxTPWsuaXNBcnJheSxEPWsuaXNOdW1iZXIsSD1rLmlzT2JqZWN0LHQ9ay5tZXJnZSxDPWsub2JqZWN0RWFjaCxsPWsucGljaztrPWQuc2V0QW5pbWF0aW9uPWZ1bmN0aW9uKGMsZyl7Zy5yZW5kZXJlci5nbG9iYWxBbmltYXRpb249bChjLGcub3B0aW9ucy5jaGFydC5hbmltYXRpb24sITApfTt2YXIgRT1kLmFuaW1PYmplY3Q9ZnVuY3Rpb24oYyl7cmV0dXJuIEgoYyk/dCh7ZHVyYXRpb246NTAwLGRlZmVyOjB9LGMpOntkdXJhdGlvbjpjPzUwMDowLGRlZmVyOjB9fSxnPWQuZ2V0RGVmZXJyZWRBbmltYXRpb249ZnVuY3Rpb24oYyxnLG4pe3ZhciBxPUUoZykseT0wLGw9MDsobj9bbl06Yy5zZXJpZXMpLmZvckVhY2goZnVuY3Rpb24oYyl7Yz1FKGMub3B0aW9ucy5hbmltYXRpb24pO1xueT1nJiZ4KGcuZGVmZXIpP3EuZGVmZXI6TWF0aC5tYXgoeSxjLmR1cmF0aW9uK2MuZGVmZXIpO2w9TWF0aC5taW4ocS5kdXJhdGlvbixjLmR1cmF0aW9uKX0pO2MucmVuZGVyZXIuZm9yRXhwb3J0JiYoeT0wKTtyZXR1cm57ZGVmZXI6TWF0aC5tYXgoMCx5LWwpLGR1cmF0aW9uOk1hdGgubWluKHksbCl9fSx5PWQuc3RvcD1mdW5jdGlvbihjLGcpe2Zvcih2YXIgbj1mLnRpbWVycy5sZW5ndGg7bi0tOylmLnRpbWVyc1tuXS5lbGVtIT09Y3x8ZyYmZyE9PWYudGltZXJzW25dLnByb3B8fChmLnRpbWVyc1tuXS5zdG9wcGVkPSEwKX07cmV0dXJue2FuaW1hdGU6ZnVuY3Rpb24oYyxnLG4pe3ZhciBxLGw9XCJcIixkLG07aWYoIUgobikpe3ZhciByPWFyZ3VtZW50cztuPXtkdXJhdGlvbjpyWzJdLGVhc2luZzpyWzNdLGNvbXBsZXRlOnJbNF19fUQobi5kdXJhdGlvbil8fChuLmR1cmF0aW9uPTQwMCk7bi5lYXNpbmc9XCJmdW5jdGlvblwiPT09dHlwZW9mIG4uZWFzaW5nP24uZWFzaW5nOk1hdGhbbi5lYXNpbmddfHxcbk1hdGguZWFzZUluT3V0U2luZTtuLmN1ckFuaW09dChnKTtDKGcsZnVuY3Rpb24oZSxoKXt5KGMsaCk7bT1uZXcgZihjLG4saCk7ZD1udWxsO1wiZFwiPT09aCYmUyhnLmQpPyhtLnBhdGhzPW0uaW5pdFBhdGgoYyxjLnBhdGhBcnJheSxnLmQpLG0udG9EPWcuZCxxPTAsZD0xKTpjLmF0dHI/cT1jLmF0dHIoaCk6KHE9cGFyc2VGbG9hdChCKGMsaCkpfHwwLFwib3BhY2l0eVwiIT09aCYmKGw9XCJweFwiKSk7ZHx8KGQ9ZSk7ZCYmZC5tYXRjaCYmZC5tYXRjaChcInB4XCIpJiYoZD1kLnJlcGxhY2UoL3B4L2csXCJcIikpO20ucnVuKHEsZCxsKX0pfSxhbmltT2JqZWN0OkUsZ2V0RGVmZXJyZWRBbmltYXRpb246ZyxzZXRBbmltYXRpb246ayxzdG9wOnl9fSk7UChrLFwiQ29yZS9SZW5kZXJlci9TVkcvU1ZHRWxlbWVudC5qc1wiLFtrW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGtbXCJDb3JlL1JlbmRlcmVyL0hUTUwvQVNULmpzXCJdLGtbXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sXG5rW1wiQ29yZS9Db2xvci9QYWxldHRlLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCxCLEcpe3ZhciBEPWYuYW5pbWF0ZSxIPWYuYW5pbU9iamVjdCx0PWYuc3RvcCxDPXguZGVnMnJhZCxsPXguZG9jLEU9eC5oYXNUb3VjaCxnPXgubm9vcCx5PXguc3ZnLGM9eC5TVkdfTlMscT14LndpbixuPUcuYXR0cixBPUcuY3JlYXRlRWxlbWVudCxNPUcuY3NzLHo9Ry5kZWZpbmVkLG09Ry5lcmFzZSxyPUcuZXh0ZW5kLGU9Ry5maXJlRXZlbnQsaD1HLmlzQXJyYXksYT1HLmlzRnVuY3Rpb24sYj1HLmlzTnVtYmVyLHc9Ry5pc1N0cmluZyxKPUcubWVyZ2UsTz1HLm9iamVjdEVhY2gsRj1HLnBpY2ssTj1HLnBJbnQsUj1HLnN5bmNUaW1lb3V0LFE9Ry51bmlxdWVLZXk7XCJcIjtmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZigpe3RoaXMuaGVpZ2h0PXRoaXMuZWxlbWVudD12b2lkIDA7dGhpcy5vcGFjaXR5PTE7dGhpcy5yZW5kZXJlcj12b2lkIDA7dGhpcy5TVkdfTlM9YztcbnRoaXMuc3ltYm9sQ3VzdG9tQXR0cmlicz1cInggeSB3aWR0aCBoZWlnaHQgciBzdGFydCBlbmQgaW5uZXJSIGFuY2hvclggYW5jaG9yWSByb3VuZGVkXCIuc3BsaXQoXCIgXCIpO3RoaXMud2lkdGg9dm9pZCAwfWYucHJvdG90eXBlLl9kZWZhdWx0R2V0dGVyPWZ1bmN0aW9uKGEpe2E9Rih0aGlzW2ErXCJWYWx1ZVwiXSx0aGlzW2FdLHRoaXMuZWxlbWVudD90aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGEpOm51bGwsMCk7L15bXFwtMC05XFwuXSskLy50ZXN0KGEpJiYoYT1wYXJzZUZsb2F0KGEpKTtyZXR1cm4gYX07Zi5wcm90b3R5cGUuX2RlZmF1bHRTZXR0ZXI9ZnVuY3Rpb24oYSxiLHApe3Auc2V0QXR0cmlidXRlKGIsYSl9O2YucHJvdG90eXBlLmFkZD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnJlbmRlcmVyLHA9dGhpcy5lbGVtZW50O2EmJih0aGlzLnBhcmVudEdyb3VwPWEpO3RoaXMucGFyZW50SW52ZXJ0ZWQ9YSYmYS5pbnZlcnRlZDtcInVuZGVmaW5lZFwiIT09dHlwZW9mIHRoaXMudGV4dFN0ciYmXG5cInRleHRcIj09PXRoaXMuZWxlbWVudC5ub2RlTmFtZSYmYi5idWlsZFRleHQodGhpcyk7dGhpcy5hZGRlZD0hMDtpZighYXx8YS5oYW5kbGVafHx0aGlzLnpJbmRleCl2YXIgZT10aGlzLnpJbmRleFNldHRlcigpO2V8fChhP2EuZWxlbWVudDpiLmJveCkuYXBwZW5kQ2hpbGQocCk7aWYodGhpcy5vbkFkZCl0aGlzLm9uQWRkKCk7cmV0dXJuIHRoaXN9O2YucHJvdG90eXBlLmFkZENsYXNzPWZ1bmN0aW9uKGEsYil7dmFyIHA9Yj9cIlwiOnRoaXMuYXR0cihcImNsYXNzXCIpfHxcIlwiO2E9KGF8fFwiXCIpLnNwbGl0KC8gL2cpLnJlZHVjZShmdW5jdGlvbihhLGIpey0xPT09cC5pbmRleE9mKGIpJiZhLnB1c2goYik7cmV0dXJuIGF9LHA/W3BdOltdKS5qb2luKFwiIFwiKTthIT09cCYmdGhpcy5hdHRyKFwiY2xhc3NcIixhKTtyZXR1cm4gdGhpc307Zi5wcm90b3R5cGUuYWZ0ZXJTZXR0ZXJzPWZ1bmN0aW9uKCl7dGhpcy5kb1RyYW5zZm9ybSYmKHRoaXMudXBkYXRlVHJhbnNmb3JtKCksdGhpcy5kb1RyYW5zZm9ybT1cbiExKX07Zi5wcm90b3R5cGUuYWxpZ249ZnVuY3Rpb24oYSxiLHApe3ZhciBlLHY9e307dmFyIGM9dGhpcy5yZW5kZXJlcjt2YXIgdT1jLmFsaWduZWRPYmplY3RzO3ZhciBoLEk7aWYoYSl7aWYodGhpcy5hbGlnbk9wdGlvbnM9YSx0aGlzLmFsaWduQnlUcmFuc2xhdGU9YiwhcHx8dyhwKSl0aGlzLmFsaWduVG89ZT1wfHxcInJlbmRlcmVyXCIsbSh1LHRoaXMpLHUucHVzaCh0aGlzKSxwPXZvaWQgMH1lbHNlIGE9dGhpcy5hbGlnbk9wdGlvbnMsYj10aGlzLmFsaWduQnlUcmFuc2xhdGUsZT10aGlzLmFsaWduVG87cD1GKHAsY1tlXSxjKTtlPWEuYWxpZ247Yz1hLnZlcnRpY2FsQWxpZ247dT0ocC54fHwwKSsoYS54fHwwKTt2YXIgZz0ocC55fHwwKSsoYS55fHwwKTtcInJpZ2h0XCI9PT1lP2g9MTpcImNlbnRlclwiPT09ZSYmKGg9Mik7aCYmKHUrPShwLndpZHRoLShhLndpZHRofHwwKSkvaCk7dltiP1widHJhbnNsYXRlWFwiOlwieFwiXT1NYXRoLnJvdW5kKHUpO1wiYm90dG9tXCI9PT1jP0k9MTpcIm1pZGRsZVwiPT09XG5jJiYoST0yKTtJJiYoZys9KHAuaGVpZ2h0LShhLmhlaWdodHx8MCkpL0kpO3ZbYj9cInRyYW5zbGF0ZVlcIjpcInlcIl09TWF0aC5yb3VuZChnKTt0aGlzW3RoaXMucGxhY2VkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh2KTt0aGlzLnBsYWNlZD0hMDt0aGlzLmFsaWduQXR0cj12O3JldHVybiB0aGlzfTtmLnByb3RvdHlwZS5hbGlnblNldHRlcj1mdW5jdGlvbihhKXt2YXIgYj17bGVmdDpcInN0YXJ0XCIsY2VudGVyOlwibWlkZGxlXCIscmlnaHQ6XCJlbmRcIn07YlthXSYmKHRoaXMuYWxpZ25WYWx1ZT1hLHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0ZXh0LWFuY2hvclwiLGJbYV0pKX07Zi5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihhLGIscCl7dmFyIGU9dGhpcyx2PUgoRihiLHRoaXMucmVuZGVyZXIuZ2xvYmFsQW5pbWF0aW9uLCEwKSk7Yj12LmRlZmVyO0YobC5oaWRkZW4sbC5tc0hpZGRlbixsLndlYmtpdEhpZGRlbiwhMSkmJih2LmR1cmF0aW9uPTApOzAhPT12LmR1cmF0aW9uPyhwJiYodi5jb21wbGV0ZT1cbnApLFIoZnVuY3Rpb24oKXtlLmVsZW1lbnQmJkQoZSxhLHYpfSxiKSk6KHRoaXMuYXR0cihhLHZvaWQgMCxwKSxPKGEsZnVuY3Rpb24oYSxiKXt2LnN0ZXAmJnYuc3RlcC5jYWxsKHRoaXMsYSx7cHJvcDpiLHBvczoxLGVsZW06dGhpc30pfSx0aGlzKSk7cmV0dXJuIHRoaXN9O2YucHJvdG90eXBlLmFwcGx5VGV4dE91dGxpbmU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50Oy0xIT09YS5pbmRleE9mKFwiY29udHJhc3RcIikmJihhPWEucmVwbGFjZSgvY29udHJhc3QvZyx0aGlzLnJlbmRlcmVyLmdldENvbnRyYXN0KGIuc3R5bGUuZmlsbCkpKTt2YXIgcD1hLnNwbGl0KFwiIFwiKTthPXBbcC5sZW5ndGgtMV07aWYoKHA9cFswXSkmJlwibm9uZVwiIT09cCYmeC5zdmcpe3RoaXMuZmFrZVRTPSEwO3RoaXMueVNldHRlcj10aGlzLnhTZXR0ZXI7cD1wLnJlcGxhY2UoLyheW1xcZFxcLl0rKSguKj8pJC9nLGZ1bmN0aW9uKGEsYixwKXtyZXR1cm4gMipOdW1iZXIoYikrcH0pO3RoaXMucmVtb3ZlVGV4dE91dGxpbmUoKTtcbnZhciBlPWwuY3JlYXRlRWxlbWVudE5TKGMsXCJ0c3BhblwiKTtuKGUse1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIsZmlsbDphLHN0cm9rZTphLFwic3Ryb2tlLXdpZHRoXCI6cCxcInN0cm9rZS1saW5lam9pblwiOlwicm91bmRcIn0pO1tdLmZvckVhY2guY2FsbChiLmNoaWxkTm9kZXMsZnVuY3Rpb24oYSl7dmFyIGI9YS5jbG9uZU5vZGUoITApO2IucmVtb3ZlQXR0cmlidXRlJiZbXCJmaWxsXCIsXCJzdHJva2VcIixcInN0cm9rZS13aWR0aFwiLFwic3Ryb2tlXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7cmV0dXJuIGIucmVtb3ZlQXR0cmlidXRlKGEpfSk7ZS5hcHBlbmRDaGlsZChiKX0pO2E9bC5jcmVhdGVFbGVtZW50TlMoYyxcInRzcGFuXCIpO2EudGV4dENvbnRlbnQ9XCJcXHUyMDBiXCI7bihhLHt4OmIuZ2V0QXR0cmlidXRlKFwieFwiKSx5OmIuZ2V0QXR0cmlidXRlKFwieVwiKX0pO2UuYXBwZW5kQ2hpbGQoYSk7Yi5pbnNlcnRCZWZvcmUoZSxiLmZpcnN0Q2hpbGQpfX07Zi5wcm90b3R5cGUuYXR0cj1mdW5jdGlvbihhLFxuYixwLGUpe3ZhciBLPXRoaXMuZWxlbWVudCx2LHU9dGhpcyxjLGgsZz10aGlzLnN5bWJvbEN1c3RvbUF0dHJpYnM7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBhJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGIpe3ZhciBMPWE7YT17fTthW0xdPWJ9XCJzdHJpbmdcIj09PXR5cGVvZiBhP3U9KHRoaXNbYStcIkdldHRlclwiXXx8dGhpcy5fZGVmYXVsdEdldHRlcikuY2FsbCh0aGlzLGEsSyk6KE8oYSxmdW5jdGlvbihiLHApe2M9ITE7ZXx8dCh0aGlzLHApO3RoaXMuc3ltYm9sTmFtZSYmLTEhPT1nLmluZGV4T2YocCkmJih2fHwodGhpcy5zeW1ib2xBdHRyKGEpLHY9ITApLGM9ITApOyF0aGlzLnJvdGF0aW9ufHxcInhcIiE9PXAmJlwieVwiIT09cHx8KHRoaXMuZG9UcmFuc2Zvcm09ITApO2N8fChoPXRoaXNbcCtcIlNldHRlclwiXXx8dGhpcy5fZGVmYXVsdFNldHRlcixoLmNhbGwodGhpcyxiLHAsSyksIXRoaXMuc3R5bGVkTW9kZSYmdGhpcy5zaGFkb3dzJiYvXih3aWR0aHxoZWlnaHR8dmlzaWJpbGl0eXx4fHl8ZHx0cmFuc2Zvcm18Y3h8Y3l8cikkLy50ZXN0KHApJiZcbnRoaXMudXBkYXRlU2hhZG93cyhwLGIsaCkpfSx0aGlzKSx0aGlzLmFmdGVyU2V0dGVycygpKTtwJiZwLmNhbGwodGhpcyk7cmV0dXJuIHV9O2YucHJvdG90eXBlLmNsaXA9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYXR0cihcImNsaXAtcGF0aFwiLGE/XCJ1cmwoXCIrdGhpcy5yZW5kZXJlci51cmwrXCIjXCIrYS5pZCtcIilcIjpcIm5vbmVcIil9O2YucHJvdG90eXBlLmNyaXNwPWZ1bmN0aW9uKGEsYil7Yj1ifHxhLnN0cm9rZVdpZHRofHwwO3ZhciBwPU1hdGgucm91bmQoYiklMi8yO2EueD1NYXRoLmZsb29yKGEueHx8dGhpcy54fHwwKStwO2EueT1NYXRoLmZsb29yKGEueXx8dGhpcy55fHwwKStwO2Eud2lkdGg9TWF0aC5mbG9vcigoYS53aWR0aHx8dGhpcy53aWR0aHx8MCktMipwKTthLmhlaWdodD1NYXRoLmZsb29yKChhLmhlaWdodHx8dGhpcy5oZWlnaHR8fDApLTIqcCk7eihhLnN0cm9rZVdpZHRoKSYmKGEuc3Ryb2tlV2lkdGg9Yik7cmV0dXJuIGF9O2YucHJvdG90eXBlLmNvbXBsZXhDb2xvcj1cbmZ1bmN0aW9uKGEsYixwKXt2YXIgSz10aGlzLnJlbmRlcmVyLHYsYyx1LGcsSSxtLEwsdyxuLHIscT1bXSxGO2UodGhpcy5yZW5kZXJlcixcImNvbXBsZXhDb2xvclwiLHthcmdzOmFyZ3VtZW50c30sZnVuY3Rpb24oKXthLnJhZGlhbEdyYWRpZW50P2M9XCJyYWRpYWxHcmFkaWVudFwiOmEubGluZWFyR3JhZGllbnQmJihjPVwibGluZWFyR3JhZGllbnRcIik7aWYoYyl7dT1hW2NdO0k9Sy5ncmFkaWVudHM7bT1hLnN0b3BzO249cC5yYWRpYWxSZWZlcmVuY2U7aCh1KSYmKGFbY109dT17eDE6dVswXSx5MTp1WzFdLHgyOnVbMl0seTI6dVszXSxncmFkaWVudFVuaXRzOlwidXNlclNwYWNlT25Vc2VcIn0pO1wicmFkaWFsR3JhZGllbnRcIj09PWMmJm4mJiF6KHUuZ3JhZGllbnRVbml0cykmJihnPXUsdT1KKHUsSy5nZXRSYWRpYWxBdHRyKG4sZykse2dyYWRpZW50VW5pdHM6XCJ1c2VyU3BhY2VPblVzZVwifSkpO08odSxmdW5jdGlvbihhLGIpe1wiaWRcIiE9PWImJnEucHVzaChiLGEpfSk7TyhtLGZ1bmN0aW9uKGEpe3EucHVzaChhKX0pO1xucT1xLmpvaW4oXCIsXCIpO2lmKElbcV0pcj1JW3FdLmF0dHIoXCJpZFwiKTtlbHNle3UuaWQ9cj1RKCk7dmFyIGU9SVtxXT1LLmNyZWF0ZUVsZW1lbnQoYykuYXR0cih1KS5hZGQoSy5kZWZzKTtlLnJhZEF0dHI9ZztlLnN0b3BzPVtdO20uZm9yRWFjaChmdW5jdGlvbihhKXswPT09YVsxXS5pbmRleE9mKFwicmdiYVwiKT8odj1rLnBhcnNlKGFbMV0pLEw9di5nZXQoXCJyZ2JcIiksdz12LmdldChcImFcIikpOihMPWFbMV0sdz0xKTthPUsuY3JlYXRlRWxlbWVudChcInN0b3BcIikuYXR0cih7b2Zmc2V0OmFbMF0sXCJzdG9wLWNvbG9yXCI6TCxcInN0b3Atb3BhY2l0eVwiOnd9KS5hZGQoZSk7ZS5zdG9wcy5wdXNoKGEpfSl9Rj1cInVybChcIitLLnVybCtcIiNcIityK1wiKVwiO3Auc2V0QXR0cmlidXRlKGIsRik7cC5ncmFkaWVudD1xO2EudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gRn19fSl9O2YucHJvdG90eXBlLmNzcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnN0eWxlcyxwPXt9LGU9dGhpcy5lbGVtZW50LGM9XCJcIixcbnY9IWIsdT1bXCJ0ZXh0T3V0bGluZVwiLFwidGV4dE92ZXJmbG93XCIsXCJ3aWR0aFwiXTthJiZhLmNvbG9yJiYoYS5maWxsPWEuY29sb3IpO2ImJk8oYSxmdW5jdGlvbihhLHUpe2ImJmJbdV0hPT1hJiYocFt1XT1hLHY9ITApfSk7aWYodil7YiYmKGE9cihiLHApKTtpZihhKWlmKG51bGw9PT1hLndpZHRofHxcImF1dG9cIj09PWEud2lkdGgpZGVsZXRlIHRoaXMudGV4dFdpZHRoO2Vsc2UgaWYoXCJ0ZXh0XCI9PT1lLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkmJmEud2lkdGgpdmFyIGg9dGhpcy50ZXh0V2lkdGg9TihhLndpZHRoKTt0aGlzLnN0eWxlcz1hO2gmJiF5JiZ0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCYmZGVsZXRlIGEud2lkdGg7aWYoZS5uYW1lc3BhY2VVUkk9PT10aGlzLlNWR19OUyl7dmFyIGc9ZnVuY3Rpb24oYSxiKXtyZXR1cm5cIi1cIitiLnRvTG93ZXJDYXNlKCl9O08oYSxmdW5jdGlvbihhLGIpey0xPT09dS5pbmRleE9mKGIpJiYoYys9Yi5yZXBsYWNlKC8oW0EtWl0pL2csZykrXCI6XCIrXG5hK1wiO1wiKX0pO2MmJm4oZSxcInN0eWxlXCIsYyl9ZWxzZSBNKGUsYSk7dGhpcy5hZGRlZCYmKFwidGV4dFwiPT09dGhpcy5lbGVtZW50Lm5vZGVOYW1lJiZ0aGlzLnJlbmRlcmVyLmJ1aWxkVGV4dCh0aGlzKSxhJiZhLnRleHRPdXRsaW5lJiZ0aGlzLmFwcGx5VGV4dE91dGxpbmUoYS50ZXh0T3V0bGluZSkpfXJldHVybiB0aGlzfTtmLnByb3RvdHlwZS5kYXNoc3R5bGVTZXR0ZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpc1tcInN0cm9rZS13aWR0aFwiXTtcImluaGVyaXRcIj09PWImJihiPTEpO2lmKGE9YSYmYS50b0xvd2VyQ2FzZSgpKXt2YXIgcD1hLnJlcGxhY2UoXCJzaG9ydGRhc2hkb3Rkb3RcIixcIjMsMSwxLDEsMSwxLFwiKS5yZXBsYWNlKFwic2hvcnRkYXNoZG90XCIsXCIzLDEsMSwxXCIpLnJlcGxhY2UoXCJzaG9ydGRvdFwiLFwiMSwxLFwiKS5yZXBsYWNlKFwic2hvcnRkYXNoXCIsXCIzLDEsXCIpLnJlcGxhY2UoXCJsb25nZGFzaFwiLFwiOCwzLFwiKS5yZXBsYWNlKC9kb3QvZyxcIjEsMyxcIikucmVwbGFjZShcImRhc2hcIixcIjQsMyxcIikucmVwbGFjZSgvLCQvLFxuXCJcIikuc3BsaXQoXCIsXCIpO2ZvcihhPXAubGVuZ3RoO2EtLTspcFthXT1cIlwiK04ocFthXSkqRihiLE5hTik7YT1wLmpvaW4oXCIsXCIpLnJlcGxhY2UoL05hTi9nLFwibm9uZVwiKTt0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwic3Ryb2tlLWRhc2hhcnJheVwiLGEpfX07Zi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmVsZW1lbnR8fHt9LHA9YS5yZW5kZXJlcixlPXAuaXNTVkcmJlwiU1BBTlwiPT09Yi5ub2RlTmFtZSYmYS5wYXJlbnRHcm91cHx8dm9pZCAwLGM9Yi5vd25lclNWR0VsZW1lbnQ7Yi5vbmNsaWNrPWIub25tb3VzZW91dD1iLm9ubW91c2VvdmVyPWIub25tb3VzZW1vdmU9Yi5wb2ludD1udWxsO3QoYSk7aWYoYS5jbGlwUGF0aCYmYyl7dmFyIGg9YS5jbGlwUGF0aDtbXS5mb3JFYWNoLmNhbGwoYy5xdWVyeVNlbGVjdG9yQWxsKFwiW2NsaXAtcGF0aF0sW0NMSVAtUEFUSF1cIiksZnVuY3Rpb24oYSl7LTE8YS5nZXRBdHRyaWJ1dGUoXCJjbGlwLXBhdGhcIikuaW5kZXhPZihoLmVsZW1lbnQuaWQpJiZcbmEucmVtb3ZlQXR0cmlidXRlKFwiY2xpcC1wYXRoXCIpfSk7YS5jbGlwUGF0aD1oLmRlc3Ryb3koKX1pZihhLnN0b3BzKXtmb3IoYz0wO2M8YS5zdG9wcy5sZW5ndGg7YysrKWEuc3RvcHNbY10uZGVzdHJveSgpO2Euc3RvcHMubGVuZ3RoPTA7YS5zdG9wcz12b2lkIDB9YS5zYWZlUmVtb3ZlQ2hpbGQoYik7Zm9yKHAuc3R5bGVkTW9kZXx8YS5kZXN0cm95U2hhZG93cygpO2UmJmUuZGl2JiYwPT09ZS5kaXYuY2hpbGROb2Rlcy5sZW5ndGg7KWI9ZS5wYXJlbnRHcm91cCxhLnNhZmVSZW1vdmVDaGlsZChlLmRpdiksZGVsZXRlIGUuZGl2LGU9YjthLmFsaWduVG8mJm0ocC5hbGlnbmVkT2JqZWN0cyxhKTtPKGEsZnVuY3Rpb24oYixwKXthW3BdJiZhW3BdLnBhcmVudEdyb3VwPT09YSYmYVtwXS5kZXN0cm95JiZhW3BdLmRlc3Ryb3koKTtkZWxldGUgYVtwXX0pfTtmLnByb3RvdHlwZS5kZXN0cm95U2hhZG93cz1mdW5jdGlvbigpeyh0aGlzLnNoYWRvd3N8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RoaXMuc2FmZVJlbW92ZUNoaWxkKGEpfSxcbnRoaXMpO3RoaXMuc2hhZG93cz12b2lkIDB9O2YucHJvdG90eXBlLmRlc3Ryb3lUZXh0UGF0aD1mdW5jdGlvbihhLGIpe3ZhciBwPWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0ZXh0XCIpWzBdO2lmKHApe2lmKHAucmVtb3ZlQXR0cmlidXRlKFwiZHhcIikscC5yZW1vdmVBdHRyaWJ1dGUoXCJkeVwiKSxiLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaWRcIixcIlwiKSx0aGlzLnRleHRQYXRoV3JhcHBlciYmcC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRleHRQYXRoXCIpLmxlbmd0aCl7Zm9yKGE9dGhpcy50ZXh0UGF0aFdyYXBwZXIuZWxlbWVudC5jaGlsZE5vZGVzO2EubGVuZ3RoOylwLmFwcGVuZENoaWxkKGFbMF0pO3AucmVtb3ZlQ2hpbGQodGhpcy50ZXh0UGF0aFdyYXBwZXIuZWxlbWVudCl9fWVsc2UgaWYoYS5nZXRBdHRyaWJ1dGUoXCJkeFwiKXx8YS5nZXRBdHRyaWJ1dGUoXCJkeVwiKSlhLnJlbW92ZUF0dHJpYnV0ZShcImR4XCIpLGEucmVtb3ZlQXR0cmlidXRlKFwiZHlcIik7dGhpcy50ZXh0UGF0aFdyYXBwZXImJlxuKHRoaXMudGV4dFBhdGhXcmFwcGVyPXRoaXMudGV4dFBhdGhXcmFwcGVyLmRlc3Ryb3koKSl9O2YucHJvdG90eXBlLmRTZXR0ZXI9ZnVuY3Rpb24oYSxiLHApe2goYSkmJihcInN0cmluZ1wiPT09dHlwZW9mIGFbMF0mJihhPXRoaXMucmVuZGVyZXIucGF0aFRvU2VnbWVudHMoYSkpLHRoaXMucGF0aEFycmF5PWEsYT1hLnJlZHVjZShmdW5jdGlvbihhLGIscCl7cmV0dXJuIGImJmIuam9pbj8ocD9hK1wiIFwiOlwiXCIpK2Iuam9pbihcIiBcIik6KGJ8fFwiXCIpLnRvU3RyaW5nKCl9LFwiXCIpKTsvKE5hTnwgezJ9fF4kKS8udGVzdChhKSYmKGE9XCJNIDAgMFwiKTt0aGlzW2JdIT09YSYmKHAuc2V0QXR0cmlidXRlKGIsYSksdGhpc1tiXT1hKX07Zi5wcm90b3R5cGUuZmFkZU91dD1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2IuYW5pbWF0ZSh7b3BhY2l0eTowfSx7ZHVyYXRpb246RihhLDE1MCksY29tcGxldGU6ZnVuY3Rpb24oKXtiLmF0dHIoe3k6LTk5OTl9KS5oaWRlKCl9fSl9O2YucHJvdG90eXBlLmZpbGxTZXR0ZXI9XG5mdW5jdGlvbihhLGIscCl7XCJzdHJpbmdcIj09PXR5cGVvZiBhP3Auc2V0QXR0cmlidXRlKGIsYSk6YSYmdGhpcy5jb21wbGV4Q29sb3IoYSxiLHApfTtmLnByb3RvdHlwZS5nZXRCQm94PWZ1bmN0aW9uKGIsZSl7dmFyIHAsYz10aGlzLnJlbmRlcmVyLGg9dGhpcy5lbGVtZW50LGc9dGhpcy5zdHlsZXMsdT10aGlzLnRleHRTdHIsbT1jLmNhY2hlLEk9Yy5jYWNoZUtleXMsdj1oLm5hbWVzcGFjZVVSST09PXRoaXMuU1ZHX05TO2U9RihlLHRoaXMucm90YXRpb24sMCk7dmFyIEw9Yy5zdHlsZWRNb2RlP2gmJmYucHJvdG90eXBlLmdldFN0eWxlLmNhbGwoaCxcImZvbnQtc2l6ZVwiKTpnJiZnLmZvbnRTaXplO2lmKHoodSkpe3ZhciB3PXUudG9TdHJpbmcoKTstMT09PXcuaW5kZXhPZihcIjxcIikmJih3PXcucmVwbGFjZSgvWzAtOV0vZyxcIjBcIikpO3crPVtcIlwiLGUsTCx0aGlzLnRleHRXaWR0aCxnJiZnLnRleHRPdmVyZmxvdyxnJiZnLmZvbnRXZWlnaHRdLmpvaW4oKX13JiYhYiYmKHA9bVt3XSk7XG5pZighcCl7aWYodnx8Yy5mb3JFeHBvcnQpe3RyeXt2YXIgbj10aGlzLmZha2VUUyYmZnVuY3Rpb24oYSl7dmFyIGI9aC5xdWVyeVNlbGVjdG9yKFwiLmhpZ2hjaGFydHMtdGV4dC1vdXRsaW5lXCIpO2ImJk0oYix7ZGlzcGxheTphfSl9O2EobikmJm4oXCJub25lXCIpO3A9aC5nZXRCQm94P3Ioe30saC5nZXRCQm94KCkpOnt3aWR0aDpoLm9mZnNldFdpZHRoLGhlaWdodDpoLm9mZnNldEhlaWdodH07YShuKSYmbihcIlwiKX1jYXRjaChkYSl7XCJcIn1pZighcHx8MD5wLndpZHRoKXA9e3dpZHRoOjAsaGVpZ2h0OjB9fWVsc2UgcD10aGlzLmh0bWxHZXRCQm94KCk7Yy5pc1NWRyYmKGI9cC53aWR0aCxjPXAuaGVpZ2h0LHYmJihwLmhlaWdodD1jPXtcIjExcHgsMTdcIjoxNCxcIjEzcHgsMjBcIjoxNn1bZyYmZy5mb250U2l6ZStcIixcIitNYXRoLnJvdW5kKGMpXXx8YyksZSYmKGc9ZSpDLHAud2lkdGg9TWF0aC5hYnMoYypNYXRoLnNpbihnKSkrTWF0aC5hYnMoYipNYXRoLmNvcyhnKSkscC5oZWlnaHQ9TWF0aC5hYnMoYypcbk1hdGguY29zKGcpKStNYXRoLmFicyhiKk1hdGguc2luKGcpKSkpO2lmKHcmJjA8cC5oZWlnaHQpe2Zvcig7MjUwPEkubGVuZ3RoOylkZWxldGUgbVtJLnNoaWZ0KCldO21bd118fEkucHVzaCh3KTttW3ddPXB9fXJldHVybiBwfTtmLnByb3RvdHlwZS5nZXRTdHlsZT1mdW5jdGlvbihhKXtyZXR1cm4gcS5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudHx8dGhpcyxcIlwiKS5nZXRQcm9wZXJ0eVZhbHVlKGEpfTtmLnByb3RvdHlwZS5oYXNDbGFzcz1mdW5jdGlvbihhKXtyZXR1cm4tMSE9PShcIlwiK3RoaXMuYXR0cihcImNsYXNzXCIpKS5zcGxpdChcIiBcIikuaW5kZXhPZihhKX07Zi5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbihhKXthP3RoaXMuYXR0cih7eTotOTk5OX0pOnRoaXMuYXR0cih7dmlzaWJpbGl0eTpcImhpZGRlblwifSk7cmV0dXJuIHRoaXN9O2YucHJvdG90eXBlLmh0bWxHZXRCQm94PWZ1bmN0aW9uKCl7cmV0dXJue2hlaWdodDowLHdpZHRoOjAseDowLHk6MH19O2YucHJvdG90eXBlLmluaXQ9XG5mdW5jdGlvbihhLGIpe3RoaXMuZWxlbWVudD1cInNwYW5cIj09PWI/QShiKTpsLmNyZWF0ZUVsZW1lbnROUyh0aGlzLlNWR19OUyxiKTt0aGlzLnJlbmRlcmVyPWE7ZSh0aGlzLFwiYWZ0ZXJJbml0XCIpfTtmLnByb3RvdHlwZS5pbnZlcnQ9ZnVuY3Rpb24oYSl7dGhpcy5pbnZlcnRlZD1hO3RoaXMudXBkYXRlVHJhbnNmb3JtKCk7cmV0dXJuIHRoaXN9O2YucHJvdG90eXBlLm9uPWZ1bmN0aW9uKGEsYil7dmFyIHAsZSxjPXRoaXMuZWxlbWVudCxoO0UmJlwiY2xpY2tcIj09PWE/KGMub250b3VjaHN0YXJ0PWZ1bmN0aW9uKGEpe3A9YS50b3VjaGVzWzBdLmNsaWVudFg7ZT1hLnRvdWNoZXNbMF0uY2xpZW50WX0sYy5vbnRvdWNoZW5kPWZ1bmN0aW9uKGEpe3AmJjQ8PU1hdGguc3FydChNYXRoLnBvdyhwLWEuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WCwyKStNYXRoLnBvdyhlLWEuY2hhbmdlZFRvdWNoZXNbMF0uY2xpZW50WSwyKSl8fGIuY2FsbChjLGEpO2g9ITA7ITEhPT1hLmNhbmNlbGFibGUmJlxuYS5wcmV2ZW50RGVmYXVsdCgpfSxjLm9uY2xpY2s9ZnVuY3Rpb24oYSl7aHx8Yi5jYWxsKGMsYSl9KTpjW1wib25cIithXT1iO3JldHVybiB0aGlzfTtmLnByb3RvdHlwZS5vcGFjaXR5U2V0dGVyPWZ1bmN0aW9uKGEsYixwKXt0aGlzLm9wYWNpdHk9YT1OdW1iZXIoTnVtYmVyKGEpLnRvRml4ZWQoMykpO3Auc2V0QXR0cmlidXRlKGIsYSl9O2YucHJvdG90eXBlLnJlbW92ZUNsYXNzPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmF0dHIoXCJjbGFzc1wiLChcIlwiK3RoaXMuYXR0cihcImNsYXNzXCIpKS5yZXBsYWNlKHcoYSk/bmV3IFJlZ0V4cChcIihefCApXCIrYStcIiggfCQpXCIpOmEsXCIgXCIpLnJlcGxhY2UoLyArL2csXCIgXCIpLnRyaW0oKSl9O2YucHJvdG90eXBlLnJlbW92ZVRleHRPdXRsaW5lPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0c3Bhbi5oaWdoY2hhcnRzLXRleHQtb3V0bGluZVwiKTthJiZ0aGlzLnNhZmVSZW1vdmVDaGlsZChhKX07Zi5wcm90b3R5cGUuc2FmZVJlbW92ZUNoaWxkPVxuZnVuY3Rpb24oYSl7dmFyIGI9YS5wYXJlbnROb2RlO2ImJmIucmVtb3ZlQ2hpbGQoYSl9O2YucHJvdG90eXBlLnNldFJhZGlhbFJlZmVyZW5jZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmVsZW1lbnQuZ3JhZGllbnQmJnRoaXMucmVuZGVyZXIuZ3JhZGllbnRzW3RoaXMuZWxlbWVudC5ncmFkaWVudF07dGhpcy5lbGVtZW50LnJhZGlhbFJlZmVyZW5jZT1hO2ImJmIucmFkQXR0ciYmYi5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0UmFkaWFsQXR0cihhLGIucmFkQXR0cikpO3JldHVybiB0aGlzfTtmLnByb3RvdHlwZS5zZXRUZXh0UGF0aD1mdW5jdGlvbihhLGUpe3ZhciBwPXRoaXMuZWxlbWVudCxjPXRoaXMudGV4dD90aGlzLnRleHQuZWxlbWVudDpwLGg9e3RleHRBbmNob3I6XCJ0ZXh0LWFuY2hvclwifSxtPSExLHU9dGhpcy50ZXh0UGF0aFdyYXBwZXIsdj0hdTtlPUooITAse2VuYWJsZWQ6ITAsYXR0cmlidXRlczp7ZHk6LTUsc3RhcnRPZmZzZXQ6XCI1MCVcIix0ZXh0QW5jaG9yOlwibWlkZGxlXCJ9fSxcbmUpO3ZhciBJPWQuZmlsdGVyVXNlckF0dHJpYnV0ZXMoZS5hdHRyaWJ1dGVzKTtpZihhJiZlJiZlLmVuYWJsZWQpe3UmJm51bGw9PT11LmVsZW1lbnQucGFyZW50Tm9kZT8odj0hMCx1PXUuZGVzdHJveSgpKTp1JiZ0aGlzLnJlbW92ZVRleHRPdXRsaW5lLmNhbGwodS5wYXJlbnRHcm91cCk7dGhpcy5vcHRpb25zJiZ0aGlzLm9wdGlvbnMucGFkZGluZyYmKEkuZHg9LXRoaXMub3B0aW9ucy5wYWRkaW5nKTt1fHwodGhpcy50ZXh0UGF0aFdyYXBwZXI9dT10aGlzLnJlbmRlcmVyLmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0UGF0aFwiKSxtPSEwKTt2YXIgdz11LmVsZW1lbnQ7KGU9YS5lbGVtZW50LmdldEF0dHJpYnV0ZShcImlkXCIpKXx8YS5lbGVtZW50LnNldEF0dHJpYnV0ZShcImlkXCIsZT1RKCkpO2lmKHYpZm9yKGMuc2V0QXR0cmlidXRlKFwieVwiLDApLGIoSS5keCkmJmMuc2V0QXR0cmlidXRlKFwieFwiLC1JLmR4KSxhPVtdLnNsaWNlLmNhbGwoYy5jaGlsZE5vZGVzKSx2PTA7djxhLmxlbmd0aDt2Kyspe3ZhciBuPVxuYVt2XTtuLm5vZGVUeXBlIT09Tm9kZS5URVhUX05PREUmJlwidHNwYW5cIiE9PW4ubm9kZU5hbWV8fHcuYXBwZW5kQ2hpbGQobil9bSYmdSYmdS5hZGQoe2VsZW1lbnQ6Y30pO3cuc2V0QXR0cmlidXRlTlMoXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIsXCJocmVmXCIsdGhpcy5yZW5kZXJlci51cmwrXCIjXCIrZSk7eihJLmR5KSYmKHcucGFyZW50Tm9kZS5zZXRBdHRyaWJ1dGUoXCJkeVwiLEkuZHkpLGRlbGV0ZSBJLmR5KTt6KEkuZHgpJiYody5wYXJlbnROb2RlLnNldEF0dHJpYnV0ZShcImR4XCIsSS5keCksZGVsZXRlIEkuZHgpO08oSSxmdW5jdGlvbihhLGIpe3cuc2V0QXR0cmlidXRlKGhbYl18fGIsYSl9KTtwLnJlbW92ZUF0dHJpYnV0ZShcInRyYW5zZm9ybVwiKTt0aGlzLnJlbW92ZVRleHRPdXRsaW5lLmNhbGwodSk7dGhpcy50ZXh0JiYhdGhpcy5yZW5kZXJlci5zdHlsZWRNb2RlJiZ0aGlzLmF0dHIoe2ZpbGw6XCJub25lXCIsXCJzdHJva2Utd2lkdGhcIjowfSk7dGhpcy5hcHBseVRleHRPdXRsaW5lPVxudGhpcy51cGRhdGVUcmFuc2Zvcm09Z31lbHNlIHUmJihkZWxldGUgdGhpcy51cGRhdGVUcmFuc2Zvcm0sZGVsZXRlIHRoaXMuYXBwbHlUZXh0T3V0bGluZSx0aGlzLmRlc3Ryb3lUZXh0UGF0aChwLGEpLHRoaXMudXBkYXRlVHJhbnNmb3JtKCksdGhpcy5vcHRpb25zJiZ0aGlzLm9wdGlvbnMucm90YXRpb24mJnRoaXMuYXBwbHlUZXh0T3V0bGluZSh0aGlzLm9wdGlvbnMuc3R5bGUudGV4dE91dGxpbmUpKTtyZXR1cm4gdGhpc307Zi5wcm90b3R5cGUuc2hhZG93PWZ1bmN0aW9uKGEsYixwKXt2YXIgZT1bXSxjPXRoaXMuZWxlbWVudCxoPSExLHU9dGhpcy5vbGRTaGFkb3dPcHRpb25zO3ZhciBnPXtjb2xvcjpCLm5ldXRyYWxDb2xvcjEwMCxvZmZzZXRYOjEsb2Zmc2V0WToxLG9wYWNpdHk6LjE1LHdpZHRoOjN9O3ZhciBJOyEwPT09YT9JPWc6XCJvYmplY3RcIj09PXR5cGVvZiBhJiYoST1yKGcsYSkpO0kmJihJJiZ1JiZPKEksZnVuY3Rpb24oYSxiKXthIT09dVtiXSYmKGg9ITApfSksaCYmXG50aGlzLmRlc3Ryb3lTaGFkb3dzKCksdGhpcy5vbGRTaGFkb3dPcHRpb25zPUkpO2lmKCFJKXRoaXMuZGVzdHJveVNoYWRvd3MoKTtlbHNlIGlmKCF0aGlzLnNoYWRvd3Mpe3ZhciBtPUkub3BhY2l0eS9JLndpZHRoO3ZhciB2PXRoaXMucGFyZW50SW52ZXJ0ZWQ/XCJ0cmFuc2xhdGUoLTEsLTEpXCI6XCJ0cmFuc2xhdGUoXCIrSS5vZmZzZXRYK1wiLCBcIitJLm9mZnNldFkrXCIpXCI7Zm9yKGc9MTtnPD1JLndpZHRoO2crKyl7dmFyIHc9Yy5jbG9uZU5vZGUoITEpO3ZhciBMPTIqSS53aWR0aCsxLTIqZztuKHcse3N0cm9rZTphLmNvbG9yfHxCLm5ldXRyYWxDb2xvcjEwMCxcInN0cm9rZS1vcGFjaXR5XCI6bSpnLFwic3Ryb2tlLXdpZHRoXCI6TCx0cmFuc2Zvcm06dixmaWxsOlwibm9uZVwifSk7dy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCh3LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiKStcIiBoaWdoY2hhcnRzLXNoYWRvd1wiKTtwJiYobih3LFwiaGVpZ2h0XCIsTWF0aC5tYXgobih3LFwiaGVpZ2h0XCIpLUwsMCkpLFxudy5jdXRIZWlnaHQ9TCk7Yj9iLmVsZW1lbnQuYXBwZW5kQ2hpbGQodyk6Yy5wYXJlbnROb2RlJiZjLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHcsYyk7ZS5wdXNoKHcpfXRoaXMuc2hhZG93cz1lfXJldHVybiB0aGlzfTtmLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLmF0dHIoe3Zpc2liaWxpdHk6YT9cImluaGVyaXRcIjpcInZpc2libGVcIn0pfTtmLnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9ZnVuY3Rpb24oYSxiLHApe3RoaXNbYl09YTt0aGlzLnN0cm9rZSYmdGhpc1tcInN0cm9rZS13aWR0aFwiXT8oZi5wcm90b3R5cGUuZmlsbFNldHRlci5jYWxsKHRoaXMsdGhpcy5zdHJva2UsXCJzdHJva2VcIixwKSxwLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLHRoaXNbXCJzdHJva2Utd2lkdGhcIl0pLHRoaXMuaGFzU3Ryb2tlPSEwKTpcInN0cm9rZS13aWR0aFwiPT09YiYmMD09PWEmJnRoaXMuaGFzU3Ryb2tlPyhwLnJlbW92ZUF0dHJpYnV0ZShcInN0cm9rZVwiKSx0aGlzLmhhc1N0cm9rZT1cbiExKTp0aGlzLnJlbmRlcmVyLnN0eWxlZE1vZGUmJnRoaXNbXCJzdHJva2Utd2lkdGhcIl0mJihwLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLHRoaXNbXCJzdHJva2Utd2lkdGhcIl0pLHRoaXMuaGFzU3Ryb2tlPSEwKX07Zi5wcm90b3R5cGUuc3Ryb2tlV2lkdGg9ZnVuY3Rpb24oKXtpZighdGhpcy5yZW5kZXJlci5zdHlsZWRNb2RlKXJldHVybiB0aGlzW1wic3Ryb2tlLXdpZHRoXCJdfHwwO3ZhciBhPXRoaXMuZ2V0U3R5bGUoXCJzdHJva2Utd2lkdGhcIiksYj0wO2lmKGEuaW5kZXhPZihcInB4XCIpPT09YS5sZW5ndGgtMiliPU4oYSk7ZWxzZSBpZihcIlwiIT09YSl7dmFyIHA9bC5jcmVhdGVFbGVtZW50TlMoYyxcInJlY3RcIik7bihwLHt3aWR0aDphLFwic3Ryb2tlLXdpZHRoXCI6MH0pO3RoaXMuZWxlbWVudC5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHApO2I9cC5nZXRCQm94KCkud2lkdGg7cC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHApfXJldHVybiBifTtmLnByb3RvdHlwZS5zeW1ib2xBdHRyPVxuZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztcInggeSByIHN0YXJ0IGVuZCB3aWR0aCBoZWlnaHQgaW5uZXJSIGFuY2hvclggYW5jaG9yWSBjbG9ja3dpc2VcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihwKXtiW3BdPUYoYVtwXSxiW3BdKX0pO2IuYXR0cih7ZDpiLnJlbmRlcmVyLnN5bWJvbHNbYi5zeW1ib2xOYW1lXShiLngsYi55LGIud2lkdGgsYi5oZWlnaHQsYil9KX07Zi5wcm90b3R5cGUudGV4dFNldHRlcj1mdW5jdGlvbihhKXthIT09dGhpcy50ZXh0U3RyJiYoZGVsZXRlIHRoaXMudGV4dFB4TGVuZ3RoLHRoaXMudGV4dFN0cj1hLHRoaXMuYWRkZWQmJnRoaXMucmVuZGVyZXIuYnVpbGRUZXh0KHRoaXMpKX07Zi5wcm90b3R5cGUudGl0bGVTZXR0ZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5lbGVtZW50LHA9Yi5nZXRFbGVtZW50c0J5VGFnTmFtZShcInRpdGxlXCIpWzBdfHxsLmNyZWF0ZUVsZW1lbnROUyh0aGlzLlNWR19OUyxcInRpdGxlXCIpO2IuaW5zZXJ0QmVmb3JlP2IuaW5zZXJ0QmVmb3JlKHAsXG5iLmZpcnN0Q2hpbGQpOmIuYXBwZW5kQ2hpbGQocCk7cC50ZXh0Q29udGVudD1TdHJpbmcoRihhLFwiXCIpKS5yZXBsYWNlKC88W14+XSo+L2csXCJcIikucmVwbGFjZSgvJmx0Oy9nLFwiPFwiKS5yZXBsYWNlKC8mZ3Q7L2csXCI+XCIpfTtmLnByb3RvdHlwZS50b0Zyb250PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5lbGVtZW50O2EucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChhKTtyZXR1cm4gdGhpc307Zi5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMuYXR0cih7dHJhbnNsYXRlWDphLHRyYW5zbGF0ZVk6Yn0pfTtmLnByb3RvdHlwZS51cGRhdGVTaGFkb3dzPWZ1bmN0aW9uKGEsYixwKXt2YXIgZT10aGlzLnNoYWRvd3M7aWYoZSlmb3IodmFyIGM9ZS5sZW5ndGg7Yy0tOylwLmNhbGwoZVtjXSxcImhlaWdodFwiPT09YT9NYXRoLm1heChiLShlW2NdLmN1dEhlaWdodHx8MCksMCk6XCJkXCI9PT1hP3RoaXMuZDpiLGEsZVtjXSl9O2YucHJvdG90eXBlLnVwZGF0ZVRyYW5zZm9ybT1cbmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy50cmFuc2xhdGVYfHwwLGI9dGhpcy50cmFuc2xhdGVZfHwwLHA9dGhpcy5zY2FsZVgsZT10aGlzLnNjYWxlWSxjPXRoaXMuaW52ZXJ0ZWQsaD10aGlzLnJvdGF0aW9uLHU9dGhpcy5tYXRyaXgsZz10aGlzLmVsZW1lbnQ7YyYmKGErPXRoaXMud2lkdGgsYis9dGhpcy5oZWlnaHQpO2E9W1widHJhbnNsYXRlKFwiK2ErXCIsXCIrYitcIilcIl07eih1KSYmYS5wdXNoKFwibWF0cml4KFwiK3Uuam9pbihcIixcIikrXCIpXCIpO2M/YS5wdXNoKFwicm90YXRlKDkwKSBzY2FsZSgtMSwxKVwiKTpoJiZhLnB1c2goXCJyb3RhdGUoXCIraCtcIiBcIitGKHRoaXMucm90YXRpb25PcmlnaW5YLGcuZ2V0QXR0cmlidXRlKFwieFwiKSwwKStcIiBcIitGKHRoaXMucm90YXRpb25PcmlnaW5ZLGcuZ2V0QXR0cmlidXRlKFwieVwiKXx8MCkrXCIpXCIpOyh6KHApfHx6KGUpKSYmYS5wdXNoKFwic2NhbGUoXCIrRihwLDEpK1wiIFwiK0YoZSwxKStcIilcIik7YS5sZW5ndGgmJmcuc2V0QXR0cmlidXRlKFwidHJhbnNmb3JtXCIsXG5hLmpvaW4oXCIgXCIpKX07Zi5wcm90b3R5cGUudmlzaWJpbGl0eVNldHRlcj1mdW5jdGlvbihhLGIscCl7XCJpbmhlcml0XCI9PT1hP3AucmVtb3ZlQXR0cmlidXRlKGIpOnRoaXNbYl0hPT1hJiZwLnNldEF0dHJpYnV0ZShiLGEpO3RoaXNbYl09YX07Zi5wcm90b3R5cGUueEdldHRlcj1mdW5jdGlvbihhKXtcImNpcmNsZVwiPT09dGhpcy5lbGVtZW50Lm5vZGVOYW1lJiYoXCJ4XCI9PT1hP2E9XCJjeFwiOlwieVwiPT09YSYmKGE9XCJjeVwiKSk7cmV0dXJuIHRoaXMuX2RlZmF1bHRHZXR0ZXIoYSl9O2YucHJvdG90eXBlLnpJbmRleFNldHRlcj1mdW5jdGlvbihhLGIpe3ZhciBwPXRoaXMucmVuZGVyZXIsZT10aGlzLnBhcmVudEdyb3VwLGM9KGV8fHApLmVsZW1lbnR8fHAuYm94LGg9dGhpcy5lbGVtZW50LHU9ITE7cD1jPT09cC5ib3g7dmFyIGc9dGhpcy5hZGRlZDt2YXIgSTt6KGEpPyhoLnNldEF0dHJpYnV0ZShcImRhdGEtei1pbmRleFwiLGEpLGE9K2EsdGhpc1tiXT09PWEmJihnPSExKSk6eih0aGlzW2JdKSYmXG5oLnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtei1pbmRleFwiKTt0aGlzW2JdPWE7aWYoZyl7KGE9dGhpcy56SW5kZXgpJiZlJiYoZS5oYW5kbGVaPSEwKTtiPWMuY2hpbGROb2Rlcztmb3IoST1iLmxlbmd0aC0xOzA8PUkmJiF1O0ktLSl7ZT1iW0ldO2c9ZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXotaW5kZXhcIik7dmFyIG09IXooZyk7aWYoZSE9PWgpaWYoMD5hJiZtJiYhcCYmIUkpYy5pbnNlcnRCZWZvcmUoaCxiW0ldKSx1PSEwO2Vsc2UgaWYoTihnKTw9YXx8bSYmKCF6KGEpfHwwPD1hKSljLmluc2VydEJlZm9yZShoLGJbSSsxXXx8bnVsbCksdT0hMH11fHwoYy5pbnNlcnRCZWZvcmUoaCxiW3A/MzowXXx8bnVsbCksdT0hMCl9cmV0dXJuIHV9O3JldHVybiBmfSgpO2YucHJvdG90eXBlW1wic3Ryb2tlLXdpZHRoU2V0dGVyXCJdPWYucHJvdG90eXBlLnN0cm9rZVNldHRlcjtmLnByb3RvdHlwZS55R2V0dGVyPWYucHJvdG90eXBlLnhHZXR0ZXI7Zi5wcm90b3R5cGUubWF0cml4U2V0dGVyPWYucHJvdG90eXBlLnJvdGF0aW9uT3JpZ2luWFNldHRlcj1cbmYucHJvdG90eXBlLnJvdGF0aW9uT3JpZ2luWVNldHRlcj1mLnByb3RvdHlwZS5yb3RhdGlvblNldHRlcj1mLnByb3RvdHlwZS5zY2FsZVhTZXR0ZXI9Zi5wcm90b3R5cGUuc2NhbGVZU2V0dGVyPWYucHJvdG90eXBlLnRyYW5zbGF0ZVhTZXR0ZXI9Zi5wcm90b3R5cGUudHJhbnNsYXRlWVNldHRlcj1mLnByb3RvdHlwZS52ZXJ0aWNhbEFsaWduU2V0dGVyPWZ1bmN0aW9uKGEsYil7dGhpc1tiXT1hO3RoaXMuZG9UcmFuc2Zvcm09ITB9O3guU1ZHRWxlbWVudD1mO3JldHVybiB4LlNWR0VsZW1lbnR9KTtQKGssXCJDb3JlL1JlbmRlcmVyL1NWRy9TVkdMYWJlbC5qc1wiLFtrW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHRWxlbWVudC5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCl7ZnVuY3Rpb24gayhmLGQpe0QoZik/ZiE9PXRoaXNbZF0mJih0aGlzW2RdPWYsdGhpcy51cGRhdGVUZXh0UGFkZGluZygpKTp0aGlzW2RdPXZvaWQgMH12YXIgeD10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8XG5mdW5jdGlvbigpe3ZhciBmPWZ1bmN0aW9uKGQsZyl7Zj1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZyxjKXtnLl9fcHJvdG9fXz1jfXx8ZnVuY3Rpb24oZyxjKXtmb3IodmFyIHEgaW4gYyljLmhhc093blByb3BlcnR5KHEpJiYoZ1txXT1jW3FdKX07cmV0dXJuIGYoZCxnKX07cmV0dXJuIGZ1bmN0aW9uKGQsZyl7ZnVuY3Rpb24geSgpe3RoaXMuY29uc3RydWN0b3I9ZH1mKGQsZyk7ZC5wcm90b3R5cGU9bnVsbD09PWc/T2JqZWN0LmNyZWF0ZShnKTooeS5wcm90b3R5cGU9Zy5wcm90b3R5cGUsbmV3IHkpfX0oKSxCPWQuZGVmaW5lZCxHPWQuZXh0ZW5kLEQ9ZC5pc051bWJlcixIPWQubWVyZ2UsdD1kLnBpY2ssQz1kLnJlbW92ZUV2ZW50O3JldHVybiBmdW5jdGlvbihkKXtmdW5jdGlvbiBsKGcsZixjLHEsbixBLE0seixtLHIpe3ZhciBlPWQuY2FsbCh0aGlzKXx8dGhpcztlLnBhZGRpbmdTZXR0ZXI9aztlLnBhZGRpbmdMZWZ0U2V0dGVyPVxuaztlLnBhZGRpbmdSaWdodFNldHRlcj1rO2UuaW5pdChnLFwiZ1wiKTtlLnRleHRTdHI9ZjtlLng9YztlLnk9cTtlLmFuY2hvclg9QTtlLmFuY2hvclk9TTtlLmJhc2VsaW5lPW07ZS5jbGFzc05hbWU9cjtcImJ1dHRvblwiIT09ciYmZS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbGFiZWxcIik7ciYmZS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrcik7ZS50ZXh0PWcudGV4dChcIlwiLDAsMCx6KS5hdHRyKHt6SW5kZXg6MX0pO2lmKFwic3RyaW5nXCI9PT10eXBlb2Ygbil7dmFyIGg9L151cmxcXCgoLio/KVxcKSQvLnRlc3Qobik7aWYoZS5yZW5kZXJlci5zeW1ib2xzW25dfHxoKWUuc3ltYm9sS2V5PW59ZS5iQm94PWwuZW1wdHlCQm94O2UucGFkZGluZz0zO2UuYmFzZWxpbmVPZmZzZXQ9MDtlLm5lZWRzQm94PWcuc3R5bGVkTW9kZXx8aDtlLmRlZmVycmVkQXR0cj17fTtlLmFsaWduRmFjdG9yPTA7cmV0dXJuIGV9eChsLGQpO2wucHJvdG90eXBlLmFsaWduU2V0dGVyPWZ1bmN0aW9uKGcpe2c9e2xlZnQ6MCxcbmNlbnRlcjouNSxyaWdodDoxfVtnXTtnIT09dGhpcy5hbGlnbkZhY3RvciYmKHRoaXMuYWxpZ25GYWN0b3I9Zyx0aGlzLmJCb3gmJkQodGhpcy54U2V0dGluZykmJnRoaXMuYXR0cih7eDp0aGlzLnhTZXR0aW5nfSkpfTtsLnByb3RvdHlwZS5hbmNob3JYU2V0dGVyPWZ1bmN0aW9uKGcsbCl7dGhpcy5hbmNob3JYPWc7dGhpcy5ib3hBdHRyKGwsTWF0aC5yb3VuZChnKS10aGlzLmdldENyaXNwQWRqdXN0KCktdGhpcy54U2V0dGluZyl9O2wucHJvdG90eXBlLmFuY2hvcllTZXR0ZXI9ZnVuY3Rpb24oZyxsKXt0aGlzLmFuY2hvclk9Zzt0aGlzLmJveEF0dHIobCxnLXRoaXMueVNldHRpbmcpfTtsLnByb3RvdHlwZS5ib3hBdHRyPWZ1bmN0aW9uKGcsbCl7dGhpcy5ib3g/dGhpcy5ib3guYXR0cihnLGwpOnRoaXMuZGVmZXJyZWRBdHRyW2ddPWx9O2wucHJvdG90eXBlLmNzcz1mdW5jdGlvbihnKXtpZihnKXt2YXIgZD17fTtnPUgoZyk7bC50ZXh0UHJvcHMuZm9yRWFjaChmdW5jdGlvbihjKXtcInVuZGVmaW5lZFwiIT09XG50eXBlb2YgZ1tjXSYmKGRbY109Z1tjXSxkZWxldGUgZ1tjXSl9KTt0aGlzLnRleHQuY3NzKGQpO3ZhciBjPVwid2lkdGhcImluIGQ7XCJmb250U2l6ZVwiaW4gZHx8XCJmb250V2VpZ2h0XCJpbiBkP3RoaXMudXBkYXRlVGV4dFBhZGRpbmcoKTpjJiZ0aGlzLnVwZGF0ZUJveFNpemUoKX1yZXR1cm4gZi5wcm90b3R5cGUuY3NzLmNhbGwodGhpcyxnKX07bC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe0ModGhpcy5lbGVtZW50LFwibW91c2VlbnRlclwiKTtDKHRoaXMuZWxlbWVudCxcIm1vdXNlbGVhdmVcIik7dGhpcy50ZXh0JiZ0aGlzLnRleHQuZGVzdHJveSgpO3RoaXMuYm94JiYodGhpcy5ib3g9dGhpcy5ib3guZGVzdHJveSgpKTtmLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyl9O2wucHJvdG90eXBlLmZpbGxTZXR0ZXI9ZnVuY3Rpb24oZyxsKXtnJiYodGhpcy5uZWVkc0JveD0hMCk7dGhpcy5maWxsPWc7dGhpcy5ib3hBdHRyKGwsZyl9O2wucHJvdG90eXBlLmdldEJCb3g9ZnVuY3Rpb24oKXt2YXIgZz1cbnRoaXMuYkJveCxsPXRoaXMucGFkZGluZyxjPXQodGhpcy5wYWRkaW5nTGVmdCxsKTtyZXR1cm57d2lkdGg6dGhpcy53aWR0aCxoZWlnaHQ6dGhpcy5oZWlnaHQseDpnLngtYyx5OmcueS1sfX07bC5wcm90b3R5cGUuZ2V0Q3Jpc3BBZGp1c3Q9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZW5kZXJlci5zdHlsZWRNb2RlJiZ0aGlzLmJveD90aGlzLmJveC5zdHJva2VXaWR0aCgpJTIvMjoodGhpc1tcInN0cm9rZS13aWR0aFwiXT9wYXJzZUludCh0aGlzW1wic3Ryb2tlLXdpZHRoXCJdLDEwKTowKSUyLzJ9O2wucHJvdG90eXBlLmhlaWdodFNldHRlcj1mdW5jdGlvbihnKXt0aGlzLmhlaWdodFNldHRpbmc9Z307bC5wcm90b3R5cGUub249ZnVuY3Rpb24oZyxsKXt2YXIgYz10aGlzLHE9Yy50ZXh0LG49cSYmXCJTUEFOXCI9PT1xLmVsZW1lbnQudGFnTmFtZT9xOnZvaWQgMDtpZihuKXt2YXIgZD1mdW5jdGlvbihxKXsoXCJtb3VzZWVudGVyXCI9PT1nfHxcIm1vdXNlbGVhdmVcIj09PWcpJiZxLnJlbGF0ZWRUYXJnZXQgaW5zdGFuY2VvZlxuRWxlbWVudCYmKGMuZWxlbWVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihxLnJlbGF0ZWRUYXJnZXQpJk5vZGUuRE9DVU1FTlRfUE9TSVRJT05fQ09OVEFJTkVEX0JZfHxuLmVsZW1lbnQuY29tcGFyZURvY3VtZW50UG9zaXRpb24ocS5yZWxhdGVkVGFyZ2V0KSZOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0NPTlRBSU5FRF9CWSl8fGwuY2FsbChjLmVsZW1lbnQscSl9O24ub24oZyxkKX1mLnByb3RvdHlwZS5vbi5jYWxsKGMsZyxkfHxsKTtyZXR1cm4gY307bC5wcm90b3R5cGUub25BZGQ9ZnVuY3Rpb24oKXt2YXIgZz10aGlzLnRleHRTdHI7dGhpcy50ZXh0LmFkZCh0aGlzKTt0aGlzLmF0dHIoe3RleHQ6QihnKT9nOlwiXCIseDp0aGlzLngseTp0aGlzLnl9KTt0aGlzLmJveCYmQih0aGlzLmFuY2hvclgpJiZ0aGlzLmF0dHIoe2FuY2hvclg6dGhpcy5hbmNob3JYLGFuY2hvclk6dGhpcy5hbmNob3JZfSl9O2wucHJvdG90eXBlLnJTZXR0ZXI9ZnVuY3Rpb24oZyxsKXt0aGlzLmJveEF0dHIobCxcbmcpfTtsLnByb3RvdHlwZS5zaGFkb3c9ZnVuY3Rpb24oZyl7ZyYmIXRoaXMucmVuZGVyZXIuc3R5bGVkTW9kZSYmKHRoaXMudXBkYXRlQm94U2l6ZSgpLHRoaXMuYm94JiZ0aGlzLmJveC5zaGFkb3coZykpO3JldHVybiB0aGlzfTtsLnByb3RvdHlwZS5zdHJva2VTZXR0ZXI9ZnVuY3Rpb24oZyxsKXt0aGlzLnN0cm9rZT1nO3RoaXMuYm94QXR0cihsLGcpfTtsLnByb3RvdHlwZVtcInN0cm9rZS13aWR0aFNldHRlclwiXT1mdW5jdGlvbihnLGwpe2cmJih0aGlzLm5lZWRzQm94PSEwKTt0aGlzW1wic3Ryb2tlLXdpZHRoXCJdPWc7dGhpcy5ib3hBdHRyKGwsZyl9O2wucHJvdG90eXBlW1widGV4dC1hbGlnblNldHRlclwiXT1mdW5jdGlvbihnKXt0aGlzLnRleHRBbGlnbj1nfTtsLnByb3RvdHlwZS50ZXh0U2V0dGVyPWZ1bmN0aW9uKGcpe1widW5kZWZpbmVkXCIhPT10eXBlb2YgZyYmdGhpcy50ZXh0LmF0dHIoe3RleHQ6Z30pO3RoaXMudXBkYXRlVGV4dFBhZGRpbmcoKX07bC5wcm90b3R5cGUudXBkYXRlQm94U2l6ZT1cbmZ1bmN0aW9uKCl7dmFyIGc9dGhpcy50ZXh0LmVsZW1lbnQuc3R5bGUsZD17fSxjPXRoaXMucGFkZGluZyxxPXRoaXMuYkJveD1EKHRoaXMud2lkdGhTZXR0aW5nKSYmRCh0aGlzLmhlaWdodFNldHRpbmcpJiYhdGhpcy50ZXh0QWxpZ258fCFCKHRoaXMudGV4dC50ZXh0U3RyKT9sLmVtcHR5QkJveDp0aGlzLnRleHQuZ2V0QkJveCgpO3RoaXMud2lkdGg9dGhpcy5nZXRQYWRkZWRXaWR0aCgpO3RoaXMuaGVpZ2h0PSh0aGlzLmhlaWdodFNldHRpbmd8fHEuaGVpZ2h0fHwwKSsyKmM7dGhpcy5iYXNlbGluZU9mZnNldD1jK01hdGgubWluKHRoaXMucmVuZGVyZXIuZm9udE1ldHJpY3MoZyYmZy5mb250U2l6ZSx0aGlzLnRleHQpLmIscS5oZWlnaHR8fEluZmluaXR5KTt0aGlzLm5lZWRzQm94JiYodGhpcy5ib3h8fChnPXRoaXMuYm94PXRoaXMuc3ltYm9sS2V5P3RoaXMucmVuZGVyZXIuc3ltYm9sKHRoaXMuc3ltYm9sS2V5KTp0aGlzLnJlbmRlcmVyLnJlY3QoKSxnLmFkZENsYXNzKChcImJ1dHRvblwiPT09XG50aGlzLmNsYXNzTmFtZT9cIlwiOlwiaGlnaGNoYXJ0cy1sYWJlbC1ib3hcIikrKHRoaXMuY2xhc3NOYW1lP1wiIGhpZ2hjaGFydHMtXCIrdGhpcy5jbGFzc05hbWUrXCItYm94XCI6XCJcIikpLGcuYWRkKHRoaXMpKSxnPXRoaXMuZ2V0Q3Jpc3BBZGp1c3QoKSxkLng9ZyxkLnk9KHRoaXMuYmFzZWxpbmU/LXRoaXMuYmFzZWxpbmVPZmZzZXQ6MCkrZyxkLndpZHRoPU1hdGgucm91bmQodGhpcy53aWR0aCksZC5oZWlnaHQ9TWF0aC5yb3VuZCh0aGlzLmhlaWdodCksdGhpcy5ib3guYXR0cihHKGQsdGhpcy5kZWZlcnJlZEF0dHIpKSx0aGlzLmRlZmVycmVkQXR0cj17fSl9O2wucHJvdG90eXBlLnVwZGF0ZVRleHRQYWRkaW5nPWZ1bmN0aW9uKCl7dmFyIGc9dGhpcy50ZXh0O3RoaXMudXBkYXRlQm94U2l6ZSgpO3ZhciBsPXRoaXMuYmFzZWxpbmU/MDp0aGlzLmJhc2VsaW5lT2Zmc2V0LGM9dCh0aGlzLnBhZGRpbmdMZWZ0LHRoaXMucGFkZGluZyk7Qih0aGlzLndpZHRoU2V0dGluZykmJnRoaXMuYkJveCYmXG4oXCJjZW50ZXJcIj09PXRoaXMudGV4dEFsaWdufHxcInJpZ2h0XCI9PT10aGlzLnRleHRBbGlnbikmJihjKz17Y2VudGVyOi41LHJpZ2h0OjF9W3RoaXMudGV4dEFsaWduXSoodGhpcy53aWR0aFNldHRpbmctdGhpcy5iQm94LndpZHRoKSk7aWYoYyE9PWcueHx8bCE9PWcueSlnLmF0dHIoXCJ4XCIsYyksZy5oYXNCb3hXaWR0aENoYW5nZWQmJih0aGlzLmJCb3g9Zy5nZXRCQm94KCEwKSksXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsJiZnLmF0dHIoXCJ5XCIsbCk7Zy54PWM7Zy55PWx9O2wucHJvdG90eXBlLndpZHRoU2V0dGVyPWZ1bmN0aW9uKGcpe3RoaXMud2lkdGhTZXR0aW5nPUQoZyk/Zzp2b2lkIDB9O2wucHJvdG90eXBlLmdldFBhZGRlZFdpZHRoPWZ1bmN0aW9uKCl7dmFyIGc9dGhpcy5wYWRkaW5nLGw9dCh0aGlzLnBhZGRpbmdMZWZ0LGcpO2c9dCh0aGlzLnBhZGRpbmdSaWdodCxnKTtyZXR1cm4odGhpcy53aWR0aFNldHRpbmd8fHRoaXMuYkJveC53aWR0aHx8MCkrbCtnfTtsLnByb3RvdHlwZS54U2V0dGVyPVxuZnVuY3Rpb24oZyl7dGhpcy54PWc7dGhpcy5hbGlnbkZhY3RvciYmKGctPXRoaXMuYWxpZ25GYWN0b3IqdGhpcy5nZXRQYWRkZWRXaWR0aCgpLHRoaXNbXCJmb3JjZUFuaW1hdGU6eFwiXT0hMCk7dGhpcy54U2V0dGluZz1NYXRoLnJvdW5kKGcpO3RoaXMuYXR0cihcInRyYW5zbGF0ZVhcIix0aGlzLnhTZXR0aW5nKX07bC5wcm90b3R5cGUueVNldHRlcj1mdW5jdGlvbihnKXt0aGlzLnlTZXR0aW5nPXRoaXMueT1NYXRoLnJvdW5kKGcpO3RoaXMuYXR0cihcInRyYW5zbGF0ZVlcIix0aGlzLnlTZXR0aW5nKX07bC5lbXB0eUJCb3g9e3dpZHRoOjAsaGVpZ2h0OjAseDowLHk6MH07bC50ZXh0UHJvcHM9XCJjb2xvciBkaXJlY3Rpb24gZm9udEZhbWlseSBmb250U2l6ZSBmb250U3R5bGUgZm9udFdlaWdodCBsaW5lSGVpZ2h0IHRleHRBbGlnbiB0ZXh0RGVjb3JhdGlvbiB0ZXh0T3V0bGluZSB0ZXh0T3ZlcmZsb3cgd2lkdGhcIi5zcGxpdChcIiBcIik7cmV0dXJuIGx9KGYpfSk7UChrLFwiQ29yZS9SZW5kZXJlci9TVkcvVGV4dEJ1aWxkZXIuanNcIixcbltrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXSxrW1wiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiXV0sZnVuY3Rpb24oZixkLGspe3ZhciB4PWYuZG9jLEI9Zi5TVkdfTlMsUz1kLmF0dHIsRD1kLmlzU3RyaW5nLEg9ZC5vYmplY3RFYWNoLHQ9ZC5waWNrO3JldHVybiBmdW5jdGlvbigpe2Z1bmN0aW9uIGQobCl7dmFyIGQ9bC5zdHlsZXM7dGhpcy5yZW5kZXJlcj1sLnJlbmRlcmVyO3RoaXMuc3ZnRWxlbWVudD1sO3RoaXMud2lkdGg9bC50ZXh0V2lkdGg7dGhpcy50ZXh0TGluZUhlaWdodD1kJiZkLmxpbmVIZWlnaHQ7dGhpcy50ZXh0T3V0bGluZT1kJiZkLnRleHRPdXRsaW5lO3RoaXMuZWxsaXBzaXM9ISghZHx8XCJlbGxpcHNpc1wiIT09ZC50ZXh0T3ZlcmZsb3cpO3RoaXMubm9XcmFwPSEoIWR8fFwibm93cmFwXCIhPT1kLndoaXRlU3BhY2UpO3RoaXMuZm9udFNpemU9ZCYmZC5mb250U2l6ZX1kLnByb3RvdHlwZS5idWlsZFNWRz1mdW5jdGlvbigpe3ZhciBsPVxudGhpcy5zdmdFbGVtZW50LGQ9bC5lbGVtZW50LGc9bC5yZW5kZXJlcixmPXQobC50ZXh0U3RyLFwiXCIpLnRvU3RyaW5nKCksYz0tMSE9PWYuaW5kZXhPZihcIjxcIikscT1kLmNoaWxkTm9kZXMsbj1xLmxlbmd0aDtnPXRoaXMud2lkdGgmJiFsLmFkZGVkJiZnLmJveDt2YXIgQT0vPGJyLio/Pi9nO3ZhciBNPVtmLHRoaXMuZWxsaXBzaXMsdGhpcy5ub1dyYXAsdGhpcy50ZXh0TGluZUhlaWdodCx0aGlzLnRleHRPdXRsaW5lLHRoaXMuZm9udFNpemUsdGhpcy53aWR0aF0uam9pbigpO2lmKE0hPT1sLnRleHRDYWNoZSl7bC50ZXh0Q2FjaGU9TTtmb3IoZGVsZXRlIGwuYWN0dWFsV2lkdGg7bi0tOylkLnJlbW92ZUNoaWxkKHFbbl0pO2N8fHRoaXMuZWxsaXBzaXN8fHRoaXMud2lkdGh8fC0xIT09Zi5pbmRleE9mKFwiIFwiKSYmKCF0aGlzLm5vV3JhcHx8QS50ZXN0KGYpKT9cIlwiIT09ZiYmKGcmJmcuYXBwZW5kQ2hpbGQoZCksZj1uZXcgayhmKSx0aGlzLm1vZGlmeVRyZWUoZi5ub2RlcyksZi5hZGRUb0RPTShsLmVsZW1lbnQpLFxudGhpcy5tb2RpZnlET00oKSx0aGlzLmVsbGlwc2lzJiYtMSE9PShkLnRleHRDb250ZW50fHxcIlwiKS5pbmRleE9mKFwiXFx1MjAyNlwiKSYmbC5hdHRyKFwidGl0bGVcIix0aGlzLnVuZXNjYXBlRW50aXRpZXMobC50ZXh0U3RyfHxcIlwiLFtcIiZsdDtcIixcIiZndDtcIl0pKSxnJiZnLnJlbW92ZUNoaWxkKGQpKTpkLmFwcGVuZENoaWxkKHguY3JlYXRlVGV4dE5vZGUodGhpcy51bmVzY2FwZUVudGl0aWVzKGYpKSk7RCh0aGlzLnRleHRPdXRsaW5lKSYmbC5hcHBseVRleHRPdXRsaW5lJiZsLmFwcGx5VGV4dE91dGxpbmUodGhpcy50ZXh0T3V0bGluZSl9fTtkLnByb3RvdHlwZS5tb2RpZnlET009ZnVuY3Rpb24oKXt2YXIgZD10aGlzLGY9dGhpcy5zdmdFbGVtZW50LGc9UyhmLmVsZW1lbnQsXCJ4XCIpO1tdLmZvckVhY2guY2FsbChmLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInRzcGFuLmhpZ2hjaGFydHMtYnJcIiksZnVuY3Rpb24oYyl7Yy5uZXh0U2libGluZyYmYy5wcmV2aW91c1NpYmxpbmcmJlMoYyxcbntkeTpkLmdldExpbmVIZWlnaHQoYy5uZXh0U2libGluZykseDpnfSl9KTt2YXIgeT10aGlzLndpZHRofHwwO2lmKHkpe3ZhciBjPWZ1bmN0aW9uKGMscSl7dmFyIG49Yy50ZXh0Q29udGVudHx8XCJcIixsPW4ucmVwbGFjZSgvKFteXFxeXSktL2csXCIkMS0gXCIpLnNwbGl0KFwiIFwiKSxtPSFkLm5vV3JhcCYmKDE8bC5sZW5ndGh8fDE8Zi5lbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoKSxyPWQuZ2V0TGluZUhlaWdodChxKSxlPTAsaD1mLmFjdHVhbFdpZHRoO2lmKGQuZWxsaXBzaXMpbiYmZC50cnVuY2F0ZShjLG4sdm9pZCAwLDAsTWF0aC5tYXgoMCx5LXBhcnNlSW50KGQuZm9udFNpemV8fDEyLDEwKSksZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5zdWJzdHJpbmcoMCxiKStcIlxcdTIwMjZcIn0pO2Vsc2UgaWYobSl7bj1bXTtmb3IobT1bXTtxLmZpcnN0Q2hpbGQmJnEuZmlyc3RDaGlsZCE9PWM7KW0ucHVzaChxLmZpcnN0Q2hpbGQpLHEucmVtb3ZlQ2hpbGQocS5maXJzdENoaWxkKTtmb3IoO2wubGVuZ3RoOylsLmxlbmd0aCYmXG4hZC5ub1dyYXAmJjA8ZSYmKG4ucHVzaChjLnRleHRDb250ZW50fHxcIlwiKSxjLnRleHRDb250ZW50PWwuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZyxcIi1cIikpLGQudHJ1bmNhdGUoYyx2b2lkIDAsbCwwPT09ZT9ofHwwOjAseSxmdW5jdGlvbihhLGIpe3JldHVybiBsLnNsaWNlKDAsYikuam9pbihcIiBcIikucmVwbGFjZSgvLSAvZyxcIi1cIil9KSxoPWYuYWN0dWFsV2lkdGgsZSsrO20uZm9yRWFjaChmdW5jdGlvbihhKXtxLmluc2VydEJlZm9yZShhLGMpfSk7bi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3EuaW5zZXJ0QmVmb3JlKHguY3JlYXRlVGV4dE5vZGUoYSksYyk7YT14LmNyZWF0ZUVsZW1lbnROUyhCLFwidHNwYW5cIik7YS50ZXh0Q29udGVudD1cIlxcdTIwMGJcIjtTKGEse2R5OnIseDpnfSk7cS5pbnNlcnRCZWZvcmUoYSxjKX0pfX0scT1mdW5jdGlvbihnKXtbXS5zbGljZS5jYWxsKGcuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbihuKXtuLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREU/YyhuLFxuZyk6KC0xIT09bi5jbGFzc05hbWUuYmFzZVZhbC5pbmRleE9mKFwiaGlnaGNoYXJ0cy1iclwiKSYmKGYuYWN0dWFsV2lkdGg9MCkscShuKSl9KX07cShmLmVsZW1lbnQpfX07ZC5wcm90b3R5cGUuZ2V0TGluZUhlaWdodD1mdW5jdGlvbihkKXt2YXIgbDtkPWQubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERT9kLnBhcmVudEVsZW1lbnQ6ZDt0aGlzLnJlbmRlcmVyLnN0eWxlZE1vZGV8fChsPWQmJi8ocHh8ZW0pJC8udGVzdChkLnN0eWxlLmZvbnRTaXplKT9kLnN0eWxlLmZvbnRTaXplOnRoaXMuZm9udFNpemV8fHRoaXMucmVuZGVyZXIuc3R5bGUuZm9udFNpemV8fDEyKTtyZXR1cm4gdGhpcy50ZXh0TGluZUhlaWdodD9wYXJzZUludCh0aGlzLnRleHRMaW5lSGVpZ2h0LnRvU3RyaW5nKCksMTApOnRoaXMucmVuZGVyZXIuZm9udE1ldHJpY3MobCxkfHx0aGlzLnN2Z0VsZW1lbnQuZWxlbWVudCkuaH07ZC5wcm90b3R5cGUubW9kaWZ5VHJlZT1mdW5jdGlvbihkKXt2YXIgbD10aGlzLGc9ZnVuY3Rpb24oZixcbmMpe3ZhciBxPWYudGFnTmFtZSxuPWwucmVuZGVyZXIuc3R5bGVkTW9kZSxBPWYuYXR0cmlidXRlc3x8e307aWYoXCJiXCI9PT1xfHxcInN0cm9uZ1wiPT09cSluP0FbXCJjbGFzc1wiXT1cImhpZ2hjaGFydHMtc3Ryb25nXCI6QS5zdHlsZT1cImZvbnQtd2VpZ2h0OmJvbGQ7XCIrKEEuc3R5bGV8fFwiXCIpO2Vsc2UgaWYoXCJpXCI9PT1xfHxcImVtXCI9PT1xKW4/QVtcImNsYXNzXCJdPVwiaGlnaGNoYXJ0cy1lbXBoYXNpemVkXCI6QS5zdHlsZT1cImZvbnQtc3R5bGU6aXRhbGljO1wiKyhBLnN0eWxlfHxcIlwiKTtEKEEuc3R5bGUpJiYoQS5zdHlsZT1BLnN0eWxlLnJlcGxhY2UoLyg7fCB8Xiljb2xvcihbIDpdKS8sXCIkMWZpbGwkMlwiKSk7XCJiclwiPT09cSYmKEFbXCJjbGFzc1wiXT1cImhpZ2hjaGFydHMtYnJcIixmLnRleHRDb250ZW50PVwiXFx1MjAwYlwiLChjPWRbYysxXSkmJmMudGV4dENvbnRlbnQmJihjLnRleHRDb250ZW50PWMudGV4dENvbnRlbnQucmVwbGFjZSgvXiArL2dtLFwiXCIpKSk7XCIjdGV4dFwiIT09cSYmXCJhXCIhPT1xJiYoZi50YWdOYW1lPVxuXCJ0c3BhblwiKTtmLmF0dHJpYnV0ZXM9QTtmLmNoaWxkcmVuJiZmLmNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbihjKXtyZXR1cm5cIiN0ZXh0XCIhPT1jLnRhZ05hbWV9KS5mb3JFYWNoKGcpfTtmb3IoZC5mb3JFYWNoKGcpO2RbMF0mJlwidHNwYW5cIj09PWRbMF0udGFnTmFtZSYmIWRbMF0uY2hpbGRyZW47KWQuc3BsaWNlKDAsMSl9O2QucHJvdG90eXBlLnRydW5jYXRlPWZ1bmN0aW9uKGQsZixnLHksYyxxKXt2YXIgbj10aGlzLnN2Z0VsZW1lbnQsbD1uLnJlbmRlcmVyLE09bi5yb3RhdGlvbix6PVtdLG09Zz8xOjAscj0oZnx8Z3x8XCJcIikubGVuZ3RoLGU9cixoLGE9ZnVuY3Rpb24oYSxiKXtiPWJ8fGE7dmFyIGU9ZC5wYXJlbnROb2RlO2lmKGUmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgeltiXSlpZihlLmdldFN1YlN0cmluZ0xlbmd0aCl0cnl7eltiXT15K2UuZ2V0U3ViU3RyaW5nTGVuZ3RoKDAsZz9iKzE6Yil9Y2F0Y2goRil7XCJcIn1lbHNlIGwuZ2V0U3BhbldpZHRoJiYoZC50ZXh0Q29udGVudD1cbnEoZnx8ZyxhKSx6W2JdPXkrbC5nZXRTcGFuV2lkdGgobixkKSk7cmV0dXJuIHpbYl19O24ucm90YXRpb249MDt2YXIgYj1hKGQudGV4dENvbnRlbnQubGVuZ3RoKTtpZih5K2I+Yyl7Zm9yKDttPD1yOyllPU1hdGguY2VpbCgobStyKS8yKSxnJiYoaD1xKGcsZSkpLGI9YShlLGgmJmgubGVuZ3RoLTEpLG09PT1yP209cisxOmI+Yz9yPWUtMTptPWU7MD09PXI/ZC50ZXh0Q29udGVudD1cIlwiOmYmJnI9PT1mLmxlbmd0aC0xfHwoZC50ZXh0Q29udGVudD1ofHxxKGZ8fGcsZSkpfWcmJmcuc3BsaWNlKDAsZSk7bi5hY3R1YWxXaWR0aD1iO24ucm90YXRpb249TX07ZC5wcm90b3R5cGUudW5lc2NhcGVFbnRpdGllcz1mdW5jdGlvbihkLGYpe0godGhpcy5yZW5kZXJlci5lc2NhcGVzLGZ1bmN0aW9uKGcsbCl7ZiYmLTEhPT1mLmluZGV4T2YoZyl8fChkPWQudG9TdHJpbmcoKS5yZXBsYWNlKG5ldyBSZWdFeHAoZyxcImdcIiksbCkpfSk7cmV0dXJuIGR9O3JldHVybiBkfSgpfSk7UChrLFwiQ29yZS9SZW5kZXJlci9TVkcvU1ZHUmVuZGVyZXIuanNcIixcbltrW1wiQ29yZS9Db2xvci9Db2xvci5qc1wiXSxrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sa1tcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0VsZW1lbnQuanNcIl0sa1tcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0xhYmVsLmpzXCJdLGtbXCJDb3JlL1JlbmRlcmVyL0hUTUwvQVNULmpzXCJdLGtbXCJDb3JlL1JlbmRlcmVyL1NWRy9UZXh0QnVpbGRlci5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCxrLHgsQixHLEQsSCl7dmFyIHQ9SC5hZGRFdmVudCxDPUguYXR0cixsPUguY3JlYXRlRWxlbWVudCxFPUguY3NzLGc9SC5kZWZpbmVkLHk9SC5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxjPUguZXh0ZW5kLHE9SC5pc0FycmF5LG49SC5pc051bWJlcixBPUguaXNPYmplY3QsTT1ILmlzU3RyaW5nLHo9SC5tZXJnZSxtPUgucGljayxyPUgucEludCxlPUgudW5pcXVlS2V5LGg9ZC5jaGFydHMsYT1kLmRlZzJyYWQsYj1kLmRvYyx3PWQuaXNGaXJlZm94LFxuSj1kLmlzTVMsTz1kLmlzV2ViS2l0O0g9ZC5ub29wO3ZhciBGPWQuU1ZHX05TLE49ZC5zeW1ib2xTaXplcyxSPWQud2luLFEsVD1mdW5jdGlvbigpe2Z1bmN0aW9uIGQoYSxiLGUsYyxoLHUsZyl7dGhpcy53aWR0aD10aGlzLnVybD10aGlzLnN0eWxlPXRoaXMuaXNTVkc9dGhpcy5pbWdDb3VudD10aGlzLmhlaWdodD10aGlzLmdyYWRpZW50cz10aGlzLmdsb2JhbEFuaW1hdGlvbj10aGlzLmRlZnM9dGhpcy5jaGFydEluZGV4PXRoaXMuY2FjaGVLZXlzPXRoaXMuY2FjaGU9dGhpcy5ib3hXcmFwcGVyPXRoaXMuYm94PXRoaXMuYWxpZ25lZE9iamVjdHM9dm9pZCAwO3RoaXMuaW5pdChhLGIsZSxjLGgsdSxnKX1kLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEscCxlLGMsaCx1LGcpe3ZhciBLPXRoaXMuY3JlYXRlRWxlbWVudChcInN2Z1wiKS5hdHRyKHt2ZXJzaW9uOlwiMS4xXCIsXCJjbGFzc1wiOlwiaGlnaGNoYXJ0cy1yb290XCJ9KTtnfHxLLmNzcyh0aGlzLmdldFN0eWxlKGMpKTtjPUsuZWxlbWVudDtcbmEuYXBwZW5kQ2hpbGQoYyk7QyhhLFwiZGlyXCIsXCJsdHJcIik7LTE9PT1hLmlubmVySFRNTC5pbmRleE9mKFwieG1sbnNcIikmJkMoYyxcInhtbG5zXCIsdGhpcy5TVkdfTlMpO3RoaXMuaXNTVkc9ITA7dGhpcy5ib3g9Yzt0aGlzLmJveFdyYXBwZXI9Szt0aGlzLmFsaWduZWRPYmplY3RzPVtdO3RoaXMudXJsPXRoaXMuZ2V0UmVmZXJlbmNlVVJMKCk7dGhpcy5jcmVhdGVFbGVtZW50KFwiZGVzY1wiKS5hZGQoKS5lbGVtZW50LmFwcGVuZENoaWxkKGIuY3JlYXRlVGV4dE5vZGUoXCJDcmVhdGVkIHdpdGggSGlnaGNoYXJ0cyA5LjAuMVwiKSk7dGhpcy5kZWZzPXRoaXMuY3JlYXRlRWxlbWVudChcImRlZnNcIikuYWRkKCk7dGhpcy5hbGxvd0hUTUw9dTt0aGlzLmZvckV4cG9ydD1oO3RoaXMuc3R5bGVkTW9kZT1nO3RoaXMuZ3JhZGllbnRzPXt9O3RoaXMuY2FjaGU9e307dGhpcy5jYWNoZUtleXM9W107dGhpcy5pbWdDb3VudD0wO3RoaXMuc2V0U2l6ZShwLGUsITEpO3ZhciBtO3cmJmEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0JiZcbihwPWZ1bmN0aW9uKCl7RShhLHtsZWZ0OjAsdG9wOjB9KTttPWEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7RShhLHtsZWZ0Ok1hdGguY2VpbChtLmxlZnQpLW0ubGVmdCtcInB4XCIsdG9wOk1hdGguY2VpbChtLnRvcCktbS50b3ArXCJweFwifSl9LHAoKSx0aGlzLnVuU3ViUGl4ZWxGaXg9dChSLFwicmVzaXplXCIscCkpfTtkLnByb3RvdHlwZS5kZWZpbml0aW9uPWZ1bmN0aW9uKGEpe3JldHVybihuZXcgRyhbYV0pKS5hZGRUb0RPTSh0aGlzLmRlZnMuZWxlbWVudCl9O2QucHJvdG90eXBlLmdldFJlZmVyZW5jZVVSTD1mdW5jdGlvbigpe2lmKCh3fHxPKSYmYi5nZXRFbGVtZW50c0J5VGFnTmFtZShcImJhc2VcIikubGVuZ3RoKXtpZighZyhRKSl7dmFyIGE9ZSgpO2E9KG5ldyBHKFt7dGFnTmFtZTpcInN2Z1wiLGF0dHJpYnV0ZXM6e3dpZHRoOjgsaGVpZ2h0Ojh9LGNoaWxkcmVuOlt7dGFnTmFtZTpcImRlZnNcIixjaGlsZHJlbjpbe3RhZ05hbWU6XCJjbGlwUGF0aFwiLGF0dHJpYnV0ZXM6e2lkOmF9LGNoaWxkcmVuOlt7dGFnTmFtZTpcInJlY3RcIixcbmF0dHJpYnV0ZXM6e3dpZHRoOjQsaGVpZ2h0OjR9fV19XX0se3RhZ05hbWU6XCJyZWN0XCIsYXR0cmlidXRlczp7aWQ6XCJoaXRtZVwiLHdpZHRoOjgsaGVpZ2h0OjgsXCJjbGlwLXBhdGhcIjpcInVybCgjXCIrYStcIilcIixmaWxsOlwicmdiYSgwLDAsMCwwLjAwMSlcIn19XX1dKSkuYWRkVG9ET00oYi5ib2R5KTtFKGEse3Bvc2l0aW9uOlwiZml4ZWRcIix0b3A6MCxsZWZ0OjAsekluZGV4OjlFNX0pO3ZhciBwPWIuZWxlbWVudEZyb21Qb2ludCg2LDYpO1E9XCJoaXRtZVwiPT09KHAmJnAuaWQpO2IuYm9keS5yZW1vdmVDaGlsZChhKX1pZihRKXJldHVybiBSLmxvY2F0aW9uLmhyZWYuc3BsaXQoXCIjXCIpWzBdLnJlcGxhY2UoLzxbXj5dKj4vZyxcIlwiKS5yZXBsYWNlKC8oW1xcKCdcXCldKS9nLFwiXFxcXCQxXCIpLnJlcGxhY2UoLyAvZyxcIiUyMFwiKX1yZXR1cm5cIlwifTtkLnByb3RvdHlwZS5nZXRTdHlsZT1mdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5zdHlsZT1jKHtmb250RmFtaWx5OidcIkx1Y2lkYSBHcmFuZGVcIiwgXCJMdWNpZGEgU2FucyBVbmljb2RlXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnLFxuZm9udFNpemU6XCIxMnB4XCJ9LGEpfTtkLnByb3RvdHlwZS5zZXRTdHlsZT1mdW5jdGlvbihhKXt0aGlzLmJveFdyYXBwZXIuY3NzKHRoaXMuZ2V0U3R5bGUoYSkpfTtkLnByb3RvdHlwZS5pc0hpZGRlbj1mdW5jdGlvbigpe3JldHVybiF0aGlzLmJveFdyYXBwZXIuZ2V0QkJveCgpLndpZHRofTtkLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5kZWZzO3RoaXMuYm94PW51bGw7dGhpcy5ib3hXcmFwcGVyPXRoaXMuYm94V3JhcHBlci5kZXN0cm95KCk7eSh0aGlzLmdyYWRpZW50c3x8e30pO3RoaXMuZ3JhZGllbnRzPW51bGw7YSYmKHRoaXMuZGVmcz1hLmRlc3Ryb3koKSk7dGhpcy51blN1YlBpeGVsRml4JiZ0aGlzLnVuU3ViUGl4ZWxGaXgoKTtyZXR1cm4gdGhpcy5hbGlnbmVkT2JqZWN0cz1udWxsfTtkLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKGEpe3ZhciBiPW5ldyB0aGlzLkVsZW1lbnQ7Yi5pbml0KHRoaXMsYSk7cmV0dXJuIGJ9O2QucHJvdG90eXBlLmdldFJhZGlhbEF0dHI9XG5mdW5jdGlvbihhLGIpe3JldHVybntjeDphWzBdLWFbMl0vMitiLmN4KmFbMl0sY3k6YVsxXS1hWzJdLzIrYi5jeSphWzJdLHI6Yi5yKmFbMl19fTtkLnByb3RvdHlwZS5idWlsZFRleHQ9ZnVuY3Rpb24oYSl7KG5ldyBEKGEpKS5idWlsZFNWRygpfTtkLnByb3RvdHlwZS5nZXRDb250cmFzdD1mdW5jdGlvbihhKXthPWYucGFyc2UoYSkucmdiYTthWzBdKj0xO2FbMV0qPTEuMjthWzJdKj0uNTtyZXR1cm4gNDU5PGFbMF0rYVsxXSthWzJdP1wiIzAwMDAwMFwiOlwiI0ZGRkZGRlwifTtkLnByb3RvdHlwZS5idXR0b249ZnVuY3Rpb24oYSxiLGUsaCxnLHUsbSxJLHcsZCl7dmFyIHA9dGhpcy5sYWJlbChhLGIsZSx3LHZvaWQgMCx2b2lkIDAsZCx2b2lkIDAsXCJidXR0b25cIiksSz0wLG49dGhpcy5zdHlsZWRNb2RlLHE9Zz96KGcpOnt9O2E9cSYmcS5zdHlsZXx8e307cT1HLmZpbHRlclVzZXJBdHRyaWJ1dGVzKHEpO3AuYXR0cih6KHtwYWRkaW5nOjgscjoyfSxxKSk7aWYoIW4pe3E9eih7ZmlsbDprLm5ldXRyYWxDb2xvcjMsXG5zdHJva2U6ay5uZXV0cmFsQ29sb3IyMCxcInN0cm9rZS13aWR0aFwiOjEsc3R5bGU6e2NvbG9yOmsubmV1dHJhbENvbG9yODAsY3Vyc29yOlwicG9pbnRlclwiLGZvbnRXZWlnaHQ6XCJub3JtYWxcIn19LHtzdHlsZTphfSxxKTt2YXIgcj1xLnN0eWxlO2RlbGV0ZSBxLnN0eWxlO3U9eihxLHtmaWxsOmsubmV1dHJhbENvbG9yMTB9LEcuZmlsdGVyVXNlckF0dHJpYnV0ZXModXx8e30pKTt2YXIgYWE9dS5zdHlsZTtkZWxldGUgdS5zdHlsZTttPXoocSx7ZmlsbDprLmhpZ2hsaWdodENvbG9yMTAsc3R5bGU6e2NvbG9yOmsubmV1dHJhbENvbG9yMTAwLGZvbnRXZWlnaHQ6XCJib2xkXCJ9fSxHLmZpbHRlclVzZXJBdHRyaWJ1dGVzKG18fHt9KSk7dmFyIGY9bS5zdHlsZTtkZWxldGUgbS5zdHlsZTtJPXoocSx7c3R5bGU6e2NvbG9yOmsubmV1dHJhbENvbG9yMjB9fSxHLmZpbHRlclVzZXJBdHRyaWJ1dGVzKEl8fHt9KSk7dmFyIHY9SS5zdHlsZTtkZWxldGUgSS5zdHlsZX10KHAuZWxlbWVudCxKP1wibW91c2VvdmVyXCI6XG5cIm1vdXNlZW50ZXJcIixmdW5jdGlvbigpezMhPT1LJiZwLnNldFN0YXRlKDEpfSk7dChwLmVsZW1lbnQsSj9cIm1vdXNlb3V0XCI6XCJtb3VzZWxlYXZlXCIsZnVuY3Rpb24oKXszIT09SyYmcC5zZXRTdGF0ZShLKX0pO3Auc2V0U3RhdGU9ZnVuY3Rpb24oYSl7MSE9PWEmJihwLnN0YXRlPUs9YSk7cC5yZW1vdmVDbGFzcygvaGlnaGNoYXJ0cy1idXR0b24tKG5vcm1hbHxob3ZlcnxwcmVzc2VkfGRpc2FibGVkKS8pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1idXR0b24tXCIrW1wibm9ybWFsXCIsXCJob3ZlclwiLFwicHJlc3NlZFwiLFwiZGlzYWJsZWRcIl1bYXx8MF0pO258fHAuYXR0cihbcSx1LG0sSV1bYXx8MF0pLmNzcyhbcixhYSxmLHZdW2F8fDBdKX07bnx8cC5hdHRyKHEpLmNzcyhjKHtjdXJzb3I6XCJkZWZhdWx0XCJ9LHIpKTtyZXR1cm4gcC5vbihcImNsaWNrXCIsZnVuY3Rpb24oYSl7MyE9PUsmJmguY2FsbChwLGEpfSl9O2QucHJvdG90eXBlLmNyaXNwTGluZT1mdW5jdGlvbihhLGIsZSl7dm9pZCAwPT09ZSYmXG4oZT1cInJvdW5kXCIpO3ZhciBwPWFbMF0sYz1hWzFdO3BbMV09PT1jWzFdJiYocFsxXT1jWzFdPU1hdGhbZV0ocFsxXSktYiUyLzIpO3BbMl09PT1jWzJdJiYocFsyXT1jWzJdPU1hdGhbZV0ocFsyXSkrYiUyLzIpO3JldHVybiBhfTtkLnByb3RvdHlwZS5wYXRoPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc3R5bGVkTW9kZT97fTp7ZmlsbDpcIm5vbmVcIn07cShhKT9iLmQ9YTpBKGEpJiZjKGIsYSk7cmV0dXJuIHRoaXMuY3JlYXRlRWxlbWVudChcInBhdGhcIikuYXR0cihiKX07ZC5wcm90b3R5cGUuY2lyY2xlPWZ1bmN0aW9uKGEsYixlKXthPUEoYSk/YTpcInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/e306e3g6YSx5OmIscjplfTtiPXRoaXMuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiKTtiLnhTZXR0ZXI9Yi55U2V0dGVyPWZ1bmN0aW9uKGEsYixwKXtwLnNldEF0dHJpYnV0ZShcImNcIitiLGEpfTtyZXR1cm4gYi5hdHRyKGEpfTtkLnByb3RvdHlwZS5hcmM9ZnVuY3Rpb24oYSxiLGUsYyxoLHUpe0EoYSk/XG4oYz1hLGI9Yy55LGU9Yy5yLGE9Yy54KTpjPXtpbm5lclI6YyxzdGFydDpoLGVuZDp1fTthPXRoaXMuc3ltYm9sKFwiYXJjXCIsYSxiLGUsZSxjKTthLnI9ZTtyZXR1cm4gYX07ZC5wcm90b3R5cGUucmVjdD1mdW5jdGlvbihhLGIsZSxjLGgsdSl7aD1BKGEpP2EucjpoO3ZhciBwPXRoaXMuY3JlYXRlRWxlbWVudChcInJlY3RcIik7YT1BKGEpP2E6XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhP3t9Ont4OmEseTpiLHdpZHRoOk1hdGgubWF4KGUsMCksaGVpZ2h0Ok1hdGgubWF4KGMsMCl9O3RoaXMuc3R5bGVkTW9kZXx8KFwidW5kZWZpbmVkXCIhPT10eXBlb2YgdSYmKGEuc3Ryb2tlV2lkdGg9dSxhPXAuY3Jpc3AoYSkpLGEuZmlsbD1cIm5vbmVcIik7aCYmKGEucj1oKTtwLnJTZXR0ZXI9ZnVuY3Rpb24oYSxiLGUpe3Aucj1hO0MoZSx7cng6YSxyeTphfSl9O3AuckdldHRlcj1mdW5jdGlvbigpe3JldHVybiBwLnJ9O3JldHVybiBwLmF0dHIoYSl9O2QucHJvdG90eXBlLnNldFNpemU9ZnVuY3Rpb24oYSxiLFxuZSl7dmFyIHA9dGhpcy5hbGlnbmVkT2JqZWN0cyxjPXAubGVuZ3RoO3RoaXMud2lkdGg9YTt0aGlzLmhlaWdodD1iO2Zvcih0aGlzLmJveFdyYXBwZXIuYW5pbWF0ZSh7d2lkdGg6YSxoZWlnaHQ6Yn0se3N0ZXA6ZnVuY3Rpb24oKXt0aGlzLmF0dHIoe3ZpZXdCb3g6XCIwIDAgXCIrdGhpcy5hdHRyKFwid2lkdGhcIikrXCIgXCIrdGhpcy5hdHRyKFwiaGVpZ2h0XCIpfSl9LGR1cmF0aW9uOm0oZSwhMCk/dm9pZCAwOjB9KTtjLS07KXBbY10uYWxpZ24oKX07ZC5wcm90b3R5cGUuZz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNyZWF0ZUVsZW1lbnQoXCJnXCIpO3JldHVybiBhP2IuYXR0cih7XCJjbGFzc1wiOlwiaGlnaGNoYXJ0cy1cIithfSk6Yn07ZC5wcm90b3R5cGUuaW1hZ2U9ZnVuY3Rpb24oYSxiLGUsaCxnLHUpe3ZhciBwPXtwcmVzZXJ2ZUFzcGVjdFJhdGlvOlwibm9uZVwifSxLPWZ1bmN0aW9uKGEsYil7YS5zZXRBdHRyaWJ1dGVOUz9hLnNldEF0dHJpYnV0ZU5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuXCJocmVmXCIsYik6YS5zZXRBdHRyaWJ1dGUoXCJoYy1zdmctaHJlZlwiLGIpfSxtPWZ1bmN0aW9uKGIpe0sody5lbGVtZW50LGEpO3UuY2FsbCh3LGIpfTsxPGFyZ3VtZW50cy5sZW5ndGgmJmMocCx7eDpiLHk6ZSx3aWR0aDpoLGhlaWdodDpnfSk7dmFyIHc9dGhpcy5jcmVhdGVFbGVtZW50KFwiaW1hZ2VcIikuYXR0cihwKTt1PyhLKHcuZWxlbWVudCxcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCIpLHA9bmV3IFIuSW1hZ2UsdChwLFwibG9hZFwiLG0pLHAuc3JjPWEscC5jb21wbGV0ZSYmbSh7fSkpOksody5lbGVtZW50LGEpO3JldHVybiB3fTtkLnByb3RvdHlwZS5zeW1ib2w9ZnVuY3Rpb24oYSxwLGUsdyxkLHUpe3ZhciBLPXRoaXMsST0vXnVybFxcKCguKj8pXFwpJC8scT1JLnRlc3QoYSksbj0hcSYmKHRoaXMuc3ltYm9sc1thXT9hOlwiY2lyY2xlXCIpLHI9biYmdGhpcy5zeW1ib2xzW25dLEo7aWYocil7XCJudW1iZXJcIj09PVxudHlwZW9mIHAmJihKPXIuY2FsbCh0aGlzLnN5bWJvbHMsTWF0aC5yb3VuZChwfHwwKSxNYXRoLnJvdW5kKGV8fDApLHd8fDAsZHx8MCx1KSk7dmFyIGY9dGhpcy5wYXRoKEopO0suc3R5bGVkTW9kZXx8Zi5hdHRyKFwiZmlsbFwiLFwibm9uZVwiKTtjKGYse3N5bWJvbE5hbWU6bix4OnAseTplLHdpZHRoOncsaGVpZ2h0OmR9KTt1JiZjKGYsdSl9ZWxzZSBpZihxKXt2YXIgdj1hLm1hdGNoKEkpWzFdO2Y9dGhpcy5pbWFnZSh2KTtmLmltZ3dpZHRoPW0oTlt2XSYmTlt2XS53aWR0aCx1JiZ1LndpZHRoKTtmLmltZ2hlaWdodD1tKE5bdl0mJk5bdl0uaGVpZ2h0LHUmJnUuaGVpZ2h0KTt2YXIgRj1mdW5jdGlvbigpe2YuYXR0cih7d2lkdGg6Zi53aWR0aCxoZWlnaHQ6Zi5oZWlnaHR9KX07W1wid2lkdGhcIixcImhlaWdodFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2ZbYStcIlNldHRlclwiXT1mdW5jdGlvbihhLGIpe3ZhciBwPXt9LGU9dGhpc1tcImltZ1wiK2JdLGM9XCJ3aWR0aFwiPT09Yj9cInRyYW5zbGF0ZVhcIjpcblwidHJhbnNsYXRlWVwiO3RoaXNbYl09YTtnKGUpJiYodSYmXCJ3aXRoaW5cIj09PXUuYmFja2dyb3VuZFNpemUmJnRoaXMud2lkdGgmJnRoaXMuaGVpZ2h0JiYoZT1NYXRoLnJvdW5kKGUqTWF0aC5taW4odGhpcy53aWR0aC90aGlzLmltZ3dpZHRoLHRoaXMuaGVpZ2h0L3RoaXMuaW1naGVpZ2h0KSkpLHRoaXMuZWxlbWVudCYmdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShiLGUpLHRoaXMuYWxpZ25CeVRyYW5zbGF0ZXx8KHBbY109KCh0aGlzW2JdfHwwKS1lKS8yLHRoaXMuYXR0cihwKSkpfX0pO2cocCkmJmYuYXR0cih7eDpwLHk6ZX0pO2YuaXNJbWc9ITA7ZyhmLmltZ3dpZHRoKSYmZyhmLmltZ2hlaWdodCk/RigpOihmLmF0dHIoe3dpZHRoOjAsaGVpZ2h0OjB9KSxsKFwiaW1nXCIse29ubG9hZDpmdW5jdGlvbigpe3ZhciBhPWhbSy5jaGFydEluZGV4XTswPT09dGhpcy53aWR0aCYmKEUodGhpcyx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHRvcDpcIi05OTllbVwifSksYi5ib2R5LmFwcGVuZENoaWxkKHRoaXMpKTtcbk5bdl09e3dpZHRoOnRoaXMud2lkdGgsaGVpZ2h0OnRoaXMuaGVpZ2h0fTtmLmltZ3dpZHRoPXRoaXMud2lkdGg7Zi5pbWdoZWlnaHQ9dGhpcy5oZWlnaHQ7Zi5lbGVtZW50JiZGKCk7dGhpcy5wYXJlbnROb2RlJiZ0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7Sy5pbWdDb3VudC0tO2lmKCFLLmltZ0NvdW50JiZhJiYhYS5oYXNMb2FkZWQpYS5vbmxvYWQoKX0sc3JjOnZ9KSx0aGlzLmltZ0NvdW50KyspfXJldHVybiBmfTtkLnByb3RvdHlwZS5jbGlwUmVjdD1mdW5jdGlvbihhLGIsYyxoKXt2YXIgcD1lKCkrXCItXCIsdT10aGlzLmNyZWF0ZUVsZW1lbnQoXCJjbGlwUGF0aFwiKS5hdHRyKHtpZDpwfSkuYWRkKHRoaXMuZGVmcyk7YT10aGlzLnJlY3QoYSxiLGMsaCwwKS5hZGQodSk7YS5pZD1wO2EuY2xpcFBhdGg9dTthLmNvdW50PTA7cmV0dXJuIGF9O2QucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oYSxiLGUsYyl7dmFyIHA9e307aWYoYyYmKHRoaXMuYWxsb3dIVE1MfHwhdGhpcy5mb3JFeHBvcnQpKXJldHVybiB0aGlzLmh0bWwoYSxcbmIsZSk7cC54PU1hdGgucm91bmQoYnx8MCk7ZSYmKHAueT1NYXRoLnJvdW5kKGUpKTtnKGEpJiYocC50ZXh0PWEpO2E9dGhpcy5jcmVhdGVFbGVtZW50KFwidGV4dFwiKS5hdHRyKHApO2N8fChhLnhTZXR0ZXI9ZnVuY3Rpb24oYSxiLHApe3ZhciBlPXAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0c3BhblwiKSx1PXAuZ2V0QXR0cmlidXRlKGIpLGM7Zm9yKGM9MDtjPGUubGVuZ3RoO2MrKyl7dmFyIGg9ZVtjXTtoLmdldEF0dHJpYnV0ZShiKT09PXUmJmguc2V0QXR0cmlidXRlKGIsYSl9cC5zZXRBdHRyaWJ1dGUoYixhKX0pO3JldHVybiBhfTtkLnByb3RvdHlwZS5mb250TWV0cmljcz1mdW5jdGlvbihhLGIpe2E9IXRoaXMuc3R5bGVkTW9kZSYmL3B4Ly50ZXN0KGEpfHwhUi5nZXRDb21wdXRlZFN0eWxlP2F8fGImJmIuc3R5bGUmJmIuc3R5bGUuZm9udFNpemV8fHRoaXMuc3R5bGUmJnRoaXMuc3R5bGUuZm9udFNpemU6YiYmeC5wcm90b3R5cGUuZ2V0U3R5bGUuY2FsbChiLFwiZm9udC1zaXplXCIpO1xuYT0vcHgvLnRlc3QoYSk/cihhKToxMjtiPTI0PmE/YSszOk1hdGgucm91bmQoMS4yKmEpO3JldHVybntoOmIsYjpNYXRoLnJvdW5kKC44KmIpLGY6YX19O2QucHJvdG90eXBlLnJvdENvcnI9ZnVuY3Rpb24oYixwLGUpe3ZhciBjPWI7cCYmZSYmKGM9TWF0aC5tYXgoYypNYXRoLmNvcyhwKmEpLDQpKTtyZXR1cm57eDotYi8zKk1hdGguc2luKHAqYSkseTpjfX07ZC5wcm90b3R5cGUucGF0aFRvU2VnbWVudHM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGU9W10sYz17QTo4LEM6NyxIOjIsTDozLE06MyxROjUsUzo1LFQ6MyxWOjJ9LGg9MDtoPGEubGVuZ3RoO2grKylNKGVbMF0pJiZuKGFbaF0pJiZlLmxlbmd0aD09PWNbZVswXS50b1VwcGVyQ2FzZSgpXSYmYS5zcGxpY2UoaCwwLGVbMF0ucmVwbGFjZShcIk1cIixcIkxcIikucmVwbGFjZShcIm1cIixcImxcIikpLFwic3RyaW5nXCI9PT10eXBlb2YgYVtoXSYmKGUubGVuZ3RoJiZiLnB1c2goZS5zbGljZSgwKSksZS5sZW5ndGg9MCksZS5wdXNoKGFbaF0pO1xuYi5wdXNoKGUuc2xpY2UoMCkpO3JldHVybiBifTtkLnByb3RvdHlwZS5sYWJlbD1mdW5jdGlvbihhLGIsZSxjLGgsdSxnLG0sdyl7cmV0dXJuIG5ldyBCKHRoaXMsYSxiLGUsYyxoLHUsZyxtLHcpfTtyZXR1cm4gZH0oKTtULnByb3RvdHlwZS5FbGVtZW50PXg7VC5wcm90b3R5cGUuU1ZHX05TPUY7VC5wcm90b3R5cGUuZHJhdz1IO1QucHJvdG90eXBlLmVzY2FwZXM9e1wiJlwiOlwiJmFtcDtcIixcIjxcIjpcIiZsdDtcIixcIj5cIjpcIiZndDtcIixcIidcIjpcIiYjMzk7XCIsJ1wiJzpcIiZxdW90O1wifTtULnByb3RvdHlwZS5zeW1ib2xzPXtjaXJjbGU6ZnVuY3Rpb24oYSxiLGUsYyl7cmV0dXJuIHRoaXMuYXJjKGErZS8yLGIrYy8yLGUvMixjLzIse3N0YXJ0Oi41Kk1hdGguUEksZW5kOjIuNSpNYXRoLlBJLG9wZW46ITF9KX0sc3F1YXJlOmZ1bmN0aW9uKGEsYixlLGMpe3JldHVybltbXCJNXCIsYSxiXSxbXCJMXCIsYStlLGJdLFtcIkxcIixhK2UsYitjXSxbXCJMXCIsYSxiK2NdLFtcIlpcIl1dfSx0cmlhbmdsZTpmdW5jdGlvbihhLFxuYixlLGMpe3JldHVybltbXCJNXCIsYStlLzIsYl0sW1wiTFwiLGErZSxiK2NdLFtcIkxcIixhLGIrY10sW1wiWlwiXV19LFwidHJpYW5nbGUtZG93blwiOmZ1bmN0aW9uKGEsYixlLGMpe3JldHVybltbXCJNXCIsYSxiXSxbXCJMXCIsYStlLGJdLFtcIkxcIixhK2UvMixiK2NdLFtcIlpcIl1dfSxkaWFtb25kOmZ1bmN0aW9uKGEsYixlLGMpe3JldHVybltbXCJNXCIsYStlLzIsYl0sW1wiTFwiLGErZSxiK2MvMl0sW1wiTFwiLGErZS8yLGIrY10sW1wiTFwiLGEsYitjLzJdLFtcIlpcIl1dfSxhcmM6ZnVuY3Rpb24oYSxiLGUsYyxoKXt2YXIgcD1bXTtpZihoKXt2YXIgdT1oLnN0YXJ0fHwwLEs9aC5lbmR8fDAsST1oLnJ8fGU7ZT1oLnJ8fGN8fGU7dmFyIHc9LjAwMT5NYXRoLmFicyhLLXUtMipNYXRoLlBJKTtLLT0uMDAxO2M9aC5pbm5lclI7dz1tKGgub3Blbix3KTt2YXIgZD1NYXRoLmNvcyh1KSxuPU1hdGguc2luKHUpLHE9TWF0aC5jb3MoSykscj1NYXRoLnNpbihLKTt1PW0oaC5sb25nQXJjLC4wMDE+Sy11LU1hdGguUEk/MDoxKTtcbnAucHVzaChbXCJNXCIsYStJKmQsYitlKm5dLFtcIkFcIixJLGUsMCx1LG0oaC5jbG9ja3dpc2UsMSksYStJKnEsYitlKnJdKTtnKGMpJiZwLnB1c2godz9bXCJNXCIsYStjKnEsYitjKnJdOltcIkxcIixhK2MqcSxiK2Mqcl0sW1wiQVwiLGMsYywwLHUsZyhoLmNsb2Nrd2lzZSk/MS1oLmNsb2Nrd2lzZTowLGErYypkLGIrYypuXSk7d3x8cC5wdXNoKFtcIlpcIl0pfXJldHVybiBwfSxjYWxsb3V0OmZ1bmN0aW9uKGEsYixlLGMsaCl7dmFyIHA9TWF0aC5taW4oaCYmaC5yfHwwLGUsYyksdT1wKzYsZz1oJiZoLmFuY2hvclg7aD1oJiZoLmFuY2hvcll8fDA7dmFyIG09W1tcIk1cIixhK3AsYl0sW1wiTFwiLGErZS1wLGJdLFtcIkNcIixhK2UsYixhK2UsYixhK2UsYitwXSxbXCJMXCIsYStlLGIrYy1wXSxbXCJDXCIsYStlLGIrYyxhK2UsYitjLGErZS1wLGIrY10sW1wiTFwiLGErcCxiK2NdLFtcIkNcIixhLGIrYyxhLGIrYyxhLGIrYy1wXSxbXCJMXCIsYSxiK3BdLFtcIkNcIixhLGIsYSxiLGErcCxiXV07aWYoIW4oZykpcmV0dXJuIG07YStcbmc+PWU/aD5iK3UmJmg8YitjLXU/bS5zcGxpY2UoMywxLFtcIkxcIixhK2UsaC02XSxbXCJMXCIsYStlKzYsaF0sW1wiTFwiLGErZSxoKzZdLFtcIkxcIixhK2UsYitjLXBdKTptLnNwbGljZSgzLDEsW1wiTFwiLGErZSxjLzJdLFtcIkxcIixnLGhdLFtcIkxcIixhK2UsYy8yXSxbXCJMXCIsYStlLGIrYy1wXSk6MD49YStnP2g+Yit1JiZoPGIrYy11P20uc3BsaWNlKDcsMSxbXCJMXCIsYSxoKzZdLFtcIkxcIixhLTYsaF0sW1wiTFwiLGEsaC02XSxbXCJMXCIsYSxiK3BdKTptLnNwbGljZSg3LDEsW1wiTFwiLGEsYy8yXSxbXCJMXCIsZyxoXSxbXCJMXCIsYSxjLzJdLFtcIkxcIixhLGIrcF0pOmgmJmg+YyYmZz5hK3UmJmc8YStlLXU/bS5zcGxpY2UoNSwxLFtcIkxcIixnKzYsYitjXSxbXCJMXCIsZyxiK2MrNl0sW1wiTFwiLGctNixiK2NdLFtcIkxcIixhK3AsYitjXSk6aCYmMD5oJiZnPmErdSYmZzxhK2UtdSYmbS5zcGxpY2UoMSwxLFtcIkxcIixnLTYsYl0sW1wiTFwiLGcsYi02XSxbXCJMXCIsZys2LGJdLFtcIkxcIixlLXAsYl0pO3JldHVybiBtfX07ZC5TVkdSZW5kZXJlcj1cblQ7ZC5SZW5kZXJlcj1kLlNWR1JlbmRlcmVyO3JldHVybiBkLlJlbmRlcmVyfSk7UChrLFwiQ29yZS9SZW5kZXJlci9IVE1ML0hUTUxFbGVtZW50LmpzXCIsW2tbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0VsZW1lbnQuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayl7dmFyIHg9ay5jc3MsQj1rLmRlZmluZWQsUz1rLmV4dGVuZCxEPWsucGljayxIPWsucEludCx0PWYuaXNGaXJlZm94O1MoZC5wcm90b3R5cGUse2h0bWxDc3M6ZnVuY3Rpb24oZCl7dmFyIGY9XCJTUEFOXCI9PT10aGlzLmVsZW1lbnQudGFnTmFtZSYmZCYmXCJ3aWR0aFwiaW4gZCx0PUQoZiYmZC53aWR0aCx2b2lkIDApO2lmKGYpe2RlbGV0ZSBkLndpZHRoO3RoaXMudGV4dFdpZHRoPXQ7dmFyIGc9ITB9ZCYmXCJlbGxpcHNpc1wiPT09ZC50ZXh0T3ZlcmZsb3cmJihkLndoaXRlU3BhY2U9XCJub3dyYXBcIixkLm92ZXJmbG93PVwiaGlkZGVuXCIpO3RoaXMuc3R5bGVzPVModGhpcy5zdHlsZXMsXG5kKTt4KHRoaXMuZWxlbWVudCxkKTtnJiZ0aGlzLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtyZXR1cm4gdGhpc30saHRtbEdldEJCb3g6ZnVuY3Rpb24oKXt2YXIgZD10aGlzLmVsZW1lbnQ7cmV0dXJue3g6ZC5vZmZzZXRMZWZ0LHk6ZC5vZmZzZXRUb3Asd2lkdGg6ZC5vZmZzZXRXaWR0aCxoZWlnaHQ6ZC5vZmZzZXRIZWlnaHR9fSxodG1sVXBkYXRlVHJhbnNmb3JtOmZ1bmN0aW9uKCl7aWYodGhpcy5hZGRlZCl7dmFyIGQ9dGhpcy5yZW5kZXJlcixmPXRoaXMuZWxlbWVudCx0PXRoaXMudHJhbnNsYXRlWHx8MCxnPXRoaXMudHJhbnNsYXRlWXx8MCx5PXRoaXMueHx8MCxjPXRoaXMueXx8MCxxPXRoaXMudGV4dEFsaWdufHxcImxlZnRcIixuPXtsZWZ0OjAsY2VudGVyOi41LHJpZ2h0OjF9W3FdLEE9dGhpcy5zdHlsZXMsTT1BJiZBLndoaXRlU3BhY2U7eChmLHttYXJnaW5MZWZ0OnQsbWFyZ2luVG9wOmd9KTshZC5zdHlsZWRNb2RlJiZ0aGlzLnNoYWRvd3MmJnRoaXMuc2hhZG93cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3goZSxcbnttYXJnaW5MZWZ0OnQrMSxtYXJnaW5Ub3A6ZysxfSl9KTt0aGlzLmludmVydGVkJiZbXS5mb3JFYWNoLmNhbGwoZi5jaGlsZE5vZGVzLGZ1bmN0aW9uKGUpe2QuaW52ZXJ0Q2hpbGQoZSxmKX0pO2lmKFwiU1BBTlwiPT09Zi50YWdOYW1lKXtBPXRoaXMucm90YXRpb247dmFyIHo9dGhpcy50ZXh0V2lkdGgmJkgodGhpcy50ZXh0V2lkdGgpLG09W0EscSxmLmlubmVySFRNTCx0aGlzLnRleHRXaWR0aCx0aGlzLnRleHRBbGlnbl0uam9pbigpLHI7KHI9eiE9PXRoaXMub2xkVGV4dFdpZHRoKSYmIShyPXo+dGhpcy5vbGRUZXh0V2lkdGgpJiYoKHI9dGhpcy50ZXh0UHhMZW5ndGgpfHwoeChmLHt3aWR0aDpcIlwiLHdoaXRlU3BhY2U6TXx8XCJub3dyYXBcIn0pLHI9Zi5vZmZzZXRXaWR0aCkscj1yPnopO3ImJigvWyBcXC1dLy50ZXN0KGYudGV4dENvbnRlbnR8fGYuaW5uZXJUZXh0KXx8XCJlbGxpcHNpc1wiPT09Zi5zdHlsZS50ZXh0T3ZlcmZsb3cpPyh4KGYse3dpZHRoOnorXCJweFwiLGRpc3BsYXk6XCJibG9ja1wiLFxud2hpdGVTcGFjZTpNfHxcIm5vcm1hbFwifSksdGhpcy5vbGRUZXh0V2lkdGg9eix0aGlzLmhhc0JveFdpZHRoQ2hhbmdlZD0hMCk6dGhpcy5oYXNCb3hXaWR0aENoYW5nZWQ9ITE7bSE9PXRoaXMuY1RUJiYoTT1kLmZvbnRNZXRyaWNzKGYuc3R5bGUuZm9udFNpemUsZikuYiwhQihBKXx8QT09PSh0aGlzLm9sZFJvdGF0aW9ufHwwKSYmcT09PXRoaXMub2xkQWxpZ258fHRoaXMuc2V0U3BhblJvdGF0aW9uKEEsbixNKSx0aGlzLmdldFNwYW5Db3JyZWN0aW9uKCFCKEEpJiZ0aGlzLnRleHRQeExlbmd0aHx8Zi5vZmZzZXRXaWR0aCxNLG4sQSxxKSk7eChmLHtsZWZ0OnkrKHRoaXMueENvcnJ8fDApK1wicHhcIix0b3A6YysodGhpcy55Q29ycnx8MCkrXCJweFwifSk7dGhpcy5jVFQ9bTt0aGlzLm9sZFJvdGF0aW9uPUE7dGhpcy5vbGRBbGlnbj1xfX1lbHNlIHRoaXMuYWxpZ25PbkFkZD0hMH0sc2V0U3BhblJvdGF0aW9uOmZ1bmN0aW9uKGQsZixrKXt2YXIgZz17fSxsPXRoaXMucmVuZGVyZXIuZ2V0VHJhbnNmb3JtS2V5KCk7XG5nW2xdPWcudHJhbnNmb3JtPVwicm90YXRlKFwiK2QrXCJkZWcpXCI7Z1tsKyh0P1wiT3JpZ2luXCI6XCItb3JpZ2luXCIpXT1nLnRyYW5zZm9ybU9yaWdpbj0xMDAqZitcIiUgXCIraytcInB4XCI7eCh0aGlzLmVsZW1lbnQsZyl9LGdldFNwYW5Db3JyZWN0aW9uOmZ1bmN0aW9uKGQsZix0KXt0aGlzLnhDb3JyPS1kKnQ7dGhpcy55Q29ycj0tZn19KTtyZXR1cm4gZH0pO1AoayxcIkNvcmUvUmVuZGVyZXIvSFRNTC9IVE1MUmVuZGVyZXIuanNcIixba1tcIkNvcmUvR2xvYmFscy5qc1wiXSxrW1wiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiXSxrW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHRWxlbWVudC5qc1wiXSxrW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHUmVuZGVyZXIuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4LEIpe3ZhciBTPWYuaXNGaXJlZm94LEQ9Zi5pc01TLEg9Zi5pc1dlYktpdCx0PWYud2luLEM9Qi5hdHRyLGw9Qi5jcmVhdGVFbGVtZW50LEU9Qi5leHRlbmQsZz1CLnBpY2s7XG5FKHgucHJvdG90eXBlLHtnZXRUcmFuc2Zvcm1LZXk6ZnVuY3Rpb24oKXtyZXR1cm4gRCYmIS9FZGdlLy50ZXN0KHQubmF2aWdhdG9yLnVzZXJBZ2VudCk/XCItbXMtdHJhbnNmb3JtXCI6SD9cIi13ZWJraXQtdHJhbnNmb3JtXCI6Uz9cIk1velRyYW5zZm9ybVwiOnQub3BlcmE/XCItby10cmFuc2Zvcm1cIjpcIlwifSxodG1sOmZ1bmN0aW9uKGYsYyxxKXt2YXIgbj10aGlzLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLEE9bi5lbGVtZW50LE09bi5yZW5kZXJlcix6PU0uaXNTVkcsbT1mdW5jdGlvbihjLGUpe1tcIm9wYWNpdHlcIixcInZpc2liaWxpdHlcIl0uZm9yRWFjaChmdW5jdGlvbihoKXtjW2grXCJTZXR0ZXJcIl09ZnVuY3Rpb24oYSxiLGcpe3ZhciBtPWMuZGl2P2MuZGl2LnN0eWxlOmU7ay5wcm90b3R5cGVbaCtcIlNldHRlclwiXS5jYWxsKHRoaXMsYSxiLGcpO20mJihtW2JdPWEpfX0pO2MuYWRkZWRTZXR0ZXJzPSEwfTtuLnRleHRTZXR0ZXI9ZnVuY3Rpb24oYyl7YyE9PXRoaXMudGV4dFN0ciYmKGRlbGV0ZSB0aGlzLmJCb3gsXG5kZWxldGUgdGhpcy5vbGRUZXh0V2lkdGgsZC5zZXRFbGVtZW50SFRNTCh0aGlzLmVsZW1lbnQsZyhjLFwiXCIpKSx0aGlzLnRleHRTdHI9YyxuLmRvVHJhbnNmb3JtPSEwKX07eiYmbShuLG4uZWxlbWVudC5zdHlsZSk7bi54U2V0dGVyPW4ueVNldHRlcj1uLmFsaWduU2V0dGVyPW4ucm90YXRpb25TZXR0ZXI9ZnVuY3Rpb24oYyxlKXtcImFsaWduXCI9PT1lP24uYWxpZ25WYWx1ZT1uLnRleHRBbGlnbj1jOm5bZV09YztuLmRvVHJhbnNmb3JtPSEwfTtuLmFmdGVyU2V0dGVycz1mdW5jdGlvbigpe3RoaXMuZG9UcmFuc2Zvcm0mJih0aGlzLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKSx0aGlzLmRvVHJhbnNmb3JtPSExKX07bi5hdHRyKHt0ZXh0OmYseDpNYXRoLnJvdW5kKGMpLHk6TWF0aC5yb3VuZChxKX0pLmNzcyh7cG9zaXRpb246XCJhYnNvbHV0ZVwifSk7TS5zdHlsZWRNb2RlfHxuLmNzcyh7Zm9udEZhbWlseTp0aGlzLnN0eWxlLmZvbnRGYW1pbHksZm9udFNpemU6dGhpcy5zdHlsZS5mb250U2l6ZX0pO1xuQS5zdHlsZS53aGl0ZVNwYWNlPVwibm93cmFwXCI7bi5jc3M9bi5odG1sQ3NzO3omJihuLmFkZD1mdW5jdGlvbihjKXt2YXIgZT1NLmJveC5wYXJlbnROb2RlLGg9W107aWYodGhpcy5wYXJlbnRHcm91cD1jKXt2YXIgYT1jLmRpdjtpZighYSl7Zm9yKDtjOyloLnB1c2goYyksYz1jLnBhcmVudEdyb3VwO2gucmV2ZXJzZSgpLmZvckVhY2goZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhLGUpe2JbZV09YTtcInRyYW5zbGF0ZVhcIj09PWU/cS5sZWZ0PWErXCJweFwiOnEudG9wPWErXCJweFwiO2IuZG9UcmFuc2Zvcm09ITB9dmFyIGc9QyhiLmVsZW1lbnQsXCJjbGFzc1wiKSxkPWIuc3R5bGVzfHx7fTthPWIuZGl2PWIuZGl2fHxsKFwiZGl2XCIsZz97Y2xhc3NOYW1lOmd9OnZvaWQgMCx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLGxlZnQ6KGIudHJhbnNsYXRlWHx8MCkrXCJweFwiLHRvcDooYi50cmFuc2xhdGVZfHwwKStcInB4XCIsZGlzcGxheTpiLmRpc3BsYXksb3BhY2l0eTpiLm9wYWNpdHksY3Vyc29yOmQuY3Vyc29yLFxucG9pbnRlckV2ZW50czpkLnBvaW50ZXJFdmVudHN9LGF8fGUpO3ZhciBxPWEuc3R5bGU7RShiLHtjbGFzc1NldHRlcjpmdW5jdGlvbihhKXtyZXR1cm4gZnVuY3Rpb24oYil7dGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYik7YS5jbGFzc05hbWU9Yn19KGEpLG9uOmZ1bmN0aW9uKCl7aFswXS5kaXYmJm4ub24uYXBwbHkoe2VsZW1lbnQ6aFswXS5kaXZ9LGFyZ3VtZW50cyk7cmV0dXJuIGJ9LHRyYW5zbGF0ZVhTZXR0ZXI6Yyx0cmFuc2xhdGVZU2V0dGVyOmN9KTtiLmFkZGVkU2V0dGVyc3x8bShiKX0pfX1lbHNlIGE9ZTthLmFwcGVuZENoaWxkKEEpO24uYWRkZWQ9ITA7bi5hbGlnbk9uQWRkJiZuLmh0bWxVcGRhdGVUcmFuc2Zvcm0oKTtyZXR1cm4gbn0pO3JldHVybiBufX0pO3JldHVybiB4fSk7UChrLFwiQ29yZS9UaW1lLmpzXCIsW2tbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQpe3ZhciBrPWYud2luLHg9ZC5kZWZpbmVkLFxuQj1kLmVycm9yLEc9ZC5leHRlbmQsRD1kLmlzT2JqZWN0LEg9ZC5tZXJnZSx0PWQub2JqZWN0RWFjaCxDPWQucGFkLGw9ZC5waWNrLEU9ZC5zcGxhdCxnPWQudGltZVVuaXRzO1wiXCI7ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGQoYyl7dGhpcy5vcHRpb25zPXt9O3RoaXMudmFyaWFibGVUaW1lem9uZT10aGlzLnVzZVVUQz0hMTt0aGlzLkRhdGU9ay5EYXRlO3RoaXMuZ2V0VGltZXpvbmVPZmZzZXQ9dGhpcy50aW1lem9uZU9mZnNldEZ1bmN0aW9uKCk7dGhpcy51cGRhdGUoYyl9ZC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGMsZyl7aWYodGhpcy52YXJpYWJsZVRpbWV6b25lfHx0aGlzLnRpbWV6b25lT2Zmc2V0KXt2YXIgZD1nLmdldFRpbWUoKSxxPWQtdGhpcy5nZXRUaW1lem9uZU9mZnNldChnKTtnLnNldFRpbWUocSk7Yz1nW1wiZ2V0VVRDXCIrY10oKTtnLnNldFRpbWUoZCk7cmV0dXJuIGN9cmV0dXJuIHRoaXMudXNlVVRDP2dbXCJnZXRVVENcIitjXSgpOmdbXCJnZXRcIitjXSgpfTtkLnByb3RvdHlwZS5zZXQ9XG5mdW5jdGlvbihjLGcsZCl7aWYodGhpcy52YXJpYWJsZVRpbWV6b25lfHx0aGlzLnRpbWV6b25lT2Zmc2V0KXtpZihcIk1pbGxpc2Vjb25kc1wiPT09Y3x8XCJTZWNvbmRzXCI9PT1jfHxcIk1pbnV0ZXNcIj09PWMmJjA9PT10aGlzLmdldFRpbWV6b25lT2Zmc2V0KGcpJTM2RTUpcmV0dXJuIGdbXCJzZXRVVENcIitjXShkKTt2YXIgbj10aGlzLmdldFRpbWV6b25lT2Zmc2V0KGcpO249Zy5nZXRUaW1lKCktbjtnLnNldFRpbWUobik7Z1tcInNldFVUQ1wiK2NdKGQpO2M9dGhpcy5nZXRUaW1lem9uZU9mZnNldChnKTtuPWcuZ2V0VGltZSgpK2M7cmV0dXJuIGcuc2V0VGltZShuKX1yZXR1cm4gdGhpcy51c2VVVEM/Z1tcInNldFVUQ1wiK2NdKGQpOmdbXCJzZXRcIitjXShkKX07ZC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGMpe3ZhciBnPWwoYyYmYy51c2VVVEMsITApO3RoaXMub3B0aW9ucz1jPUgoITAsdGhpcy5vcHRpb25zfHx7fSxjKTt0aGlzLkRhdGU9Yy5EYXRlfHxrLkRhdGV8fERhdGU7dGhpcy50aW1lem9uZU9mZnNldD1cbih0aGlzLnVzZVVUQz1nKSYmYy50aW1lem9uZU9mZnNldDt0aGlzLmdldFRpbWV6b25lT2Zmc2V0PXRoaXMudGltZXpvbmVPZmZzZXRGdW5jdGlvbigpO3RoaXMudmFyaWFibGVUaW1lem9uZT1nJiYhKCFjLmdldFRpbWV6b25lT2Zmc2V0JiYhYy50aW1lem9uZSl9O2QucHJvdG90eXBlLm1ha2VUaW1lPWZ1bmN0aW9uKGMsZyxkLEEsTSx6KXtpZih0aGlzLnVzZVVUQyl7dmFyIG09dGhpcy5EYXRlLlVUQy5hcHBseSgwLGFyZ3VtZW50cyk7dmFyIG49dGhpcy5nZXRUaW1lem9uZU9mZnNldChtKTttKz1uO3ZhciBlPXRoaXMuZ2V0VGltZXpvbmVPZmZzZXQobSk7biE9PWU/bSs9ZS1uOm4tMzZFNSE9PXRoaXMuZ2V0VGltZXpvbmVPZmZzZXQobS0zNkU1KXx8Zi5pc1NhZmFyaXx8KG0tPTM2RTUpfWVsc2UgbT0obmV3IHRoaXMuRGF0ZShjLGcsbChkLDEpLGwoQSwwKSxsKE0sMCksbCh6LDApKSkuZ2V0VGltZSgpO3JldHVybiBtfTtkLnByb3RvdHlwZS50aW1lem9uZU9mZnNldEZ1bmN0aW9uPVxuZnVuY3Rpb24oKXt2YXIgYz10aGlzLGc9dGhpcy5vcHRpb25zLGQ9Zy5tb21lbnR8fGsubW9tZW50O2lmKCF0aGlzLnVzZVVUQylyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIDZFNCoobmV3IERhdGUoYy50b1N0cmluZygpKSkuZ2V0VGltZXpvbmVPZmZzZXQoKX07aWYoZy50aW1lem9uZSl7aWYoZClyZXR1cm4gZnVuY3Rpb24oYyl7cmV0dXJuIDZFNCotZC50eihjLGcudGltZXpvbmUpLnV0Y09mZnNldCgpfTtCKDI1KX1yZXR1cm4gdGhpcy51c2VVVEMmJmcuZ2V0VGltZXpvbmVPZmZzZXQ/ZnVuY3Rpb24oYyl7cmV0dXJuIDZFNCpnLmdldFRpbWV6b25lT2Zmc2V0KGMudmFsdWVPZigpKX06ZnVuY3Rpb24oKXtyZXR1cm4gNkU0KihjLnRpbWV6b25lT2Zmc2V0fHwwKX19O2QucHJvdG90eXBlLmRhdGVGb3JtYXQ9ZnVuY3Rpb24oYyxnLGQpe3ZhciBuO2lmKCF4KGcpfHxpc05hTihnKSlyZXR1cm4obnVsbD09PShuPWYuZGVmYXVsdE9wdGlvbnMubGFuZyl8fHZvaWQgMD09PW4/dm9pZCAwOlxubi5pbnZhbGlkRGF0ZSl8fFwiXCI7Yz1sKGMsXCIlWS0lbS0lZCAlSDolTTolU1wiKTt2YXIgcT10aGlzO249bmV3IHRoaXMuRGF0ZShnKTt2YXIgej10aGlzLmdldChcIkhvdXJzXCIsbiksbT10aGlzLmdldChcIkRheVwiLG4pLHI9dGhpcy5nZXQoXCJEYXRlXCIsbiksZT10aGlzLmdldChcIk1vbnRoXCIsbiksaD10aGlzLmdldChcIkZ1bGxZZWFyXCIsbiksYT1mLmRlZmF1bHRPcHRpb25zLmxhbmcsYj1udWxsPT09YXx8dm9pZCAwPT09YT92b2lkIDA6YS53ZWVrZGF5cyx3PW51bGw9PT1hfHx2b2lkIDA9PT1hP3ZvaWQgMDphLnNob3J0V2Vla2RheXM7bj1HKHthOnc/d1ttXTpiW21dLnN1YnN0cigwLDMpLEE6YlttXSxkOkMociksZTpDKHIsMixcIiBcIiksdzptLGI6YS5zaG9ydE1vbnRoc1tlXSxCOmEubW9udGhzW2VdLG06QyhlKzEpLG86ZSsxLHk6aC50b1N0cmluZygpLnN1YnN0cigyLDIpLFk6aCxIOkMoeiksazp6LEk6Qyh6JTEyfHwxMiksbDp6JTEyfHwxMixNOkModGhpcy5nZXQoXCJNaW51dGVzXCIsXG5uKSkscDoxMj56P1wiQU1cIjpcIlBNXCIsUDoxMj56P1wiYW1cIjpcInBtXCIsUzpDKG4uZ2V0U2Vjb25kcygpKSxMOkMoTWF0aC5mbG9vcihnJTFFMyksMyl9LGYuZGF0ZUZvcm1hdHMpO3QobixmdW5jdGlvbihhLGIpe2Zvcig7LTEhPT1jLmluZGV4T2YoXCIlXCIrYik7KWM9Yy5yZXBsYWNlKFwiJVwiK2IsXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5jYWxsKHEsZyk6YSl9KTtyZXR1cm4gZD9jLnN1YnN0cigwLDEpLnRvVXBwZXJDYXNlKCkrYy5zdWJzdHIoMSk6Y307ZC5wcm90b3R5cGUucmVzb2x2ZURUTEZvcm1hdD1mdW5jdGlvbihjKXtyZXR1cm4gRChjLCEwKT9jOihjPUUoYykse21haW46Y1swXSxmcm9tOmNbMV0sdG86Y1syXX0pfTtkLnByb3RvdHlwZS5nZXRUaW1lVGlja3M9ZnVuY3Rpb24oYyxkLG4sZil7dmFyIHE9dGhpcyxBPVtdLG09e307dmFyIHI9bmV3IHEuRGF0ZShkKTt2YXIgZT1jLnVuaXRSYW5nZSxoPWMuY291bnR8fDEsYTtmPWwoZiwxKTtpZih4KGQpKXtxLnNldChcIk1pbGxpc2Vjb25kc1wiLFxucixlPj1nLnNlY29uZD8wOmgqTWF0aC5mbG9vcihxLmdldChcIk1pbGxpc2Vjb25kc1wiLHIpL2gpKTtlPj1nLnNlY29uZCYmcS5zZXQoXCJTZWNvbmRzXCIscixlPj1nLm1pbnV0ZT8wOmgqTWF0aC5mbG9vcihxLmdldChcIlNlY29uZHNcIixyKS9oKSk7ZT49Zy5taW51dGUmJnEuc2V0KFwiTWludXRlc1wiLHIsZT49Zy5ob3VyPzA6aCpNYXRoLmZsb29yKHEuZ2V0KFwiTWludXRlc1wiLHIpL2gpKTtlPj1nLmhvdXImJnEuc2V0KFwiSG91cnNcIixyLGU+PWcuZGF5PzA6aCpNYXRoLmZsb29yKHEuZ2V0KFwiSG91cnNcIixyKS9oKSk7ZT49Zy5kYXkmJnEuc2V0KFwiRGF0ZVwiLHIsZT49Zy5tb250aD8xOk1hdGgubWF4KDEsaCpNYXRoLmZsb29yKHEuZ2V0KFwiRGF0ZVwiLHIpL2gpKSk7aWYoZT49Zy5tb250aCl7cS5zZXQoXCJNb250aFwiLHIsZT49Zy55ZWFyPzA6aCpNYXRoLmZsb29yKHEuZ2V0KFwiTW9udGhcIixyKS9oKSk7dmFyIGI9cS5nZXQoXCJGdWxsWWVhclwiLHIpfWU+PWcueWVhciYmcS5zZXQoXCJGdWxsWWVhclwiLFxucixiLWIlaCk7ZT09PWcud2VlayYmKGI9cS5nZXQoXCJEYXlcIixyKSxxLnNldChcIkRhdGVcIixyLHEuZ2V0KFwiRGF0ZVwiLHIpLWIrZisoYjxmPy03OjApKSk7Yj1xLmdldChcIkZ1bGxZZWFyXCIscik7Zj1xLmdldChcIk1vbnRoXCIscik7dmFyIHc9cS5nZXQoXCJEYXRlXCIsciksSj1xLmdldChcIkhvdXJzXCIscik7ZD1yLmdldFRpbWUoKTshcS52YXJpYWJsZVRpbWV6b25lJiZxLnVzZVVUQ3x8IXgobil8fChhPW4tZD40KmcubW9udGh8fHEuZ2V0VGltZXpvbmVPZmZzZXQoZCkhPT1xLmdldFRpbWV6b25lT2Zmc2V0KG4pKTtkPXIuZ2V0VGltZSgpO2ZvcihyPTE7ZDxuOylBLnB1c2goZCksZD1lPT09Zy55ZWFyP3EubWFrZVRpbWUoYityKmgsMCk6ZT09PWcubW9udGg/cS5tYWtlVGltZShiLGYrcipoKTohYXx8ZSE9PWcuZGF5JiZlIT09Zy53ZWVrP2EmJmU9PT1nLmhvdXImJjE8aD9xLm1ha2VUaW1lKGIsZix3LEorcipoKTpkK2UqaDpxLm1ha2VUaW1lKGIsZix3K3IqaCooZT09PWcuZGF5PzE6NykpLFxucisrO0EucHVzaChkKTtlPD1nLmhvdXImJjFFND5BLmxlbmd0aCYmQS5mb3JFYWNoKGZ1bmN0aW9uKGEpezA9PT1hJTE4RTUmJlwiMDAwMDAwMDAwXCI9PT1xLmRhdGVGb3JtYXQoXCIlSCVNJVMlTFwiLGEpJiYobVthXT1cImRheVwiKX0pfUEuaW5mbz1HKGMse2hpZ2hlclJhbmtzOm0sdG90YWxSYW5nZTplKmh9KTtyZXR1cm4gQX07cmV0dXJuIGR9KCk7Zi5UaW1lPWQ7cmV0dXJuIGYuVGltZX0pO1AoayxcIkNvcmUvT3B0aW9ucy5qc1wiLFtrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCJdLGtbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sa1tcIkNvcmUvVGltZS5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCxrLHgsQil7dmFyIEc9Zi5pc1RvdWNoRGV2aWNlLEQ9Zi5zdmc7ZD1kLnBhcnNlO0I9Qi5tZXJnZTtcIlwiO2YuZGVmYXVsdE9wdGlvbnM9e2NvbG9yczprLmNvbG9ycyxzeW1ib2xzOltcImNpcmNsZVwiLFwiZGlhbW9uZFwiLFwic3F1YXJlXCIsXG5cInRyaWFuZ2xlXCIsXCJ0cmlhbmdsZS1kb3duXCJdLGxhbmc6e2xvYWRpbmc6XCJMb2FkaW5nLi4uXCIsbW9udGhzOlwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKSxzaG9ydE1vbnRoczpcIkphbiBGZWIgTWFyIEFwciBNYXkgSnVuIEp1bCBBdWcgU2VwIE9jdCBOb3YgRGVjXCIuc3BsaXQoXCIgXCIpLHdlZWtkYXlzOlwiU3VuZGF5IE1vbmRheSBUdWVzZGF5IFdlZG5lc2RheSBUaHVyc2RheSBGcmlkYXkgU2F0dXJkYXlcIi5zcGxpdChcIiBcIiksZGVjaW1hbFBvaW50OlwiLlwiLG51bWVyaWNTeW1ib2xzOlwia01HVFBFXCIuc3BsaXQoXCJcIikscmVzZXRab29tOlwiUmVzZXQgem9vbVwiLHJlc2V0Wm9vbVRpdGxlOlwiUmVzZXQgem9vbSBsZXZlbCAxOjFcIix0aG91c2FuZHNTZXA6XCIgXCJ9LGdsb2JhbDp7fSx0aW1lOntEYXRlOnZvaWQgMCxnZXRUaW1lem9uZU9mZnNldDp2b2lkIDAsdGltZXpvbmU6dm9pZCAwLFxudGltZXpvbmVPZmZzZXQ6MCx1c2VVVEM6ITB9LGNoYXJ0OntzdHlsZWRNb2RlOiExLGJvcmRlclJhZGl1czowLGNvbG9yQ291bnQ6MTAsZGVmYXVsdFNlcmllc1R5cGU6XCJsaW5lXCIsaWdub3JlSGlkZGVuU2VyaWVzOiEwLHNwYWNpbmc6WzEwLDEwLDE1LDEwXSxyZXNldFpvb21CdXR0b246e3RoZW1lOnt6SW5kZXg6Nn0scG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx5OjEwfX0sem9vbUJ5U2luZ2xlVG91Y2g6ITEsd2lkdGg6bnVsbCxoZWlnaHQ6bnVsbCxib3JkZXJDb2xvcjprLmhpZ2hsaWdodENvbG9yODAsYmFja2dyb3VuZENvbG9yOmsuYmFja2dyb3VuZENvbG9yLHBsb3RCb3JkZXJDb2xvcjprLm5ldXRyYWxDb2xvcjIwfSx0aXRsZTp7dGV4dDpcIkNoYXJ0IHRpdGxlXCIsYWxpZ246XCJjZW50ZXJcIixtYXJnaW46MTUsd2lkdGhBZGp1c3Q6LTQ0fSxzdWJ0aXRsZTp7dGV4dDpcIlwiLGFsaWduOlwiY2VudGVyXCIsd2lkdGhBZGp1c3Q6LTQ0fSxjYXB0aW9uOnttYXJnaW46MTUsdGV4dDpcIlwiLFxuYWxpZ246XCJsZWZ0XCIsdmVydGljYWxBbGlnbjpcImJvdHRvbVwifSxwbG90T3B0aW9uczp7fSxsYWJlbHM6e3N0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsY29sb3I6ay5uZXV0cmFsQ29sb3I4MH19LGxlZ2VuZDp7ZW5hYmxlZDohMCxhbGlnbjpcImNlbnRlclwiLGFsaWduQ29sdW1uczohMCxsYXlvdXQ6XCJob3Jpem9udGFsXCIsbGFiZWxGb3JtYXR0ZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfSxib3JkZXJDb2xvcjprLm5ldXRyYWxDb2xvcjQwLGJvcmRlclJhZGl1czowLG5hdmlnYXRpb246e2FjdGl2ZUNvbG9yOmsuaGlnaGxpZ2h0Q29sb3IxMDAsaW5hY3RpdmVDb2xvcjprLm5ldXRyYWxDb2xvcjIwfSxpdGVtU3R5bGU6e2NvbG9yOmsubmV1dHJhbENvbG9yODAsY3Vyc29yOlwicG9pbnRlclwiLGZvbnRTaXplOlwiMTJweFwiLGZvbnRXZWlnaHQ6XCJib2xkXCIsdGV4dE92ZXJmbG93OlwiZWxsaXBzaXNcIn0saXRlbUhvdmVyU3R5bGU6e2NvbG9yOmsubmV1dHJhbENvbG9yMTAwfSxpdGVtSGlkZGVuU3R5bGU6e2NvbG9yOmsubmV1dHJhbENvbG9yMjB9LFxuc2hhZG93OiExLGl0ZW1DaGVja2JveFN0eWxlOntwb3NpdGlvbjpcImFic29sdXRlXCIsd2lkdGg6XCIxM3B4XCIsaGVpZ2h0OlwiMTNweFwifSxzcXVhcmVTeW1ib2w6ITAsc3ltYm9sUGFkZGluZzo1LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowLHRpdGxlOntzdHlsZTp7Zm9udFdlaWdodDpcImJvbGRcIn19fSxsb2FkaW5nOntsYWJlbFN0eWxlOntmb250V2VpZ2h0OlwiYm9sZFwiLHBvc2l0aW9uOlwicmVsYXRpdmVcIix0b3A6XCI0NSVcIn0sc3R5bGU6e3Bvc2l0aW9uOlwiYWJzb2x1dGVcIixiYWNrZ3JvdW5kQ29sb3I6ay5iYWNrZ3JvdW5kQ29sb3Isb3BhY2l0eTouNSx0ZXh0QWxpZ246XCJjZW50ZXJcIn19LHRvb2x0aXA6e2VuYWJsZWQ6ITAsYW5pbWF0aW9uOkQsYm9yZGVyUmFkaXVzOjMsZGF0ZVRpbWVMYWJlbEZvcm1hdHM6e21pbGxpc2Vjb25kOlwiJUEsICViICVlLCAlSDolTTolUy4lTFwiLHNlY29uZDpcIiVBLCAlYiAlZSwgJUg6JU06JVNcIixtaW51dGU6XCIlQSwgJWIgJWUsICVIOiVNXCIsaG91cjpcIiVBLCAlYiAlZSwgJUg6JU1cIixcbmRheTpcIiVBLCAlYiAlZSwgJVlcIix3ZWVrOlwiV2VlayBmcm9tICVBLCAlYiAlZSwgJVlcIixtb250aDpcIiVCICVZXCIseWVhcjpcIiVZXCJ9LGZvb3RlckZvcm1hdDpcIlwiLHBhZGRpbmc6OCxzbmFwOkc/MjU6MTAsaGVhZGVyRm9ybWF0Oic8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiPntwb2ludC5rZXl9PC9zcGFuPjxici8+Jyxwb2ludEZvcm1hdDonPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVjZjwvc3Bhbj4ge3Nlcmllcy5uYW1lfTogPGI+e3BvaW50Lnl9PC9iPjxici8+JyxiYWNrZ3JvdW5kQ29sb3I6ZChrLm5ldXRyYWxDb2xvcjMpLnNldE9wYWNpdHkoLjg1KS5nZXQoKSxib3JkZXJXaWR0aDoxLHNoYWRvdzohMCxzdHlsZTp7Y29sb3I6ay5uZXV0cmFsQ29sb3I4MCxjdXJzb3I6XCJkZWZhdWx0XCIsZm9udFNpemU6XCIxMnB4XCIsd2hpdGVTcGFjZTpcIm5vd3JhcFwifX0sY3JlZGl0czp7ZW5hYmxlZDohMCxocmVmOlwiaHR0cHM6Ly93d3cuaGlnaGNoYXJ0cy5jb20/Y3JlZGl0c1wiLFxucG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4Oi0xMCx2ZXJ0aWNhbEFsaWduOlwiYm90dG9tXCIseTotNX0sc3R5bGU6e2N1cnNvcjpcInBvaW50ZXJcIixjb2xvcjprLm5ldXRyYWxDb2xvcjQwLGZvbnRTaXplOlwiOXB4XCJ9LHRleHQ6XCJIaWdoY2hhcnRzLmNvbVwifX07Zi5kZWZhdWx0T3B0aW9ucy5jaGFydC5zdHlsZWRNb2RlPSExO1wiXCI7Zi50aW1lPW5ldyB4KEIoZi5kZWZhdWx0T3B0aW9ucy5nbG9iYWwsZi5kZWZhdWx0T3B0aW9ucy50aW1lKSk7Zi5kYXRlRm9ybWF0PWZ1bmN0aW9uKGQsdCxrKXtyZXR1cm4gZi50aW1lLmRhdGVGb3JtYXQoZCx0LGspfTtyZXR1cm57ZGF0ZUZvcm1hdDpmLmRhdGVGb3JtYXQsZGVmYXVsdE9wdGlvbnM6Zi5kZWZhdWx0T3B0aW9ucyx0aW1lOmYudGltZX19KTtQKGssXCJDb3JlL0F4aXMvVGljay5qc1wiLFtrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkKXt2YXIgaz1mLmRlZzJyYWQseD1kLmNsYW1wLEI9XG5kLmNvcnJlY3RGbG9hdCxHPWQuZGVmaW5lZCxEPWQuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsSD1kLmV4dGVuZCx0PWQuZmlyZUV2ZW50LEM9ZC5pc051bWJlcixsPWQubWVyZ2UsRT1kLm9iamVjdEVhY2gsZz1kLnBpY2s7XCJcIjtkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZChjLGcsZCxmLGwpe3RoaXMuaXNOZXdMYWJlbD10aGlzLmlzTmV3PSEwO3RoaXMuYXhpcz1jO3RoaXMucG9zPWc7dGhpcy50eXBlPWR8fFwiXCI7dGhpcy5wYXJhbWV0ZXJzPWx8fHt9O3RoaXMudGlja21hcmtPZmZzZXQ9dGhpcy5wYXJhbWV0ZXJzLnRpY2ttYXJrT2Zmc2V0O3RoaXMub3B0aW9ucz10aGlzLnBhcmFtZXRlcnMub3B0aW9uczt0KHRoaXMsXCJpbml0XCIpO2R8fGZ8fHRoaXMuYWRkTGFiZWwoKX1kLnByb3RvdHlwZS5hZGRMYWJlbD1mdW5jdGlvbigpe3ZhciBjPXRoaXMsZD1jLmF4aXMsbj1kLm9wdGlvbnMsZj1kLmNoYXJ0LGw9ZC5jYXRlZ29yaWVzLHo9ZC5sb2dhcml0aG1pYyxtPWQubmFtZXMscj1jLnBvcyxcbmU9ZyhjLm9wdGlvbnMmJmMub3B0aW9ucy5sYWJlbHMsbi5sYWJlbHMpLGg9ZC50aWNrUG9zaXRpb25zLGE9cj09PWhbMF0sYj1yPT09aFtoLmxlbmd0aC0xXTttPXRoaXMucGFyYW1ldGVycy5jYXRlZ29yeXx8KGw/ZyhsW3JdLG1bcl0scik6cik7dmFyIHc9Yy5sYWJlbDtsPSghZS5zdGVwfHwxPT09ZS5zdGVwKSYmMT09PWQudGlja0ludGVydmFsO2g9aC5pbmZvO3ZhciBKLE87aWYoZC5kYXRlVGltZSYmaCl7dmFyIEY9Zi50aW1lLnJlc29sdmVEVExGb3JtYXQobi5kYXRlVGltZUxhYmVsRm9ybWF0c1shbi5ncmlkJiZoLmhpZ2hlclJhbmtzW3JdfHxoLnVuaXROYW1lXSk7dmFyIE49Ri5tYWlufWMuaXNGaXJzdD1hO2MuaXNMYXN0PWI7Yy5mb3JtYXRDdHg9e2F4aXM6ZCxjaGFydDpmLGlzRmlyc3Q6YSxpc0xhc3Q6YixkYXRlVGltZUxhYmVsRm9ybWF0Ok4sdGlja1Bvc2l0aW9uSW5mbzpoLHZhbHVlOno/Qih6LmxpbjJsb2cobSkpOm0scG9zOnJ9O249ZC5sYWJlbEZvcm1hdHRlci5jYWxsKGMuZm9ybWF0Q3R4LFxudGhpcy5mb3JtYXRDdHgpO2lmKE89RiYmRi5saXN0KWMuc2hvcnRlbkxhYmVsPWZ1bmN0aW9uKCl7Zm9yKEo9MDtKPE8ubGVuZ3RoO0orKylpZih3LmF0dHIoe3RleHQ6ZC5sYWJlbEZvcm1hdHRlci5jYWxsKEgoYy5mb3JtYXRDdHgse2RhdGVUaW1lTGFiZWxGb3JtYXQ6T1tKXX0pKX0pLHcuZ2V0QkJveCgpLndpZHRoPGQuZ2V0U2xvdFdpZHRoKGMpLTIqZyhlLnBhZGRpbmcsNSkpcmV0dXJuO3cuYXR0cih7dGV4dDpcIlwifSl9O2wmJmQuX2FkZGVkUGxvdExCJiZjLm1vdmVMYWJlbChuLGUpO0codyl8fGMubW92ZWRMYWJlbD93JiZ3LnRleHRTdHIhPT1uJiYhbCYmKCF3LnRleHRXaWR0aHx8ZS5zdHlsZSYmZS5zdHlsZS53aWR0aHx8dy5zdHlsZXMud2lkdGh8fHcuY3NzKHt3aWR0aDpudWxsfSksdy5hdHRyKHt0ZXh0Om59KSx3LnRleHRQeExlbmd0aD13LmdldEJCb3goKS53aWR0aCk6KGMubGFiZWw9dz1jLmNyZWF0ZUxhYmVsKHt4OjAseTowfSxuLGUpLGMucm90YXRpb249MCl9O2QucHJvdG90eXBlLmNyZWF0ZUxhYmVsPVxuZnVuY3Rpb24oYyxnLGQpe3ZhciBuPXRoaXMuYXhpcyxmPW4uY2hhcnQ7aWYoYz1HKGcpJiZkLmVuYWJsZWQ/Zi5yZW5kZXJlci50ZXh0KGcsYy54LGMueSxkLnVzZUhUTUwpLmFkZChuLmxhYmVsR3JvdXApOm51bGwpZi5zdHlsZWRNb2RlfHxjLmNzcyhsKGQuc3R5bGUpKSxjLnRleHRQeExlbmd0aD1jLmdldEJCb3goKS53aWR0aDtyZXR1cm4gY307ZC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe0QodGhpcyx0aGlzLmF4aXMpfTtkLnByb3RvdHlwZS5nZXRQb3NpdGlvbj1mdW5jdGlvbihjLGcsZCxmKXt2YXIgbj10aGlzLmF4aXMscT1uLmNoYXJ0LG09ZiYmcS5vbGRDaGFydEhlaWdodHx8cS5jaGFydEhlaWdodDtjPXt4OmM/QihuLnRyYW5zbGF0ZShnK2QsbnVsbCxudWxsLGYpK24udHJhbnNCKTpuLmxlZnQrbi5vZmZzZXQrKG4ub3Bwb3NpdGU/KGYmJnEub2xkQ2hhcnRXaWR0aHx8cS5jaGFydFdpZHRoKS1uLnJpZ2h0LW4ubGVmdDowKSx5OmM/bS1uLmJvdHRvbStuLm9mZnNldC1cbihuLm9wcG9zaXRlP24uaGVpZ2h0OjApOkIobS1uLnRyYW5zbGF0ZShnK2QsbnVsbCxudWxsLGYpLW4udHJhbnNCKX07Yy55PXgoYy55LC0xRTUsMUU1KTt0KHRoaXMsXCJhZnRlckdldFBvc2l0aW9uXCIse3BvczpjfSk7cmV0dXJuIGN9O2QucHJvdG90eXBlLmdldExhYmVsUG9zaXRpb249ZnVuY3Rpb24oYyxnLGQsZixsLHosbSxyKXt2YXIgZT10aGlzLmF4aXMsaD1lLnRyYW5zQSxhPWUuaXNMaW5rZWQmJmUubGlua2VkUGFyZW50P2UubGlua2VkUGFyZW50LnJldmVyc2VkOmUucmV2ZXJzZWQsYj1lLnN0YWdnZXJMaW5lcyx3PWUudGlja1JvdENvcnJ8fHt4OjAseTowfSxuPWwueSxxPWZ8fGUucmVzZXJ2ZVNwYWNlRGVmYXVsdD8wOi1lLmxhYmVsT2Zmc2V0KihcImNlbnRlclwiPT09ZS5sYWJlbEFsaWduPy41OjEpLEY9e307RyhuKXx8KG49MD09PWUuc2lkZT9kLnJvdGF0aW9uPy04Oi1kLmdldEJCb3goKS5oZWlnaHQ6Mj09PWUuc2lkZT93LnkrODpNYXRoLmNvcyhkLnJvdGF0aW9uKmspKlxuKHcueS1kLmdldEJCb3goITEsMCkuaGVpZ2h0LzIpKTtjPWMrbC54K3Erdy54LSh6JiZmP3oqaCooYT8tMToxKTowKTtnPWcrbi0oeiYmIWY/eipoKihhPzE6LTEpOjApO2ImJihkPW0vKHJ8fDEpJWIsZS5vcHBvc2l0ZSYmKGQ9Yi1kLTEpLGcrPWUubGFiZWxPZmZzZXQvYipkKTtGLng9YztGLnk9TWF0aC5yb3VuZChnKTt0KHRoaXMsXCJhZnRlckdldExhYmVsUG9zaXRpb25cIix7cG9zOkYsdGlja21hcmtPZmZzZXQ6eixpbmRleDptfSk7cmV0dXJuIEZ9O2QucHJvdG90eXBlLmdldExhYmVsU2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsP3RoaXMubGFiZWwuZ2V0QkJveCgpW3RoaXMuYXhpcy5ob3Jpej9cImhlaWdodFwiOlwid2lkdGhcIl06MH07ZC5wcm90b3R5cGUuZ2V0TWFya1BhdGg9ZnVuY3Rpb24oYyxnLGQsZixsLHope3JldHVybiB6LmNyaXNwTGluZShbW1wiTVwiLGMsZ10sW1wiTFwiLGMrKGw/MDotZCksZysobD9kOjApXV0sZil9O2QucHJvdG90eXBlLmhhbmRsZU92ZXJmbG93PVxuZnVuY3Rpb24oYyl7dmFyIGQ9dGhpcy5heGlzLGY9ZC5vcHRpb25zLmxhYmVscyxsPWMueCx0PWQuY2hhcnQuY2hhcnRXaWR0aCx6PWQuY2hhcnQuc3BhY2luZyxtPWcoZC5sYWJlbExlZnQsTWF0aC5taW4oZC5wb3MselszXSkpO3o9ZyhkLmxhYmVsUmlnaHQsTWF0aC5tYXgoZC5pc1JhZGlhbD8wOmQucG9zK2QubGVuLHQtelsxXSkpO3ZhciByPXRoaXMubGFiZWwsZT10aGlzLnJvdGF0aW9uLGg9e2xlZnQ6MCxjZW50ZXI6LjUscmlnaHQ6MX1bZC5sYWJlbEFsaWdufHxyLmF0dHIoXCJhbGlnblwiKV0sYT1yLmdldEJCb3goKS53aWR0aCxiPWQuZ2V0U2xvdFdpZHRoKHRoaXMpLHc9YixKPTEsTyxGPXt9O2lmKGV8fFwianVzdGlmeVwiIT09ZyhmLm92ZXJmbG93LFwianVzdGlmeVwiKSkwPmUmJmwtaCphPG0/Tz1NYXRoLnJvdW5kKGwvTWF0aC5jb3MoZSprKS1tKTowPGUmJmwraCphPnomJihPPU1hdGgucm91bmQoKHQtbCkvTWF0aC5jb3MoZSprKSkpO2Vsc2UgaWYodD1sKygxLWgpKmEsbC1oKlxuYTxtP3c9Yy54K3cqKDEtaCktbTp0PnomJih3PXotYy54K3cqaCxKPS0xKSx3PU1hdGgubWluKGIsdyksdzxiJiZcImNlbnRlclwiPT09ZC5sYWJlbEFsaWduJiYoYy54Kz1KKihiLXctaCooYi1NYXRoLm1pbihhLHcpKSkpLGE+d3x8ZC5hdXRvUm90YXRpb24mJihyLnN0eWxlc3x8e30pLndpZHRoKU89dztPJiYodGhpcy5zaG9ydGVuTGFiZWw/dGhpcy5zaG9ydGVuTGFiZWwoKTooRi53aWR0aD1NYXRoLmZsb29yKE8pK1wicHhcIiwoZi5zdHlsZXx8e30pLnRleHRPdmVyZmxvd3x8KEYudGV4dE92ZXJmbG93PVwiZWxsaXBzaXNcIiksci5jc3MoRikpKX07ZC5wcm90b3R5cGUubW92ZUxhYmVsPWZ1bmN0aW9uKGMsZyl7dmFyIGQ9dGhpcyxmPWQubGFiZWwscT0hMSxsPWQuYXhpcyxtPWwucmV2ZXJzZWQ7ZiYmZi50ZXh0U3RyPT09Yz8oZC5tb3ZlZExhYmVsPWYscT0hMCxkZWxldGUgZC5sYWJlbCk6RShsLnRpY2tzLGZ1bmN0aW9uKGUpe3F8fGUuaXNOZXd8fGU9PT1kfHwhZS5sYWJlbHx8ZS5sYWJlbC50ZXh0U3RyIT09XG5jfHwoZC5tb3ZlZExhYmVsPWUubGFiZWwscT0hMCxlLmxhYmVsUG9zPWQubW92ZWRMYWJlbC54eSxkZWxldGUgZS5sYWJlbCl9KTtpZighcSYmKGQubGFiZWxQb3N8fGYpKXt2YXIgcj1kLmxhYmVsUG9zfHxmLnh5O2Y9bC5ob3Jpej9tPzA6bC53aWR0aCtsLmxlZnQ6ci54O2w9bC5ob3Jpej9yLnk6bT9sLndpZHRoK2wubGVmdDowO2QubW92ZWRMYWJlbD1kLmNyZWF0ZUxhYmVsKHt4OmYseTpsfSxjLGcpO2QubW92ZWRMYWJlbCYmZC5tb3ZlZExhYmVsLmF0dHIoe29wYWNpdHk6MH0pfX07ZC5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGMsZCxmKXt2YXIgbj10aGlzLmF4aXMscT1uLmhvcml6LGw9dGhpcy5wb3MsbT1nKHRoaXMudGlja21hcmtPZmZzZXQsbi50aWNrbWFya09mZnNldCk7bD10aGlzLmdldFBvc2l0aW9uKHEsbCxtLGQpO209bC54O3ZhciByPWwueTtuPXEmJm09PT1uLnBvcytuLmxlbnx8IXEmJnI9PT1uLnBvcz8tMToxO2Y9ZyhmLDEpO3RoaXMuaXNBY3RpdmU9ITA7XG50aGlzLnJlbmRlckdyaWRMaW5lKGQsZixuKTt0aGlzLnJlbmRlck1hcmsobCxmLG4pO3RoaXMucmVuZGVyTGFiZWwobCxkLGYsYyk7dGhpcy5pc05ldz0hMTt0KHRoaXMsXCJhZnRlclJlbmRlclwiKX07ZC5wcm90b3R5cGUucmVuZGVyR3JpZExpbmU9ZnVuY3Rpb24oYyxkLGYpe3ZhciBuPXRoaXMuYXhpcyxxPW4ub3B0aW9ucyxsPXRoaXMuZ3JpZExpbmUsbT17fSxyPXRoaXMucG9zLGU9dGhpcy50eXBlLGg9Zyh0aGlzLnRpY2ttYXJrT2Zmc2V0LG4udGlja21hcmtPZmZzZXQpLGE9bi5jaGFydC5yZW5kZXJlcixiPWU/ZStcIkdyaWRcIjpcImdyaWRcIix3PXFbYitcIkxpbmVXaWR0aFwiXSxKPXFbYitcIkxpbmVDb2xvclwiXTtxPXFbYitcIkxpbmVEYXNoU3R5bGVcIl07bHx8KG4uY2hhcnQuc3R5bGVkTW9kZXx8KG0uc3Ryb2tlPUosbVtcInN0cm9rZS13aWR0aFwiXT13LHEmJihtLmRhc2hzdHlsZT1xKSksZXx8KG0uekluZGV4PTEpLGMmJihkPTApLHRoaXMuZ3JpZExpbmU9bD1hLnBhdGgoKS5hdHRyKG0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1cIitcbihlP2UrXCItXCI6XCJcIikrXCJncmlkLWxpbmVcIikuYWRkKG4uZ3JpZEdyb3VwKSk7aWYobCYmKGY9bi5nZXRQbG90TGluZVBhdGgoe3ZhbHVlOnIraCxsaW5lV2lkdGg6bC5zdHJva2VXaWR0aCgpKmYsZm9yY2U6XCJwYXNzXCIsb2xkOmN9KSkpbFtjfHx0aGlzLmlzTmV3P1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7ZDpmLG9wYWNpdHk6ZH0pfTtkLnByb3RvdHlwZS5yZW5kZXJNYXJrPWZ1bmN0aW9uKGMsZCxmKXt2YXIgbj10aGlzLmF4aXMscT1uLm9wdGlvbnMsbD1uLmNoYXJ0LnJlbmRlcmVyLG09dGhpcy50eXBlLHI9bT9tK1wiVGlja1wiOlwidGlja1wiLGU9bi50aWNrU2l6ZShyKSxoPXRoaXMubWFyayxhPSFoLGI9Yy54O2M9Yy55O3ZhciB3PWcocVtyK1wiV2lkdGhcIl0sIW0mJm4uaXNYQXhpcz8xOjApO3E9cVtyK1wiQ29sb3JcIl07ZSYmKG4ub3Bwb3NpdGUmJihlWzBdPS1lWzBdKSxhJiYodGhpcy5tYXJrPWg9bC5wYXRoKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiKyhtP20rXCItXCI6XCJcIikrXCJ0aWNrXCIpLmFkZChuLmF4aXNHcm91cCksXG5uLmNoYXJ0LnN0eWxlZE1vZGV8fGguYXR0cih7c3Ryb2tlOnEsXCJzdHJva2Utd2lkdGhcIjp3fSkpLGhbYT9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2Q6dGhpcy5nZXRNYXJrUGF0aChiLGMsZVswXSxoLnN0cm9rZVdpZHRoKCkqZixuLmhvcml6LGwpLG9wYWNpdHk6ZH0pKX07ZC5wcm90b3R5cGUucmVuZGVyTGFiZWw9ZnVuY3Rpb24oYyxkLGYsbCl7dmFyIG49dGhpcy5heGlzLHE9bi5ob3JpeixtPW4ub3B0aW9ucyxyPXRoaXMubGFiZWwsZT1tLmxhYmVscyxoPWUuc3RlcDtuPWcodGhpcy50aWNrbWFya09mZnNldCxuLnRpY2ttYXJrT2Zmc2V0KTt2YXIgYT0hMCxiPWMueDtjPWMueTtyJiZDKGIpJiYoci54eT1jPXRoaXMuZ2V0TGFiZWxQb3NpdGlvbihiLGMscixxLGUsbixsLGgpLHRoaXMuaXNGaXJzdCYmIXRoaXMuaXNMYXN0JiYhZyhtLnNob3dGaXJzdExhYmVsLDEpfHx0aGlzLmlzTGFzdCYmIXRoaXMuaXNGaXJzdCYmIWcobS5zaG93TGFzdExhYmVsLDEpP2E9ITE6IXF8fGUuc3RlcHx8XG5lLnJvdGF0aW9ufHxkfHwwPT09Znx8dGhpcy5oYW5kbGVPdmVyZmxvdyhjKSxoJiZsJWgmJihhPSExKSxhJiZDKGMueSk/KGMub3BhY2l0eT1mLHJbdGhpcy5pc05ld0xhYmVsP1wiYXR0clwiOlwiYW5pbWF0ZVwiXShjKSx0aGlzLmlzTmV3TGFiZWw9ITEpOihyLmF0dHIoXCJ5XCIsLTk5OTkpLHRoaXMuaXNOZXdMYWJlbD0hMCkpfTtkLnByb3RvdHlwZS5yZXBsYWNlTW92ZWRMYWJlbD1mdW5jdGlvbigpe3ZhciBjPXRoaXMubGFiZWwsZz10aGlzLmF4aXMsZD1nLnJldmVyc2VkO2lmKGMmJiF0aGlzLmlzTmV3KXt2YXIgZj1nLmhvcml6P2Q/Zy5sZWZ0Omcud2lkdGgrZy5sZWZ0OmMueHkueDtkPWcuaG9yaXo/Yy54eS55OmQ/Zy53aWR0aCtnLnRvcDpnLnRvcDtjLmFuaW1hdGUoe3g6Zix5OmQsb3BhY2l0eTowfSx2b2lkIDAsYy5kZXN0cm95KTtkZWxldGUgdGhpcy5sYWJlbH1nLmlzRGlydHk9ITA7dGhpcy5sYWJlbD10aGlzLm1vdmVkTGFiZWw7ZGVsZXRlIHRoaXMubW92ZWRMYWJlbH07cmV0dXJuIGR9KCk7XG5mLlRpY2s9ZDtyZXR1cm4gZi5UaWNrfSk7UChrLFwiQ29yZS9BeGlzL0F4aXMuanNcIixba1tcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxrW1wiQ29yZS9Db2xvci9Db2xvci5qc1wiXSxrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sa1tcIkNvcmUvT3B0aW9ucy5qc1wiXSxrW1wiQ29yZS9BeGlzL1RpY2suanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4LEIsRyxEKXt2YXIgSD1mLmFuaW1PYmplY3QsdD1CLmRlZmF1bHRPcHRpb25zLEM9RC5hZGRFdmVudCxsPUQuYXJyYXlNYXgsRT1ELmFycmF5TWluLGc9RC5jbGFtcCx5PUQuY29ycmVjdEZsb2F0LGM9RC5kZWZpbmVkLHE9RC5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxuPUQuZXJhc2UsQT1ELmVycm9yLE09RC5leHRlbmQsej1ELmZpcmVFdmVudCxtPUQuZm9ybWF0LHI9RC5nZXRNYWduaXR1ZGUsZT1ELmlzQXJyYXksaD1ELmlzRnVuY3Rpb24sXG5hPUQuaXNOdW1iZXIsYj1ELmlzU3RyaW5nLHc9RC5tZXJnZSxKPUQubm9ybWFsaXplVGlja0ludGVydmFsLE89RC5vYmplY3RFYWNoLEY9RC5waWNrLE49RC5yZWxhdGl2ZUxlbmd0aCxSPUQucmVtb3ZlRXZlbnQsUT1ELnNwbGF0LFQ9RC5zeW5jVGltZW91dDtcIlwiO3ZhciB2PWsuZGVnMnJhZDtmPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZihhLGIpe3RoaXMuem9vbUVuYWJsZWQ9dGhpcy53aWR0aD10aGlzLnZpc2libGU9dGhpcy51c2VyT3B0aW9ucz10aGlzLnRyYW5zbGF0aW9uU2xvcGU9dGhpcy50cmFuc0I9dGhpcy50cmFuc0E9dGhpcy50b3A9dGhpcy50aWNrcz10aGlzLnRpY2tSb3RDb3JyPXRoaXMudGlja1Bvc2l0aW9ucz10aGlzLnRpY2ttYXJrT2Zmc2V0PXRoaXMudGlja0ludGVydmFsPXRoaXMudGlja0Ftb3VudD10aGlzLnNpZGU9dGhpcy5zZXJpZXM9dGhpcy5yaWdodD10aGlzLnBvc2l0aXZlVmFsdWVzT25seT10aGlzLnBvcz10aGlzLnBvaW50UmFuZ2VQYWRkaW5nPXRoaXMucG9pbnRSYW5nZT1cbnRoaXMucGxvdExpbmVzQW5kQmFuZHNHcm91cHM9dGhpcy5wbG90TGluZXNBbmRCYW5kcz10aGlzLnBhZGRlZFRpY2tzPXRoaXMub3ZlcmxhcD10aGlzLm9wdGlvbnM9dGhpcy5vZmZzZXQ9dGhpcy5uYW1lcz10aGlzLm1pblBpeGVsUGFkZGluZz10aGlzLm1pbm9yVGlja3M9dGhpcy5taW5vclRpY2tJbnRlcnZhbD10aGlzLm1pbj10aGlzLm1heExhYmVsTGVuZ3RoPXRoaXMubWF4PXRoaXMubGVuPXRoaXMubGVmdD10aGlzLmxhYmVsRm9ybWF0dGVyPXRoaXMubGFiZWxFZGdlPXRoaXMuaXNMaW5rZWQ9dGhpcy5oZWlnaHQ9dGhpcy5oYXNWaXNpYmxlU2VyaWVzPXRoaXMuaGFzTmFtZXM9dGhpcy5jb2xsPXRoaXMuY2xvc2VzdFBvaW50UmFuZ2U9dGhpcy5jaGFydD10aGlzLmNhdGVnb3JpZXM9dGhpcy5ib3R0b209dGhpcy5hbHRlcm5hdGVCYW5kcz12b2lkIDA7dGhpcy5pbml0KGEsYil9Zi5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhLGIpe3ZhciBlPWIuaXNYLHA9dGhpcztwLmNoYXJ0PVxuYTtwLmhvcml6PWEuaW52ZXJ0ZWQmJiFwLmlzWkF4aXM/IWU6ZTtwLmlzWEF4aXM9ZTtwLmNvbGw9cC5jb2xsfHwoZT9cInhBeGlzXCI6XCJ5QXhpc1wiKTt6KHRoaXMsXCJpbml0XCIse3VzZXJPcHRpb25zOmJ9KTtwLm9wcG9zaXRlPUYoYi5vcHBvc2l0ZSxwLm9wcG9zaXRlKTtwLnNpZGU9RihiLnNpZGUscC5zaWRlLHAuaG9yaXo/cC5vcHBvc2l0ZT8wOjI6cC5vcHBvc2l0ZT8xOjMpO3Auc2V0T3B0aW9ucyhiKTt2YXIgdT10aGlzLm9wdGlvbnMsZz11LnR5cGU7cC5sYWJlbEZvcm1hdHRlcj11LmxhYmVscy5mb3JtYXR0ZXJ8fHAuZGVmYXVsdExhYmVsRm9ybWF0dGVyO3AudXNlck9wdGlvbnM9YjtwLm1pblBpeGVsUGFkZGluZz0wO3AucmV2ZXJzZWQ9Rih1LnJldmVyc2VkLHAucmV2ZXJzZWQpO3AudmlzaWJsZT0hMSE9PXUudmlzaWJsZTtwLnpvb21FbmFibGVkPSExIT09dS56b29tRW5hYmxlZDtwLmhhc05hbWVzPVwiY2F0ZWdvcnlcIj09PWd8fCEwPT09dS5jYXRlZ29yaWVzO3AuY2F0ZWdvcmllcz1cbnUuY2F0ZWdvcmllc3x8cC5oYXNOYW1lcztwLm5hbWVzfHwocC5uYW1lcz1bXSxwLm5hbWVzLmtleXM9e30pO3AucGxvdExpbmVzQW5kQmFuZHNHcm91cHM9e307cC5wb3NpdGl2ZVZhbHVlc09ubHk9ISFwLmxvZ2FyaXRobWljO3AuaXNMaW5rZWQ9Yyh1LmxpbmtlZFRvKTtwLnRpY2tzPXt9O3AubGFiZWxFZGdlPVtdO3AubWlub3JUaWNrcz17fTtwLnBsb3RMaW5lc0FuZEJhbmRzPVtdO3AuYWx0ZXJuYXRlQmFuZHM9e307cC5sZW49MDtwLm1pblJhbmdlPXAudXNlck1pblJhbmdlPXUubWluUmFuZ2V8fHUubWF4Wm9vbTtwLnJhbmdlPXUucmFuZ2U7cC5vZmZzZXQ9dS5vZmZzZXR8fDA7cC5tYXg9bnVsbDtwLm1pbj1udWxsO3AuY3Jvc3NoYWlyPUYodS5jcm9zc2hhaXIsUShhLm9wdGlvbnMudG9vbHRpcC5jcm9zc2hhaXJzKVtlPzA6MV0sITEpO2I9cC5vcHRpb25zLmV2ZW50czstMT09PWEuYXhlcy5pbmRleE9mKHApJiYoZT9hLmF4ZXMuc3BsaWNlKGEueEF4aXMubGVuZ3RoLDAscCk6XG5hLmF4ZXMucHVzaChwKSxhW3AuY29sbF0ucHVzaChwKSk7cC5zZXJpZXM9cC5zZXJpZXN8fFtdO2EuaW52ZXJ0ZWQmJiFwLmlzWkF4aXMmJmUmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgcC5yZXZlcnNlZCYmKHAucmV2ZXJzZWQ9ITApO3AubGFiZWxSb3RhdGlvbj1wLm9wdGlvbnMubGFiZWxzLnJvdGF0aW9uO08oYixmdW5jdGlvbihhLGIpe2goYSkmJkMocCxiLGEpfSk7eih0aGlzLFwiYWZ0ZXJJbml0XCIpfTtmLnByb3RvdHlwZS5zZXRPcHRpb25zPWZ1bmN0aW9uKGEpe3RoaXMub3B0aW9ucz13KGYuZGVmYXVsdE9wdGlvbnMsXCJ5QXhpc1wiPT09dGhpcy5jb2xsJiZmLmRlZmF1bHRZQXhpc09wdGlvbnMsW2YuZGVmYXVsdFRvcEF4aXNPcHRpb25zLGYuZGVmYXVsdFJpZ2h0QXhpc09wdGlvbnMsZi5kZWZhdWx0Qm90dG9tQXhpc09wdGlvbnMsZi5kZWZhdWx0TGVmdEF4aXNPcHRpb25zXVt0aGlzLnNpZGVdLHcodFt0aGlzLmNvbGxdLGEpKTt6KHRoaXMsXCJhZnRlclNldE9wdGlvbnNcIix7dXNlck9wdGlvbnM6YX0pfTtcbmYucHJvdG90eXBlLmRlZmF1bHRMYWJlbEZvcm1hdHRlcj1mdW5jdGlvbigpe3ZhciBiPXRoaXMuYXhpcyxlPWEodGhpcy52YWx1ZSk/dGhpcy52YWx1ZTpOYU4sYz1iLmNoYXJ0LnRpbWUsZz1iLmNhdGVnb3JpZXMsdT10aGlzLmRhdGVUaW1lTGFiZWxGb3JtYXQsaD10LmxhbmcsZD1oLm51bWVyaWNTeW1ib2xzO2g9aC5udW1lcmljU3ltYm9sTWFnbml0dWRlfHwxRTM7dmFyIGY9ZCYmZC5sZW5ndGgsdz1iLm9wdGlvbnMubGFiZWxzLmZvcm1hdDtiPWIubG9nYXJpdGhtaWM/TWF0aC5hYnMoZSk6Yi50aWNrSW50ZXJ2YWw7dmFyIG49dGhpcy5jaGFydCxxPW4ubnVtYmVyRm9ybWF0dGVyO2lmKHcpdmFyIHI9bSh3LHRoaXMsbik7ZWxzZSBpZihnKXI9XCJcIit0aGlzLnZhbHVlO2Vsc2UgaWYodSlyPWMuZGF0ZUZvcm1hdCh1LGUpO2Vsc2UgaWYoZiYmMUUzPD1iKWZvcig7Zi0tJiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIHI7KWM9TWF0aC5wb3coaCxmKzEpLGI+PWMmJjA9PT0xMCplJWMmJm51bGwhPT1cbmRbZl0mJjAhPT1lJiYocj1xKGUvYywtMSkrZFtmXSk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiByJiYocj0xRTQ8PU1hdGguYWJzKGUpP3EoZSwtMSk6cShlLC0xLHZvaWQgMCxcIlwiKSk7cmV0dXJuIHJ9O2YucHJvdG90eXBlLmdldFNlcmllc0V4dHJlbWVzPWZ1bmN0aW9uKCl7dmFyIGI9dGhpcyxlPWIuY2hhcnQsZzt6KHRoaXMsXCJnZXRTZXJpZXNFeHRyZW1lc1wiLG51bGwsZnVuY3Rpb24oKXtiLmhhc1Zpc2libGVTZXJpZXM9ITE7Yi5kYXRhTWluPWIuZGF0YU1heD1iLnRocmVzaG9sZD1udWxsO2Iuc29mdFRocmVzaG9sZD0hYi5pc1hBeGlzO2Iuc3RhY2tpbmcmJmIuc3RhY2tpbmcuYnVpbGRTdGFja3MoKTtiLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKHApe2lmKHAudmlzaWJsZXx8IWUub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMpe3ZhciB1PXAub3B0aW9ucyxoPXUudGhyZXNob2xkO2IuaGFzVmlzaWJsZVNlcmllcz0hMDtiLnBvc2l0aXZlVmFsdWVzT25seSYmMD49aCYmXG4oaD1udWxsKTtpZihiLmlzWEF4aXMpe2lmKHU9cC54RGF0YSx1Lmxlbmd0aCl7dT1iLmxvZ2FyaXRobWljP3UuZmlsdGVyKGIudmFsaWRhdGVQb3NpdGl2ZVZhbHVlKTp1O2c9cC5nZXRYRXh0cmVtZXModSk7dmFyIGQ9Zy5taW47dmFyIGY9Zy5tYXg7YShkKXx8ZCBpbnN0YW5jZW9mIERhdGV8fCh1PXUuZmlsdGVyKGEpLGc9cC5nZXRYRXh0cmVtZXModSksZD1nLm1pbixmPWcubWF4KTt1Lmxlbmd0aCYmKGIuZGF0YU1pbj1NYXRoLm1pbihGKGIuZGF0YU1pbixkKSxkKSxiLmRhdGFNYXg9TWF0aC5tYXgoRihiLmRhdGFNYXgsZiksZikpfX1lbHNlIGlmKHA9cC5hcHBseUV4dHJlbWVzKCksYShwLmRhdGFNaW4pJiYoZD1wLmRhdGFNaW4sYi5kYXRhTWluPU1hdGgubWluKEYoYi5kYXRhTWluLGQpLGQpKSxhKHAuZGF0YU1heCkmJihmPXAuZGF0YU1heCxiLmRhdGFNYXg9TWF0aC5tYXgoRihiLmRhdGFNYXgsZiksZikpLGMoaCkmJihiLnRocmVzaG9sZD1oKSwhdS5zb2Z0VGhyZXNob2xkfHxcbmIucG9zaXRpdmVWYWx1ZXNPbmx5KWIuc29mdFRocmVzaG9sZD0hMX19KX0pO3oodGhpcyxcImFmdGVyR2V0U2VyaWVzRXh0cmVtZXNcIil9O2YucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbihiLGUsYyxnLHUsaCl7dmFyIHA9dGhpcy5saW5rZWRQYXJlbnR8fHRoaXMsZD0xLGY9MCxtPWcmJnAub2xkP3Aub2xkLnRyYW5zQTpwLnRyYW5zQTtnPWcmJnAub2xkP3Aub2xkLm1pbjpwLm1pbjt2YXIgdz1wLm1pblBpeGVsUGFkZGluZzt1PShwLmlzT3JkaW5hbHx8cC5icm9rZW5BeGlzJiZwLmJyb2tlbkF4aXMuaGFzQnJlYWtzfHxwLmxvZ2FyaXRobWljJiZ1KSYmcC5saW4ydmFsO218fChtPXAudHJhbnNBKTtjJiYoZCo9LTEsZj1wLmxlbik7cC5yZXZlcnNlZCYmKGQqPS0xLGYtPWQqKHAuc2VjdG9yfHxwLmxlbikpO2U/KGI9KGIqZCtmLXcpL20rZyx1JiYoYj1wLmxpbjJ2YWwoYikpKToodSYmKGI9cC52YWwybGluKGIpKSxiPWEoZyk/ZCooYi1nKSptK2YrZCp3KyhhKGgpP20qaDowKTpcbnZvaWQgMCk7cmV0dXJuIGJ9O2YucHJvdG90eXBlLnRvUGl4ZWxzPWZ1bmN0aW9uKGEsYil7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGEsITEsIXRoaXMuaG9yaXosbnVsbCwhMCkrKGI/MDp0aGlzLnBvcyl9O2YucHJvdG90eXBlLnRvVmFsdWU9ZnVuY3Rpb24oYSxiKXtyZXR1cm4gdGhpcy50cmFuc2xhdGUoYS0oYj8wOnRoaXMucG9zKSwhMCwhdGhpcy5ob3JpeixudWxsLCEwKX07Zi5wcm90b3R5cGUuZ2V0UGxvdExpbmVQYXRoPWZ1bmN0aW9uKGIpe2Z1bmN0aW9uIGUoYSxiLGUpe2lmKFwicGFzc1wiIT09biYmYTxifHxhPmUpbj9hPWcoYSxiLGUpOlo9ITA7cmV0dXJuIGF9dmFyIGM9dGhpcyxwPWMuY2hhcnQsdT1jLmxlZnQsaD1jLnRvcCxkPWIub2xkLGY9Yi52YWx1ZSxtPWIudHJhbnNsYXRlZFZhbHVlLHc9Yi5saW5lV2lkdGgsbj1iLmZvcmNlLHIscSxsLEosdj1kJiZwLm9sZENoYXJ0SGVpZ2h0fHxwLmNoYXJ0SGVpZ2h0LFY9ZCYmcC5vbGRDaGFydFdpZHRofHxwLmNoYXJ0V2lkdGgsXG5aLE49Yy50cmFuc0I7Yj17dmFsdWU6ZixsaW5lV2lkdGg6dyxvbGQ6ZCxmb3JjZTpuLGFjcm9zc1BhbmVzOmIuYWNyb3NzUGFuZXMsdHJhbnNsYXRlZFZhbHVlOm19O3oodGhpcyxcImdldFBsb3RMaW5lUGF0aFwiLGIsZnVuY3Rpb24oYil7bT1GKG0sYy50cmFuc2xhdGUoZixudWxsLG51bGwsZCkpO209ZyhtLC0xRTUsMUU1KTtyPWw9TWF0aC5yb3VuZChtK04pO3E9Sj1NYXRoLnJvdW5kKHYtbS1OKTthKG0pP2MuaG9yaXo/KHE9aCxKPXYtYy5ib3R0b20scj1sPWUocix1LHUrYy53aWR0aCkpOihyPXUsbD1WLWMucmlnaHQscT1KPWUocSxoLGgrYy5oZWlnaHQpKTooWj0hMCxuPSExKTtiLnBhdGg9WiYmIW4/bnVsbDpwLnJlbmRlcmVyLmNyaXNwTGluZShbW1wiTVwiLHIscV0sW1wiTFwiLGwsSl1dLHd8fDEpfSk7cmV0dXJuIGIucGF0aH07Zi5wcm90b3R5cGUuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucz1mdW5jdGlvbihhLGIsZSl7dmFyIGM9eShNYXRoLmZsb29yKGIvYSkqYSk7ZT15KE1hdGguY2VpbChlL1xuYSkqYSk7dmFyIHA9W10sZzt5KGMrYSk9PT1jJiYoZz0yMCk7aWYodGhpcy5zaW5nbGUpcmV0dXJuW2JdO2ZvcihiPWM7Yjw9ZTspe3AucHVzaChiKTtiPXkoYithLGcpO2lmKGI9PT1oKWJyZWFrO3ZhciBoPWJ9cmV0dXJuIHB9O2YucHJvdG90eXBlLmdldE1pbm9yVGlja0ludGVydmFsPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zO3JldHVybiEwPT09YS5taW5vclRpY2tzP0YoYS5taW5vclRpY2tJbnRlcnZhbCxcImF1dG9cIik6ITE9PT1hLm1pbm9yVGlja3M/bnVsbDphLm1pbm9yVGlja0ludGVydmFsfTtmLnByb3RvdHlwZS5nZXRNaW5vclRpY2tQb3NpdGlvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLnRpY2tQb3NpdGlvbnMsZT10aGlzLm1pbm9yVGlja0ludGVydmFsLGM9W10sdT10aGlzLnBvaW50UmFuZ2VQYWRkaW5nfHwwLGc9dGhpcy5taW4tdTt1PXRoaXMubWF4K3U7dmFyIGg9dS1nO2lmKGgmJmgvZTx0aGlzLmxlbi8zKXt2YXIgZD10aGlzLmxvZ2FyaXRobWljO1xuaWYoZCl0aGlzLnBhZGRlZFRpY2tzLmZvckVhY2goZnVuY3Rpb24oYSxiLHApe2ImJmMucHVzaC5hcHBseShjLGQuZ2V0TG9nVGlja1Bvc2l0aW9ucyhlLHBbYi0xXSxwW2JdLCEwKSl9KTtlbHNlIGlmKHRoaXMuZGF0ZVRpbWUmJlwiYXV0b1wiPT09dGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpKWM9Yy5jb25jYXQodGhpcy5nZXRUaW1lVGlja3ModGhpcy5kYXRlVGltZS5ub3JtYWxpemVUaW1lVGlja0ludGVydmFsKGUpLGcsdSxhLnN0YXJ0T2ZXZWVrKSk7ZWxzZSBmb3IoYT1nKyhiWzBdLWcpJWU7YTw9dSYmYSE9PWNbMF07YSs9ZSljLnB1c2goYSl9MCE9PWMubGVuZ3RoJiZ0aGlzLnRyaW1UaWNrcyhjKTtyZXR1cm4gY307Zi5wcm90b3R5cGUuYWRqdXN0Rm9yTWluUmFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLm1pbixlPXRoaXMubWF4LGc9dGhpcy5sb2dhcml0aG1pYyx1PTAsaCxkLGYsbTt0aGlzLmlzWEF4aXMmJlwidW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5taW5SYW5nZSYmXG4hZyYmKGMoYS5taW4pfHxjKGEubWF4KT90aGlzLm1pblJhbmdlPW51bGw6KHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYSl7Zj1hLnhEYXRhO209YS54SW5jcmVtZW50PzE6Zi5sZW5ndGgtMTtpZigxPGYubGVuZ3RoKWZvcihoPW07MDxoO2gtLSlpZihkPWZbaF0tZltoLTFdLCF1fHxkPHUpdT1kfSksdGhpcy5taW5SYW5nZT1NYXRoLm1pbig1KnUsdGhpcy5kYXRhTWF4LXRoaXMuZGF0YU1pbikpKTtpZihlLWI8dGhpcy5taW5SYW5nZSl7dmFyIHc9dGhpcy5kYXRhTWF4LXRoaXMuZGF0YU1pbj49dGhpcy5taW5SYW5nZTt2YXIgbj10aGlzLm1pblJhbmdlO3ZhciByPShuLWUrYikvMjtyPVtiLXIsRihhLm1pbixiLXIpXTt3JiYoclsyXT10aGlzLmxvZ2FyaXRobWljP3RoaXMubG9nYXJpdGhtaWMubG9nMmxpbih0aGlzLmRhdGFNaW4pOnRoaXMuZGF0YU1pbik7Yj1sKHIpO2U9W2IrbixGKGEubWF4LGIrbildO3cmJihlWzJdPWc/Zy5sb2cybGluKHRoaXMuZGF0YU1heCk6dGhpcy5kYXRhTWF4KTtcbmU9RShlKTtlLWI8biYmKHJbMF09ZS1uLHJbMV09RihhLm1pbixlLW4pLGI9bChyKSl9dGhpcy5taW49Yjt0aGlzLm1heD1lfTtmLnByb3RvdHlwZS5nZXRDbG9zZXN0PWZ1bmN0aW9uKCl7dmFyIGE7dGhpcy5jYXRlZ29yaWVzP2E9MTp0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGIpe3ZhciBlPWIuY2xvc2VzdFBvaW50UmFuZ2UscD1iLnZpc2libGV8fCFiLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzOyFiLm5vU2hhcmVkVG9vbHRpcCYmYyhlKSYmcCYmKGE9YyhhKT9NYXRoLm1pbihhLGUpOmUpfSk7cmV0dXJuIGF9O2YucHJvdG90eXBlLm5hbWVUb1g9ZnVuY3Rpb24oYSl7dmFyIGI9ZSh0aGlzLmNhdGVnb3JpZXMpLHA9Yj90aGlzLmNhdGVnb3JpZXM6dGhpcy5uYW1lcyxnPWEub3B0aW9ucy54O2Euc2VyaWVzLnJlcXVpcmVTb3J0aW5nPSExO2MoZyl8fChnPSExPT09dGhpcy5vcHRpb25zLnVuaXF1ZU5hbWVzP2Euc2VyaWVzLmF1dG9JbmNyZW1lbnQoKTpcbmI/cC5pbmRleE9mKGEubmFtZSk6RihwLmtleXNbYS5uYW1lXSwtMSkpO2lmKC0xPT09Zyl7aWYoIWIpdmFyIHU9cC5sZW5ndGh9ZWxzZSB1PWc7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB1JiYodGhpcy5uYW1lc1t1XT1hLm5hbWUsdGhpcy5uYW1lcy5rZXlzW2EubmFtZV09dSk7cmV0dXJuIHV9O2YucHJvdG90eXBlLnVwZGF0ZU5hbWVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMubmFtZXM7MDxiLmxlbmd0aCYmKE9iamVjdC5rZXlzKGIua2V5cykuZm9yRWFjaChmdW5jdGlvbihhKXtkZWxldGUgYi5rZXlzW2FdfSksYi5sZW5ndGg9MCx0aGlzLm1pblJhbmdlPXRoaXMudXNlck1pblJhbmdlLCh0aGlzLnNlcmllc3x8W10pLmZvckVhY2goZnVuY3Rpb24oYil7Yi54SW5jcmVtZW50PW51bGw7aWYoIWIucG9pbnRzfHxiLmlzRGlydHlEYXRhKWEubWF4PU1hdGgubWF4KGEubWF4LGIueERhdGEubGVuZ3RoLTEpLGIucHJvY2Vzc0RhdGEoKSxiLmdlbmVyYXRlUG9pbnRzKCk7Yi5kYXRhLmZvckVhY2goZnVuY3Rpb24oZSxcbmMpe2lmKGUmJmUub3B0aW9ucyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBlLm5hbWUpe3ZhciBwPWEubmFtZVRvWChlKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIHAmJnAhPT1lLngmJihlLng9cCxiLnhEYXRhW2NdPXApfX0pfSkpfTtmLnByb3RvdHlwZS5zZXRBeGlzVHJhbnNsYXRpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGU9YS5tYXgtYS5taW4sYz1hLmF4aXNQb2ludFJhbmdlfHwwLGc9MCx1PTAsaD1hLmxpbmtlZFBhcmVudCxkPSEhYS5jYXRlZ29yaWVzLGY9YS50cmFuc0EsbT1hLmlzWEF4aXM7aWYobXx8ZHx8Yyl7dmFyIHc9YS5nZXRDbG9zZXN0KCk7aD8oZz1oLm1pblBvaW50T2Zmc2V0LHU9aC5wb2ludFJhbmdlUGFkZGluZyk6YS5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgcD1kPzE6bT9GKGUub3B0aW9ucy5wb2ludFJhbmdlLHcsMCk6YS5heGlzUG9pbnRSYW5nZXx8MCxoPWUub3B0aW9ucy5wb2ludFBsYWNlbWVudDtjPU1hdGgubWF4KGMscCk7aWYoIWEuc2luZ2xlfHxcbmQpZT1lLmlzKFwieHJhbmdlXCIpPyFtOm0sZz1NYXRoLm1heChnLGUmJmIoaCk/MDpwLzIpLHU9TWF0aC5tYXgodSxlJiZcIm9uXCI9PT1oPzA6cCl9KTtoPWEub3JkaW5hbCYmYS5vcmRpbmFsLnNsb3BlJiZ3P2Eub3JkaW5hbC5zbG9wZS93OjE7YS5taW5Qb2ludE9mZnNldD1nKj1oO2EucG9pbnRSYW5nZVBhZGRpbmc9dSo9aDthLnBvaW50UmFuZ2U9TWF0aC5taW4oYyxhLnNpbmdsZSYmZD8xOmUpO20mJihhLmNsb3Nlc3RQb2ludFJhbmdlPXcpfWEudHJhbnNsYXRpb25TbG9wZT1hLnRyYW5zQT1mPWEuc3RhdGljU2NhbGV8fGEubGVuLyhlK3V8fDEpO2EudHJhbnNCPWEuaG9yaXo/YS5sZWZ0OmEuYm90dG9tO2EubWluUGl4ZWxQYWRkaW5nPWYqZzt6KHRoaXMsXCJhZnRlclNldEF4aXNUcmFuc2xhdGlvblwiKX07Zi5wcm90b3R5cGUubWluRnJvbVJhbmdlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4LXRoaXMucmFuZ2V9O2YucHJvdG90eXBlLnNldFRpY2tJbnRlcnZhbD1mdW5jdGlvbihiKXt2YXIgZT1cbnRoaXMscD1lLmNoYXJ0LGc9ZS5sb2dhcml0aG1pYyx1PWUub3B0aW9ucyxoPWUuaXNYQXhpcyxkPWUuaXNMaW5rZWQsZj11Lm1heFBhZGRpbmcsbT11Lm1pblBhZGRpbmcsdz11LnRpY2tJbnRlcnZhbCxuPXUudGlja1BpeGVsSW50ZXJ2YWwscT1lLmNhdGVnb3JpZXMsbD1hKGUudGhyZXNob2xkKT9lLnRocmVzaG9sZDpudWxsLHY9ZS5zb2Z0VGhyZXNob2xkO2UuZGF0ZVRpbWV8fHF8fGR8fHRoaXMuZ2V0VGlja0Ftb3VudCgpO3ZhciBOPUYoZS51c2VyTWluLHUubWluKTt2YXIgTz1GKGUudXNlck1heCx1Lm1heCk7aWYoZCl7ZS5saW5rZWRQYXJlbnQ9cFtlLmNvbGxdW3UubGlua2VkVG9dO3ZhciBWPWUubGlua2VkUGFyZW50LmdldEV4dHJlbWVzKCk7ZS5taW49RihWLm1pbixWLmRhdGFNaW4pO2UubWF4PUYoVi5tYXgsVi5kYXRhTWF4KTt1LnR5cGUhPT1lLmxpbmtlZFBhcmVudC5vcHRpb25zLnR5cGUmJkEoMTEsMSxwKX1lbHNle2lmKHYmJmMobCkpaWYoZS5kYXRhTWluPj1sKVY9XG5sLG09MDtlbHNlIGlmKGUuZGF0YU1heDw9bCl7dmFyIFo9bDtmPTB9ZS5taW49RihOLFYsZS5kYXRhTWluKTtlLm1heD1GKE8sWixlLmRhdGFNYXgpfWcmJihlLnBvc2l0aXZlVmFsdWVzT25seSYmIWImJjA+PU1hdGgubWluKGUubWluLEYoZS5kYXRhTWluLGUubWluKSkmJkEoMTAsMSxwKSxlLm1pbj15KGcubG9nMmxpbihlLm1pbiksMTYpLGUubWF4PXkoZy5sb2cybGluKGUubWF4KSwxNikpO2UucmFuZ2UmJmMoZS5tYXgpJiYoZS51c2VyTWluPWUubWluPU49TWF0aC5tYXgoZS5kYXRhTWluLGUubWluRnJvbVJhbmdlKCkpLGUudXNlck1heD1PPWUubWF4LGUucmFuZ2U9bnVsbCk7eihlLFwiZm91bmRFeHRyZW1lc1wiKTtlLmJlZm9yZVBhZGRpbmcmJmUuYmVmb3JlUGFkZGluZygpO2UuYWRqdXN0Rm9yTWluUmFuZ2UoKTshKHF8fGUuYXhpc1BvaW50UmFuZ2V8fGUuc3RhY2tpbmcmJmUuc3RhY2tpbmcudXNlUGVyY2VudGFnZXx8ZCkmJmMoZS5taW4pJiZjKGUubWF4KSYmKHA9ZS5tYXgtXG5lLm1pbikmJighYyhOKSYmbSYmKGUubWluLT1wKm0pLCFjKE8pJiZmJiYoZS5tYXgrPXAqZikpO2EoZS51c2VyTWluKXx8KGEodS5zb2Z0TWluKSYmdS5zb2Z0TWluPGUubWluJiYoZS5taW49Tj11LnNvZnRNaW4pLGEodS5mbG9vcikmJihlLm1pbj1NYXRoLm1heChlLm1pbix1LmZsb29yKSkpO2EoZS51c2VyTWF4KXx8KGEodS5zb2Z0TWF4KSYmdS5zb2Z0TWF4PmUubWF4JiYoZS5tYXg9Tz11LnNvZnRNYXgpLGEodS5jZWlsaW5nKSYmKGUubWF4PU1hdGgubWluKGUubWF4LHUuY2VpbGluZykpKTt2JiZjKGUuZGF0YU1pbikmJihsPWx8fDAsIWMoTikmJmUubWluPGwmJmUuZGF0YU1pbj49bD9lLm1pbj1lLm9wdGlvbnMubWluUmFuZ2U/TWF0aC5taW4obCxlLm1heC1lLm1pblJhbmdlKTpsOiFjKE8pJiZlLm1heD5sJiZlLmRhdGFNYXg8PWwmJihlLm1heD1lLm9wdGlvbnMubWluUmFuZ2U/TWF0aC5tYXgobCxlLm1pbitlLm1pblJhbmdlKTpsKSk7YShlLm1pbikmJmEoZS5tYXgpJiZcbiF0aGlzLmNoYXJ0LnBvbGFyJiZlLm1pbj5lLm1heCYmKGMoZS5vcHRpb25zLm1pbik/ZS5tYXg9ZS5taW46YyhlLm9wdGlvbnMubWF4KSYmKGUubWluPWUubWF4KSk7ZS50aWNrSW50ZXJ2YWw9ZS5taW49PT1lLm1heHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBlLm1pbnx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBlLm1heD8xOmQmJiF3JiZuPT09ZS5saW5rZWRQYXJlbnQub3B0aW9ucy50aWNrUGl4ZWxJbnRlcnZhbD93PWUubGlua2VkUGFyZW50LnRpY2tJbnRlcnZhbDpGKHcsdGhpcy50aWNrQW1vdW50PyhlLm1heC1lLm1pbikvTWF0aC5tYXgodGhpcy50aWNrQW1vdW50LTEsMSk6dm9pZCAwLHE/MTooZS5tYXgtZS5taW4pKm4vTWF0aC5tYXgoZS5sZW4sbikpO2gmJiFiJiZlLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiLGM7YS5wcm9jZXNzRGF0YShlLm1pbiE9PShudWxsPT09KGI9ZS5vbGQpfHx2b2lkIDA9PT1iP3ZvaWQgMDpiLm1pbil8fGUubWF4IT09KG51bGw9PT1cbihjPWUub2xkKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy5tYXgpKX0pO2Uuc2V0QXhpc1RyYW5zbGF0aW9uKCk7eih0aGlzLFwiaW5pdGlhbEF4aXNUcmFuc2xhdGlvblwiKTtlLnBvaW50UmFuZ2UmJiF3JiYoZS50aWNrSW50ZXJ2YWw9TWF0aC5tYXgoZS5wb2ludFJhbmdlLGUudGlja0ludGVydmFsKSk7Yj1GKHUubWluVGlja0ludGVydmFsLGUuZGF0ZVRpbWUmJiFlLnNlcmllcy5zb21lKGZ1bmN0aW9uKGEpe3JldHVybiBhLm5vU2hhcmVkVG9vbHRpcH0pP2UuY2xvc2VzdFBvaW50UmFuZ2U6MCk7IXcmJmUudGlja0ludGVydmFsPGImJihlLnRpY2tJbnRlcnZhbD1iKTtlLmRhdGVUaW1lfHxlLmxvZ2FyaXRobWljfHx3fHwoZS50aWNrSW50ZXJ2YWw9SihlLnRpY2tJbnRlcnZhbCx2b2lkIDAscihlLnRpY2tJbnRlcnZhbCksRih1LmFsbG93RGVjaW1hbHMsLjU+ZS50aWNrSW50ZXJ2YWx8fHZvaWQgMCE9PXRoaXMudGlja0Ftb3VudCksISF0aGlzLnRpY2tBbW91bnQpKTt0aGlzLnRpY2tBbW91bnR8fFxuKGUudGlja0ludGVydmFsPWUudW5zcXVpc2goKSk7dGhpcy5zZXRUaWNrUG9zaXRpb25zKCl9O2YucHJvdG90eXBlLnNldFRpY2tQb3NpdGlvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj1hLnRpY2tQb3NpdGlvbnM7dmFyIGU9dGhpcy5nZXRNaW5vclRpY2tJbnRlcnZhbCgpO3ZhciBnPWEudGlja1Bvc2l0aW9uZXIsaD10aGlzLmhhc1ZlcnRpY2FsUGFubmluZygpLGQ9XCJjb2xvckF4aXNcIj09PXRoaXMuY29sbCxmPShkfHwhaCkmJmEuc3RhcnRPblRpY2s7aD0oZHx8IWgpJiZhLmVuZE9uVGljazt0aGlzLnRpY2ttYXJrT2Zmc2V0PXRoaXMuY2F0ZWdvcmllcyYmXCJiZXR3ZWVuXCI9PT1hLnRpY2ttYXJrUGxhY2VtZW50JiYxPT09dGhpcy50aWNrSW50ZXJ2YWw/LjU6MDt0aGlzLm1pbm9yVGlja0ludGVydmFsPVwiYXV0b1wiPT09ZSYmdGhpcy50aWNrSW50ZXJ2YWw/dGhpcy50aWNrSW50ZXJ2YWwvNTplO3RoaXMuc2luZ2xlPXRoaXMubWluPT09dGhpcy5tYXgmJmModGhpcy5taW4pJiZcbiF0aGlzLnRpY2tBbW91bnQmJihwYXJzZUludCh0aGlzLm1pbiwxMCk9PT10aGlzLm1pbnx8ITEhPT1hLmFsbG93RGVjaW1hbHMpO3RoaXMudGlja1Bvc2l0aW9ucz1lPWImJmIuc2xpY2UoKTshZSYmKHRoaXMub3JkaW5hbCYmdGhpcy5vcmRpbmFsLnBvc2l0aW9uc3x8ISgodGhpcy5tYXgtdGhpcy5taW4pL3RoaXMudGlja0ludGVydmFsPk1hdGgubWF4KDIqdGhpcy5sZW4sMjAwKSk/ZT10aGlzLmRhdGVUaW1lP3RoaXMuZ2V0VGltZVRpY2tzKHRoaXMuZGF0ZVRpbWUubm9ybWFsaXplVGltZVRpY2tJbnRlcnZhbCh0aGlzLnRpY2tJbnRlcnZhbCxhLnVuaXRzKSx0aGlzLm1pbix0aGlzLm1heCxhLnN0YXJ0T2ZXZWVrLHRoaXMub3JkaW5hbCYmdGhpcy5vcmRpbmFsLnBvc2l0aW9ucyx0aGlzLmNsb3Nlc3RQb2ludFJhbmdlLCEwKTp0aGlzLmxvZ2FyaXRobWljP3RoaXMubG9nYXJpdGhtaWMuZ2V0TG9nVGlja1Bvc2l0aW9ucyh0aGlzLnRpY2tJbnRlcnZhbCx0aGlzLm1pbix0aGlzLm1heCk6XG50aGlzLmdldExpbmVhclRpY2tQb3NpdGlvbnModGhpcy50aWNrSW50ZXJ2YWwsdGhpcy5taW4sdGhpcy5tYXgpOihlPVt0aGlzLm1pbix0aGlzLm1heF0sQSgxOSwhMSx0aGlzLmNoYXJ0KSksZS5sZW5ndGg+dGhpcy5sZW4mJihlPVtlWzBdLGUucG9wKCldLGVbMF09PT1lWzFdJiYoZS5sZW5ndGg9MSkpLHRoaXMudGlja1Bvc2l0aW9ucz1lLGcmJihnPWcuYXBwbHkodGhpcyxbdGhpcy5taW4sdGhpcy5tYXhdKSkpJiYodGhpcy50aWNrUG9zaXRpb25zPWU9Zyk7dGhpcy5wYWRkZWRUaWNrcz1lLnNsaWNlKDApO3RoaXMudHJpbVRpY2tzKGUsZixoKTt0aGlzLmlzTGlua2VkfHwodGhpcy5zaW5nbGUmJjI+ZS5sZW5ndGgmJiF0aGlzLmNhdGVnb3JpZXMmJiF0aGlzLnNlcmllcy5zb21lKGZ1bmN0aW9uKGEpe3JldHVybiBhLmlzKFwiaGVhdG1hcFwiKSYmXCJiZXR3ZWVuXCI9PT1hLm9wdGlvbnMucG9pbnRQbGFjZW1lbnR9KSYmKHRoaXMubWluLT0uNSx0aGlzLm1heCs9LjUpLGJ8fGd8fHRoaXMuYWRqdXN0VGlja0Ftb3VudCgpKTtcbnoodGhpcyxcImFmdGVyU2V0VGlja1Bvc2l0aW9uc1wiKX07Zi5wcm90b3R5cGUudHJpbVRpY2tzPWZ1bmN0aW9uKGEsYixlKXt2YXIgZz1hWzBdLHA9YVthLmxlbmd0aC0xXSxoPSF0aGlzLmlzT3JkaW5hbCYmdGhpcy5taW5Qb2ludE9mZnNldHx8MDt6KHRoaXMsXCJ0cmltVGlja3NcIik7aWYoIXRoaXMuaXNMaW5rZWQpe2lmKGImJi1JbmZpbml0eSE9PWcpdGhpcy5taW49ZztlbHNlIGZvcig7dGhpcy5taW4taD5hWzBdOylhLnNoaWZ0KCk7aWYoZSl0aGlzLm1heD1wO2Vsc2UgZm9yKDt0aGlzLm1heCtoPGFbYS5sZW5ndGgtMV07KWEucG9wKCk7MD09PWEubGVuZ3RoJiZjKGcpJiYhdGhpcy5vcHRpb25zLnRpY2tQb3NpdGlvbnMmJmEucHVzaCgocCtnKS8yKX19O2YucHJvdG90eXBlLmFsaWduVG9PdGhlcnM9ZnVuY3Rpb24oKXt2YXIgYT17fSxiLGU9dGhpcy5vcHRpb25zOyExPT09dGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0LmFsaWduVGlja3N8fCExPT09ZS5hbGlnblRpY2tzfHwhMT09PVxuZS5zdGFydE9uVGlja3x8ITE9PT1lLmVuZE9uVGlja3x8dGhpcy5sb2dhcml0aG1pY3x8dGhpcy5jaGFydFt0aGlzLmNvbGxdLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIGM9ZS5vcHRpb25zO2M9W2UuaG9yaXo/Yy5sZWZ0OmMudG9wLGMud2lkdGgsYy5oZWlnaHQsYy5wYW5lXS5qb2luKCk7ZS5zZXJpZXMubGVuZ3RoJiYoYVtjXT9iPSEwOmFbY109MSl9KTtyZXR1cm4gYn07Zi5wcm90b3R5cGUuZ2V0VGlja0Ftb3VudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPWEudGlja0Ftb3VudCxlPWEudGlja1BpeGVsSW50ZXJ2YWw7IWMoYS50aWNrSW50ZXJ2YWwpJiYhYiYmdGhpcy5sZW48ZSYmIXRoaXMuaXNSYWRpYWwmJiF0aGlzLmxvZ2FyaXRobWljJiZhLnN0YXJ0T25UaWNrJiZhLmVuZE9uVGljayYmKGI9Mik7IWImJnRoaXMuYWxpZ25Ub090aGVycygpJiYoYj1NYXRoLmNlaWwodGhpcy5sZW4vZSkrMSk7ND5iJiYodGhpcy5maW5hbFRpY2tBbXQ9YixiPTUpO3RoaXMudGlja0Ftb3VudD1cbmJ9O2YucHJvdG90eXBlLmFkanVzdFRpY2tBbW91bnQ9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLm9wdGlvbnMsZT10aGlzLnRpY2tJbnRlcnZhbCxnPXRoaXMudGlja1Bvc2l0aW9ucyxoPXRoaXMudGlja0Ftb3VudCx1PXRoaXMuZmluYWxUaWNrQW10LGQ9ZyYmZy5sZW5ndGgsZj1GKHRoaXMudGhyZXNob2xkLHRoaXMuc29mdFRocmVzaG9sZD8wOm51bGwpO2lmKHRoaXMuaGFzRGF0YSgpJiZhKHRoaXMubWluKSYmYSh0aGlzLm1heCkpe2lmKGQ8aCl7Zm9yKDtnLmxlbmd0aDxoOylnLmxlbmd0aCUyfHx0aGlzLm1pbj09PWY/Zy5wdXNoKHkoZ1tnLmxlbmd0aC0xXStlKSk6Zy51bnNoaWZ0KHkoZ1swXS1lKSk7dGhpcy50cmFuc0EqPShkLTEpLyhoLTEpO3RoaXMubWluPWIuc3RhcnRPblRpY2s/Z1swXTpNYXRoLm1pbih0aGlzLm1pbixnWzBdKTt0aGlzLm1heD1iLmVuZE9uVGljaz9nW2cubGVuZ3RoLTFdOk1hdGgubWF4KHRoaXMubWF4LGdbZy5sZW5ndGgtMV0pfWVsc2UgZD5oJiYodGhpcy50aWNrSW50ZXJ2YWwqPVxuMix0aGlzLnNldFRpY2tQb3NpdGlvbnMoKSk7aWYoYyh1KSl7Zm9yKGU9Yj1nLmxlbmd0aDtlLS07KSgzPT09dSYmMT09PWUlMnx8Mj49dSYmMDxlJiZlPGItMSkmJmcuc3BsaWNlKGUsMSk7dGhpcy5maW5hbFRpY2tBbXQ9dm9pZCAwfX19O2YucHJvdG90eXBlLnNldFNjYWxlPWZ1bmN0aW9uKCl7dmFyIGEsYixlLGMsZyxoLGQ9ITEsZj0hMTt0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiO2Q9ZHx8YS5pc0RpcnR5RGF0YXx8YS5pc0RpcnR5O2Y9Znx8KG51bGw9PT0oYj1hLnhBeGlzKXx8dm9pZCAwPT09Yj92b2lkIDA6Yi5pc0RpcnR5KXx8ITF9KTt0aGlzLnNldEF4aXNTaXplKCk7KGg9dGhpcy5sZW4hPT0obnVsbD09PShhPXRoaXMub2xkKXx8dm9pZCAwPT09YT92b2lkIDA6YS5sZW4pKXx8ZHx8Znx8dGhpcy5pc0xpbmtlZHx8dGhpcy5mb3JjZVJlZHJhd3x8dGhpcy51c2VyTWluIT09KG51bGw9PT0oYj10aGlzLm9sZCl8fHZvaWQgMD09PWI/dm9pZCAwOmIudXNlck1pbil8fFxudGhpcy51c2VyTWF4IT09KG51bGw9PT0oZT10aGlzLm9sZCl8fHZvaWQgMD09PWU/dm9pZCAwOmUudXNlck1heCl8fHRoaXMuYWxpZ25Ub090aGVycygpPyh0aGlzLnN0YWNraW5nJiZ0aGlzLnN0YWNraW5nLnJlc2V0U3RhY2tzKCksdGhpcy5mb3JjZVJlZHJhdz0hMSx0aGlzLmdldFNlcmllc0V4dHJlbWVzKCksdGhpcy5zZXRUaWNrSW50ZXJ2YWwoKSx0aGlzLmlzRGlydHl8fCh0aGlzLmlzRGlydHk9aHx8dGhpcy5taW4hPT0obnVsbD09PShjPXRoaXMub2xkKXx8dm9pZCAwPT09Yz92b2lkIDA6Yy5taW4pfHx0aGlzLm1heCE9PShudWxsPT09KGc9dGhpcy5vbGQpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLm1heCkpKTp0aGlzLnN0YWNraW5nJiZ0aGlzLnN0YWNraW5nLmNsZWFuU3RhY2tzKCk7ZCYmdGhpcy5wYW5uaW5nU3RhdGUmJih0aGlzLnBhbm5pbmdTdGF0ZS5pc0RpcnR5PSEwKTt6KHRoaXMsXCJhZnRlclNldFNjYWxlXCIpfTtmLnByb3RvdHlwZS5zZXRFeHRyZW1lcz1mdW5jdGlvbihhLFxuYixlLGMsZyl7dmFyIGg9dGhpcyxwPWguY2hhcnQ7ZT1GKGUsITApO2guc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYSl7ZGVsZXRlIGEua2RUcmVlfSk7Zz1NKGcse21pbjphLG1heDpifSk7eihoLFwic2V0RXh0cmVtZXNcIixnLGZ1bmN0aW9uKCl7aC51c2VyTWluPWE7aC51c2VyTWF4PWI7aC5ldmVudEFyZ3M9ZztlJiZwLnJlZHJhdyhjKX0pfTtmLnByb3RvdHlwZS56b29tPWZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcyxnPXRoaXMuZGF0YU1pbixoPXRoaXMuZGF0YU1heCxwPXRoaXMub3B0aW9ucyxkPU1hdGgubWluKGcsRihwLm1pbixnKSksZj1NYXRoLm1heChoLEYocC5tYXgsaCkpO2E9e25ld01pbjphLG5ld01heDpifTt6KHRoaXMsXCJ6b29tXCIsYSxmdW5jdGlvbihhKXt2YXIgYj1hLm5ld01pbixwPWEubmV3TWF4O2lmKGIhPT1lLm1pbnx8cCE9PWUubWF4KWUuYWxsb3dab29tT3V0c2lkZXx8KGMoZykmJihiPGQmJihiPWQpLGI+ZiYmKGI9ZikpLGMoaCkmJihwPGQmJihwPWQpLFxucD5mJiYocD1mKSkpLGUuZGlzcGxheUJ0bj1cInVuZGVmaW5lZFwiIT09dHlwZW9mIGJ8fFwidW5kZWZpbmVkXCIhPT10eXBlb2YgcCxlLnNldEV4dHJlbWVzKGIscCwhMSx2b2lkIDAse3RyaWdnZXI6XCJ6b29tXCJ9KTthLnpvb21lZD0hMH0pO3JldHVybiBhLnpvb21lZH07Zi5wcm90b3R5cGUuc2V0QXhpc1NpemU9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9dGhpcy5vcHRpb25zLGU9Yi5vZmZzZXRzfHxbMCwwLDAsMF0sYz10aGlzLmhvcml6LGc9dGhpcy53aWR0aD1NYXRoLnJvdW5kKE4oRihiLndpZHRoLGEucGxvdFdpZHRoLWVbM10rZVsxXSksYS5wbG90V2lkdGgpKSxoPXRoaXMuaGVpZ2h0PU1hdGgucm91bmQoTihGKGIuaGVpZ2h0LGEucGxvdEhlaWdodC1lWzBdK2VbMl0pLGEucGxvdEhlaWdodCkpLGQ9dGhpcy50b3A9TWF0aC5yb3VuZChOKEYoYi50b3AsYS5wbG90VG9wK2VbMF0pLGEucGxvdEhlaWdodCxhLnBsb3RUb3ApKTtiPXRoaXMubGVmdD1NYXRoLnJvdW5kKE4oRihiLmxlZnQsXG5hLnBsb3RMZWZ0K2VbM10pLGEucGxvdFdpZHRoLGEucGxvdExlZnQpKTt0aGlzLmJvdHRvbT1hLmNoYXJ0SGVpZ2h0LWgtZDt0aGlzLnJpZ2h0PWEuY2hhcnRXaWR0aC1nLWI7dGhpcy5sZW49TWF0aC5tYXgoYz9nOmgsMCk7dGhpcy5wb3M9Yz9iOmR9O2YucHJvdG90eXBlLmdldEV4dHJlbWVzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5sb2dhcml0aG1pYztyZXR1cm57bWluOmE/eShhLmxpbjJsb2codGhpcy5taW4pKTp0aGlzLm1pbixtYXg6YT95KGEubGluMmxvZyh0aGlzLm1heCkpOnRoaXMubWF4LGRhdGFNaW46dGhpcy5kYXRhTWluLGRhdGFNYXg6dGhpcy5kYXRhTWF4LHVzZXJNaW46dGhpcy51c2VyTWluLHVzZXJNYXg6dGhpcy51c2VyTWF4fX07Zi5wcm90b3R5cGUuZ2V0VGhyZXNob2xkPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMubG9nYXJpdGhtaWMsZT1iP2IubGluMmxvZyh0aGlzLm1pbik6dGhpcy5taW47Yj1iP2IubGluMmxvZyh0aGlzLm1heCk6dGhpcy5tYXg7bnVsbD09PVxuYXx8LUluZmluaXR5PT09YT9hPWU6SW5maW5pdHk9PT1hP2E9YjplPmE/YT1lOmI8YSYmKGE9Yik7cmV0dXJuIHRoaXMudHJhbnNsYXRlKGEsMCwxLDAsMSl9O2YucHJvdG90eXBlLmF1dG9MYWJlbEFsaWduPWZ1bmN0aW9uKGEpe3ZhciBiPShGKGEsMCktOTAqdGhpcy5zaWRlKzcyMCklMzYwO2E9e2FsaWduOlwiY2VudGVyXCJ9O3oodGhpcyxcImF1dG9MYWJlbEFsaWduXCIsYSxmdW5jdGlvbihhKXsxNTxiJiYxNjU+Yj9hLmFsaWduPVwicmlnaHRcIjoxOTU8YiYmMzQ1PmImJihhLmFsaWduPVwibGVmdFwiKX0pO3JldHVybiBhLmFsaWdufTtmLnByb3RvdHlwZS50aWNrU2l6ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnMsZT1iW1widGlja1wiPT09YT9cInRpY2tMZW5ndGhcIjpcIm1pbm9yVGlja0xlbmd0aFwiXSxjPUYoYltcInRpY2tcIj09PWE/XCJ0aWNrV2lkdGhcIjpcIm1pbm9yVGlja1dpZHRoXCJdLFwidGlja1wiPT09YSYmdGhpcy5pc1hBeGlzJiYhdGhpcy5jYXRlZ29yaWVzPzE6MCk7aWYoYyYmZSl7XCJpbnNpZGVcIj09PVxuYlthK1wiUG9zaXRpb25cIl0mJihlPS1lKTt2YXIgZz1bZSxjXX1hPXt0aWNrU2l6ZTpnfTt6KHRoaXMsXCJhZnRlclRpY2tTaXplXCIsYSk7cmV0dXJuIGEudGlja1NpemV9O2YucHJvdG90eXBlLmxhYmVsTWV0cmljcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMudGlja1Bvc2l0aW9ucyYmdGhpcy50aWNrUG9zaXRpb25zWzBdfHwwO3JldHVybiB0aGlzLmNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKHRoaXMub3B0aW9ucy5sYWJlbHMuc3R5bGUmJnRoaXMub3B0aW9ucy5sYWJlbHMuc3R5bGUuZm9udFNpemUsdGhpcy50aWNrc1thXSYmdGhpcy50aWNrc1thXS5sYWJlbCl9O2YucHJvdG90eXBlLnVuc3F1aXNoPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLmxhYmVscyxiPXRoaXMuaG9yaXosZT10aGlzLnRpY2tJbnRlcnZhbCxnPWUsaD10aGlzLmxlbi8oKCh0aGlzLmNhdGVnb3JpZXM/MTowKSt0aGlzLm1heC10aGlzLm1pbikvZSksZCxmPWEucm90YXRpb24sbT10aGlzLmxhYmVsTWV0cmljcygpLFxudyxuPU51bWJlci5NQVhfVkFMVUUscixsPU1hdGgubWF4KHRoaXMubWF4LXRoaXMubWluLDApLHE9ZnVuY3Rpb24oYSl7dmFyIGI9YS8oaHx8MSk7Yj0xPGI/TWF0aC5jZWlsKGIpOjE7YiplPmwmJkluZmluaXR5IT09YSYmSW5maW5pdHkhPT1oJiZsJiYoYj1NYXRoLmNlaWwobC9lKSk7cmV0dXJuIHkoYiplKX07Yj8ocj0hYS5zdGFnZ2VyTGluZXMmJiFhLnN0ZXAmJihjKGYpP1tmXTpoPEYoYS5hdXRvUm90YXRpb25MaW1pdCw4MCkmJmEuYXV0b1JvdGF0aW9uKSkmJnIuZm9yRWFjaChmdW5jdGlvbihhKXtpZihhPT09Znx8YSYmLTkwPD1hJiY5MD49YSl7dz1xKE1hdGguYWJzKG0uaC9NYXRoLnNpbih2KmEpKSk7dmFyIGI9dytNYXRoLmFicyhhLzM2MCk7YjxuJiYobj1iLGQ9YSxnPXcpfX0pOmEuc3RlcHx8KGc9cShtLmgpKTt0aGlzLmF1dG9Sb3RhdGlvbj1yO3RoaXMubGFiZWxSb3RhdGlvbj1GKGQsZik7cmV0dXJuIGd9O2YucHJvdG90eXBlLmdldFNsb3RXaWR0aD1mdW5jdGlvbihiKXt2YXIgZSxcbmM9dGhpcy5jaGFydCxnPXRoaXMuaG9yaXosaD10aGlzLm9wdGlvbnMubGFiZWxzLGQ9TWF0aC5tYXgodGhpcy50aWNrUG9zaXRpb25zLmxlbmd0aC0odGhpcy5jYXRlZ29yaWVzPzA6MSksMSkscD1jLm1hcmdpblszXTtpZihiJiZhKGIuc2xvdFdpZHRoKSlyZXR1cm4gYi5zbG90V2lkdGg7aWYoZyYmaCYmMj4oaC5zdGVwfHwwKSlyZXR1cm4gaC5yb3RhdGlvbj8wOih0aGlzLnN0YWdnZXJMaW5lc3x8MSkqdGhpcy5sZW4vZDtpZighZyl7Yj1udWxsPT09KGU9bnVsbD09PWh8fHZvaWQgMD09PWg/dm9pZCAwOmguc3R5bGUpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLndpZHRoO2lmKHZvaWQgMCE9PWIpcmV0dXJuIHBhcnNlSW50KGIsMTApO2lmKHApcmV0dXJuIHAtYy5zcGFjaW5nWzNdfXJldHVybi4zMypjLmNoYXJ0V2lkdGh9O2YucHJvdG90eXBlLnJlbmRlclVuc3F1aXNoPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxlPWEucmVuZGVyZXIsYz10aGlzLnRpY2tQb3NpdGlvbnMsZz1cbnRoaXMudGlja3MsaD10aGlzLm9wdGlvbnMubGFiZWxzLGQ9aCYmaC5zdHlsZXx8e30sZj10aGlzLmhvcml6LG09dGhpcy5nZXRTbG90V2lkdGgoKSx3PU1hdGgubWF4KDEsTWF0aC5yb3VuZChtLTIqKGgucGFkZGluZ3x8NSkpKSxuPXt9LHI9dGhpcy5sYWJlbE1ldHJpY3MoKSxsPWguc3R5bGUmJmguc3R5bGUudGV4dE92ZXJmbG93LHE9MDtiKGgucm90YXRpb24pfHwobi5yb3RhdGlvbj1oLnJvdGF0aW9ufHwwKTtjLmZvckVhY2goZnVuY3Rpb24oYSl7YT1nW2FdO2EubW92ZWRMYWJlbCYmYS5yZXBsYWNlTW92ZWRMYWJlbCgpO2EmJmEubGFiZWwmJmEubGFiZWwudGV4dFB4TGVuZ3RoPnEmJihxPWEubGFiZWwudGV4dFB4TGVuZ3RoKX0pO3RoaXMubWF4TGFiZWxMZW5ndGg9cTtpZih0aGlzLmF1dG9Sb3RhdGlvbilxPncmJnE+ci5oP24ucm90YXRpb249dGhpcy5sYWJlbFJvdGF0aW9uOnRoaXMubGFiZWxSb3RhdGlvbj0wO2Vsc2UgaWYobSl7dmFyIEo9dztpZighbCl7dmFyIEY9XCJjbGlwXCI7XG5mb3Iodz1jLmxlbmd0aDshZiYmdy0tOyl7dmFyIHY9Y1t3XTtpZih2PWdbdl0ubGFiZWwpdi5zdHlsZXMmJlwiZWxsaXBzaXNcIj09PXYuc3R5bGVzLnRleHRPdmVyZmxvdz92LmNzcyh7dGV4dE92ZXJmbG93OlwiY2xpcFwifSk6di50ZXh0UHhMZW5ndGg+bSYmdi5jc3Moe3dpZHRoOm0rXCJweFwifSksdi5nZXRCQm94KCkuaGVpZ2h0PnRoaXMubGVuL2MubGVuZ3RoLShyLmgtci5mKSYmKHYuc3BlY2lmaWNUZXh0T3ZlcmZsb3c9XCJlbGxpcHNpc1wiKX19fW4ucm90YXRpb24mJihKPXE+LjUqYS5jaGFydEhlaWdodD8uMzMqYS5jaGFydEhlaWdodDpxLGx8fChGPVwiZWxsaXBzaXNcIikpO2lmKHRoaXMubGFiZWxBbGlnbj1oLmFsaWdufHx0aGlzLmF1dG9MYWJlbEFsaWduKHRoaXMubGFiZWxSb3RhdGlvbikpbi5hbGlnbj10aGlzLmxhYmVsQWxpZ247Yy5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPShhPWdbYV0pJiZhLmxhYmVsLGU9ZC53aWR0aCxjPXt9O2ImJihiLmF0dHIobiksYS5zaG9ydGVuTGFiZWw/XG5hLnNob3J0ZW5MYWJlbCgpOkomJiFlJiZcIm5vd3JhcFwiIT09ZC53aGl0ZVNwYWNlJiYoSjxiLnRleHRQeExlbmd0aHx8XCJTUEFOXCI9PT1iLmVsZW1lbnQudGFnTmFtZSk/KGMud2lkdGg9SitcInB4XCIsbHx8KGMudGV4dE92ZXJmbG93PWIuc3BlY2lmaWNUZXh0T3ZlcmZsb3d8fEYpLGIuY3NzKGMpKTpiLnN0eWxlcyYmYi5zdHlsZXMud2lkdGgmJiFjLndpZHRoJiYhZSYmYi5jc3Moe3dpZHRoOm51bGx9KSxkZWxldGUgYi5zcGVjaWZpY1RleHRPdmVyZmxvdyxhLnJvdGF0aW9uPW4ucm90YXRpb24pfSx0aGlzKTt0aGlzLnRpY2tSb3RDb3JyPWUucm90Q29ycihyLmIsdGhpcy5sYWJlbFJvdGF0aW9ufHwwLDAhPT10aGlzLnNpZGUpfTtmLnByb3RvdHlwZS5oYXNEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VyaWVzLnNvbWUoZnVuY3Rpb24oYSl7cmV0dXJuIGEuaGFzRGF0YSgpfSl8fHRoaXMub3B0aW9ucy5zaG93RW1wdHkmJmModGhpcy5taW4pJiZjKHRoaXMubWF4KX07Zi5wcm90b3R5cGUuYWRkVGl0bGU9XG5mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LnJlbmRlcmVyLGU9dGhpcy5ob3JpeixjPXRoaXMub3Bwb3NpdGUsZz10aGlzLm9wdGlvbnMudGl0bGUsaCxkPXRoaXMuY2hhcnQuc3R5bGVkTW9kZTt0aGlzLmF4aXNUaXRsZXx8KChoPWcudGV4dEFsaWduKXx8KGg9KGU/e2xvdzpcImxlZnRcIixtaWRkbGU6XCJjZW50ZXJcIixoaWdoOlwicmlnaHRcIn06e2xvdzpjP1wicmlnaHRcIjpcImxlZnRcIixtaWRkbGU6XCJjZW50ZXJcIixoaWdoOmM/XCJsZWZ0XCI6XCJyaWdodFwifSlbZy5hbGlnbl0pLHRoaXMuYXhpc1RpdGxlPWIudGV4dChnLnRleHQsMCwwLGcudXNlSFRNTCkuYXR0cih7ekluZGV4Ojcscm90YXRpb246Zy5yb3RhdGlvbnx8MCxhbGlnbjpofSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWF4aXMtdGl0bGVcIiksZHx8dGhpcy5heGlzVGl0bGUuY3NzKHcoZy5zdHlsZSkpLHRoaXMuYXhpc1RpdGxlLmFkZCh0aGlzLmF4aXNHcm91cCksdGhpcy5heGlzVGl0bGUuaXNOZXc9ITApO2R8fGcuc3R5bGUud2lkdGh8fFxudGhpcy5pc1JhZGlhbHx8dGhpcy5heGlzVGl0bGUuY3NzKHt3aWR0aDp0aGlzLmxlbitcInB4XCJ9KTt0aGlzLmF4aXNUaXRsZVthP1wic2hvd1wiOlwiaGlkZVwiXShhKX07Zi5wcm90b3R5cGUuZ2VuZXJhdGVUaWNrPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMudGlja3M7YlthXT9iW2FdLmFkZExhYmVsKCk6YlthXT1uZXcgRyh0aGlzLGEpfTtmLnByb3RvdHlwZS5nZXRPZmZzZXQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcyxlPWIuY2hhcnQsZz1lLnJlbmRlcmVyLGg9Yi5vcHRpb25zLGQ9Yi50aWNrUG9zaXRpb25zLGY9Yi50aWNrcyxtPWIuaG9yaXosdz1iLnNpZGUsbj1lLmludmVydGVkJiYhYi5pc1pBeGlzP1sxLDAsMywyXVt3XTp3LHIsbD0wLHE9MCxKPWgudGl0bGUsdj1oLmxhYmVscyxOPTAsVj1lLmF4aXNPZmZzZXQ7ZT1lLmNsaXBPZmZzZXQ7dmFyIFo9Wy0xLDEsMSwtMV1bd10saz1oLmNsYXNzTmFtZSx0PWIuYXhpc1BhcmVudDt2YXIgeT1iLmhhc0RhdGEoKTtiLnNob3dBeGlzPVxucj15fHxGKGguc2hvd0VtcHR5LCEwKTtiLnN0YWdnZXJMaW5lcz1iLmhvcml6JiZ2LnN0YWdnZXJMaW5lcztpZighYi5heGlzR3JvdXApe3ZhciBBPWZ1bmN0aW9uKGIsZSxjKXtyZXR1cm4gZy5nKGIpLmF0dHIoe3pJbmRleDpjfSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLVwiK2EuY29sbC50b0xvd2VyQ2FzZSgpK2UrXCIgXCIrKGEuaXNSYWRpYWw/XCJoaWdoY2hhcnRzLXJhZGlhbC1heGlzXCIrZStcIiBcIjpcIlwiKSsoa3x8XCJcIikpLmFkZCh0KX07Yi5ncmlkR3JvdXA9QShcImdyaWRcIixcIi1ncmlkXCIsaC5ncmlkWkluZGV4fHwxKTtiLmF4aXNHcm91cD1BKFwiYXhpc1wiLFwiXCIsaC56SW5kZXh8fDIpO2IubGFiZWxHcm91cD1BKFwiYXhpcy1sYWJlbHNcIixcIi1sYWJlbHNcIix2LnpJbmRleHx8Nyl9eXx8Yi5pc0xpbmtlZD8oZC5mb3JFYWNoKGZ1bmN0aW9uKGEsZSl7Yi5nZW5lcmF0ZVRpY2soYSxlKX0pLGIucmVuZGVyVW5zcXVpc2goKSxiLnJlc2VydmVTcGFjZURlZmF1bHQ9MD09PXd8fDI9PT13fHx7MTpcImxlZnRcIixcbjM6XCJyaWdodFwifVt3XT09PWIubGFiZWxBbGlnbixGKHYucmVzZXJ2ZVNwYWNlLFwiY2VudGVyXCI9PT1iLmxhYmVsQWxpZ24/ITA6bnVsbCxiLnJlc2VydmVTcGFjZURlZmF1bHQpJiZkLmZvckVhY2goZnVuY3Rpb24oYSl7Tj1NYXRoLm1heChmW2FdLmdldExhYmVsU2l6ZSgpLE4pfSksYi5zdGFnZ2VyTGluZXMmJihOKj1iLnN0YWdnZXJMaW5lcyksYi5sYWJlbE9mZnNldD1OKihiLm9wcG9zaXRlPy0xOjEpKTpPKGYsZnVuY3Rpb24oYSxiKXthLmRlc3Ryb3koKTtkZWxldGUgZltiXX0pO2lmKEomJkoudGV4dCYmITEhPT1KLmVuYWJsZWQmJihiLmFkZFRpdGxlKHIpLHImJiExIT09Si5yZXNlcnZlU3BhY2UpKXtiLnRpdGxlT2Zmc2V0PWw9Yi5heGlzVGl0bGUuZ2V0QkJveCgpW20/XCJoZWlnaHRcIjpcIndpZHRoXCJdO3ZhciBSPUoub2Zmc2V0O3E9YyhSKT8wOkYoSi5tYXJnaW4sbT81OjEwKX1iLnJlbmRlckxpbmUoKTtiLm9mZnNldD1aKkYoaC5vZmZzZXQsVlt3XT9WW3ddKyhoLm1hcmdpbnx8XG4wKTowKTtiLnRpY2tSb3RDb3JyPWIudGlja1JvdENvcnJ8fHt4OjAseTowfTtKPTA9PT13Py1iLmxhYmVsTWV0cmljcygpLmg6Mj09PXc/Yi50aWNrUm90Q29yci55OjA7cT1NYXRoLmFicyhOKStxO04mJihxPXEtSitaKihtP0Yodi55LGIudGlja1JvdENvcnIueSs4KlopOnYueCkpO2IuYXhpc1RpdGxlTWFyZ2luPUYoUixxKTtiLmdldE1heExhYmVsRGltZW5zaW9ucyYmKGIubWF4TGFiZWxEaW1lbnNpb25zPWIuZ2V0TWF4TGFiZWxEaW1lbnNpb25zKGYsZCkpO209dGhpcy50aWNrU2l6ZShcInRpY2tcIik7Vlt3XT1NYXRoLm1heChWW3ddLGIuYXhpc1RpdGxlTWFyZ2luK2wrWipiLm9mZnNldCxxLGQmJmQubGVuZ3RoJiZtP21bMF0rWipiLm9mZnNldDowKTtoPWgub2Zmc2V0PzA6MipNYXRoLmZsb29yKGIuYXhpc0xpbmUuc3Ryb2tlV2lkdGgoKS8yKTtlW25dPU1hdGgubWF4KGVbbl0saCk7eih0aGlzLFwiYWZ0ZXJHZXRPZmZzZXRcIil9O2YucHJvdG90eXBlLmdldExpbmVQYXRoPWZ1bmN0aW9uKGEpe3ZhciBiPVxudGhpcy5jaGFydCxlPXRoaXMub3Bwb3NpdGUsYz10aGlzLm9mZnNldCxnPXRoaXMuaG9yaXosaD10aGlzLmxlZnQrKGU/dGhpcy53aWR0aDowKStjO2M9Yi5jaGFydEhlaWdodC10aGlzLmJvdHRvbS0oZT90aGlzLmhlaWdodDowKStjO2UmJihhKj0tMSk7cmV0dXJuIGIucmVuZGVyZXIuY3Jpc3BMaW5lKFtbXCJNXCIsZz90aGlzLmxlZnQ6aCxnP2M6dGhpcy50b3BdLFtcIkxcIixnP2IuY2hhcnRXaWR0aC10aGlzLnJpZ2h0OmgsZz9jOmIuY2hhcnRIZWlnaHQtdGhpcy5ib3R0b21dXSxhKX07Zi5wcm90b3R5cGUucmVuZGVyTGluZT1mdW5jdGlvbigpe3RoaXMuYXhpc0xpbmV8fCh0aGlzLmF4aXNMaW5lPXRoaXMuY2hhcnQucmVuZGVyZXIucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1heGlzLWxpbmVcIikuYWRkKHRoaXMuYXhpc0dyb3VwKSx0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fHRoaXMuYXhpc0xpbmUuYXR0cih7c3Ryb2tlOnRoaXMub3B0aW9ucy5saW5lQ29sb3IsXCJzdHJva2Utd2lkdGhcIjp0aGlzLm9wdGlvbnMubGluZVdpZHRoLFxuekluZGV4Ojd9KSl9O2YucHJvdG90eXBlLmdldFRpdGxlUG9zaXRpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmhvcml6LGI9dGhpcy5sZWZ0LGU9dGhpcy50b3AsYz10aGlzLmxlbixnPXRoaXMub3B0aW9ucy50aXRsZSxoPWE/YjplLGQ9dGhpcy5vcHBvc2l0ZSxmPXRoaXMub2Zmc2V0LG09Zy54fHwwLHc9Zy55fHwwLG49dGhpcy5heGlzVGl0bGUscj10aGlzLmNoYXJ0LnJlbmRlcmVyLmZvbnRNZXRyaWNzKGcuc3R5bGUmJmcuc3R5bGUuZm9udFNpemUsbik7bj1NYXRoLm1heChuLmdldEJCb3gobnVsbCwwKS5oZWlnaHQtci5oLTEsMCk7Yz17bG93OmgrKGE/MDpjKSxtaWRkbGU6aCtjLzIsaGlnaDpoKyhhP2M6MCl9W2cuYWxpZ25dO2I9KGE/ZSt0aGlzLmhlaWdodDpiKSsoYT8xOi0xKSooZD8tMToxKSp0aGlzLmF4aXNUaXRsZU1hcmdpbitbLW4sbixyLmYsLW5dW3RoaXMuc2lkZV07YT17eDphP2MrbTpiKyhkP3RoaXMud2lkdGg6MCkrZittLHk6YT9iK3ctKGQ/dGhpcy5oZWlnaHQ6XG4wKStmOmMrd307eih0aGlzLFwiYWZ0ZXJHZXRUaXRsZVBvc2l0aW9uXCIse3RpdGxlUG9zaXRpb246YX0pO3JldHVybiBhfTtmLnByb3RvdHlwZS5yZW5kZXJNaW5vclRpY2s9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydC5oYXNSZW5kZXJlZCYmdGhpcy5vbGQsZT10aGlzLm1pbm9yVGlja3M7ZVthXXx8KGVbYV09bmV3IEcodGhpcyxhLFwibWlub3JcIikpO2ImJmVbYV0uaXNOZXcmJmVbYV0ucmVuZGVyKG51bGwsITApO2VbYV0ucmVuZGVyKG51bGwsITEsMSl9O2YucHJvdG90eXBlLnJlbmRlclRpY2s9ZnVuY3Rpb24oYSxiKXt2YXIgZSxjPXRoaXMudGlja3MsZz10aGlzLmNoYXJ0Lmhhc1JlbmRlcmVkJiZ0aGlzLm9sZDtpZighdGhpcy5pc0xpbmtlZHx8YT49dGhpcy5taW4mJmE8PXRoaXMubWF4fHwobnVsbD09PShlPXRoaXMuZ3JpZCl8fHZvaWQgMD09PWU/MDplLmlzQ29sdW1uKSljW2FdfHwoY1thXT1uZXcgRyh0aGlzLGEpKSxnJiZjW2FdLmlzTmV3JiZjW2FdLnJlbmRlcihiLFxuITAsLTEpLGNbYV0ucmVuZGVyKGIpfTtmLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLGU9Yi5jaGFydCxjPWIubG9nYXJpdGhtaWMsZz1iLm9wdGlvbnMsaD1iLmlzTGlua2VkLGQ9Yi50aWNrUG9zaXRpb25zLGY9Yi5heGlzVGl0bGUsbT1iLnRpY2tzLHc9Yi5taW5vclRpY2tzLG49Yi5hbHRlcm5hdGVCYW5kcyxyPWcuc3RhY2tMYWJlbHMscT1nLmFsdGVybmF0ZUdyaWRDb2xvcixsPWIudGlja21hcmtPZmZzZXQsSj1iLmF4aXNMaW5lLEY9Yi5zaG93QXhpcyx2PUgoZS5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24pLFYsTjtiLmxhYmVsRWRnZS5sZW5ndGg9MDtiLm92ZXJsYXA9ITE7W20sdyxuXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe08oYSxmdW5jdGlvbihhKXthLmlzQWN0aXZlPSExfSl9KTtpZihiLmhhc0RhdGEoKXx8aCliLm1pbm9yVGlja0ludGVydmFsJiYhYi5jYXRlZ29yaWVzJiZiLmdldE1pbm9yVGlja1Bvc2l0aW9ucygpLmZvckVhY2goZnVuY3Rpb24oYSl7Yi5yZW5kZXJNaW5vclRpY2soYSl9KSxcbmQubGVuZ3RoJiYoZC5mb3JFYWNoKGZ1bmN0aW9uKGEsZSl7Yi5yZW5kZXJUaWNrKGEsZSl9KSxsJiYoMD09PWIubWlufHxiLnNpbmdsZSkmJihtWy0xXXx8KG1bLTFdPW5ldyBHKGIsLTEsbnVsbCwhMCkpLG1bLTFdLnJlbmRlcigtMSkpKSxxJiZkLmZvckVhY2goZnVuY3Rpb24oYSxnKXtOPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgZFtnKzFdP2RbZysxXStsOmIubWF4LWw7MD09PWclMiYmYTxiLm1heCYmTjw9Yi5tYXgrKGUucG9sYXI/LWw6bCkmJihuW2FdfHwoblthXT1uZXcgay5QbG90TGluZU9yQmFuZChiKSksVj1hK2wsblthXS5vcHRpb25zPXtmcm9tOmM/Yy5saW4ybG9nKFYpOlYsdG86Yz9jLmxpbjJsb2coTik6Tixjb2xvcjpxLGNsYXNzTmFtZTpcImhpZ2hjaGFydHMtYWx0ZXJuYXRlLWdyaWRcIn0sblthXS5yZW5kZXIoKSxuW2FdLmlzQWN0aXZlPSEwKX0pLGIuX2FkZGVkUGxvdExCfHwoYi5fYWRkZWRQbG90TEI9ITAsKGcucGxvdExpbmVzfHxbXSkuY29uY2F0KGcucGxvdEJhbmRzfHxcbltdKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2IuYWRkUGxvdEJhbmRPckxpbmUoYSl9KSk7W20sdyxuXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiLGM9W10sZz12LmR1cmF0aW9uO08oYSxmdW5jdGlvbihhLGIpe2EuaXNBY3RpdmV8fChhLnJlbmRlcihiLCExLDApLGEuaXNBY3RpdmU9ITEsYy5wdXNoKGIpKX0pO1QoZnVuY3Rpb24oKXtmb3IoYj1jLmxlbmd0aDtiLS07KWFbY1tiXV0mJiFhW2NbYl1dLmlzQWN0aXZlJiYoYVtjW2JdXS5kZXN0cm95KCksZGVsZXRlIGFbY1tiXV0pfSxhIT09biYmZS5oYXNSZW5kZXJlZCYmZz9nOjApfSk7SiYmKEpbSi5pc1BsYWNlZD9cImFuaW1hdGVcIjpcImF0dHJcIl0oe2Q6dGhpcy5nZXRMaW5lUGF0aChKLnN0cm9rZVdpZHRoKCkpfSksSi5pc1BsYWNlZD0hMCxKW0Y/XCJzaG93XCI6XCJoaWRlXCJdKEYpKTtmJiZGJiYoZz1iLmdldFRpdGxlUG9zaXRpb24oKSxhKGcueSk/KGZbZi5pc05ldz9cImF0dHJcIjpcImFuaW1hdGVcIl0oZyksZi5pc05ldz0hMSk6KGYuYXR0cihcInlcIixcbi05OTk5KSxmLmlzTmV3PSEwKSk7ciYmci5lbmFibGVkJiZiLnN0YWNraW5nJiZiLnN0YWNraW5nLnJlbmRlclN0YWNrVG90YWxzKCk7Yi5vbGQ9e2xlbjpiLmxlbixtYXg6Yi5tYXgsbWluOmIubWluLHRyYW5zQTpiLnRyYW5zQSx1c2VyTWF4OmIudXNlck1heCx1c2VyTWluOmIudXNlck1pbn07Yi5pc0RpcnR5PSExO3oodGhpcyxcImFmdGVyUmVuZGVyXCIpfTtmLnByb3RvdHlwZS5yZWRyYXc9ZnVuY3Rpb24oKXt0aGlzLnZpc2libGUmJih0aGlzLnJlbmRlcigpLHRoaXMucGxvdExpbmVzQW5kQmFuZHMuZm9yRWFjaChmdW5jdGlvbihhKXthLnJlbmRlcigpfSkpO3RoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYSl7YS5pc0RpcnR5PSEwfSl9O2YucHJvdG90eXBlLmdldEtlZXBQcm9wcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLmtlZXBQcm9wc3x8Zi5rZWVwUHJvcHN9O2YucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxlPWIucGxvdExpbmVzQW5kQmFuZHMsXG5jO3oodGhpcyxcImRlc3Ryb3lcIix7a2VlcEV2ZW50czphfSk7YXx8UihiKTtbYi50aWNrcyxiLm1pbm9yVGlja3MsYi5hbHRlcm5hdGVCYW5kc10uZm9yRWFjaChmdW5jdGlvbihhKXtxKGEpfSk7aWYoZSlmb3IoYT1lLmxlbmd0aDthLS07KWVbYV0uZGVzdHJveSgpO1wiYXhpc0xpbmUgYXhpc1RpdGxlIGF4aXNHcm91cCBncmlkR3JvdXAgbGFiZWxHcm91cCBjcm9zcyBzY3JvbGxiYXJcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXtiW2FdJiYoYlthXT1iW2FdLmRlc3Ryb3koKSl9KTtmb3IoYyBpbiBiLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzKWIucGxvdExpbmVzQW5kQmFuZHNHcm91cHNbY109Yi5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1tjXS5kZXN0cm95KCk7TyhiLGZ1bmN0aW9uKGEsZSl7LTE9PT1iLmdldEtlZXBQcm9wcygpLmluZGV4T2YoZSkmJmRlbGV0ZSBiW2VdfSl9O2YucHJvdG90eXBlLmRyYXdDcm9zc2hhaXI9ZnVuY3Rpb24oYSxiKXt2YXIgZT10aGlzLmNyb3NzaGFpcixcbmc9RihlLnNuYXAsITApLGgsZj10aGlzLmNyb3NzLG09dGhpcy5jaGFydDt6KHRoaXMsXCJkcmF3Q3Jvc3NoYWlyXCIse2U6YSxwb2ludDpifSk7YXx8KGE9dGhpcy5jcm9zcyYmdGhpcy5jcm9zcy5lKTtpZih0aGlzLmNyb3NzaGFpciYmITEhPT0oYyhiKXx8IWcpKXtnP2MoYikmJihoPUYoXCJjb2xvckF4aXNcIiE9PXRoaXMuY29sbD9iLmNyb3NzaGFpclBvczpudWxsLHRoaXMuaXNYQXhpcz9iLnBsb3RYOnRoaXMubGVuLWIucGxvdFkpKTpoPWEmJih0aGlzLmhvcml6P2EuY2hhcnRYLXRoaXMucG9zOnRoaXMubGVuLWEuY2hhcnRZK3RoaXMucG9zKTtpZihjKGgpKXt2YXIgcD17dmFsdWU6YiYmKHRoaXMuaXNYQXhpcz9iLng6RihiLnN0YWNrWSxiLnkpKSx0cmFuc2xhdGVkVmFsdWU6aH07bS5wb2xhciYmTShwLHtpc0Nyb3NzaGFpcjohMCxjaGFydFg6YSYmYS5jaGFydFgsY2hhcnRZOmEmJmEuY2hhcnRZLHBvaW50OmJ9KTtwPXRoaXMuZ2V0UGxvdExpbmVQYXRoKHApfHxudWxsfWlmKCFjKHApKXt0aGlzLmhpZGVDcm9zc2hhaXIoKTtcbnJldHVybn1nPXRoaXMuY2F0ZWdvcmllcyYmIXRoaXMuaXNSYWRpYWw7Znx8KHRoaXMuY3Jvc3M9Zj1tLnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtY3Jvc3NoYWlyIGhpZ2hjaGFydHMtY3Jvc3NoYWlyLVwiKyhnP1wiY2F0ZWdvcnkgXCI6XCJ0aGluIFwiKStlLmNsYXNzTmFtZSkuYXR0cih7ekluZGV4OkYoZS56SW5kZXgsMil9KS5hZGQoKSxtLnN0eWxlZE1vZGV8fChmLmF0dHIoe3N0cm9rZTplLmNvbG9yfHwoZz9kLnBhcnNlKHguaGlnaGxpZ2h0Q29sb3IyMCkuc2V0T3BhY2l0eSguMjUpLmdldCgpOngubmV1dHJhbENvbG9yMjApLFwic3Ryb2tlLXdpZHRoXCI6RihlLndpZHRoLDEpfSkuY3NzKHtcInBvaW50ZXItZXZlbnRzXCI6XCJub25lXCJ9KSxlLmRhc2hTdHlsZSYmZi5hdHRyKHtkYXNoc3R5bGU6ZS5kYXNoU3R5bGV9KSkpO2Yuc2hvdygpLmF0dHIoe2Q6cH0pO2cmJiFlLndpZHRoJiZmLmF0dHIoe1wic3Ryb2tlLXdpZHRoXCI6dGhpcy50cmFuc0F9KTt0aGlzLmNyb3NzLmU9XG5hfWVsc2UgdGhpcy5oaWRlQ3Jvc3NoYWlyKCk7eih0aGlzLFwiYWZ0ZXJEcmF3Q3Jvc3NoYWlyXCIse2U6YSxwb2ludDpifSl9O2YucHJvdG90eXBlLmhpZGVDcm9zc2hhaXI9ZnVuY3Rpb24oKXt0aGlzLmNyb3NzJiZ0aGlzLmNyb3NzLmhpZGUoKTt6KHRoaXMsXCJhZnRlckhpZGVDcm9zc2hhaXJcIil9O2YucHJvdG90eXBlLmhhc1ZlcnRpY2FsUGFubmluZz1mdW5jdGlvbigpe3ZhciBhLGI9bnVsbD09PShhPXRoaXMuY2hhcnQub3B0aW9ucy5jaGFydCl8fHZvaWQgMD09PWE/dm9pZCAwOmEucGFubmluZztyZXR1cm4hIShiJiZiLmVuYWJsZWQmJi95Ly50ZXN0KGIudHlwZSkpfTtmLnByb3RvdHlwZS52YWxpZGF0ZVBvc2l0aXZlVmFsdWU9ZnVuY3Rpb24oYil7cmV0dXJuIGEoYikmJjA8Yn07Zi5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYil7dmFyIGU9dGhpcy5jaGFydCxjPWEmJmEuZXZlbnRzfHx7fTthPXcodGhpcy51c2VyT3B0aW9ucyxhKTtlLm9wdGlvbnNbdGhpcy5jb2xsXS5pbmRleE9mJiZcbihlLm9wdGlvbnNbdGhpcy5jb2xsXVtlLm9wdGlvbnNbdGhpcy5jb2xsXS5pbmRleE9mKHRoaXMudXNlck9wdGlvbnMpXT1hKTtPKGUub3B0aW9uc1t0aGlzLmNvbGxdLmV2ZW50cyxmdW5jdGlvbihhLGIpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgY1tiXSYmKGNbYl09dm9pZCAwKX0pO3RoaXMuZGVzdHJveSghMCk7dGhpcy5pbml0KGUsTShhLHtldmVudHM6Y30pKTtlLmlzRGlydHlCb3g9ITA7RihiLCEwKSYmZS5yZWRyYXcoKX07Zi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy5jb2xsLGc9dGhpcy5zZXJpZXMsaD1nLmxlbmd0aDtoLS07KWdbaF0mJmdbaF0ucmVtb3ZlKCExKTtuKGIuYXhlcyx0aGlzKTtuKGJbY10sdGhpcyk7ZShiLm9wdGlvbnNbY10pP2Iub3B0aW9uc1tjXS5zcGxpY2UodGhpcy5vcHRpb25zLmluZGV4LDEpOmRlbGV0ZSBiLm9wdGlvbnNbY107YltjXS5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7YS5vcHRpb25zLmluZGV4PVxuYS51c2VyT3B0aW9ucy5pbmRleD1ifSk7dGhpcy5kZXN0cm95KCk7Yi5pc0RpcnR5Qm94PSEwO0YoYSwhMCkmJmIucmVkcmF3KCl9O2YucHJvdG90eXBlLnNldFRpdGxlPWZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGUoe3RpdGxlOmF9LGIpfTtmLnByb3RvdHlwZS5zZXRDYXRlZ29yaWVzPWZ1bmN0aW9uKGEsYil7dGhpcy51cGRhdGUoe2NhdGVnb3JpZXM6YX0sYil9O2YuZGVmYXVsdE9wdGlvbnM9e2RhdGVUaW1lTGFiZWxGb3JtYXRzOnttaWxsaXNlY29uZDp7bWFpbjpcIiVIOiVNOiVTLiVMXCIscmFuZ2U6ITF9LHNlY29uZDp7bWFpbjpcIiVIOiVNOiVTXCIscmFuZ2U6ITF9LG1pbnV0ZTp7bWFpbjpcIiVIOiVNXCIscmFuZ2U6ITF9LGhvdXI6e21haW46XCIlSDolTVwiLHJhbmdlOiExfSxkYXk6e21haW46XCIlZS4gJWJcIn0sd2Vlazp7bWFpbjpcIiVlLiAlYlwifSxtb250aDp7bWFpbjpcIiViICcleVwifSx5ZWFyOnttYWluOlwiJVlcIn19LGVuZE9uVGljazohMSxsYWJlbHM6e2VuYWJsZWQ6ITAsaW5kZW50YXRpb246MTAsXG54OjAsc3R5bGU6e2NvbG9yOngubmV1dHJhbENvbG9yNjAsY3Vyc29yOlwiZGVmYXVsdFwiLGZvbnRTaXplOlwiMTFweFwifX0sbWF4UGFkZGluZzouMDEsbWlub3JUaWNrTGVuZ3RoOjIsbWlub3JUaWNrUG9zaXRpb246XCJvdXRzaWRlXCIsbWluUGFkZGluZzouMDEsc2hvd0VtcHR5OiEwLHN0YXJ0T2ZXZWVrOjEsc3RhcnRPblRpY2s6ITEsdGlja0xlbmd0aDoxMCx0aWNrUGl4ZWxJbnRlcnZhbDoxMDAsdGlja21hcmtQbGFjZW1lbnQ6XCJiZXR3ZWVuXCIsdGlja1Bvc2l0aW9uOlwib3V0c2lkZVwiLHRpdGxlOnthbGlnbjpcIm1pZGRsZVwiLHN0eWxlOntjb2xvcjp4Lm5ldXRyYWxDb2xvcjYwfX0sdHlwZTpcImxpbmVhclwiLG1pbm9yR3JpZExpbmVDb2xvcjp4Lm5ldXRyYWxDb2xvcjUsbWlub3JHcmlkTGluZVdpZHRoOjEsbWlub3JUaWNrQ29sb3I6eC5uZXV0cmFsQ29sb3I0MCxsaW5lQ29sb3I6eC5oaWdobGlnaHRDb2xvcjIwLGxpbmVXaWR0aDoxLGdyaWRMaW5lQ29sb3I6eC5uZXV0cmFsQ29sb3IxMCxcbnRpY2tDb2xvcjp4LmhpZ2hsaWdodENvbG9yMjB9O2YuZGVmYXVsdFlBeGlzT3B0aW9ucz17ZW5kT25UaWNrOiEwLG1heFBhZGRpbmc6LjA1LG1pblBhZGRpbmc6LjA1LHRpY2tQaXhlbEludGVydmFsOjcyLHNob3dMYXN0TGFiZWw6ITAsbGFiZWxzOnt4Oi04fSxzdGFydE9uVGljazohMCx0aXRsZTp7cm90YXRpb246MjcwLHRleHQ6XCJWYWx1ZXNcIn0sc3RhY2tMYWJlbHM6e2FuaW1hdGlvbjp7fSxhbGxvd092ZXJsYXA6ITEsZW5hYmxlZDohMSxjcm9wOiEwLG92ZXJmbG93OlwianVzdGlmeVwiLGZvcm1hdHRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuYXhpcy5jaGFydC5udW1iZXJGb3JtYXR0ZXI7cmV0dXJuIGEodGhpcy50b3RhbCwtMSl9LHN0eWxlOntjb2xvcjp4Lm5ldXRyYWxDb2xvcjEwMCxmb250U2l6ZTpcIjExcHhcIixmb250V2VpZ2h0OlwiYm9sZFwiLHRleHRPdXRsaW5lOlwiMXB4IGNvbnRyYXN0XCJ9fSxncmlkTGluZVdpZHRoOjEsbGluZVdpZHRoOjB9O2YuZGVmYXVsdExlZnRBeGlzT3B0aW9ucz1cbntsYWJlbHM6e3g6LTE1fSx0aXRsZTp7cm90YXRpb246MjcwfX07Zi5kZWZhdWx0UmlnaHRBeGlzT3B0aW9ucz17bGFiZWxzOnt4OjE1fSx0aXRsZTp7cm90YXRpb246OTB9fTtmLmRlZmF1bHRCb3R0b21BeGlzT3B0aW9ucz17bGFiZWxzOnthdXRvUm90YXRpb246Wy00NV0seDowfSxtYXJnaW46MTUsdGl0bGU6e3JvdGF0aW9uOjB9fTtmLmRlZmF1bHRUb3BBeGlzT3B0aW9ucz17bGFiZWxzOnthdXRvUm90YXRpb246Wy00NV0seDowfSxtYXJnaW46MTUsdGl0bGU6e3JvdGF0aW9uOjB9fTtmLmtlZXBQcm9wcz1cImV4dEtleSBoY0V2ZW50cyBuYW1lcyBzZXJpZXMgdXNlck1heCB1c2VyTWluXCIuc3BsaXQoXCIgXCIpO3JldHVybiBmfSgpO2suQXhpcz1mO3JldHVybiBrLkF4aXN9KTtQKGssXCJDb3JlL0F4aXMvRGF0ZVRpbWVBeGlzLmpzXCIsW2tbXCJDb3JlL0F4aXMvQXhpcy5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCl7dmFyIGs9ZC5hZGRFdmVudCx4PWQuZ2V0TWFnbml0dWRlLFxuQj1kLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbCxHPWQudGltZVVuaXRzLEQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKGQpe3RoaXMuYXhpcz1kfWQucHJvdG90eXBlLm5vcm1hbGl6ZVRpbWVUaWNrSW50ZXJ2YWw9ZnVuY3Rpb24oZCxmKXt2YXIgbD1mfHxbW1wibWlsbGlzZWNvbmRcIixbMSwyLDUsMTAsMjAsMjUsNTAsMTAwLDIwMCw1MDBdXSxbXCJzZWNvbmRcIixbMSwyLDUsMTAsMTUsMzBdXSxbXCJtaW51dGVcIixbMSwyLDUsMTAsMTUsMzBdXSxbXCJob3VyXCIsWzEsMiwzLDQsNiw4LDEyXV0sW1wiZGF5XCIsWzEsMl1dLFtcIndlZWtcIixbMSwyXV0sW1wibW9udGhcIixbMSwyLDMsNCw2XV0sW1wieWVhclwiLG51bGxdXTtmPWxbbC5sZW5ndGgtMV07dmFyIGs9R1tmWzBdXSxnPWZbMV0sdDtmb3IodD0wO3Q8bC5sZW5ndGgmJiEoZj1sW3RdLGs9R1tmWzBdXSxnPWZbMV0sbFt0KzFdJiZkPD0oaypnW2cubGVuZ3RoLTFdK0dbbFt0KzFdWzBdXSkvMik7dCsrKTtrPT09Ry55ZWFyJiZkPDUqayYmKGc9WzEsMiw1XSk7XG5kPUIoZC9rLGcsXCJ5ZWFyXCI9PT1mWzBdP01hdGgubWF4KHgoZC9rKSwxKToxKTtyZXR1cm57dW5pdFJhbmdlOmssY291bnQ6ZCx1bml0TmFtZTpmWzBdfX07cmV0dXJuIGR9KCk7ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGQoKXt9ZC5jb21wb3NlPWZ1bmN0aW9uKGQpe2Qua2VlcFByb3BzLnB1c2goXCJkYXRlVGltZVwiKTtkLnByb3RvdHlwZS5nZXRUaW1lVGlja3M9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFydC50aW1lLmdldFRpbWVUaWNrcy5hcHBseSh0aGlzLmNoYXJ0LnRpbWUsYXJndW1lbnRzKX07ayhkLFwiaW5pdFwiLGZ1bmN0aW9uKGQpe1wiZGF0ZXRpbWVcIiE9PWQudXNlck9wdGlvbnMudHlwZT90aGlzLmRhdGVUaW1lPXZvaWQgMDp0aGlzLmRhdGVUaW1lfHwodGhpcy5kYXRlVGltZT1uZXcgRCh0aGlzKSl9KX07ZC5BZGRpdGlvbnNDbGFzcz1EO3JldHVybiBkfSgpO2QuY29tcG9zZShmKTtyZXR1cm4gZH0pO1AoayxcIkNvcmUvQXhpcy9Mb2dhcml0aG1pY0F4aXMuanNcIixba1tcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLFxua1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQpe3ZhciBrPWQuYWRkRXZlbnQseD1kLmdldE1hZ25pdHVkZSxCPWQubm9ybWFsaXplVGlja0ludGVydmFsLEc9ZC5waWNrLEQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKGQpe3RoaXMuYXhpcz1kfWQucHJvdG90eXBlLmdldExvZ1RpY2tQb3NpdGlvbnM9ZnVuY3Rpb24oZCxmLGwsayl7dmFyIGc9dGhpcy5heGlzLHk9Zy5sZW4sYz1nLm9wdGlvbnMscT1bXTtrfHwodGhpcy5taW5vckF1dG9JbnRlcnZhbD12b2lkIDApO2lmKC41PD1kKWQ9TWF0aC5yb3VuZChkKSxxPWcuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhkLGYsbCk7ZWxzZSBpZiguMDg8PWQpe2M9TWF0aC5mbG9vcihmKTt2YXIgbixBO2Zvcih5PS4zPGQ/WzEsMiw0XTouMTU8ZD9bMSwyLDQsNiw4XTpbMSwyLDMsNCw1LDYsNyw4LDldO2M8bCsxJiYhQTtjKyspe3ZhciB0PXkubGVuZ3RoO2ZvcihuPTA7bjx0JiYhQTtuKyspe3ZhciB6PXRoaXMubG9nMmxpbih0aGlzLmxpbjJsb2coYykqXG55W25dKTt6PmYmJigha3x8bTw9bCkmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgbSYmcS5wdXNoKG0pO20+bCYmKEE9ITApO3ZhciBtPXp9fX1lbHNlIGY9dGhpcy5saW4ybG9nKGYpLGw9dGhpcy5saW4ybG9nKGwpLGQ9az9nLmdldE1pbm9yVGlja0ludGVydmFsKCk6Yy50aWNrSW50ZXJ2YWwsZD1HKFwiYXV0b1wiPT09ZD9udWxsOmQsdGhpcy5taW5vckF1dG9JbnRlcnZhbCxjLnRpY2tQaXhlbEludGVydmFsLyhrPzU6MSkqKGwtZikvKChrP3kvZy50aWNrUG9zaXRpb25zLmxlbmd0aDp5KXx8MSkpLGQ9QihkLHZvaWQgMCx4KGQpKSxxPWcuZ2V0TGluZWFyVGlja1Bvc2l0aW9ucyhkLGYsbCkubWFwKHRoaXMubG9nMmxpbiksa3x8KHRoaXMubWlub3JBdXRvSW50ZXJ2YWw9ZC81KTtrfHwoZy50aWNrSW50ZXJ2YWw9ZCk7cmV0dXJuIHF9O2QucHJvdG90eXBlLmxpbjJsb2c9ZnVuY3Rpb24oZCl7cmV0dXJuIE1hdGgucG93KDEwLGQpfTtkLnByb3RvdHlwZS5sb2cybGluPWZ1bmN0aW9uKGQpe3JldHVybiBNYXRoLmxvZyhkKS9cbk1hdGguTE4xMH07cmV0dXJuIGR9KCk7ZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGQoKXt9ZC5jb21wb3NlPWZ1bmN0aW9uKGQpe2Qua2VlcFByb3BzLnB1c2goXCJsb2dhcml0aG1pY1wiKTtrKGQsXCJpbml0XCIsZnVuY3Rpb24oZCl7dmFyIGY9dGhpcy5sb2dhcml0aG1pYztcImxvZ2FyaXRobWljXCIhPT1kLnVzZXJPcHRpb25zLnR5cGU/dGhpcy5sb2dhcml0aG1pYz12b2lkIDA6Znx8KHRoaXMubG9nYXJpdGhtaWM9bmV3IEQodGhpcykpfSk7ayhkLFwiYWZ0ZXJJbml0XCIsZnVuY3Rpb24oKXt2YXIgZD10aGlzLmxvZ2FyaXRobWljO2QmJih0aGlzLmxpbjJ2YWw9ZnVuY3Rpb24oZil7cmV0dXJuIGQubGluMmxvZyhmKX0sdGhpcy52YWwybGluPWZ1bmN0aW9uKGYpe3JldHVybiBkLmxvZzJsaW4oZil9KX0pfTtyZXR1cm4gZH0oKTtkLmNvbXBvc2UoZik7cmV0dXJuIGR9KTtQKGssXCJDb3JlL0F4aXMvUGxvdExpbmVPckJhbmQuanNcIixba1tcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sXG5rW1wiQ29yZS9Db2xvci9QYWxldHRlLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCl7dmFyIEI9eC5hcnJheU1heCxHPXguYXJyYXlNaW4sRD14LmRlZmluZWQsSD14LmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLHQ9eC5lcmFzZSxDPXguZXh0ZW5kLGw9eC5maXJlRXZlbnQsRT14Lm1lcmdlLGc9eC5vYmplY3RFYWNoLHk9eC5waWNrO3g9ZnVuY3Rpb24oKXtmdW5jdGlvbiBjKGMsZyl7dGhpcy5heGlzPWM7ZyYmKHRoaXMub3B0aW9ucz1nLHRoaXMuaWQ9Zy5pZCl9Yy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7bCh0aGlzLFwicmVuZGVyXCIpO3ZhciBjPXRoaXMsZD1jLmF4aXMsZj1kLmhvcml6LHQ9ZC5sb2dhcml0aG1pYyx6PWMub3B0aW9ucyxtPXoubGFiZWwscj1jLmxhYmVsLGU9ei50byxoPXouZnJvbSxhPXoudmFsdWUsYj1EKGgpJiZEKGUpLHc9RChhKSxKPWMuc3ZnRWxlbSxPPSFKLEY9W10sTj16LmNvbG9yLFI9eSh6LnpJbmRleCwwKSxcblE9ei5ldmVudHM7Rj17XCJjbGFzc1wiOlwiaGlnaGNoYXJ0cy1wbG90LVwiKyhiP1wiYmFuZCBcIjpcImxpbmUgXCIpKyh6LmNsYXNzTmFtZXx8XCJcIil9O3ZhciBDPXt9LHY9ZC5jaGFydC5yZW5kZXJlcix4PWI/XCJiYW5kc1wiOlwibGluZXNcIjt0JiYoaD10LmxvZzJsaW4oaCksZT10LmxvZzJsaW4oZSksYT10LmxvZzJsaW4oYSkpO2QuY2hhcnQuc3R5bGVkTW9kZXx8KHc/KEYuc3Ryb2tlPU58fGsubmV1dHJhbENvbG9yNDAsRltcInN0cm9rZS13aWR0aFwiXT15KHoud2lkdGgsMSksei5kYXNoU3R5bGUmJihGLmRhc2hzdHlsZT16LmRhc2hTdHlsZSkpOmImJihGLmZpbGw9Tnx8ay5oaWdobGlnaHRDb2xvcjEwLHouYm9yZGVyV2lkdGgmJihGLnN0cm9rZT16LmJvcmRlckNvbG9yLEZbXCJzdHJva2Utd2lkdGhcIl09ei5ib3JkZXJXaWR0aCkpKTtDLnpJbmRleD1SO3grPVwiLVwiK1I7KHQ9ZC5wbG90TGluZXNBbmRCYW5kc0dyb3Vwc1t4XSl8fChkLnBsb3RMaW5lc0FuZEJhbmRzR3JvdXBzW3hdPXQ9di5nKFwicGxvdC1cIitcbngpLmF0dHIoQykuYWRkKCkpO08mJihjLnN2Z0VsZW09Sj12LnBhdGgoKS5hdHRyKEYpLmFkZCh0KSk7aWYodylGPWQuZ2V0UGxvdExpbmVQYXRoKHt2YWx1ZTphLGxpbmVXaWR0aDpKLnN0cm9rZVdpZHRoKCksYWNyb3NzUGFuZXM6ei5hY3Jvc3NQYW5lc30pO2Vsc2UgaWYoYilGPWQuZ2V0UGxvdEJhbmRQYXRoKGgsZSx6KTtlbHNlIHJldHVybjshYy5ldmVudHNBZGRlZCYmUSYmKGcoUSxmdW5jdGlvbihhLGIpe0oub24oYixmdW5jdGlvbihhKXtRW2JdLmFwcGx5KGMsW2FdKX0pfSksYy5ldmVudHNBZGRlZD0hMCk7KE98fCFKLmQpJiZGJiZGLmxlbmd0aD9KLmF0dHIoe2Q6Rn0pOkomJihGPyhKLnNob3coITApLEouYW5pbWF0ZSh7ZDpGfSkpOkouZCYmKEouaGlkZSgpLHImJihjLmxhYmVsPXI9ci5kZXN0cm95KCkpKSk7bSYmKEQobS50ZXh0KXx8RChtLmZvcm1hdHRlcikpJiZGJiZGLmxlbmd0aCYmMDxkLndpZHRoJiYwPGQuaGVpZ2h0JiYhRi5pc0ZsYXQ/KG09RSh7YWxpZ246ZiYmXG5iJiZcImNlbnRlclwiLHg6Zj8hYiYmNDoxMCx2ZXJ0aWNhbEFsaWduOiFmJiZiJiZcIm1pZGRsZVwiLHk6Zj9iPzE2OjEwOmI/NjotNCxyb3RhdGlvbjpmJiYhYiYmOTB9LG0pLHRoaXMucmVuZGVyTGFiZWwobSxGLGIsUikpOnImJnIuaGlkZSgpO3JldHVybiBjfTtjLnByb3RvdHlwZS5yZW5kZXJMYWJlbD1mdW5jdGlvbihjLGcsZCxmKXt2YXIgbj10aGlzLmxhYmVsLG09dGhpcy5heGlzLmNoYXJ0LnJlbmRlcmVyO258fChuPXthbGlnbjpjLnRleHRBbGlnbnx8Yy5hbGlnbixyb3RhdGlvbjpjLnJvdGF0aW9uLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtcGxvdC1cIisoZD9cImJhbmRcIjpcImxpbmVcIikrXCItbGFiZWwgXCIrKGMuY2xhc3NOYW1lfHxcIlwiKX0sbi56SW5kZXg9ZixmPXRoaXMuZ2V0TGFiZWxUZXh0KGMpLHRoaXMubGFiZWw9bj1tLnRleHQoZiwwLDAsYy51c2VIVE1MKS5hdHRyKG4pLmFkZCgpLHRoaXMuYXhpcy5jaGFydC5zdHlsZWRNb2RlfHxuLmNzcyhjLnN0eWxlKSk7bT1nLnhCb3VuZHN8fFxuW2dbMF1bMV0sZ1sxXVsxXSxkP2dbMl1bMV06Z1swXVsxXV07Zz1nLnlCb3VuZHN8fFtnWzBdWzJdLGdbMV1bMl0sZD9nWzJdWzJdOmdbMF1bMl1dO2Q9RyhtKTtmPUcoZyk7bi5hbGlnbihjLCExLHt4OmQseTpmLHdpZHRoOkIobSktZCxoZWlnaHQ6QihnKS1mfSk7bi5zaG93KCEwKX07Yy5wcm90b3R5cGUuZ2V0TGFiZWxUZXh0PWZ1bmN0aW9uKGMpe3JldHVybiBEKGMuZm9ybWF0dGVyKT9jLmZvcm1hdHRlci5jYWxsKHRoaXMpOmMudGV4dH07Yy5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3QodGhpcy5heGlzLnBsb3RMaW5lc0FuZEJhbmRzLHRoaXMpO2RlbGV0ZSB0aGlzLmF4aXM7SCh0aGlzKX07cmV0dXJuIGN9KCk7QyhmLnByb3RvdHlwZSx7Z2V0UGxvdEJhbmRQYXRoOmZ1bmN0aW9uKGMsZyxkKXt2b2lkIDA9PT1kJiYoZD10aGlzLm9wdGlvbnMpO3ZhciBmPXRoaXMuZ2V0UGxvdExpbmVQYXRoKHt2YWx1ZTpnLGZvcmNlOiEwLGFjcm9zc1BhbmVzOmQuYWNyb3NzUGFuZXN9KTtcbmQ9dGhpcy5nZXRQbG90TGluZVBhdGgoe3ZhbHVlOmMsZm9yY2U6ITAsYWNyb3NzUGFuZXM6ZC5hY3Jvc3NQYW5lc30pO3ZhciBuPVtdLGw9dGhpcy5ob3JpeixtPTE7Yz1jPHRoaXMubWluJiZnPHRoaXMubWlufHxjPnRoaXMubWF4JiZnPnRoaXMubWF4O2lmKGQmJmYpe2lmKGMpe3ZhciByPWQudG9TdHJpbmcoKT09PWYudG9TdHJpbmcoKTttPTB9Zm9yKGM9MDtjPGQubGVuZ3RoO2MrPTIpe2c9ZFtjXTt2YXIgZT1kW2MrMV0saD1mW2NdLGE9ZltjKzFdO1wiTVwiIT09Z1swXSYmXCJMXCIhPT1nWzBdfHxcIk1cIiE9PWVbMF0mJlwiTFwiIT09ZVswXXx8XCJNXCIhPT1oWzBdJiZcIkxcIiE9PWhbMF18fFwiTVwiIT09YVswXSYmXCJMXCIhPT1hWzBdfHwobCYmaFsxXT09PWdbMV0/KGhbMV0rPW0sYVsxXSs9bSk6bHx8aFsyXSE9PWdbMl18fChoWzJdKz1tLGFbMl0rPW0pLG4ucHVzaChbXCJNXCIsZ1sxXSxnWzJdXSxbXCJMXCIsZVsxXSxlWzJdXSxbXCJMXCIsYVsxXSxhWzJdXSxbXCJMXCIsaFsxXSxoWzJdXSxbXCJaXCJdKSk7XG5uLmlzRmxhdD1yfX1yZXR1cm4gbn0sYWRkUGxvdEJhbmQ6ZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUoYyxcInBsb3RCYW5kc1wiKX0sYWRkUGxvdExpbmU6ZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMuYWRkUGxvdEJhbmRPckxpbmUoYyxcInBsb3RMaW5lc1wiKX0sYWRkUGxvdEJhbmRPckxpbmU6ZnVuY3Rpb24oYyxnKXt2YXIgZj10aGlzLGw9bmV3IGQuUGxvdExpbmVPckJhbmQodGhpcyxjKSxxPXRoaXMudXNlck9wdGlvbnM7dGhpcy52aXNpYmxlJiYobD1sLnJlbmRlcigpKTtpZihsKXt0aGlzLl9hZGRlZFBsb3RMQnx8KHRoaXMuX2FkZGVkUGxvdExCPSEwLChxLnBsb3RMaW5lc3x8W10pLmNvbmNhdChxLnBsb3RCYW5kc3x8W10pLmZvckVhY2goZnVuY3Rpb24oYyl7Zi5hZGRQbG90QmFuZE9yTGluZShjKX0pKTtpZihnKXt2YXIgaz1xW2ddfHxbXTtrLnB1c2goYyk7cVtnXT1rfXRoaXMucGxvdExpbmVzQW5kQmFuZHMucHVzaChsKX1yZXR1cm4gbH0scmVtb3ZlUGxvdEJhbmRPckxpbmU6ZnVuY3Rpb24oYyl7Zm9yKHZhciBnPVxudGhpcy5wbG90TGluZXNBbmRCYW5kcyxkPXRoaXMub3B0aW9ucyxmPXRoaXMudXNlck9wdGlvbnMsbD1nLmxlbmd0aDtsLS07KWdbbF0uaWQ9PT1jJiZnW2xdLmRlc3Ryb3koKTtbZC5wbG90TGluZXN8fFtdLGYucGxvdExpbmVzfHxbXSxkLnBsb3RCYW5kc3x8W10sZi5wbG90QmFuZHN8fFtdXS5mb3JFYWNoKGZ1bmN0aW9uKGcpe2ZvcihsPWcubGVuZ3RoO2wtLTspKGdbbF18fHt9KS5pZD09PWMmJnQoZyxnW2xdKX0pfSxyZW1vdmVQbG90QmFuZDpmdW5jdGlvbihjKXt0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGMpfSxyZW1vdmVQbG90TGluZTpmdW5jdGlvbihjKXt0aGlzLnJlbW92ZVBsb3RCYW5kT3JMaW5lKGMpfX0pO2QuUGxvdExpbmVPckJhbmQ9eDtyZXR1cm4gZC5QbG90TGluZU9yQmFuZH0pO1AoayxcIkNvcmUvVG9vbHRpcC5qc1wiLFtrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLFxuZCxrKXt2YXIgeD1mLmRvYyxCPWsuY2xhbXAsRz1rLmNzcyxEPWsuZGVmaW5lZCxIPWsuZGlzY2FyZEVsZW1lbnQsdD1rLmV4dGVuZCxDPWsuZmlyZUV2ZW50LGw9ay5mb3JtYXQsRT1rLmlzTnVtYmVyLGc9ay5pc1N0cmluZyx5PWsubWVyZ2UsYz1rLnBpY2sscT1rLnNwbGF0LG49ay5zeW5jVGltZW91dCxBPWsudGltZVVuaXRzO1wiXCI7dmFyIE09ZnVuY3Rpb24oKXtmdW5jdGlvbiB6KGMsZyl7dGhpcy5jb250YWluZXI9dm9pZCAwO3RoaXMuY3Jvc3NoYWlycz1bXTt0aGlzLmRpc3RhbmNlPTA7dGhpcy5pc0hpZGRlbj0hMDt0aGlzLmlzU3RpY2t5PSExO3RoaXMubm93PXt9O3RoaXMub3B0aW9ucz17fTt0aGlzLm91dHNpZGU9ITE7dGhpcy5jaGFydD1jO3RoaXMuaW5pdChjLGcpfXoucHJvdG90eXBlLmFwcGx5RmlsdGVyPWZ1bmN0aW9uKCl7dmFyIGM9dGhpcy5jaGFydDtjLnJlbmRlcmVyLmRlZmluaXRpb24oe3RhZ05hbWU6XCJmaWx0ZXJcIixhdHRyaWJ1dGVzOntpZDpcImRyb3Atc2hhZG93LVwiK1xuYy5pbmRleCxvcGFjaXR5Oi41fSxjaGlsZHJlbjpbe3RhZ05hbWU6XCJmZUdhdXNzaWFuQmx1clwiLGF0dHJpYnV0ZXM6e1wiaW5cIjpcIlNvdXJjZUFscGhhXCIsc3RkRGV2aWF0aW9uOjF9fSx7dGFnTmFtZTpcImZlT2Zmc2V0XCIsYXR0cmlidXRlczp7ZHg6MSxkeToxfX0se3RhZ05hbWU6XCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsY2hpbGRyZW46W3t0YWdOYW1lOlwiZmVGdW5jQVwiLGF0dHJpYnV0ZXM6e3R5cGU6XCJsaW5lYXJcIixzbG9wZTouM319XX0se3RhZ05hbWU6XCJmZU1lcmdlXCIsY2hpbGRyZW46W3t0YWdOYW1lOlwiZmVNZXJnZU5vZGVcIn0se3RhZ05hbWU6XCJmZU1lcmdlTm9kZVwiLGF0dHJpYnV0ZXM6e1wiaW5cIjpcIlNvdXJjZUdyYXBoaWNcIn19XX1dfSk7Yy5yZW5kZXJlci5kZWZpbml0aW9uKHt0YWdOYW1lOlwic3R5bGVcIix0ZXh0Q29udGVudDpcIi5oaWdoY2hhcnRzLXRvb2x0aXAtXCIrYy5pbmRleCtcIntmaWx0ZXI6dXJsKCNkcm9wLXNoYWRvdy1cIitjLmluZGV4K1wiKX1cIn0pfTt6LnByb3RvdHlwZS5ib2R5Rm9ybWF0dGVyPVxuZnVuY3Rpb24oYyl7cmV0dXJuIGMubWFwKGZ1bmN0aW9uKGMpe3ZhciBlPWMuc2VyaWVzLnRvb2x0aXBPcHRpb25zO3JldHVybihlWyhjLnBvaW50LmZvcm1hdFByZWZpeHx8XCJwb2ludFwiKStcIkZvcm1hdHRlclwiXXx8Yy5wb2ludC50b29sdGlwRm9ybWF0dGVyKS5jYWxsKGMucG9pbnQsZVsoYy5wb2ludC5mb3JtYXRQcmVmaXh8fFwicG9pbnRcIikrXCJGb3JtYXRcIl18fFwiXCIpfSl9O3oucHJvdG90eXBlLmNsZWFuU3BsaXQ9ZnVuY3Rpb24oYyl7dGhpcy5jaGFydC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihnKXt2YXIgZT1nJiZnLnR0O2UmJighZS5pc0FjdGl2ZXx8Yz9nLnR0PWUuZGVzdHJveSgpOmUuaXNBY3RpdmU9ITEpfSl9O3oucHJvdG90eXBlLmRlZmF1bHRGb3JtYXR0ZXI9ZnVuY3Rpb24oYyl7dmFyIGc9dGhpcy5wb2ludHN8fHEodGhpcyk7dmFyIGU9W2MudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcihnWzBdKV07ZT1lLmNvbmNhdChjLmJvZHlGb3JtYXR0ZXIoZykpO2UucHVzaChjLnRvb2x0aXBGb290ZXJIZWFkZXJGb3JtYXR0ZXIoZ1swXSxcbiEwKSk7cmV0dXJuIGV9O3oucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt0aGlzLmxhYmVsJiYodGhpcy5sYWJlbD10aGlzLmxhYmVsLmRlc3Ryb3koKSk7dGhpcy5zcGxpdCYmdGhpcy50dCYmKHRoaXMuY2xlYW5TcGxpdCh0aGlzLmNoYXJ0LCEwKSx0aGlzLnR0PXRoaXMudHQuZGVzdHJveSgpKTt0aGlzLnJlbmRlcmVyJiYodGhpcy5yZW5kZXJlcj10aGlzLnJlbmRlcmVyLmRlc3Ryb3koKSxIKHRoaXMuY29udGFpbmVyKSk7ay5jbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO2suY2xlYXJUaW1lb3V0KHRoaXMudG9vbHRpcFRpbWVvdXQpfTt6LnByb3RvdHlwZS5nZXRBbmNob3I9ZnVuY3Rpb24oYyxnKXt2YXIgZT10aGlzLmNoYXJ0O3ZhciBkPWUucG9pbnRlcjt2YXIgYT1lLmludmVydGVkLGI9ZS5wbG90VG9wLGY9ZS5wbG90TGVmdCxtPTAsbj0wLGwscjtjPXEoYyk7dGhpcy5mb2xsb3dQb2ludGVyJiZnPyhcInVuZGVmaW5lZFwiPT09dHlwZW9mIGcuY2hhcnRYJiYoZz1kLm5vcm1hbGl6ZShnKSksXG5kPVtnLmNoYXJ0WC1mLGcuY2hhcnRZLWJdKTpjWzBdLnRvb2x0aXBQb3M/ZD1jWzBdLnRvb2x0aXBQb3M6KGMuZm9yRWFjaChmdW5jdGlvbihjKXtsPWMuc2VyaWVzLnlBeGlzO3I9Yy5zZXJpZXMueEF4aXM7bSs9Yy5wbG90WHx8MDtuKz1jLnBsb3RMb3c/KGMucGxvdExvdysoYy5wbG90SGlnaHx8MCkpLzI6Yy5wbG90WXx8MDtyJiZsJiYoYT8obSs9YitlLnBsb3RIZWlnaHQtci5sZW4tci5wb3Msbis9ZitlLnBsb3RXaWR0aC1sLmxlbi1sLnBvcyk6KG0rPXIucG9zLWYsbis9bC5wb3MtYikpfSksbS89Yy5sZW5ndGgsbi89Yy5sZW5ndGgsZD1bYT9lLnBsb3RXaWR0aC1uOm0sYT9lLnBsb3RIZWlnaHQtbTpuXSx0aGlzLnNoYXJlZCYmMTxjLmxlbmd0aCYmZyYmKGE/ZFswXT1nLmNoYXJ0WC1mOmRbMV09Zy5jaGFydFktYikpO3JldHVybiBkLm1hcChNYXRoLnJvdW5kKX07ei5wcm90b3R5cGUuZ2V0RGF0ZUZvcm1hdD1mdW5jdGlvbihjLGcsZSxkKXt2YXIgYT10aGlzLmNoYXJ0LnRpbWUsXG5iPWEuZGF0ZUZvcm1hdChcIiVtLSVkICVIOiVNOiVTLiVMXCIsZyksaD17bWlsbGlzZWNvbmQ6MTUsc2Vjb25kOjEyLG1pbnV0ZTo5LGhvdXI6NixkYXk6M30sZj1cIm1pbGxpc2Vjb25kXCI7Zm9yKG0gaW4gQSl7aWYoYz09PUEud2VlayYmK2EuZGF0ZUZvcm1hdChcIiV3XCIsZyk9PT1lJiZcIjAwOjAwOjAwLjAwMFwiPT09Yi5zdWJzdHIoNikpe3ZhciBtPVwid2Vla1wiO2JyZWFrfWlmKEFbbV0+Yyl7bT1mO2JyZWFrfWlmKGhbbV0mJmIuc3Vic3RyKGhbbV0pIT09XCIwMS0wMSAwMDowMDowMC4wMDBcIi5zdWJzdHIoaFttXSkpYnJlYWs7XCJ3ZWVrXCIhPT1tJiYoZj1tKX1pZihtKXZhciBuPWEucmVzb2x2ZURUTEZvcm1hdChkW21dKS5tYWluO3JldHVybiBufTt6LnByb3RvdHlwZS5nZXRMYWJlbD1mdW5jdGlvbigpe3ZhciBjLGcsZSxkPXRoaXMsYT10aGlzLmNoYXJ0LnJlbmRlcmVyLGI9dGhpcy5jaGFydC5zdHlsZWRNb2RlLHc9dGhpcy5vcHRpb25zLG49XCJ0b29sdGlwXCIrKEQody5jbGFzc05hbWUpP1xuXCIgXCIrdy5jbGFzc05hbWU6XCJcIiksbD0obnVsbD09PShjPXcuc3R5bGUpfHx2b2lkIDA9PT1jP3ZvaWQgMDpjLnBvaW50ZXJFdmVudHMpfHwoIXRoaXMuZm9sbG93UG9pbnRlciYmdy5zdGlja09uQ29udGFjdD9cImF1dG9cIjpcIm5vbmVcIikscTtjPWZ1bmN0aW9uKCl7ZC5pbkNvbnRhY3Q9ITB9O3ZhciBrPWZ1bmN0aW9uKCl7dmFyIGE9ZC5jaGFydC5ob3ZlclNlcmllcztkLmluQ29udGFjdD0hMTtpZihhJiZhLm9uTW91c2VPdXQpYS5vbk1vdXNlT3V0KCl9O2lmKCF0aGlzLmxhYmVsKXtpZih0aGlzLm91dHNpZGUpe3ZhciB0PW51bGw9PT0oZz10aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQpfHx2b2lkIDA9PT1nP3ZvaWQgMDpnLnN0eWxlO3RoaXMuY29udGFpbmVyPXE9Zi5kb2MuY3JlYXRlRWxlbWVudChcImRpdlwiKTtxLmNsYXNzTmFtZT1cImhpZ2hjaGFydHMtdG9vbHRpcC1jb250YWluZXJcIjtHKHEse3Bvc2l0aW9uOlwiYWJzb2x1dGVcIix0b3A6XCIxcHhcIixwb2ludGVyRXZlbnRzOmwsekluZGV4Ok1hdGgubWF4KChudWxsPT09XG4oZT10aGlzLm9wdGlvbnMuc3R5bGUpfHx2b2lkIDA9PT1lP3ZvaWQgMDplLnpJbmRleCl8fDAsKChudWxsPT09dHx8dm9pZCAwPT09dD92b2lkIDA6dC56SW5kZXgpfHwwKSszKX0pO2YuZG9jLmJvZHkuYXBwZW5kQ2hpbGQocSk7dGhpcy5yZW5kZXJlcj1hPW5ldyBmLlJlbmRlcmVyKHEsMCwwLHQsdm9pZCAwLHZvaWQgMCxhLnN0eWxlZE1vZGUpfXRoaXMuc3BsaXQ/dGhpcy5sYWJlbD1hLmcobik6KHRoaXMubGFiZWw9YS5sYWJlbChcIlwiLDAsMCx3LnNoYXBlfHxcImNhbGxvdXRcIixudWxsLG51bGwsdy51c2VIVE1MLG51bGwsbikuYXR0cih7cGFkZGluZzp3LnBhZGRpbmcscjp3LmJvcmRlclJhZGl1c30pLGJ8fHRoaXMubGFiZWwuYXR0cih7ZmlsbDp3LmJhY2tncm91bmRDb2xvcixcInN0cm9rZS13aWR0aFwiOncuYm9yZGVyV2lkdGh9KS5jc3Mody5zdHlsZSkuY3NzKHtwb2ludGVyRXZlbnRzOmx9KS5zaGFkb3cody5zaGFkb3cpKTtiJiYodGhpcy5hcHBseUZpbHRlcigpLHRoaXMubGFiZWwuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRvb2x0aXAtXCIrXG50aGlzLmNoYXJ0LmluZGV4KSk7aWYoZC5vdXRzaWRlJiYhZC5zcGxpdCl7dmFyIHk9dGhpcy5sYWJlbCx6PXkueFNldHRlcix2PXkueVNldHRlcjt5LnhTZXR0ZXI9ZnVuY3Rpb24oYSl7ei5jYWxsKHksZC5kaXN0YW5jZSk7cS5zdHlsZS5sZWZ0PWErXCJweFwifTt5LnlTZXR0ZXI9ZnVuY3Rpb24oYSl7di5jYWxsKHksZC5kaXN0YW5jZSk7cS5zdHlsZS50b3A9YStcInB4XCJ9fXRoaXMubGFiZWwub24oXCJtb3VzZWVudGVyXCIsYykub24oXCJtb3VzZWxlYXZlXCIsaykuYXR0cih7ekluZGV4Ojh9KS5hZGQoKX1yZXR1cm4gdGhpcy5sYWJlbH07ei5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oZyxkLGUpe3ZhciBoPXRoaXMuY2hhcnQsYT10aGlzLmRpc3RhbmNlLGI9e30sZj1oLmludmVydGVkJiZlLmh8fDAsbSxuPXRoaXMub3V0c2lkZSxsPW4/eC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgtMiphOmguY2hhcnRXaWR0aCxyPW4/TWF0aC5tYXgoeC5ib2R5LnNjcm9sbEhlaWdodCxcbnguZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCx4LmJvZHkub2Zmc2V0SGVpZ2h0LHguZG9jdW1lbnRFbGVtZW50Lm9mZnNldEhlaWdodCx4LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpOmguY2hhcnRIZWlnaHQscT1oLnBvaW50ZXIuZ2V0Q2hhcnRQb3NpdGlvbigpLGs9ZnVuY3Rpb24oYil7dmFyIGM9XCJ4XCI9PT1iO3JldHVybltiLGM/bDpyLGM/ZzpkXS5jb25jYXQobj9bYz9nKnEuc2NhbGVYOmQqcS5zY2FsZVksYz9xLmxlZnQtYSsoZS5wbG90WCtoLnBsb3RMZWZ0KSpxLnNjYWxlWDpxLnRvcC1hKyhlLnBsb3RZK2gucGxvdFRvcCkqcS5zY2FsZVksMCxjP2w6cl06W2M/ZzpkLGM/ZS5wbG90WCtoLnBsb3RMZWZ0OmUucGxvdFkraC5wbG90VG9wLGM/aC5wbG90TGVmdDpoLnBsb3RUb3AsYz9oLnBsb3RMZWZ0K2gucGxvdFdpZHRoOmgucGxvdFRvcCtoLnBsb3RIZWlnaHRdKX0seT1rKFwieVwiKSx2PWsoXCJ4XCIpLHQ9IXRoaXMuZm9sbG93UG9pbnRlciYmYyhlLnR0QmVsb3csXG4haC5pbnZlcnRlZD09PSEhZS5uZWdhdGl2ZSkscD1mdW5jdGlvbihlLGMsZyxkLGgsbSxwKXt2YXIgdT1uP1wieVwiPT09ZT9hKnEuc2NhbGVZOmEqcS5zY2FsZVg6YSx3PShnLWQpLzIsbD1kPGgtYSxyPWgrYStkPGMsSj1oLXUtZyt3O2g9aCt1LXc7aWYodCYmciliW2VdPWg7ZWxzZSBpZighdCYmbCliW2VdPUo7ZWxzZSBpZihsKWJbZV09TWF0aC5taW4ocC1kLDA+Si1mP0o6Si1mKTtlbHNlIGlmKHIpYltlXT1NYXRoLm1heChtLGgrZitnPmM/aDpoK2YpO2Vsc2UgcmV0dXJuITF9LHo9ZnVuY3Rpb24oZSxjLGcsZCxoKXt2YXIgZjtoPGF8fGg+Yy1hP2Y9ITE6YltlXT1oPGcvMj8xOmg+Yy1kLzI/Yy1kLTI6aC1nLzI7cmV0dXJuIGZ9LEE9ZnVuY3Rpb24oYSl7dmFyIGI9eTt5PXY7dj1iO209YX0sRT1mdW5jdGlvbigpeyExIT09cC5hcHBseSgwLHkpPyExIT09ei5hcHBseSgwLHYpfHxtfHwoQSghMCksRSgpKTptP2IueD1iLnk9MDooQSghMCksRSgpKX07KGguaW52ZXJ0ZWR8fDE8dGhpcy5sZW4pJiZcbkEoKTtFKCk7cmV0dXJuIGJ9O3oucHJvdG90eXBlLmdldFhEYXRlRm9ybWF0PWZ1bmN0aW9uKGMsZyxlKXtnPWcuZGF0ZVRpbWVMYWJlbEZvcm1hdHM7dmFyIGQ9ZSYmZS5jbG9zZXN0UG9pbnRSYW5nZTtyZXR1cm4oZD90aGlzLmdldERhdGVGb3JtYXQoZCxjLngsZS5vcHRpb25zLnN0YXJ0T2ZXZWVrLGcpOmcuZGF5KXx8Zy55ZWFyfTt6LnByb3RvdHlwZS5oaWRlPWZ1bmN0aW9uKGcpe3ZhciBkPXRoaXM7ay5jbGVhclRpbWVvdXQodGhpcy5oaWRlVGltZXIpO2c9YyhnLHRoaXMub3B0aW9ucy5oaWRlRGVsYXksNTAwKTt0aGlzLmlzSGlkZGVufHwodGhpcy5oaWRlVGltZXI9bihmdW5jdGlvbigpe2QuZ2V0TGFiZWwoKS5mYWRlT3V0KGc/dm9pZCAwOmcpO2QuaXNIaWRkZW49ITB9LGcpKX07ei5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihnLGQpe3RoaXMuY2hhcnQ9Zzt0aGlzLm9wdGlvbnM9ZDt0aGlzLmNyb3NzaGFpcnM9W107dGhpcy5ub3c9e3g6MCx5OjB9O3RoaXMuaXNIaWRkZW49XG4hMDt0aGlzLnNwbGl0PWQuc3BsaXQmJiFnLmludmVydGVkJiYhZy5wb2xhcjt0aGlzLnNoYXJlZD1kLnNoYXJlZHx8dGhpcy5zcGxpdDt0aGlzLm91dHNpZGU9YyhkLm91dHNpZGUsISghZy5zY3JvbGxhYmxlUGl4ZWxzWCYmIWcuc2Nyb2xsYWJsZVBpeGVsc1kpKX07ei5wcm90b3R5cGUuaXNTdGlja3lPbkNvbnRhY3Q9ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMuZm9sbG93UG9pbnRlcnx8IXRoaXMub3B0aW9ucy5zdGlja09uQ29udGFjdHx8IXRoaXMuaW5Db250YWN0KX07ei5wcm90b3R5cGUubW92ZT1mdW5jdGlvbihjLGcsZSxkKXt2YXIgYT10aGlzLGI9YS5ub3csaD0hMSE9PWEub3B0aW9ucy5hbmltYXRpb24mJiFhLmlzSGlkZGVuJiYoMTxNYXRoLmFicyhjLWIueCl8fDE8TWF0aC5hYnMoZy1iLnkpKSxmPWEuZm9sbG93UG9pbnRlcnx8MTxhLmxlbjt0KGIse3g6aD8oMipiLngrYykvMzpjLHk6aD8oYi55K2cpLzI6ZyxhbmNob3JYOmY/dm9pZCAwOmg/KDIqYi5hbmNob3JYK2UpL1xuMzplLGFuY2hvclk6Zj92b2lkIDA6aD8oYi5hbmNob3JZK2QpLzI6ZH0pO2EuZ2V0TGFiZWwoKS5hdHRyKGIpO2EuZHJhd1RyYWNrZXIoKTtoJiYoay5jbGVhclRpbWVvdXQodGhpcy50b29sdGlwVGltZW91dCksdGhpcy50b29sdGlwVGltZW91dD1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSYmYS5tb3ZlKGMsZyxlLGQpfSwzMikpfTt6LnByb3RvdHlwZS5yZWZyZXNoPWZ1bmN0aW9uKGcsZil7dmFyIGU9dGhpcy5jaGFydCxoPXRoaXMub3B0aW9ucyxhPWcsYj17fSxtPVtdLG49aC5mb3JtYXR0ZXJ8fHRoaXMuZGVmYXVsdEZvcm1hdHRlcjtiPXRoaXMuc2hhcmVkO3ZhciBsPWUuc3R5bGVkTW9kZTtpZihoLmVuYWJsZWQpe2suY2xlYXJUaW1lb3V0KHRoaXMuaGlkZVRpbWVyKTt0aGlzLmZvbGxvd1BvaW50ZXI9cShhKVswXS5zZXJpZXMudG9vbHRpcE9wdGlvbnMuZm9sbG93UG9pbnRlcjt2YXIgcj10aGlzLmdldEFuY2hvcihhLGYpO2Y9clswXTt2YXIgTj1yWzFdOyFifHxhLnNlcmllcyYmXG5hLnNlcmllcy5ub1NoYXJlZFRvb2x0aXA/Yj1hLmdldExhYmVsQ29uZmlnKCk6KGUucG9pbnRlci5hcHBseUluYWN0aXZlU3RhdGUoYSksYS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoXCJob3ZlclwiKTttLnB1c2goYS5nZXRMYWJlbENvbmZpZygpKX0pLGI9e3g6YVswXS5jYXRlZ29yeSx5OmFbMF0ueX0sYi5wb2ludHM9bSxhPWFbMF0pO3RoaXMubGVuPW0ubGVuZ3RoO2U9bi5jYWxsKGIsdGhpcyk7bj1hLnNlcmllczt0aGlzLmRpc3RhbmNlPWMobi50b29sdGlwT3B0aW9ucy5kaXN0YW5jZSwxNik7ITE9PT1lP3RoaXMuaGlkZSgpOih0aGlzLnNwbGl0P3RoaXMucmVuZGVyU3BsaXQoZSxxKGcpKTooZz10aGlzLmdldExhYmVsKCksaC5zdHlsZS53aWR0aCYmIWx8fGcuY3NzKHt3aWR0aDp0aGlzLmNoYXJ0LnNwYWNpbmdCb3gud2lkdGgrXCJweFwifSksZy5hdHRyKHt0ZXh0OmUmJmUuam9pbj9lLmpvaW4oXCJcIik6ZX0pLGcucmVtb3ZlQ2xhc3MoL2hpZ2hjaGFydHMtY29sb3ItW1xcZF0rL2cpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1jb2xvci1cIitcbmMoYS5jb2xvckluZGV4LG4uY29sb3JJbmRleCkpLGx8fGcuYXR0cih7c3Ryb2tlOmguYm9yZGVyQ29sb3J8fGEuY29sb3J8fG4uY29sb3J8fGQubmV1dHJhbENvbG9yNjB9KSx0aGlzLnVwZGF0ZVBvc2l0aW9uKHtwbG90WDpmLHBsb3RZOk4sbmVnYXRpdmU6YS5uZWdhdGl2ZSx0dEJlbG93OmEudHRCZWxvdyxoOnJbMl18fDB9KSksdGhpcy5pc0hpZGRlbiYmdGhpcy5sYWJlbCYmdGhpcy5sYWJlbC5hdHRyKHtvcGFjaXR5OjF9KS5zaG93KCksdGhpcy5pc0hpZGRlbj0hMSk7Qyh0aGlzLFwicmVmcmVzaFwiKX19O3oucHJvdG90eXBlLnJlbmRlclNwbGl0PWZ1bmN0aW9uKG0sbil7ZnVuY3Rpb24gZShhLGIsZSxjLGcpe3ZvaWQgMD09PWcmJihnPSEwKTtlPyhiPWFhPzA6VSxhPUIoYS1jLzIseC5sZWZ0LHgucmlnaHQtYykpOihiLT1JLGE9Zz9hLWMtcDphK3AsYT1CKGEsZz9hOngubGVmdCx4LnJpZ2h0KSk7cmV0dXJue3g6YSx5OmJ9fXZhciBoPXRoaXMsYT1oLmNoYXJ0LGI9aC5jaGFydCxcbnc9Yi5wbG90SGVpZ2h0LGw9Yi5wbG90TGVmdCxxPWIucGxvdFRvcCxyPWIucG9pbnRlcixrPWIucmVuZGVyZXIseT1iLnNjcm9sbGFibGVQaXhlbHNZLHo9dm9pZCAwPT09eT8wOnk7eT1iLnNjcm9sbGluZ0NvbnRhaW5lcjt5PXZvaWQgMD09PXk/e3Njcm9sbExlZnQ6MCxzY3JvbGxUb3A6MH06eTt2YXIgQT15LnNjcm9sbExlZnQsdj15LnNjcm9sbFRvcCxFPWIuc3R5bGVkTW9kZSxwPWguZGlzdGFuY2UsQz1oLm9wdGlvbnMsTT1oLm9wdGlvbnMucG9zaXRpb25lcix4PXtsZWZ0OkEscmlnaHQ6QStiLmNoYXJ0V2lkdGgsdG9wOnYsYm90dG9tOnYrYi5jaGFydEhlaWdodH0sdT1oLmdldExhYmVsKCksYWE9ISghYS54QXhpc1swXXx8IWEueEF4aXNbMF0ub3Bwb3NpdGUpLEk9cSt2LFg9MCxVPXctejtnKG0pJiYobT1bITEsbV0pO209bS5zbGljZSgwLG4ubGVuZ3RoKzEpLnJlZHVjZShmdW5jdGlvbihhLGIsZyl7aWYoITEhPT1iJiZcIlwiIT09Yil7Zz1uW2ctMV18fHtpc0hlYWRlcjohMCxcbnBsb3RYOm5bMF0ucGxvdFgscGxvdFk6dyxzZXJpZXM6e319O3ZhciBmPWcuaXNIZWFkZXIsbT1mP2g6Zy5zZXJpZXMscj1tLnR0LEo9Zy5pc0hlYWRlcjt2YXIgRj1nLnNlcmllczt2YXIgTj1cImhpZ2hjaGFydHMtY29sb3ItXCIrYyhnLmNvbG9ySW5kZXgsRi5jb2xvckluZGV4LFwibm9uZVwiKTtyfHwocj17cGFkZGluZzpDLnBhZGRpbmcscjpDLmJvcmRlclJhZGl1c30sRXx8KHIuZmlsbD1DLmJhY2tncm91bmRDb2xvcixyW1wic3Ryb2tlLXdpZHRoXCJdPUMuYm9yZGVyV2lkdGgpLHI9ay5sYWJlbChcIlwiLDAsMCxDW0o/XCJoZWFkZXJTaGFwZVwiOlwic2hhcGVcIl18fFwiY2FsbG91dFwiLHZvaWQgMCx2b2lkIDAsQy51c2VIVE1MKS5hZGRDbGFzcygoSj9cImhpZ2hjaGFydHMtdG9vbHRpcC1oZWFkZXIgXCI6XCJcIikrXCJoaWdoY2hhcnRzLXRvb2x0aXAtYm94IFwiK04pLmF0dHIocikuYWRkKHUpKTtyLmlzQWN0aXZlPSEwO3IuYXR0cih7dGV4dDpifSk7RXx8ci5jc3MoQy5zdHlsZSkuc2hhZG93KEMuc2hhZG93KS5hdHRyKHtzdHJva2U6Qy5ib3JkZXJDb2xvcnx8XG5nLmNvbG9yfHxGLmNvbG9yfHxkLm5ldXRyYWxDb2xvcjgwfSk7Yj1tLnR0PXI7Sj1iLmdldEJCb3goKTttPUoud2lkdGgrYi5zdHJva2VXaWR0aCgpO2YmJihYPUouaGVpZ2h0LFUrPVgsYWEmJihJLT1YKSk7Rj1nLnBsb3RYO0Y9dm9pZCAwPT09Rj8wOkY7Tj1nLnBsb3RZO049dm9pZCAwPT09Tj8wOk47dmFyIE89Zy5zZXJpZXM7aWYoZy5pc0hlYWRlcil7Rj1sK0Y7dmFyIHk9cSt3LzJ9ZWxzZSByPU8ueEF4aXMsTz1PLnlBeGlzLEY9ci5wb3MrQihGLC1wLHIubGVuK3ApLE8ucG9zK04+PXYrcSYmTy5wb3MrTjw9ditxK3cteiYmKHk9Ty5wb3MrTik7Rj1CKEYseC5sZWZ0LXAseC5yaWdodCtwKTtcIm51bWJlclwiPT09dHlwZW9mIHk/KEo9Si5oZWlnaHQrMSxOPU0/TS5jYWxsKGgsbSxKLGcpOmUoRix5LGYsbSksYS5wdXNoKHthbGlnbjpNPzA6dm9pZCAwLGFuY2hvclg6RixhbmNob3JZOnksYm94V2lkdGg6bSxwb2ludDpnLHJhbms6YyhOLnJhbmssZj8xOjApLHNpemU6Six0YXJnZXQ6Ti55LFxudHQ6Yix4Ok4ueH0pKTpiLmlzQWN0aXZlPSExfXJldHVybiBhfSxbXSk7IU0mJm0uc29tZShmdW5jdGlvbihhKXtyZXR1cm4gYS54PHgubGVmdH0pJiYobT1tLm1hcChmdW5jdGlvbihhKXt2YXIgYj1lKGEuYW5jaG9yWCxhLmFuY2hvclksYS5wb2ludC5pc0hlYWRlcixhLmJveFdpZHRoLCExKTtyZXR1cm4gdChhLHt0YXJnZXQ6Yi55LHg6Yi54fSl9KSk7aC5jbGVhblNwbGl0KCk7Zi5kaXN0cmlidXRlKG0sVSk7bS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucG9zO2EudHQuYXR0cih7dmlzaWJpbGl0eTpcInVuZGVmaW5lZFwiPT09dHlwZW9mIGI/XCJoaWRkZW5cIjpcImluaGVyaXRcIix4OmEueCx5OmIrSSxhbmNob3JYOmEuYW5jaG9yWCxhbmNob3JZOmEuYW5jaG9yWX0pfSk7bT1oLmNvbnRhaW5lcjthPWgucmVuZGVyZXI7aC5vdXRzaWRlJiZtJiZhJiYoYj11LmdldEJCb3goKSxhLnNldFNpemUoYi53aWR0aCtiLngsYi5oZWlnaHQrYi55LCExKSxyPXIuZ2V0Q2hhcnRQb3NpdGlvbigpLFxubS5zdHlsZS5sZWZ0PXIubGVmdCtcInB4XCIsbS5zdHlsZS50b3A9ci50b3ArXCJweFwiKX07ei5wcm90b3R5cGUuZHJhd1RyYWNrZXI9ZnVuY3Rpb24oKXtpZih0aGlzLmZvbGxvd1BvaW50ZXJ8fCF0aGlzLm9wdGlvbnMuc3RpY2tPbkNvbnRhY3QpdGhpcy50cmFja2VyJiZ0aGlzLnRyYWNrZXIuZGVzdHJveSgpO2Vsc2V7dmFyIGM9dGhpcy5jaGFydCxnPXRoaXMubGFiZWwsZT1jLmhvdmVyUG9pbnQ7aWYoZyYmZSl7dmFyIGQ9e3g6MCx5OjAsd2lkdGg6MCxoZWlnaHQ6MH07ZT10aGlzLmdldEFuY2hvcihlKTt2YXIgYT1nLmdldEJCb3goKTtlWzBdKz1jLnBsb3RMZWZ0LWcudHJhbnNsYXRlWDtlWzFdKz1jLnBsb3RUb3AtZy50cmFuc2xhdGVZO2QueD1NYXRoLm1pbigwLGVbMF0pO2QueT1NYXRoLm1pbigwLGVbMV0pO2Qud2lkdGg9MD5lWzBdP01hdGgubWF4KE1hdGguYWJzKGVbMF0pLGEud2lkdGgtZVswXSk6TWF0aC5tYXgoTWF0aC5hYnMoZVswXSksYS53aWR0aCk7ZC5oZWlnaHQ9MD5cbmVbMV0/TWF0aC5tYXgoTWF0aC5hYnMoZVsxXSksYS5oZWlnaHQtTWF0aC5hYnMoZVsxXSkpOk1hdGgubWF4KE1hdGguYWJzKGVbMV0pLGEuaGVpZ2h0KTt0aGlzLnRyYWNrZXI/dGhpcy50cmFja2VyLmF0dHIoZCk6KHRoaXMudHJhY2tlcj1nLnJlbmRlcmVyLnJlY3QoZCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikuYWRkKGcpLGMuc3R5bGVkTW9kZXx8dGhpcy50cmFja2VyLmF0dHIoe2ZpbGw6XCJyZ2JhKDAsMCwwLDApXCJ9KSl9fX07ei5wcm90b3R5cGUuc3R5bGVkTW9kZUZvcm1hdD1mdW5jdGlvbihjKXtyZXR1cm4gYy5yZXBsYWNlKCdzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiJywnY2xhc3M9XCJoaWdoY2hhcnRzLWhlYWRlclwiJykucmVwbGFjZSgvc3R5bGU9XCJjb2xvcjp7KHBvaW50fHNlcmllcylcXC5jb2xvcn1cIi9nLCdjbGFzcz1cImhpZ2hjaGFydHMtY29sb3IteyQxLmNvbG9ySW5kZXh9XCInKX07ei5wcm90b3R5cGUudG9vbHRpcEZvb3RlckhlYWRlckZvcm1hdHRlcj1cbmZ1bmN0aW9uKGMsZyl7dmFyIGU9Zz9cImZvb3RlclwiOlwiaGVhZGVyXCIsZD1jLnNlcmllcyxhPWQudG9vbHRpcE9wdGlvbnMsYj1hLnhEYXRlRm9ybWF0LGY9ZC54QXhpcyxtPWYmJlwiZGF0ZXRpbWVcIj09PWYub3B0aW9ucy50eXBlJiZFKGMua2V5KSxuPWFbZStcIkZvcm1hdFwiXTtnPXtpc0Zvb3RlcjpnLGxhYmVsQ29uZmlnOmN9O0ModGhpcyxcImhlYWRlckZvcm1hdHRlclwiLGcsZnVuY3Rpb24oZSl7bSYmIWImJihiPXRoaXMuZ2V0WERhdGVGb3JtYXQoYyxhLGYpKTttJiZiJiYoYy5wb2ludCYmYy5wb2ludC50b29sdGlwRGF0ZUtleXN8fFtcImtleVwiXSkuZm9yRWFjaChmdW5jdGlvbihhKXtuPW4ucmVwbGFjZShcIntwb2ludC5cIithK1wifVwiLFwie3BvaW50LlwiK2ErXCI6XCIrYitcIn1cIil9KTtkLmNoYXJ0LnN0eWxlZE1vZGUmJihuPXRoaXMuc3R5bGVkTW9kZUZvcm1hdChuKSk7ZS50ZXh0PWwobix7cG9pbnQ6YyxzZXJpZXM6ZH0sdGhpcy5jaGFydCl9KTtyZXR1cm4gZy50ZXh0fTt6LnByb3RvdHlwZS51cGRhdGU9XG5mdW5jdGlvbihjKXt0aGlzLmRlc3Ryb3koKTt5KCEwLHRoaXMuY2hhcnQub3B0aW9ucy50b29sdGlwLnVzZXJPcHRpb25zLGMpO3RoaXMuaW5pdCh0aGlzLmNoYXJ0LHkoITAsdGhpcy5vcHRpb25zLGMpKX07ei5wcm90b3R5cGUudXBkYXRlUG9zaXRpb249ZnVuY3Rpb24oYyl7dmFyIGc9dGhpcy5jaGFydCxlPWcucG9pbnRlcixkPXRoaXMuZ2V0TGFiZWwoKSxhPWMucGxvdFgrZy5wbG90TGVmdDtnPWMucGxvdFkrZy5wbG90VG9wO2U9ZS5nZXRDaGFydFBvc2l0aW9uKCk7Yz0odGhpcy5vcHRpb25zLnBvc2l0aW9uZXJ8fHRoaXMuZ2V0UG9zaXRpb24pLmNhbGwodGhpcyxkLndpZHRoLGQuaGVpZ2h0LGMpO2lmKHRoaXMub3V0c2lkZSl7dmFyIGI9KHRoaXMub3B0aW9ucy5ib3JkZXJXaWR0aHx8MCkrMip0aGlzLmRpc3RhbmNlO3RoaXMucmVuZGVyZXIuc2V0U2l6ZShkLndpZHRoK2IsZC5oZWlnaHQrYiwhMSk7aWYoMSE9PWUuc2NhbGVYfHwxIT09ZS5zY2FsZVkpRyh0aGlzLmNvbnRhaW5lcixcbnt0cmFuc2Zvcm06XCJzY2FsZShcIitlLnNjYWxlWCtcIiwgXCIrZS5zY2FsZVkrXCIpXCJ9KSxhKj1lLnNjYWxlWCxnKj1lLnNjYWxlWTthKz1lLmxlZnQtYy54O2crPWUudG9wLWMueX10aGlzLm1vdmUoTWF0aC5yb3VuZChjLngpLE1hdGgucm91bmQoYy55fHwwKSxhLGcpfTtyZXR1cm4gen0oKTtmLlRvb2x0aXA9TTtyZXR1cm4gZi5Ub29sdGlwfSk7UChrLFwiQ29yZS9Qb2ludGVyLmpzXCIsW2tbXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvQ29sb3IvUGFsZXR0ZS5qc1wiXSxrW1wiQ29yZS9Ub29sdGlwLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCxCKXt2YXIgRz1mLnBhcnNlLEQ9ZC5jaGFydHMsSD1kLm5vb3AsdD1CLmFkZEV2ZW50LEM9Qi5hdHRyLGw9Qi5jc3MsRT1CLmRlZmluZWQsZz1CLmV4dGVuZCx5PUIuZmluZCxjPUIuZmlyZUV2ZW50LHE9Qi5pc051bWJlcixuPUIuaXNPYmplY3QsQT1CLm9iamVjdEVhY2gsXG5NPUIub2Zmc2V0LHo9Qi5waWNrLG09Qi5zcGxhdDtcIlwiO2Y9ZnVuY3Rpb24oKXtmdW5jdGlvbiBmKGUsYyl7dGhpcy5sYXN0VmFsaWRUb3VjaD17fTt0aGlzLnBpbmNoRG93bj1bXTt0aGlzLnJ1bkNoYXJ0Q2xpY2s9ITE7dGhpcy5jaGFydD1lO3RoaXMuaGFzRHJhZ2dlZD0hMTt0aGlzLm9wdGlvbnM9Yzt0aGlzLnVuYmluZENvbnRhaW5lck1vdXNlTGVhdmU9ZnVuY3Rpb24oKXt9O3RoaXMudW5iaW5kQ29udGFpbmVyTW91c2VFbnRlcj1mdW5jdGlvbigpe307dGhpcy5pbml0KGUsYyl9Zi5wcm90b3R5cGUuYXBwbHlJbmFjdGl2ZVN0YXRlPWZ1bmN0aW9uKGUpe3ZhciBjPVtdLGE7KGV8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2E9Yi5zZXJpZXM7Yy5wdXNoKGEpO2EubGlua2VkUGFyZW50JiZjLnB1c2goYS5saW5rZWRQYXJlbnQpO2EubGlua2VkU2VyaWVzJiYoYz1jLmNvbmNhdChhLmxpbmtlZFNlcmllcykpO2EubmF2aWdhdG9yU2VyaWVzJiZjLnB1c2goYS5uYXZpZ2F0b3JTZXJpZXMpfSk7XG50aGlzLmNoYXJ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGEpey0xPT09Yy5pbmRleE9mKGEpP2Euc2V0U3RhdGUoXCJpbmFjdGl2ZVwiLCEwKTphLm9wdGlvbnMuaW5hY3RpdmVPdGhlclBvaW50cyYmYS5zZXRBbGxQb2ludHNUb1N0YXRlKFwiaW5hY3RpdmVcIil9KX07Zi5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBlLnVuRG9jTW91c2VNb3ZlJiZlLnVuRG9jTW91c2VNb3ZlKCk7dGhpcy51bmJpbmRDb250YWluZXJNb3VzZUxlYXZlKCk7ZC5jaGFydENvdW50fHwoZC51bmJpbmREb2N1bWVudE1vdXNlVXAmJihkLnVuYmluZERvY3VtZW50TW91c2VVcD1kLnVuYmluZERvY3VtZW50TW91c2VVcCgpKSxkLnVuYmluZERvY3VtZW50VG91Y2hFbmQmJihkLnVuYmluZERvY3VtZW50VG91Y2hFbmQ9ZC51bmJpbmREb2N1bWVudFRvdWNoRW5kKCkpKTtjbGVhckludGVydmFsKGUudG9vbHRpcFRpbWVvdXQpO0EoZSxmdW5jdGlvbihjLFxuYSl7ZVthXT12b2lkIDB9KX07Zi5wcm90b3R5cGUuZHJhZz1mdW5jdGlvbihlKXt2YXIgYz10aGlzLmNoYXJ0LGE9Yy5vcHRpb25zLmNoYXJ0LGI9ZS5jaGFydFgsZz1lLmNoYXJ0WSxkPXRoaXMuem9vbUhvcixmPXRoaXMuem9vbVZlcnQsbT1jLnBsb3RMZWZ0LGw9Yy5wbG90VG9wLHE9Yy5wbG90V2lkdGgscj1jLnBsb3RIZWlnaHQseT10aGlzLnNlbGVjdGlvbk1hcmtlcix2PXRoaXMubW91c2VEb3duWHx8MCx0PXRoaXMubW91c2VEb3duWXx8MCxwPW4oYS5wYW5uaW5nKT9hLnBhbm5pbmcmJmEucGFubmluZy5lbmFibGVkOmEucGFubmluZyx6PWEucGFuS2V5JiZlW2EucGFuS2V5K1wiS2V5XCJdO2lmKCF5fHwheS50b3VjaClpZihiPG0/Yj1tOmI+bStxJiYoYj1tK3EpLGc8bD9nPWw6Zz5sK3ImJihnPWwrciksdGhpcy5oYXNEcmFnZ2VkPU1hdGguc3FydChNYXRoLnBvdyh2LWIsMikrTWF0aC5wb3codC1nLDIpKSwxMDx0aGlzLmhhc0RyYWdnZWQpe3ZhciBBPWMuaXNJbnNpZGVQbG90KHYtXG5tLHQtbCk7Yy5oYXNDYXJ0ZXNpYW5TZXJpZXMmJih0aGlzLnpvb21YfHx0aGlzLnpvb21ZKSYmQSYmIXomJiF5JiYodGhpcy5zZWxlY3Rpb25NYXJrZXI9eT1jLnJlbmRlcmVyLnJlY3QobSxsLGQ/MTpxLGY/MTpyLDApLmF0dHIoe1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtc2VsZWN0aW9uLW1hcmtlclwiLHpJbmRleDo3fSkuYWRkKCksYy5zdHlsZWRNb2RlfHx5LmF0dHIoe2ZpbGw6YS5zZWxlY3Rpb25NYXJrZXJGaWxsfHxHKGsuaGlnaGxpZ2h0Q29sb3I4MCkuc2V0T3BhY2l0eSguMjUpLmdldCgpfSkpO3kmJmQmJihiLT12LHkuYXR0cih7d2lkdGg6TWF0aC5hYnMoYikseDooMDxiPzA6Yikrdn0pKTt5JiZmJiYoYj1nLXQseS5hdHRyKHtoZWlnaHQ6TWF0aC5hYnMoYikseTooMDxiPzA6YikrdH0pKTtBJiYheSYmcCYmYy5wYW4oZSxhLnBhbm5pbmcpfX07Zi5wcm90b3R5cGUuZHJhZ1N0YXJ0PWZ1bmN0aW9uKGUpe3ZhciBjPXRoaXMuY2hhcnQ7Yy5tb3VzZUlzRG93bj1lLnR5cGU7Yy5jYW5jZWxDbGljaz1cbiExO2MubW91c2VEb3duWD10aGlzLm1vdXNlRG93blg9ZS5jaGFydFg7Yy5tb3VzZURvd25ZPXRoaXMubW91c2VEb3duWT1lLmNoYXJ0WX07Zi5wcm90b3R5cGUuZHJvcD1mdW5jdGlvbihlKXt2YXIgZD10aGlzLGE9dGhpcy5jaGFydCxiPXRoaXMuaGFzUGluY2hlZDtpZih0aGlzLnNlbGVjdGlvbk1hcmtlcil7dmFyIGY9e29yaWdpbmFsRXZlbnQ6ZSx4QXhpczpbXSx5QXhpczpbXX0sbT10aGlzLnNlbGVjdGlvbk1hcmtlcixuPW0uYXR0cj9tLmF0dHIoXCJ4XCIpOm0ueCxyPW0uYXR0cj9tLmF0dHIoXCJ5XCIpOm0ueSxrPW0uYXR0cj9tLmF0dHIoXCJ3aWR0aFwiKTptLndpZHRoLHk9bS5hdHRyP20uYXR0cihcImhlaWdodFwiKTptLmhlaWdodCx0O2lmKHRoaXMuaGFzRHJhZ2dlZHx8YilhLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihhKXtpZihhLnpvb21FbmFibGVkJiZFKGEubWluKSYmKGJ8fGRbe3hBeGlzOlwiem9vbVhcIix5QXhpczpcInpvb21ZXCJ9W2EuY29sbF1dKSYmcShuKSYmcShyKSl7dmFyIGM9XG5hLmhvcml6LGc9XCJ0b3VjaGVuZFwiPT09ZS50eXBlP2EubWluUGl4ZWxQYWRkaW5nOjAsaD1hLnRvVmFsdWUoKGM/bjpyKStnKTtjPWEudG9WYWx1ZSgoYz9uK2s6cit5KS1nKTtmW2EuY29sbF0ucHVzaCh7YXhpczphLG1pbjpNYXRoLm1pbihoLGMpLG1heDpNYXRoLm1heChoLGMpfSk7dD0hMH19KSx0JiZjKGEsXCJzZWxlY3Rpb25cIixmLGZ1bmN0aW9uKGUpe2Euem9vbShnKGUsYj97YW5pbWF0aW9uOiExfTpudWxsKSl9KTtxKGEuaW5kZXgpJiYodGhpcy5zZWxlY3Rpb25NYXJrZXI9dGhpcy5zZWxlY3Rpb25NYXJrZXIuZGVzdHJveSgpKTtiJiZ0aGlzLnNjYWxlR3JvdXBzKCl9YSYmcShhLmluZGV4KSYmKGwoYS5jb250YWluZXIse2N1cnNvcjphLl9jdXJzb3J9KSxhLmNhbmNlbENsaWNrPTEwPHRoaXMuaGFzRHJhZ2dlZCxhLm1vdXNlSXNEb3duPXRoaXMuaGFzRHJhZ2dlZD10aGlzLmhhc1BpbmNoZWQ9ITEsdGhpcy5waW5jaERvd249W10pfTtmLnByb3RvdHlwZS5maW5kTmVhcmVzdEtEUG9pbnQ9XG5mdW5jdGlvbihlLGMsYSl7dmFyIGI9dGhpcy5jaGFydCxnPWIuaG92ZXJQb2ludDtiPWIudG9vbHRpcDtpZihnJiZiJiZiLmlzU3RpY2t5T25Db250YWN0KCkpcmV0dXJuIGc7dmFyIGQ7ZS5mb3JFYWNoKGZ1bmN0aW9uKGIpe3ZhciBlPSEoYi5ub1NoYXJlZFRvb2x0aXAmJmMpJiYwPmIub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik7Yj1iLnNlYXJjaFBvaW50KGEsZSk7aWYoKGU9bihiLCEwKSYmYi5zZXJpZXMpJiYhKGU9IW4oZCwhMCkpKXtlPWQuZGlzdFgtYi5kaXN0WDt2YXIgZz1kLmRpc3QtYi5kaXN0LGY9KGIuc2VyaWVzLmdyb3VwJiZiLnNlcmllcy5ncm91cC56SW5kZXgpLShkLnNlcmllcy5ncm91cCYmZC5zZXJpZXMuZ3JvdXAuekluZGV4KTtlPTA8KDAhPT1lJiZjP2U6MCE9PWc/ZzowIT09Zj9mOmQuc2VyaWVzLmluZGV4PmIuc2VyaWVzLmluZGV4Py0xOjEpfWUmJihkPWIpfSk7cmV0dXJuIGR9O2YucHJvdG90eXBlLmdldENoYXJ0Q29vcmRpbmF0ZXNGcm9tUG9pbnQ9XG5mdW5jdGlvbihlLGMpe3ZhciBhPWUuc2VyaWVzLGI9YS54QXhpczthPWEueUF4aXM7dmFyIGc9eihlLmNsaWVudFgsZS5wbG90WCksZD1lLnNoYXBlQXJncztpZihiJiZhKXJldHVybiBjP3tjaGFydFg6Yi5sZW4rYi5wb3MtZyxjaGFydFk6YS5sZW4rYS5wb3MtZS5wbG90WX06e2NoYXJ0WDpnK2IucG9zLGNoYXJ0WTplLnBsb3RZK2EucG9zfTtpZihkJiZkLngmJmQueSlyZXR1cm57Y2hhcnRYOmQueCxjaGFydFk6ZC55fX07Zi5wcm90b3R5cGUuZ2V0Q2hhcnRQb3NpdGlvbj1mdW5jdGlvbigpe2lmKHRoaXMuY2hhcnRQb3NpdGlvbilyZXR1cm4gdGhpcy5jaGFydFBvc2l0aW9uO3ZhciBlPXRoaXMuY2hhcnQuY29udGFpbmVyLGM9TShlKTt0aGlzLmNoYXJ0UG9zaXRpb249e2xlZnQ6Yy5sZWZ0LHRvcDpjLnRvcCxzY2FsZVg6MSxzY2FsZVk6MX07dmFyIGE9ZS5vZmZzZXRXaWR0aDtlPWUub2Zmc2V0SGVpZ2h0OzI8YSYmMjxlJiYodGhpcy5jaGFydFBvc2l0aW9uLnNjYWxlWD1jLndpZHRoL1xuYSx0aGlzLmNoYXJ0UG9zaXRpb24uc2NhbGVZPWMuaGVpZ2h0L2UpO3JldHVybiB0aGlzLmNoYXJ0UG9zaXRpb259O2YucHJvdG90eXBlLmdldENvb3JkaW5hdGVzPWZ1bmN0aW9uKGUpe3ZhciBjPXt4QXhpczpbXSx5QXhpczpbXX07dGhpcy5jaGFydC5heGVzLmZvckVhY2goZnVuY3Rpb24oYSl7Y1thLmlzWEF4aXM/XCJ4QXhpc1wiOlwieUF4aXNcIl0ucHVzaCh7YXhpczphLHZhbHVlOmEudG9WYWx1ZShlW2EuaG9yaXo/XCJjaGFydFhcIjpcImNoYXJ0WVwiXSl9KX0pO3JldHVybiBjfTtmLnByb3RvdHlwZS5nZXRIb3ZlckRhdGE9ZnVuY3Rpb24oZSxnLGEsYixkLGYpe3ZhciBoLG09W107Yj0hKCFifHwhZSk7dmFyIHc9ZyYmIWcuc3RpY2t5VHJhY2tpbmcsbD17Y2hhcnRYOmY/Zi5jaGFydFg6dm9pZCAwLGNoYXJ0WTpmP2YuY2hhcnRZOnZvaWQgMCxzaGFyZWQ6ZH07Yyh0aGlzLFwiYmVmb3JlR2V0SG92ZXJEYXRhXCIsbCk7dz13P1tnXTphLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gbC5maWx0ZXI/XG5sLmZpbHRlcihhKTphLnZpc2libGUmJiEoIWQmJmEuZGlyZWN0VG91Y2gpJiZ6KGEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nLCEwKSYmYS5zdGlja3lUcmFja2luZ30pO2c9KGg9Ynx8IWY/ZTp0aGlzLmZpbmROZWFyZXN0S0RQb2ludCh3LGQsZikpJiZoLnNlcmllcztoJiYoZCYmIWcubm9TaGFyZWRUb29sdGlwPyh3PWEuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBsLmZpbHRlcj9sLmZpbHRlcihhKTphLnZpc2libGUmJiEoIWQmJmEuZGlyZWN0VG91Y2gpJiZ6KGEub3B0aW9ucy5lbmFibGVNb3VzZVRyYWNraW5nLCEwKSYmIWEubm9TaGFyZWRUb29sdGlwfSksdy5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPXkoYS5wb2ludHMsZnVuY3Rpb24oYSl7cmV0dXJuIGEueD09PWgueCYmIWEuaXNOdWxsfSk7bihiKSYmKGEuY2hhcnQuaXNCb29zdGluZyYmKGI9YS5nZXRQb2ludChiKSksbS5wdXNoKGIpKX0pKTptLnB1c2goaCkpO2w9e2hvdmVyUG9pbnQ6aH07Yyh0aGlzLFwiYWZ0ZXJHZXRIb3ZlckRhdGFcIixcbmwpO3JldHVybntob3ZlclBvaW50OmwuaG92ZXJQb2ludCxob3ZlclNlcmllczpnLGhvdmVyUG9pbnRzOm19fTtmLnByb3RvdHlwZS5nZXRQb2ludEZyb21FdmVudD1mdW5jdGlvbihlKXtlPWUudGFyZ2V0O2Zvcih2YXIgYztlJiYhYzspYz1lLnBvaW50LGU9ZS5wYXJlbnROb2RlO3JldHVybiBjfTtmLnByb3RvdHlwZS5vblRyYWNrZXJNb3VzZU91dD1mdW5jdGlvbihlKXtlPWUucmVsYXRlZFRhcmdldHx8ZS50b0VsZW1lbnQ7dmFyIGM9dGhpcy5jaGFydC5ob3ZlclNlcmllczt0aGlzLmlzRGlyZWN0VG91Y2g9ITE7aWYoISghY3x8IWV8fGMuc3RpY2t5VHJhY2tpbmd8fHRoaXMuaW5DbGFzcyhlLFwiaGlnaGNoYXJ0cy10b29sdGlwXCIpfHx0aGlzLmluQ2xhc3MoZSxcImhpZ2hjaGFydHMtc2VyaWVzLVwiK2MuaW5kZXgpJiZ0aGlzLmluQ2xhc3MoZSxcImhpZ2hjaGFydHMtdHJhY2tlclwiKSkpYy5vbk1vdXNlT3V0KCl9O2YucHJvdG90eXBlLmluQ2xhc3M9ZnVuY3Rpb24oZSxjKXtmb3IodmFyIGE7ZTspe2lmKGE9XG5DKGUsXCJjbGFzc1wiKSl7aWYoLTEhPT1hLmluZGV4T2YoYykpcmV0dXJuITA7aWYoLTEhPT1hLmluZGV4T2YoXCJoaWdoY2hhcnRzLWNvbnRhaW5lclwiKSlyZXR1cm4hMX1lPWUucGFyZW50Tm9kZX19O2YucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oZSxjKXt0aGlzLm9wdGlvbnM9Yzt0aGlzLmNoYXJ0PWU7dGhpcy5ydW5DaGFydENsaWNrPWMuY2hhcnQuZXZlbnRzJiYhIWMuY2hhcnQuZXZlbnRzLmNsaWNrO3RoaXMucGluY2hEb3duPVtdO3RoaXMubGFzdFZhbGlkVG91Y2g9e307eCYmKGUudG9vbHRpcD1uZXcgeChlLGMudG9vbHRpcCksdGhpcy5mb2xsb3dUb3VjaE1vdmU9eihjLnRvb2x0aXAuZm9sbG93VG91Y2hNb3ZlLCEwKSk7dGhpcy5zZXRET01FdmVudHMoKX07Zi5wcm90b3R5cGUubm9ybWFsaXplPWZ1bmN0aW9uKGUsYyl7dmFyIGE9ZS50b3VjaGVzLGI9YT9hLmxlbmd0aD9hLml0ZW0oMCk6eihhLmNoYW5nZWRUb3VjaGVzLGUuY2hhbmdlZFRvdWNoZXMpWzBdOmU7Y3x8KGM9XG50aGlzLmdldENoYXJ0UG9zaXRpb24oKSk7YT1iLnBhZ2VYLWMubGVmdDtiPWIucGFnZVktYy50b3A7YS89Yy5zY2FsZVg7Yi89Yy5zY2FsZVk7cmV0dXJuIGcoZSx7Y2hhcnRYOk1hdGgucm91bmQoYSksY2hhcnRZOk1hdGgucm91bmQoYil9KX07Zi5wcm90b3R5cGUub25Db250YWluZXJDbGljaz1mdW5jdGlvbihlKXt2YXIgZD10aGlzLmNoYXJ0LGE9ZC5ob3ZlclBvaW50O2U9dGhpcy5ub3JtYWxpemUoZSk7dmFyIGI9ZC5wbG90TGVmdCxmPWQucGxvdFRvcDtkLmNhbmNlbENsaWNrfHwoYSYmdGhpcy5pbkNsYXNzKGUudGFyZ2V0LFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpPyhjKGEuc2VyaWVzLFwiY2xpY2tcIixnKGUse3BvaW50OmF9KSksZC5ob3ZlclBvaW50JiZhLmZpcmVQb2ludEV2ZW50KFwiY2xpY2tcIixlKSk6KGcoZSx0aGlzLmdldENvb3JkaW5hdGVzKGUpKSxkLmlzSW5zaWRlUGxvdChlLmNoYXJ0WC1iLGUuY2hhcnRZLWYpJiZjKGQsXCJjbGlja1wiLGUpKSl9O2YucHJvdG90eXBlLm9uQ29udGFpbmVyTW91c2VEb3duPVxuZnVuY3Rpb24oZSl7dmFyIGM9MT09PSgoZS5idXR0b25zfHxlLmJ1dHRvbikmMSk7ZT10aGlzLm5vcm1hbGl6ZShlKTtpZihkLmlzRmlyZWZveCYmMCE9PWUuYnV0dG9uKXRoaXMub25Db250YWluZXJNb3VzZU1vdmUoZSk7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBlLmJ1dHRvbnx8Yyl0aGlzLnpvb21PcHRpb24oZSksYyYmZS5wcmV2ZW50RGVmYXVsdCYmZS5wcmV2ZW50RGVmYXVsdCgpLHRoaXMuZHJhZ1N0YXJ0KGUpfTtmLnByb3RvdHlwZS5vbkNvbnRhaW5lck1vdXNlTGVhdmU9ZnVuY3Rpb24oZSl7dmFyIGM9RFt6KGQuaG92ZXJDaGFydEluZGV4LC0xKV0sYT10aGlzLmNoYXJ0LnRvb2x0aXA7ZT10aGlzLm5vcm1hbGl6ZShlKTtjJiYoZS5yZWxhdGVkVGFyZ2V0fHxlLnRvRWxlbWVudCkmJihjLnBvaW50ZXIucmVzZXQoKSxjLnBvaW50ZXIuY2hhcnRQb3NpdGlvbj12b2lkIDApO2EmJiFhLmlzSGlkZGVuJiZ0aGlzLnJlc2V0KCl9O2YucHJvdG90eXBlLm9uQ29udGFpbmVyTW91c2VFbnRlcj1cbmZ1bmN0aW9uKGUpe2RlbGV0ZSB0aGlzLmNoYXJ0UG9zaXRpb259O2YucHJvdG90eXBlLm9uQ29udGFpbmVyTW91c2VNb3ZlPWZ1bmN0aW9uKGUpe3ZhciBjPXRoaXMuY2hhcnQ7ZT10aGlzLm5vcm1hbGl6ZShlKTt0aGlzLnNldEhvdmVyQ2hhcnRJbmRleCgpO2UucHJldmVudERlZmF1bHR8fChlLnJldHVyblZhbHVlPSExKTsoXCJtb3VzZWRvd25cIj09PWMubW91c2VJc0Rvd258fHRoaXMudG91Y2hTZWxlY3QoZSkpJiZ0aGlzLmRyYWcoZSk7Yy5vcGVuTWVudXx8IXRoaXMuaW5DbGFzcyhlLnRhcmdldCxcImhpZ2hjaGFydHMtdHJhY2tlclwiKSYmIWMuaXNJbnNpZGVQbG90KGUuY2hhcnRYLWMucGxvdExlZnQsZS5jaGFydFktYy5wbG90VG9wKXx8dGhpcy5ydW5Qb2ludEFjdGlvbnMoZSl9O2YucHJvdG90eXBlLm9uRG9jdW1lbnRUb3VjaEVuZD1mdW5jdGlvbihlKXtEW2QuaG92ZXJDaGFydEluZGV4XSYmRFtkLmhvdmVyQ2hhcnRJbmRleF0ucG9pbnRlci5kcm9wKGUpfTtmLnByb3RvdHlwZS5vbkNvbnRhaW5lclRvdWNoTW92ZT1cbmZ1bmN0aW9uKGUpe2lmKHRoaXMudG91Y2hTZWxlY3QoZSkpdGhpcy5vbkNvbnRhaW5lck1vdXNlTW92ZShlKTtlbHNlIHRoaXMudG91Y2goZSl9O2YucHJvdG90eXBlLm9uQ29udGFpbmVyVG91Y2hTdGFydD1mdW5jdGlvbihlKXtpZih0aGlzLnRvdWNoU2VsZWN0KGUpKXRoaXMub25Db250YWluZXJNb3VzZURvd24oZSk7ZWxzZSB0aGlzLnpvb21PcHRpb24oZSksdGhpcy50b3VjaChlLCEwKX07Zi5wcm90b3R5cGUub25Eb2N1bWVudE1vdXNlTW92ZT1mdW5jdGlvbihlKXt2YXIgYz10aGlzLmNoYXJ0LGE9dGhpcy5jaGFydFBvc2l0aW9uO2U9dGhpcy5ub3JtYWxpemUoZSxhKTt2YXIgYj1jLnRvb2x0aXA7IWF8fGImJmIuaXNTdGlja3lPbkNvbnRhY3QoKXx8Yy5pc0luc2lkZVBsb3QoZS5jaGFydFgtYy5wbG90TGVmdCxlLmNoYXJ0WS1jLnBsb3RUb3ApfHx0aGlzLmluQ2xhc3MoZS50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIil8fHRoaXMucmVzZXQoKX07Zi5wcm90b3R5cGUub25Eb2N1bWVudE1vdXNlVXA9XG5mdW5jdGlvbihlKXt2YXIgYz1EW3ooZC5ob3ZlckNoYXJ0SW5kZXgsLTEpXTtjJiZjLnBvaW50ZXIuZHJvcChlKX07Zi5wcm90b3R5cGUucGluY2g9ZnVuY3Rpb24oZSl7dmFyIGM9dGhpcyxhPWMuY2hhcnQsYj1jLnBpbmNoRG93bixkPWUudG91Y2hlc3x8W10sZj1kLmxlbmd0aCxtPWMubGFzdFZhbGlkVG91Y2gsbj1jLmhhc1pvb20sbD1jLnNlbGVjdGlvbk1hcmtlcixxPXt9LHI9MT09PWYmJihjLmluQ2xhc3MoZS50YXJnZXQsXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikmJmEucnVuVHJhY2tlckNsaWNrfHxjLnJ1bkNoYXJ0Q2xpY2spLGs9e307MTxmJiYoYy5pbml0aWF0ZWQ9ITApO24mJmMuaW5pdGlhdGVkJiYhciYmITEhPT1lLmNhbmNlbGFibGUmJmUucHJldmVudERlZmF1bHQoKTtbXS5tYXAuY2FsbChkLGZ1bmN0aW9uKGEpe3JldHVybiBjLm5vcm1hbGl6ZShhKX0pO1widG91Y2hzdGFydFwiPT09ZS50eXBlPyhbXS5mb3JFYWNoLmNhbGwoZCxmdW5jdGlvbihhLGUpe2JbZV09e2NoYXJ0WDphLmNoYXJ0WCxcbmNoYXJ0WTphLmNoYXJ0WX19KSxtLng9W2JbMF0uY2hhcnRYLGJbMV0mJmJbMV0uY2hhcnRYXSxtLnk9W2JbMF0uY2hhcnRZLGJbMV0mJmJbMV0uY2hhcnRZXSxhLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihiKXtpZihiLnpvb21FbmFibGVkKXt2YXIgZT1hLmJvdW5kc1tiLmhvcml6P1wiaFwiOlwidlwiXSxjPWIubWluUGl4ZWxQYWRkaW5nLGc9Yi50b1BpeGVscyhNYXRoLm1pbih6KGIub3B0aW9ucy5taW4sYi5kYXRhTWluKSxiLmRhdGFNaW4pKSxkPWIudG9QaXhlbHMoTWF0aC5tYXgoeihiLm9wdGlvbnMubWF4LGIuZGF0YU1heCksYi5kYXRhTWF4KSksZj1NYXRoLm1heChnLGQpO2UubWluPU1hdGgubWluKGIucG9zLE1hdGgubWluKGcsZCktYyk7ZS5tYXg9TWF0aC5tYXgoYi5wb3MrYi5sZW4sZitjKX19KSxjLnJlcz0hMCk6Yy5mb2xsb3dUb3VjaE1vdmUmJjE9PT1mP3RoaXMucnVuUG9pbnRBY3Rpb25zKGMubm9ybWFsaXplKGUpKTpiLmxlbmd0aCYmKGx8fChjLnNlbGVjdGlvbk1hcmtlcj1cbmw9Zyh7ZGVzdHJveTpILHRvdWNoOiEwfSxhLnBsb3RCb3gpKSxjLnBpbmNoVHJhbnNsYXRlKGIsZCxxLGwsayxtKSxjLmhhc1BpbmNoZWQ9bixjLnNjYWxlR3JvdXBzKHEsayksYy5yZXMmJihjLnJlcz0hMSx0aGlzLnJlc2V0KCExLDApKSl9O2YucHJvdG90eXBlLnBpbmNoVHJhbnNsYXRlPWZ1bmN0aW9uKGUsYyxhLGIsZyxkKXt0aGlzLnpvb21Ib3ImJnRoaXMucGluY2hUcmFuc2xhdGVEaXJlY3Rpb24oITAsZSxjLGEsYixnLGQpO3RoaXMuem9vbVZlcnQmJnRoaXMucGluY2hUcmFuc2xhdGVEaXJlY3Rpb24oITEsZSxjLGEsYixnLGQpfTtmLnByb3RvdHlwZS5waW5jaFRyYW5zbGF0ZURpcmVjdGlvbj1mdW5jdGlvbihlLGMsYSxiLGcsZCxmLG0pe3ZhciBoPXRoaXMuY2hhcnQsbj1lP1wieFwiOlwieVwiLGw9ZT9cIlhcIjpcIllcIix3PVwiY2hhcnRcIitsLHE9ZT9cIndpZHRoXCI6XCJoZWlnaHRcIixyPWhbXCJwbG90XCIrKGU/XCJMZWZ0XCI6XCJUb3BcIildLHAsSixGPW18fDEsaz1oLmludmVydGVkLHU9aC5ib3VuZHNbZT9cblwiaFwiOlwidlwiXSx5PTE9PT1jLmxlbmd0aCxJPWNbMF1bd10sdD1hWzBdW3ddLHo9IXkmJmNbMV1bd10sTz0heSYmYVsxXVt3XTthPWZ1bmN0aW9uKCl7XCJudW1iZXJcIj09PXR5cGVvZiBPJiYyMDxNYXRoLmFicyhJLXopJiYoRj1tfHxNYXRoLmFicyh0LU8pL01hdGguYWJzKEkteikpO0o9KHItdCkvRitJO3A9aFtcInBsb3RcIisoZT9cIldpZHRoXCI6XCJIZWlnaHRcIildL0Z9O2EoKTtjPUo7aWYoYzx1Lm1pbil7Yz11Lm1pbjt2YXIgQT0hMH1lbHNlIGMrcD51Lm1heCYmKGM9dS5tYXgtcCxBPSEwKTtBPyh0LT0uOCoodC1mW25dWzBdKSxcIm51bWJlclwiPT09dHlwZW9mIE8mJihPLT0uOCooTy1mW25dWzFdKSksYSgpKTpmW25dPVt0LE9dO2t8fChkW25dPUotcixkW3FdPXApO2Q9az8xL0Y6RjtnW3FdPXA7Z1tuXT1jO2Jbaz9lP1wic2NhbGVZXCI6XCJzY2FsZVhcIjpcInNjYWxlXCIrbF09RjtiW1widHJhbnNsYXRlXCIrbF09ZCpyKyh0LWQqSSl9O2YucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKGUsYyl7dmFyIGE9XG50aGlzLmNoYXJ0LGI9YS5ob3ZlclNlcmllcyxnPWEuaG92ZXJQb2ludCxkPWEuaG92ZXJQb2ludHMsZj1hLnRvb2x0aXAsaD1mJiZmLnNoYXJlZD9kOmc7ZSYmaCYmbShoKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2Euc2VyaWVzLmlzQ2FydGVzaWFuJiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEucGxvdFgmJihlPSExKX0pO2lmKGUpZiYmaCYmbShoKS5sZW5ndGgmJihmLnJlZnJlc2goaCksZi5zaGFyZWQmJmQ/ZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe2Euc2V0U3RhdGUoYS5zdGF0ZSwhMCk7YS5zZXJpZXMuaXNDYXJ0ZXNpYW4mJihhLnNlcmllcy54QXhpcy5jcm9zc2hhaXImJmEuc2VyaWVzLnhBeGlzLmRyYXdDcm9zc2hhaXIobnVsbCxhKSxhLnNlcmllcy55QXhpcy5jcm9zc2hhaXImJmEuc2VyaWVzLnlBeGlzLmRyYXdDcm9zc2hhaXIobnVsbCxhKSl9KTpnJiYoZy5zZXRTdGF0ZShnLnN0YXRlLCEwKSxhLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihhKXthLmNyb3NzaGFpciYmZy5zZXJpZXNbYS5jb2xsXT09PVxuYSYmYS5kcmF3Q3Jvc3NoYWlyKG51bGwsZyl9KSkpO2Vsc2V7aWYoZylnLm9uTW91c2VPdXQoKTtkJiZkLmZvckVhY2goZnVuY3Rpb24oYSl7YS5zZXRTdGF0ZSgpfSk7aWYoYiliLm9uTW91c2VPdXQoKTtmJiZmLmhpZGUoYyk7dGhpcy51bkRvY01vdXNlTW92ZSYmKHRoaXMudW5Eb2NNb3VzZU1vdmU9dGhpcy51bkRvY01vdXNlTW92ZSgpKTthLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihhKXthLmhpZGVDcm9zc2hhaXIoKX0pO3RoaXMuaG92ZXJYPWEuaG92ZXJQb2ludHM9YS5ob3ZlclBvaW50PW51bGx9fTtmLnByb3RvdHlwZS5ydW5Qb2ludEFjdGlvbnM9ZnVuY3Rpb24oZSxjKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS50b29sdGlwJiZhLnRvb2x0aXAub3B0aW9ucy5lbmFibGVkP2EudG9vbHRpcDp2b2lkIDAsZz1iP2Iuc2hhcmVkOiExLGY9Y3x8YS5ob3ZlclBvaW50LGg9ZiYmZi5zZXJpZXN8fGEuaG92ZXJTZXJpZXM7aD10aGlzLmdldEhvdmVyRGF0YShmLGgsYS5zZXJpZXMsKCFlfHxcblwidG91Y2htb3ZlXCIhPT1lLnR5cGUpJiYoISFjfHxoJiZoLmRpcmVjdFRvdWNoJiZ0aGlzLmlzRGlyZWN0VG91Y2gpLGcsZSk7Zj1oLmhvdmVyUG9pbnQ7dmFyIG09aC5ob3ZlclBvaW50cztjPShoPWguaG92ZXJTZXJpZXMpJiZoLnRvb2x0aXBPcHRpb25zLmZvbGxvd1BvaW50ZXI7Zz1nJiZoJiYhaC5ub1NoYXJlZFRvb2x0aXA7aWYoZiYmKGYhPT1hLmhvdmVyUG9pbnR8fGImJmIuaXNIaWRkZW4pKXsoYS5ob3ZlclBvaW50c3x8W10pLmZvckVhY2goZnVuY3Rpb24oYSl7LTE9PT1tLmluZGV4T2YoYSkmJmEuc2V0U3RhdGUoKX0pO2lmKGEuaG92ZXJTZXJpZXMhPT1oKWgub25Nb3VzZU92ZXIoKTt0aGlzLmFwcGx5SW5hY3RpdmVTdGF0ZShtKTsobXx8W10pLmZvckVhY2goZnVuY3Rpb24oYSl7YS5zZXRTdGF0ZShcImhvdmVyXCIpfSk7YS5ob3ZlclBvaW50JiZhLmhvdmVyUG9pbnQuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU91dFwiKTtpZighZi5zZXJpZXMpcmV0dXJuO2EuaG92ZXJQb2ludHM9XG5tO2EuaG92ZXJQb2ludD1mO2YuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU92ZXJcIik7YiYmYi5yZWZyZXNoKGc/bTpmLGUpfWVsc2UgYyYmYiYmIWIuaXNIaWRkZW4mJihmPWIuZ2V0QW5jaG9yKFt7fV0sZSksYi51cGRhdGVQb3NpdGlvbih7cGxvdFg6ZlswXSxwbG90WTpmWzFdfSkpO3RoaXMudW5Eb2NNb3VzZU1vdmV8fCh0aGlzLnVuRG9jTW91c2VNb3ZlPXQoYS5jb250YWluZXIub3duZXJEb2N1bWVudCxcIm1vdXNlbW92ZVwiLGZ1bmN0aW9uKGEpe3ZhciBiPURbZC5ob3ZlckNoYXJ0SW5kZXhdO2lmKGIpYi5wb2ludGVyLm9uRG9jdW1lbnRNb3VzZU1vdmUoYSl9KSk7YS5heGVzLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGM9eigoYi5jcm9zc2hhaXJ8fHt9KS5zbmFwLCEwKSxnO2MmJigoZz1hLmhvdmVyUG9pbnQpJiZnLnNlcmllc1tiLmNvbGxdPT09Ynx8KGc9eShtLGZ1bmN0aW9uKGEpe3JldHVybiBhLnNlcmllc1tiLmNvbGxdPT09Yn0pKSk7Z3x8IWM/Yi5kcmF3Q3Jvc3NoYWlyKGUsXG5nKTpiLmhpZGVDcm9zc2hhaXIoKX0pfTtmLnByb3RvdHlwZS5zY2FsZUdyb3Vwcz1mdW5jdGlvbihlLGMpe3ZhciBhPXRoaXMuY2hhcnQsYjthLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGcpe2I9ZXx8Zy5nZXRQbG90Qm94KCk7Zy54QXhpcyYmZy54QXhpcy56b29tRW5hYmxlZCYmZy5ncm91cCYmKGcuZ3JvdXAuYXR0cihiKSxnLm1hcmtlckdyb3VwJiYoZy5tYXJrZXJHcm91cC5hdHRyKGIpLGcubWFya2VyR3JvdXAuY2xpcChjP2EuY2xpcFJlY3Q6bnVsbCkpLGcuZGF0YUxhYmVsc0dyb3VwJiZnLmRhdGFMYWJlbHNHcm91cC5hdHRyKGIpKX0pO2EuY2xpcFJlY3QuYXR0cihjfHxhLmNsaXBCb3gpfTtmLnByb3RvdHlwZS5zZXRET01FdmVudHM9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLGM9dGhpcy5jaGFydC5jb250YWluZXIsYT1jLm93bmVyRG9jdW1lbnQ7Yy5vbm1vdXNlZG93bj10aGlzLm9uQ29udGFpbmVyTW91c2VEb3duLmJpbmQodGhpcyk7Yy5vbm1vdXNlbW92ZT10aGlzLm9uQ29udGFpbmVyTW91c2VNb3ZlLmJpbmQodGhpcyk7XG5jLm9uY2xpY2s9dGhpcy5vbkNvbnRhaW5lckNsaWNrLmJpbmQodGhpcyk7dGhpcy51bmJpbmRDb250YWluZXJNb3VzZUVudGVyPXQoYyxcIm1vdXNlZW50ZXJcIix0aGlzLm9uQ29udGFpbmVyTW91c2VFbnRlci5iaW5kKHRoaXMpKTt0aGlzLnVuYmluZENvbnRhaW5lck1vdXNlTGVhdmU9dChjLFwibW91c2VsZWF2ZVwiLHRoaXMub25Db250YWluZXJNb3VzZUxlYXZlLmJpbmQodGhpcykpO2QudW5iaW5kRG9jdW1lbnRNb3VzZVVwfHwoZC51bmJpbmREb2N1bWVudE1vdXNlVXA9dChhLFwibW91c2V1cFwiLHRoaXMub25Eb2N1bWVudE1vdXNlVXAuYmluZCh0aGlzKSkpO2Zvcih2YXIgYj10aGlzLmNoYXJ0LnJlbmRlclRvLnBhcmVudEVsZW1lbnQ7YiYmXCJCT0RZXCIhPT1iLnRhZ05hbWU7KXQoYixcInNjcm9sbFwiLGZ1bmN0aW9uKCl7ZGVsZXRlIGUuY2hhcnRQb3NpdGlvbn0pLGI9Yi5wYXJlbnRFbGVtZW50O2QuaGFzVG91Y2gmJih0KGMsXCJ0b3VjaHN0YXJ0XCIsdGhpcy5vbkNvbnRhaW5lclRvdWNoU3RhcnQuYmluZCh0aGlzKSxcbntwYXNzaXZlOiExfSksdChjLFwidG91Y2htb3ZlXCIsdGhpcy5vbkNvbnRhaW5lclRvdWNoTW92ZS5iaW5kKHRoaXMpLHtwYXNzaXZlOiExfSksZC51bmJpbmREb2N1bWVudFRvdWNoRW5kfHwoZC51bmJpbmREb2N1bWVudFRvdWNoRW5kPXQoYSxcInRvdWNoZW5kXCIsdGhpcy5vbkRvY3VtZW50VG91Y2hFbmQuYmluZCh0aGlzKSx7cGFzc2l2ZTohMX0pKSl9O2YucHJvdG90eXBlLnNldEhvdmVyQ2hhcnRJbmRleD1mdW5jdGlvbigpe3ZhciBlPXRoaXMuY2hhcnQsYz1kLmNoYXJ0c1t6KGQuaG92ZXJDaGFydEluZGV4LC0xKV07aWYoYyYmYyE9PWUpYy5wb2ludGVyLm9uQ29udGFpbmVyTW91c2VMZWF2ZSh7cmVsYXRlZFRhcmdldDohMH0pO2MmJmMubW91c2VJc0Rvd258fChkLmhvdmVyQ2hhcnRJbmRleD1lLmluZGV4KX07Zi5wcm90b3R5cGUudG91Y2g9ZnVuY3Rpb24oZSxjKXt2YXIgYT10aGlzLmNoYXJ0LGI7dGhpcy5zZXRIb3ZlckNoYXJ0SW5kZXgoKTtpZigxPT09ZS50b3VjaGVzLmxlbmd0aClpZihlPVxudGhpcy5ub3JtYWxpemUoZSksKGI9YS5pc0luc2lkZVBsb3QoZS5jaGFydFgtYS5wbG90TGVmdCxlLmNoYXJ0WS1hLnBsb3RUb3ApKSYmIWEub3Blbk1lbnUpe2MmJnRoaXMucnVuUG9pbnRBY3Rpb25zKGUpO2lmKFwidG91Y2htb3ZlXCI9PT1lLnR5cGUpe2M9dGhpcy5waW5jaERvd247dmFyIGc9Y1swXT80PD1NYXRoLnNxcnQoTWF0aC5wb3coY1swXS5jaGFydFgtZS5jaGFydFgsMikrTWF0aC5wb3coY1swXS5jaGFydFktZS5jaGFydFksMikpOiExfXooZywhMCkmJnRoaXMucGluY2goZSl9ZWxzZSBjJiZ0aGlzLnJlc2V0KCk7ZWxzZSAyPT09ZS50b3VjaGVzLmxlbmd0aCYmdGhpcy5waW5jaChlKX07Zi5wcm90b3R5cGUudG91Y2hTZWxlY3Q9ZnVuY3Rpb24oZSl7cmV0dXJuISghdGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0Lnpvb21CeVNpbmdsZVRvdWNofHwhZS50b3VjaGVzfHwxIT09ZS50b3VjaGVzLmxlbmd0aCl9O2YucHJvdG90eXBlLnpvb21PcHRpb249ZnVuY3Rpb24oZSl7dmFyIGM9XG50aGlzLmNoYXJ0LGE9Yy5vcHRpb25zLmNoYXJ0LGI9YS56b29tVHlwZXx8XCJcIjtjPWMuaW52ZXJ0ZWQ7L3RvdWNoLy50ZXN0KGUudHlwZSkmJihiPXooYS5waW5jaFR5cGUsYikpO3RoaXMuem9vbVg9ZT0veC8udGVzdChiKTt0aGlzLnpvb21ZPWI9L3kvLnRlc3QoYik7dGhpcy56b29tSG9yPWUmJiFjfHxiJiZjO3RoaXMuem9vbVZlcnQ9YiYmIWN8fGUmJmM7dGhpcy5oYXNab29tPWV8fGJ9O3JldHVybiBmfSgpO3JldHVybiBkLlBvaW50ZXI9Zn0pO1AoayxcIkNvcmUvTVNQb2ludGVyLmpzXCIsW2tbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvUG9pbnRlci5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCxrKXtmdW5jdGlvbiB4KCl7dmFyIGM9W107Yy5pdGVtPWZ1bmN0aW9uKGMpe3JldHVybiB0aGlzW2NdfTtFKHksZnVuY3Rpb24oZyl7Yy5wdXNoKHtwYWdlWDpnLnBhZ2VYLHBhZ2VZOmcucGFnZVksdGFyZ2V0OmcudGFyZ2V0fSl9KTtyZXR1cm4gY31mdW5jdGlvbiBCKGMsXG5nLGQsbCl7XCJ0b3VjaFwiIT09Yy5wb2ludGVyVHlwZSYmYy5wb2ludGVyVHlwZSE9PWMuTVNQT0lOVEVSX1RZUEVfVE9VQ0h8fCFEW2YuaG92ZXJDaGFydEluZGV4XXx8KGwoYyksbD1EW2YuaG92ZXJDaGFydEluZGV4XS5wb2ludGVyLGxbZ10oe3R5cGU6ZCx0YXJnZXQ6Yy5jdXJyZW50VGFyZ2V0LHByZXZlbnREZWZhdWx0OnQsdG91Y2hlczp4KCl9KSl9dmFyIEc9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIGM9ZnVuY3Rpb24oZyxkKXtjPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihjLGcpe2MuX19wcm90b19fPWd9fHxmdW5jdGlvbihjLGcpe2Zvcih2YXIgZCBpbiBnKWcuaGFzT3duUHJvcGVydHkoZCkmJihjW2RdPWdbZF0pfTtyZXR1cm4gYyhnLGQpfTtyZXR1cm4gZnVuY3Rpb24oZyxkKXtmdW5jdGlvbiBmKCl7dGhpcy5jb25zdHJ1Y3Rvcj1nfWMoZyxkKTtnLnByb3RvdHlwZT1udWxsPT09XG5kP09iamVjdC5jcmVhdGUoZCk6KGYucHJvdG90eXBlPWQucHJvdG90eXBlLG5ldyBmKX19KCksRD1mLmNoYXJ0cyxIPWYuZG9jLHQ9Zi5ub29wLEM9ay5hZGRFdmVudCxsPWsuY3NzLEU9ay5vYmplY3RFYWNoLGc9ay5yZW1vdmVFdmVudCx5PXt9LGM9ISFmLndpbi5Qb2ludGVyRXZlbnQ7cmV0dXJuIGZ1bmN0aW9uKGQpe2Z1bmN0aW9uIGYoKXtyZXR1cm4gbnVsbCE9PWQmJmQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzfUcoZixkKTtmLnByb3RvdHlwZS5iYXRjaE1TRXZlbnRzPWZ1bmN0aW9uKGcpe2codGhpcy5jaGFydC5jb250YWluZXIsYz9cInBvaW50ZXJkb3duXCI6XCJNU1BvaW50ZXJEb3duXCIsdGhpcy5vbkNvbnRhaW5lclBvaW50ZXJEb3duKTtnKHRoaXMuY2hhcnQuY29udGFpbmVyLGM/XCJwb2ludGVybW92ZVwiOlwiTVNQb2ludGVyTW92ZVwiLHRoaXMub25Db250YWluZXJQb2ludGVyTW92ZSk7ZyhILGM/XCJwb2ludGVydXBcIjpcIk1TUG9pbnRlclVwXCIsdGhpcy5vbkRvY3VtZW50UG9pbnRlclVwKX07XG5mLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5iYXRjaE1TRXZlbnRzKGcpO2QucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKX07Zi5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihjLGcpe2QucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzLGMsZyk7dGhpcy5oYXNab29tJiZsKGMuY29udGFpbmVyLHtcIi1tcy10b3VjaC1hY3Rpb25cIjpcIm5vbmVcIixcInRvdWNoLWFjdGlvblwiOlwibm9uZVwifSl9O2YucHJvdG90eXBlLm9uQ29udGFpbmVyUG9pbnRlckRvd249ZnVuY3Rpb24oYyl7QihjLFwib25Db250YWluZXJUb3VjaFN0YXJ0XCIsXCJ0b3VjaHN0YXJ0XCIsZnVuY3Rpb24oYyl7eVtjLnBvaW50ZXJJZF09e3BhZ2VYOmMucGFnZVgscGFnZVk6Yy5wYWdlWSx0YXJnZXQ6Yy5jdXJyZW50VGFyZ2V0fX0pfTtmLnByb3RvdHlwZS5vbkNvbnRhaW5lclBvaW50ZXJNb3ZlPWZ1bmN0aW9uKGMpe0IoYyxcIm9uQ29udGFpbmVyVG91Y2hNb3ZlXCIsXCJ0b3VjaG1vdmVcIixmdW5jdGlvbihjKXt5W2MucG9pbnRlcklkXT1cbntwYWdlWDpjLnBhZ2VYLHBhZ2VZOmMucGFnZVl9O3lbYy5wb2ludGVySWRdLnRhcmdldHx8KHlbYy5wb2ludGVySWRdLnRhcmdldD1jLmN1cnJlbnRUYXJnZXQpfSl9O2YucHJvdG90eXBlLm9uRG9jdW1lbnRQb2ludGVyVXA9ZnVuY3Rpb24oYyl7QihjLFwib25Eb2N1bWVudFRvdWNoRW5kXCIsXCJ0b3VjaGVuZFwiLGZ1bmN0aW9uKGMpe2RlbGV0ZSB5W2MucG9pbnRlcklkXX0pfTtmLnByb3RvdHlwZS5zZXRET01FdmVudHM9ZnVuY3Rpb24oKXtkLnByb3RvdHlwZS5zZXRET01FdmVudHMuY2FsbCh0aGlzKTsodGhpcy5oYXNab29tfHx0aGlzLmZvbGxvd1RvdWNoTW92ZSkmJnRoaXMuYmF0Y2hNU0V2ZW50cyhDKX07cmV0dXJuIGZ9KGQpfSk7UChrLFwiQ29yZS9TZXJpZXMvUG9pbnQuanNcIixba1tcIkNvcmUvUmVuZGVyZXIvSFRNTC9BU1QuanNcIl0sa1tcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL09wdGlvbnMuanNcIl0sXG5rW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCxrLHgsQil7dmFyIEc9ZC5hbmltT2JqZWN0LEQ9eC5kZWZhdWx0T3B0aW9ucyxIPUIuYWRkRXZlbnQsdD1CLmRlZmluZWQsQz1CLmVyYXNlLGw9Qi5leHRlbmQsRT1CLmZpcmVFdmVudCxnPUIuZm9ybWF0LHk9Qi5nZXROZXN0ZWRQcm9wZXJ0eSxjPUIuaXNBcnJheSxxPUIuaXNGdW5jdGlvbixuPUIuaXNOdW1iZXIsQT1CLmlzT2JqZWN0LE09Qi5tZXJnZSx6PUIub2JqZWN0RWFjaCxtPUIucGljayxyPUIuc3luY1RpbWVvdXQsZT1CLnJlbW92ZUV2ZW50LGg9Qi51bmlxdWVLZXk7XCJcIjtkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe3RoaXMuY29sb3JJbmRleD10aGlzLmNhdGVnb3J5PXZvaWQgMDt0aGlzLmZvcm1hdFByZWZpeD1cInBvaW50XCI7dGhpcy5pZD12b2lkIDA7dGhpcy5pc051bGw9ITE7dGhpcy5wZXJjZW50YWdlPXRoaXMub3B0aW9ucz10aGlzLm5hbWU9dm9pZCAwO3RoaXMuc2VsZWN0ZWQ9ITE7dGhpcy50b3RhbD1cbnRoaXMuc2VyaWVzPXZvaWQgMDt0aGlzLnZpc2libGU9ITA7dGhpcy54PXZvaWQgMH1hLnByb3RvdHlwZS5hbmltYXRlQmVmb3JlRGVzdHJveT1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYz17eDphLnN0YXJ0WFBvcyxvcGFjaXR5OjB9LGUsZz1hLmdldEdyYXBoaWNhbFByb3BzKCk7Zy5zaW5ndWxhci5mb3JFYWNoKGZ1bmN0aW9uKGIpe2U9XCJkYXRhTGFiZWxcIj09PWI7YVtiXT1hW2JdLmFuaW1hdGUoZT97eDphW2JdLnN0YXJ0WFBvcyx5OmFbYl0uc3RhcnRZUG9zLG9wYWNpdHk6MH06Yyl9KTtnLnBsdXJhbC5mb3JFYWNoKGZ1bmN0aW9uKGIpe2FbYl0uZm9yRWFjaChmdW5jdGlvbihiKXtiLmVsZW1lbnQmJmIuYW5pbWF0ZShsKHt4OmEuc3RhcnRYUG9zfSxiLnN0YXJ0WVBvcz97eDpiLnN0YXJ0WFBvcyx5OmIuc3RhcnRZUG9zfTp7fSkpfSl9KX07YS5wcm90b3R5cGUuYXBwbHlPcHRpb25zPWZ1bmN0aW9uKGIsYyl7dmFyIGU9dGhpcy5zZXJpZXMsZz1lLm9wdGlvbnMucG9pbnRWYWxLZXl8fFxuZS5wb2ludFZhbEtleTtiPWEucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdC5jYWxsKHRoaXMsYik7bCh0aGlzLGIpO3RoaXMub3B0aW9ucz10aGlzLm9wdGlvbnM/bCh0aGlzLm9wdGlvbnMsYik6YjtiLmdyb3VwJiZkZWxldGUgdGhpcy5ncm91cDtiLmRhdGFMYWJlbHMmJmRlbGV0ZSB0aGlzLmRhdGFMYWJlbHM7ZyYmKHRoaXMueT1hLnByb3RvdHlwZS5nZXROZXN0ZWRQcm9wZXJ0eS5jYWxsKHRoaXMsZykpO3RoaXMuZm9ybWF0UHJlZml4PSh0aGlzLmlzTnVsbD1tKHRoaXMuaXNWYWxpZCYmIXRoaXMuaXNWYWxpZCgpLG51bGw9PT10aGlzLnh8fCFuKHRoaXMueSkpKT9cIm51bGxcIjpcInBvaW50XCI7dGhpcy5zZWxlY3RlZCYmKHRoaXMuc3RhdGU9XCJzZWxlY3RcIik7XCJuYW1lXCJpbiB0aGlzJiZcInVuZGVmaW5lZFwiPT09dHlwZW9mIGMmJmUueEF4aXMmJmUueEF4aXMuaGFzTmFtZXMmJih0aGlzLng9ZS54QXhpcy5uYW1lVG9YKHRoaXMpKTtcInVuZGVmaW5lZFwiPT09dHlwZW9mIHRoaXMueCYmXG5lJiYodGhpcy54PVwidW5kZWZpbmVkXCI9PT10eXBlb2YgYz9lLmF1dG9JbmNyZW1lbnQodGhpcyk6Yyk7cmV0dXJuIHRoaXN9O2EucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7aWYoYy5ncmFwaGljfHxjLmRhdGFMYWJlbHx8Yy5kYXRhTGFiZWxzKWUoYyksYy5kZXN0cm95RWxlbWVudHMoKTtmb3IobSBpbiBjKWNbbV09bnVsbH12YXIgYz10aGlzLGc9Yy5zZXJpZXMsZD1nLmNoYXJ0O2c9Zy5vcHRpb25zLmRhdGFTb3J0aW5nO3ZhciBmPWQuaG92ZXJQb2ludHMsaD1HKGMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLmdsb2JhbEFuaW1hdGlvbiksbTtjLmxlZ2VuZEl0ZW0mJmQubGVnZW5kLmRlc3Ryb3lJdGVtKGMpO2YmJihjLnNldFN0YXRlKCksQyhmLGMpLGYubGVuZ3RofHwoZC5ob3ZlclBvaW50cz1udWxsKSk7aWYoYz09PWQuaG92ZXJQb2ludCljLm9uTW91c2VPdXQoKTtnJiZnLmVuYWJsZWQ/KHRoaXMuYW5pbWF0ZUJlZm9yZURlc3Ryb3koKSxyKGEsaC5kdXJhdGlvbikpOlxuYSgpO2QucG9pbnRDb3VudC0tfTthLnByb3RvdHlwZS5kZXN0cm95RWxlbWVudHM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthPWIuZ2V0R3JhcGhpY2FsUHJvcHMoYSk7YS5zaW5ndWxhci5mb3JFYWNoKGZ1bmN0aW9uKGEpe2JbYV09YlthXS5kZXN0cm95KCl9KTthLnBsdXJhbC5mb3JFYWNoKGZ1bmN0aW9uKGEpe2JbYV0uZm9yRWFjaChmdW5jdGlvbihhKXthLmVsZW1lbnQmJmEuZGVzdHJveSgpfSk7ZGVsZXRlIGJbYV19KX07YS5wcm90b3R5cGUuZmlyZVBvaW50RXZlbnQ9ZnVuY3Rpb24oYSxjLGUpe3ZhciBiPXRoaXMsZz10aGlzLnNlcmllcy5vcHRpb25zOyhnLnBvaW50LmV2ZW50c1thXXx8Yi5vcHRpb25zJiZiLm9wdGlvbnMuZXZlbnRzJiZiLm9wdGlvbnMuZXZlbnRzW2FdKSYmYi5pbXBvcnRFdmVudHMoKTtcImNsaWNrXCI9PT1hJiZnLmFsbG93UG9pbnRTZWxlY3QmJihlPWZ1bmN0aW9uKGEpe2Iuc2VsZWN0JiZiLnNlbGVjdChudWxsLGEuY3RybEtleXx8YS5tZXRhS2V5fHxcbmEuc2hpZnRLZXkpfSk7RShiLGEsYyxlKX07YS5wcm90b3R5cGUuZ2V0Q2xhc3NOYW1lPWZ1bmN0aW9uKCl7cmV0dXJuXCJoaWdoY2hhcnRzLXBvaW50XCIrKHRoaXMuc2VsZWN0ZWQ/XCIgaGlnaGNoYXJ0cy1wb2ludC1zZWxlY3RcIjpcIlwiKSsodGhpcy5uZWdhdGl2ZT9cIiBoaWdoY2hhcnRzLW5lZ2F0aXZlXCI6XCJcIikrKHRoaXMuaXNOdWxsP1wiIGhpZ2hjaGFydHMtbnVsbC1wb2ludFwiOlwiXCIpKyhcInVuZGVmaW5lZFwiIT09dHlwZW9mIHRoaXMuY29sb3JJbmRleD9cIiBoaWdoY2hhcnRzLWNvbG9yLVwiK3RoaXMuY29sb3JJbmRleDpcIlwiKSsodGhpcy5vcHRpb25zLmNsYXNzTmFtZT9cIiBcIit0aGlzLm9wdGlvbnMuY2xhc3NOYW1lOlwiXCIpKyh0aGlzLnpvbmUmJnRoaXMuem9uZS5jbGFzc05hbWU/XCIgXCIrdGhpcy56b25lLmNsYXNzTmFtZS5yZXBsYWNlKFwiaGlnaGNoYXJ0cy1uZWdhdGl2ZVwiLFwiXCIpOlwiXCIpfTthLnByb3RvdHlwZS5nZXRHcmFwaGljYWxQcm9wcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9XG5bXSxlLGc9e3Npbmd1bGFyOltdLHBsdXJhbDpbXX07YT1hfHx7Z3JhcGhpYzoxLGRhdGFMYWJlbDoxfTthLmdyYXBoaWMmJmMucHVzaChcImdyYXBoaWNcIixcInVwcGVyR3JhcGhpY1wiLFwic2hhZG93R3JvdXBcIik7YS5kYXRhTGFiZWwmJmMucHVzaChcImRhdGFMYWJlbFwiLFwiZGF0YUxhYmVsVXBwZXJcIixcImNvbm5lY3RvclwiKTtmb3IoZT1jLmxlbmd0aDtlLS07KXt2YXIgZD1jW2VdO2JbZF0mJmcuc2luZ3VsYXIucHVzaChkKX1bXCJkYXRhTGFiZWxcIixcImNvbm5lY3RvclwiXS5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBlPWMrXCJzXCI7YVtjXSYmYltlXSYmZy5wbHVyYWwucHVzaChlKX0pO3JldHVybiBnfTthLnByb3RvdHlwZS5nZXRMYWJlbENvbmZpZz1mdW5jdGlvbigpe3JldHVybnt4OnRoaXMuY2F0ZWdvcnkseTp0aGlzLnksY29sb3I6dGhpcy5jb2xvcixjb2xvckluZGV4OnRoaXMuY29sb3JJbmRleCxrZXk6dGhpcy5uYW1lfHx0aGlzLmNhdGVnb3J5LHNlcmllczp0aGlzLnNlcmllcyxwb2ludDp0aGlzLFxucGVyY2VudGFnZTp0aGlzLnBlcmNlbnRhZ2UsdG90YWw6dGhpcy50b3RhbHx8dGhpcy5zdGFja1RvdGFsfX07YS5wcm90b3R5cGUuZ2V0TmVzdGVkUHJvcGVydHk9ZnVuY3Rpb24oYSl7aWYoYSlyZXR1cm4gMD09PWEuaW5kZXhPZihcImN1c3RvbS5cIik/eShhLHRoaXMub3B0aW9ucyk6dGhpc1thXX07YS5wcm90b3R5cGUuZ2V0Wm9uZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc2VyaWVzLGM9YS56b25lczthPWEuem9uZUF4aXN8fFwieVwiO3ZhciBlPTAsZztmb3IoZz1jW2VdO3RoaXNbYV0+PWcudmFsdWU7KWc9Y1srK2VdO3RoaXMubm9uWm9uZWRDb2xvcnx8KHRoaXMubm9uWm9uZWRDb2xvcj10aGlzLmNvbG9yKTt0aGlzLmNvbG9yPWcmJmcuY29sb3ImJiF0aGlzLm9wdGlvbnMuY29sb3I/Zy5jb2xvcjp0aGlzLm5vblpvbmVkQ29sb3I7cmV0dXJuIGd9O2EucHJvdG90eXBlLmhhc05ld1NoYXBlVHlwZT1mdW5jdGlvbigpe3JldHVybih0aGlzLmdyYXBoaWMmJih0aGlzLmdyYXBoaWMuc3ltYm9sTmFtZXx8XG50aGlzLmdyYXBoaWMuZWxlbWVudC5ub2RlTmFtZSkpIT09dGhpcy5zaGFwZVR5cGV9O2EucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSxjLGUpe3RoaXMuc2VyaWVzPWE7dGhpcy5hcHBseU9wdGlvbnMoYyxlKTt0aGlzLmlkPXQodGhpcy5pZCk/dGhpcy5pZDpoKCk7dGhpcy5yZXNvbHZlQ29sb3IoKTthLmNoYXJ0LnBvaW50Q291bnQrKztFKHRoaXMsXCJhZnRlckluaXRcIik7cmV0dXJuIHRoaXN9O2EucHJvdG90eXBlLm9wdGlvbnNUb09iamVjdD1mdW5jdGlvbihiKXt2YXIgZT17fSxnPXRoaXMuc2VyaWVzLGQ9Zy5vcHRpb25zLmtleXMsZj1kfHxnLnBvaW50QXJyYXlNYXB8fFtcInlcIl0saD1mLmxlbmd0aCxtPTAsbD0wO2lmKG4oYil8fG51bGw9PT1iKWVbZlswXV09YjtlbHNlIGlmKGMoYikpZm9yKCFkJiZiLmxlbmd0aD5oJiYoZz10eXBlb2YgYlswXSxcInN0cmluZ1wiPT09Zz9lLm5hbWU9YlswXTpcIm51bWJlclwiPT09ZyYmKGUueD1iWzBdKSxtKyspO2w8aDspZCYmXCJ1bmRlZmluZWRcIj09PVxudHlwZW9mIGJbbV18fCgwPGZbbF0uaW5kZXhPZihcIi5cIik/YS5wcm90b3R5cGUuc2V0TmVzdGVkUHJvcGVydHkoZSxiW21dLGZbbF0pOmVbZltsXV09YlttXSksbSsrLGwrKztlbHNlXCJvYmplY3RcIj09PXR5cGVvZiBiJiYoZT1iLGIuZGF0YUxhYmVscyYmKGcuX2hhc1BvaW50TGFiZWxzPSEwKSxiLm1hcmtlciYmKGcuX2hhc1BvaW50TWFya2Vycz0hMCkpO3JldHVybiBlfTthLnByb3RvdHlwZS5yZXNvbHZlQ29sb3I9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnNlcmllczt2YXIgYz1hLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuY29sb3JDb3VudDt2YXIgZT1hLmNoYXJ0LnN0eWxlZE1vZGU7ZGVsZXRlIHRoaXMubm9uWm9uZWRDb2xvcjtlfHx0aGlzLm9wdGlvbnMuY29sb3J8fCh0aGlzLmNvbG9yPWEuY29sb3IpO2Eub3B0aW9ucy5jb2xvckJ5UG9pbnQ/KGV8fChjPWEub3B0aW9ucy5jb2xvcnN8fGEuY2hhcnQub3B0aW9ucy5jb2xvcnMsdGhpcy5jb2xvcj10aGlzLmNvbG9yfHxjW2EuY29sb3JDb3VudGVyXSxcbmM9Yy5sZW5ndGgpLGU9YS5jb2xvckNvdW50ZXIsYS5jb2xvckNvdW50ZXIrKyxhLmNvbG9yQ291bnRlcj09PWMmJihhLmNvbG9yQ291bnRlcj0wKSk6ZT1hLmNvbG9ySW5kZXg7dGhpcy5jb2xvckluZGV4PW0odGhpcy5vcHRpb25zLmNvbG9ySW5kZXgsZSl9O2EucHJvdG90eXBlLnNldE5lc3RlZFByb3BlcnR5PWZ1bmN0aW9uKGEsYyxlKXtlLnNwbGl0KFwiLlwiKS5yZWR1Y2UoZnVuY3Rpb24oYSxiLGUsZyl7YVtiXT1nLmxlbmd0aC0xPT09ZT9jOkEoYVtiXSwhMCk/YVtiXTp7fTtyZXR1cm4gYVtiXX0sYSk7cmV0dXJuIGF9O2EucHJvdG90eXBlLnRvb2x0aXBGb3JtYXR0ZXI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5zZXJpZXMsYz1iLnRvb2x0aXBPcHRpb25zLGU9bShjLnZhbHVlRGVjaW1hbHMsXCJcIiksZD1jLnZhbHVlUHJlZml4fHxcIlwiLGY9Yy52YWx1ZVN1ZmZpeHx8XCJcIjtiLmNoYXJ0LnN0eWxlZE1vZGUmJihhPWIuY2hhcnQudG9vbHRpcC5zdHlsZWRNb2RlRm9ybWF0KGEpKTsoYi5wb2ludEFycmF5TWFwfHxcbltcInlcIl0pLmZvckVhY2goZnVuY3Rpb24oYil7Yj1cIntwb2ludC5cIitiO2lmKGR8fGYpYT1hLnJlcGxhY2UoUmVnRXhwKGIrXCJ9XCIsXCJnXCIpLGQrYitcIn1cIitmKTthPWEucmVwbGFjZShSZWdFeHAoYitcIn1cIixcImdcIiksYitcIjosLlwiK2UrXCJmfVwiKX0pO3JldHVybiBnKGEse3BvaW50OnRoaXMsc2VyaWVzOnRoaXMuc2VyaWVzfSxiLmNoYXJ0KX07YS5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEsYyxlLGcpe2Z1bmN0aW9uIGIoKXtkLmFwcGx5T3B0aW9ucyhhKTt2YXIgYj1oJiZkLmhhc0R1bW15R3JhcGhpYztiPW51bGw9PT1kLnk/IWI6YjtoJiZiJiYoZC5ncmFwaGljPWguZGVzdHJveSgpLGRlbGV0ZSBkLmhhc0R1bW15R3JhcGhpYyk7QShhLCEwKSYmKGgmJmguZWxlbWVudCYmYSYmYS5tYXJrZXImJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgYS5tYXJrZXIuc3ltYm9sJiYoZC5ncmFwaGljPWguZGVzdHJveSgpKSxhJiZhLmRhdGFMYWJlbHMmJmQuZGF0YUxhYmVsJiYoZC5kYXRhTGFiZWw9XG5kLmRhdGFMYWJlbC5kZXN0cm95KCkpLGQuY29ubmVjdG9yJiYoZC5jb25uZWN0b3I9ZC5jb25uZWN0b3IuZGVzdHJveSgpKSk7bD1kLmluZGV4O2YudXBkYXRlUGFyYWxsZWxBcnJheXMoZCxsKTtxLmRhdGFbbF09QShxLmRhdGFbbF0sITApfHxBKGEsITApP2Qub3B0aW9uczptKGEscS5kYXRhW2xdKTtmLmlzRGlydHk9Zi5pc0RpcnR5RGF0YT0hMDshZi5maXhlZEJveCYmZi5oYXNDYXJ0ZXNpYW5TZXJpZXMmJihuLmlzRGlydHlCb3g9ITApO1wicG9pbnRcIj09PXEubGVnZW5kVHlwZSYmKG4uaXNEaXJ0eUxlZ2VuZD0hMCk7YyYmbi5yZWRyYXcoZSl9dmFyIGQ9dGhpcyxmPWQuc2VyaWVzLGg9ZC5ncmFwaGljLGwsbj1mLmNoYXJ0LHE9Zi5vcHRpb25zO2M9bShjLCEwKTshMT09PWc/YigpOmQuZmlyZVBvaW50RXZlbnQoXCJ1cGRhdGVcIix7b3B0aW9uczphfSxiKX07YS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKGEsYyl7dGhpcy5zZXJpZXMucmVtb3ZlUG9pbnQodGhpcy5zZXJpZXMuZGF0YS5pbmRleE9mKHRoaXMpLFxuYSxjKX07YS5wcm90b3R5cGUuc2VsZWN0PWZ1bmN0aW9uKGEsYyl7dmFyIGI9dGhpcyxlPWIuc2VyaWVzLGc9ZS5jaGFydDt0aGlzLnNlbGVjdGVkU3RhZ2luZz1hPW0oYSwhYi5zZWxlY3RlZCk7Yi5maXJlUG9pbnRFdmVudChhP1wic2VsZWN0XCI6XCJ1bnNlbGVjdFwiLHthY2N1bXVsYXRlOmN9LGZ1bmN0aW9uKCl7Yi5zZWxlY3RlZD1iLm9wdGlvbnMuc2VsZWN0ZWQ9YTtlLm9wdGlvbnMuZGF0YVtlLmRhdGEuaW5kZXhPZihiKV09Yi5vcHRpb25zO2Iuc2V0U3RhdGUoYSYmXCJzZWxlY3RcIik7Y3x8Zy5nZXRTZWxlY3RlZFBvaW50cygpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGM9YS5zZXJpZXM7YS5zZWxlY3RlZCYmYSE9PWImJihhLnNlbGVjdGVkPWEub3B0aW9ucy5zZWxlY3RlZD0hMSxjLm9wdGlvbnMuZGF0YVtjLmRhdGEuaW5kZXhPZihhKV09YS5vcHRpb25zLGEuc2V0U3RhdGUoZy5ob3ZlclBvaW50cyYmYy5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHM/XCJpbmFjdGl2ZVwiOlwiXCIpLFxuYS5maXJlUG9pbnRFdmVudChcInVuc2VsZWN0XCIpKX0pfSk7ZGVsZXRlIHRoaXMuc2VsZWN0ZWRTdGFnaW5nfTthLnByb3RvdHlwZS5vbk1vdXNlT3Zlcj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnNlcmllcy5jaGFydCxjPWIucG9pbnRlcjthPWE/Yy5ub3JtYWxpemUoYSk6Yy5nZXRDaGFydENvb3JkaW5hdGVzRnJvbVBvaW50KHRoaXMsYi5pbnZlcnRlZCk7Yy5ydW5Qb2ludEFjdGlvbnMoYSx0aGlzKX07YS5wcm90b3R5cGUub25Nb3VzZU91dD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuc2VyaWVzLmNoYXJ0O3RoaXMuZmlyZVBvaW50RXZlbnQoXCJtb3VzZU91dFwiKTt0aGlzLnNlcmllcy5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHN8fChhLmhvdmVyUG9pbnRzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihhKXthLnNldFN0YXRlKCl9KTthLmhvdmVyUG9pbnRzPWEuaG92ZXJQb2ludD1udWxsfTthLnByb3RvdHlwZS5pbXBvcnRFdmVudHM9ZnVuY3Rpb24oKXtpZighdGhpcy5oYXNJbXBvcnRlZEV2ZW50cyl7dmFyIGE9XG50aGlzLGM9TShhLnNlcmllcy5vcHRpb25zLnBvaW50LGEub3B0aW9ucykuZXZlbnRzO2EuZXZlbnRzPWM7eihjLGZ1bmN0aW9uKGIsYyl7cShiKSYmSChhLGMsYil9KTt0aGlzLmhhc0ltcG9ydGVkRXZlbnRzPSEwfX07YS5wcm90b3R5cGUuc2V0U3RhdGU9ZnVuY3Rpb24oYSxjKXt2YXIgYj10aGlzLnNlcmllcyxlPXRoaXMuc3RhdGUsZz1iLm9wdGlvbnMuc3RhdGVzW2F8fFwibm9ybWFsXCJdfHx7fSxkPUQucGxvdE9wdGlvbnNbYi50eXBlXS5tYXJrZXImJmIub3B0aW9ucy5tYXJrZXIsaD1kJiYhMT09PWQuZW5hYmxlZCxuPWQmJmQuc3RhdGVzJiZkLnN0YXRlc1thfHxcIm5vcm1hbFwiXXx8e30scT0hMT09PW4uZW5hYmxlZCxyPWIuc3RhdGVNYXJrZXJHcmFwaGljLHc9dGhpcy5tYXJrZXJ8fHt9LHA9Yi5jaGFydCxrPWIuaGFsbyx5LHQ9ZCYmYi5tYXJrZXJBdHRyaWJzO2E9YXx8XCJcIjtpZighKGE9PT10aGlzLnN0YXRlJiYhY3x8dGhpcy5zZWxlY3RlZCYmXCJzZWxlY3RcIiE9PWF8fCExPT09XG5nLmVuYWJsZWR8fGEmJihxfHxoJiYhMT09PW4uZW5hYmxlZCl8fGEmJncuc3RhdGVzJiZ3LnN0YXRlc1thXSYmITE9PT13LnN0YXRlc1thXS5lbmFibGVkKSl7dGhpcy5zdGF0ZT1hO3QmJih5PWIubWFya2VyQXR0cmlicyh0aGlzLGEpKTtpZih0aGlzLmdyYXBoaWMpe2UmJnRoaXMuZ3JhcGhpYy5yZW1vdmVDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnQtXCIrZSk7YSYmdGhpcy5ncmFwaGljLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludC1cIithKTtpZighcC5zdHlsZWRNb2RlKXt2YXIgdT1iLnBvaW50QXR0cmlicyh0aGlzLGEpO3ZhciB6PW0ocC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbixnLmFuaW1hdGlvbik7Yi5vcHRpb25zLmluYWN0aXZlT3RoZXJQb2ludHMmJnUub3BhY2l0eSYmKCh0aGlzLmRhdGFMYWJlbHN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EmJmEuYW5pbWF0ZSh7b3BhY2l0eTp1Lm9wYWNpdHl9LHopfSksdGhpcy5jb25uZWN0b3ImJnRoaXMuY29ubmVjdG9yLmFuaW1hdGUoe29wYWNpdHk6dS5vcGFjaXR5fSxcbnopKTt0aGlzLmdyYXBoaWMuYW5pbWF0ZSh1LHopfXkmJnRoaXMuZ3JhcGhpYy5hbmltYXRlKHksbShwLm9wdGlvbnMuY2hhcnQuYW5pbWF0aW9uLG4uYW5pbWF0aW9uLGQuYW5pbWF0aW9uKSk7ciYmci5oaWRlKCl9ZWxzZXtpZihhJiZuKXtlPXcuc3ltYm9sfHxiLnN5bWJvbDtyJiZyLmN1cnJlbnRTeW1ib2whPT1lJiYocj1yLmRlc3Ryb3koKSk7aWYoeSlpZihyKXJbYz9cImFuaW1hdGVcIjpcImF0dHJcIl0oe3g6eS54LHk6eS55fSk7ZWxzZSBlJiYoYi5zdGF0ZU1hcmtlckdyYXBoaWM9cj1wLnJlbmRlcmVyLnN5bWJvbChlLHkueCx5LnkseS53aWR0aCx5LmhlaWdodCkuYWRkKGIubWFya2VyR3JvdXApLHIuY3VycmVudFN5bWJvbD1lKTshcC5zdHlsZWRNb2RlJiZyJiZyLmF0dHIoYi5wb2ludEF0dHJpYnModGhpcyxhKSl9ciYmKHJbYSYmdGhpcy5pc0luc2lkZT9cInNob3dcIjpcImhpZGVcIl0oKSxyLmVsZW1lbnQucG9pbnQ9dGhpcyl9YT1nLmhhbG87Zz0ocj10aGlzLmdyYXBoaWN8fHIpJiZcbnIudmlzaWJpbGl0eXx8XCJpbmhlcml0XCI7YSYmYS5zaXplJiZyJiZcImhpZGRlblwiIT09ZyYmIXRoaXMuaXNDbHVzdGVyPyhrfHwoYi5oYWxvPWs9cC5yZW5kZXJlci5wYXRoKCkuYWRkKHIucGFyZW50R3JvdXApKSxrLnNob3coKVtjP1wiYW5pbWF0ZVwiOlwiYXR0clwiXSh7ZDp0aGlzLmhhbG9QYXRoKGEuc2l6ZSl9KSxrLmF0dHIoe1wiY2xhc3NcIjpcImhpZ2hjaGFydHMtaGFsbyBoaWdoY2hhcnRzLWNvbG9yLVwiK20odGhpcy5jb2xvckluZGV4LGIuY29sb3JJbmRleCkrKHRoaXMuY2xhc3NOYW1lP1wiIFwiK3RoaXMuY2xhc3NOYW1lOlwiXCIpLHZpc2liaWxpdHk6Zyx6SW5kZXg6LTF9KSxrLnBvaW50PXRoaXMscC5zdHlsZWRNb2RlfHxrLmF0dHIobCh7ZmlsbDp0aGlzLmNvbG9yfHxiLmNvbG9yLFwiZmlsbC1vcGFjaXR5XCI6YS5vcGFjaXR5fSxmLmZpbHRlclVzZXJBdHRyaWJ1dGVzKGEuYXR0cmlidXRlc3x8e30pKSkpOmsmJmsucG9pbnQmJmsucG9pbnQuaGFsb1BhdGgmJmsuYW5pbWF0ZSh7ZDprLnBvaW50LmhhbG9QYXRoKDApfSxcbm51bGwsay5oaWRlKTtFKHRoaXMsXCJhZnRlclNldFN0YXRlXCIpfX07YS5wcm90b3R5cGUuaGFsb1BhdGg9ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuc2VyaWVzLmNoYXJ0LnJlbmRlcmVyLnN5bWJvbHMuY2lyY2xlKE1hdGguZmxvb3IodGhpcy5wbG90WCktYSx0aGlzLnBsb3RZLWEsMiphLDIqYSl9O3JldHVybiBhfSgpO3JldHVybiBrLlBvaW50PWR9KTtQKGssXCJDb3JlL0xlZ2VuZC5qc1wiLFtrW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1BvaW50LmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCl7dmFyIEI9Zi5hbmltT2JqZWN0LEc9Zi5zZXRBbmltYXRpb247Zj1kLmlzRmlyZWZveDt2YXIgRD1kLm1hcmdpbk5hbWVzLEg9ZC53aW4sdD14LmFkZEV2ZW50LEM9eC5jcmVhdGVFbGVtZW50LGw9eC5jc3MsRT14LmRlZmluZWQsZz14LmRpc2NhcmRFbGVtZW50LFxueT14LmZpbmQsYz14LmZpcmVFdmVudCxxPXguZm9ybWF0LG49eC5pc051bWJlcixBPXgubWVyZ2UsTT14LnBpY2ssej14LnJlbGF0aXZlTGVuZ3RoLG09eC5zdGFibGVTb3J0LHI9eC5zeW5jVGltZW91dDt4PXgud3JhcDt2YXIgZT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoYSxiKXt0aGlzLmFsbEl0ZW1zPVtdO3RoaXMuY29udGVudEdyb3VwPXRoaXMuYm94PXZvaWQgMDt0aGlzLmRpc3BsYXk9ITE7dGhpcy5ncm91cD12b2lkIDA7dGhpcy5vZmZzZXRXaWR0aD10aGlzLm1heExlZ2VuZFdpZHRoPXRoaXMubWF4SXRlbVdpZHRoPXRoaXMubGVnZW5kV2lkdGg9dGhpcy5sZWdlbmRIZWlnaHQ9dGhpcy5sYXN0TGluZUhlaWdodD10aGlzLmxhc3RJdGVtWT10aGlzLml0ZW1ZPXRoaXMuaXRlbVg9dGhpcy5pdGVtTWFyZ2luVG9wPXRoaXMuaXRlbU1hcmdpbkJvdHRvbT10aGlzLml0ZW1IZWlnaHQ9dGhpcy5pbml0aWFsSXRlbVk9MDt0aGlzLm9wdGlvbnM9e307dGhpcy5wYWRkaW5nPTA7dGhpcy5wYWdlcz1cbltdO3RoaXMucHJveGltYXRlPSExO3RoaXMuc2Nyb2xsR3JvdXA9dm9pZCAwO3RoaXMud2lkdGhPcHRpb249dGhpcy50b3RhbEl0ZW1XaWR0aD10aGlzLnRpdGxlSGVpZ2h0PXRoaXMuc3ltYm9sV2lkdGg9dGhpcy5zeW1ib2xIZWlnaHQ9MDt0aGlzLmNoYXJ0PWE7dGhpcy5pbml0KGEsYil9ZS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhLGIpe3RoaXMuY2hhcnQ9YTt0aGlzLnNldE9wdGlvbnMoYik7Yi5lbmFibGVkJiYodGhpcy5yZW5kZXIoKSx0KHRoaXMuY2hhcnQsXCJlbmRSZXNpemVcIixmdW5jdGlvbigpe3RoaXMubGVnZW5kLnBvc2l0aW9uQ2hlY2tib3hlcygpfSksdGhpcy5wcm94aW1hdGU/dGhpcy51bmNoYXJ0cmVuZGVyPXQodGhpcy5jaGFydCxcInJlbmRlclwiLGZ1bmN0aW9uKCl7dGhpcy5sZWdlbmQucHJveGltYXRlUG9zaXRpb25zKCk7dGhpcy5sZWdlbmQucG9zaXRpb25JdGVtcygpfSk6dGhpcy51bmNoYXJ0cmVuZGVyJiZ0aGlzLnVuY2hhcnRyZW5kZXIoKSl9O2UucHJvdG90eXBlLnNldE9wdGlvbnM9XG5mdW5jdGlvbihhKXt2YXIgYj1NKGEucGFkZGluZyw4KTt0aGlzLm9wdGlvbnM9YTt0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fCh0aGlzLml0ZW1TdHlsZT1hLml0ZW1TdHlsZSx0aGlzLml0ZW1IaWRkZW5TdHlsZT1BKHRoaXMuaXRlbVN0eWxlLGEuaXRlbUhpZGRlblN0eWxlKSk7dGhpcy5pdGVtTWFyZ2luVG9wPWEuaXRlbU1hcmdpblRvcHx8MDt0aGlzLml0ZW1NYXJnaW5Cb3R0b209YS5pdGVtTWFyZ2luQm90dG9tfHwwO3RoaXMucGFkZGluZz1iO3RoaXMuaW5pdGlhbEl0ZW1ZPWItNTt0aGlzLnN5bWJvbFdpZHRoPU0oYS5zeW1ib2xXaWR0aCwxNik7dGhpcy5wYWdlcz1bXTt0aGlzLnByb3hpbWF0ZT1cInByb3hpbWF0ZVwiPT09YS5sYXlvdXQmJiF0aGlzLmNoYXJ0LmludmVydGVkO3RoaXMuYmFzZWxpbmU9dm9pZCAwfTtlLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiKXt2YXIgZT10aGlzLmNoYXJ0O3RoaXMuc2V0T3B0aW9ucyhBKCEwLHRoaXMub3B0aW9ucyxhKSk7dGhpcy5kZXN0cm95KCk7XG5lLmlzRGlydHlMZWdlbmQ9ZS5pc0RpcnR5Qm94PSEwO00oYiwhMCkmJmUucmVkcmF3KCk7Yyh0aGlzLFwiYWZ0ZXJVcGRhdGVcIil9O2UucHJvdG90eXBlLmNvbG9yaXplSXRlbT1mdW5jdGlvbihhLGIpe2EubGVnZW5kR3JvdXBbYj9cInJlbW92ZUNsYXNzXCI6XCJhZGRDbGFzc1wiXShcImhpZ2hjaGFydHMtbGVnZW5kLWl0ZW0taGlkZGVuXCIpO2lmKCF0aGlzLmNoYXJ0LnN0eWxlZE1vZGUpe3ZhciBlPXRoaXMub3B0aW9ucyxnPWEubGVnZW5kSXRlbSxkPWEubGVnZW5kTGluZSxmPWEubGVnZW5kU3ltYm9sLGg9dGhpcy5pdGVtSGlkZGVuU3R5bGUuY29sb3I7ZT1iP2UuaXRlbVN0eWxlLmNvbG9yOmg7dmFyIG09Yj9hLmNvbG9yfHxoOmgsbD1hLm9wdGlvbnMmJmEub3B0aW9ucy5tYXJrZXIsbj17ZmlsbDptfTtnJiZnLmNzcyh7ZmlsbDplLGNvbG9yOmV9KTtkJiZkLmF0dHIoe3N0cm9rZTptfSk7ZiYmKGwmJmYuaXNNYXJrZXImJihuPWEucG9pbnRBdHRyaWJzKCksYnx8KG4uc3Ryb2tlPW4uZmlsbD1cbmgpKSxmLmF0dHIobikpfWModGhpcyxcImFmdGVyQ29sb3JpemVJdGVtXCIse2l0ZW06YSx2aXNpYmxlOmJ9KX07ZS5wcm90b3R5cGUucG9zaXRpb25JdGVtcz1mdW5jdGlvbigpe3RoaXMuYWxsSXRlbXMuZm9yRWFjaCh0aGlzLnBvc2l0aW9uSXRlbSx0aGlzKTt0aGlzLmNoYXJ0LmlzUmVzaXppbmd8fHRoaXMucG9zaXRpb25DaGVja2JveGVzKCl9O2UucHJvdG90eXBlLnBvc2l0aW9uSXRlbT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGU9dGhpcy5vcHRpb25zLGc9ZS5zeW1ib2xQYWRkaW5nLGQ9IWUucnRsLGY9YS5fbGVnZW5kSXRlbVBvcztlPWZbMF07Zj1mWzFdO3ZhciBoPWEuY2hlY2tib3gsbT1hLmxlZ2VuZEdyb3VwO20mJm0uZWxlbWVudCYmKGc9e3RyYW5zbGF0ZVg6ZD9lOnRoaXMubGVnZW5kV2lkdGgtZS0yKmctNCx0cmFuc2xhdGVZOmZ9LGQ9ZnVuY3Rpb24oKXtjKGIsXCJhZnRlclBvc2l0aW9uSXRlbVwiLHtpdGVtOmF9KX0sRShtLnRyYW5zbGF0ZVkpP20uYW5pbWF0ZShnLHZvaWQgMCxcbmQpOihtLmF0dHIoZyksZCgpKSk7aCYmKGgueD1lLGgueT1mKX07ZS5wcm90b3R5cGUuZGVzdHJveUl0ZW09ZnVuY3Rpb24oYSl7dmFyIGI9YS5jaGVja2JveDtbXCJsZWdlbmRJdGVtXCIsXCJsZWdlbmRMaW5lXCIsXCJsZWdlbmRTeW1ib2xcIixcImxlZ2VuZEdyb3VwXCJdLmZvckVhY2goZnVuY3Rpb24oYil7YVtiXSYmKGFbYl09YVtiXS5kZXN0cm95KCkpfSk7YiYmZyhhLmNoZWNrYm94KX07ZS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSl7dGhpc1thXSYmKHRoaXNbYV09dGhpc1thXS5kZXN0cm95KCkpfXRoaXMuZ2V0QWxsSXRlbXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe1tcImxlZ2VuZEl0ZW1cIixcImxlZ2VuZEdyb3VwXCJdLmZvckVhY2goYSxiKX0pO1wiY2xpcFJlY3QgdXAgZG93biBwYWdlciBuYXYgYm94IHRpdGxlIGdyb3VwXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goYSx0aGlzKTt0aGlzLmRpc3BsYXk9bnVsbH07ZS5wcm90b3R5cGUucG9zaXRpb25DaGVja2JveGVzPVxuZnVuY3Rpb24oKXt2YXIgYT10aGlzLmdyb3VwJiZ0aGlzLmdyb3VwLmFsaWduQXR0cixiPXRoaXMuY2xpcEhlaWdodHx8dGhpcy5sZWdlbmRIZWlnaHQsYz10aGlzLnRpdGxlSGVpZ2h0O2lmKGEpe3ZhciBlPWEudHJhbnNsYXRlWTt0aGlzLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oZyl7dmFyIGQ9Zy5jaGVja2JveDtpZihkKXt2YXIgZj1lK2MrZC55Kyh0aGlzLnNjcm9sbE9mZnNldHx8MCkrMztsKGQse2xlZnQ6YS50cmFuc2xhdGVYK2cuY2hlY2tib3hPZmZzZXQrZC54LTIwK1wicHhcIix0b3A6ZitcInB4XCIsZGlzcGxheTp0aGlzLnByb3hpbWF0ZXx8Zj5lLTYmJmY8ZStiLTY/XCJcIjpcIm5vbmVcIn0pfX0sdGhpcyl9fTtlLnByb3RvdHlwZS5yZW5kZXJUaXRsZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucyxiPXRoaXMucGFkZGluZyxjPWEudGl0bGUsZT0wO2MudGV4dCYmKHRoaXMudGl0bGV8fCh0aGlzLnRpdGxlPXRoaXMuY2hhcnQucmVuZGVyZXIubGFiZWwoYy50ZXh0LGItXG4zLGItNCxudWxsLG51bGwsbnVsbCxhLnVzZUhUTUwsbnVsbCxcImxlZ2VuZC10aXRsZVwiKS5hdHRyKHt6SW5kZXg6MX0pLHRoaXMuY2hhcnQuc3R5bGVkTW9kZXx8dGhpcy50aXRsZS5jc3MoYy5zdHlsZSksdGhpcy50aXRsZS5hZGQodGhpcy5ncm91cCkpLGMud2lkdGh8fHRoaXMudGl0bGUuY3NzKHt3aWR0aDp0aGlzLm1heExlZ2VuZFdpZHRoK1wicHhcIn0pLGE9dGhpcy50aXRsZS5nZXRCQm94KCksZT1hLmhlaWdodCx0aGlzLm9mZnNldFdpZHRoPWEud2lkdGgsdGhpcy5jb250ZW50R3JvdXAuYXR0cih7dHJhbnNsYXRlWTplfSkpO3RoaXMudGl0bGVIZWlnaHQ9ZX07ZS5wcm90b3R5cGUuc2V0VGV4dD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLm9wdGlvbnM7YS5sZWdlbmRJdGVtLmF0dHIoe3RleHQ6Yi5sYWJlbEZvcm1hdD9xKGIubGFiZWxGb3JtYXQsYSx0aGlzLmNoYXJ0KTpiLmxhYmVsRm9ybWF0dGVyLmNhbGwoYSl9KX07ZS5wcm90b3R5cGUucmVuZGVySXRlbT1mdW5jdGlvbihhKXt2YXIgYj1cbnRoaXMuY2hhcnQsYz1iLnJlbmRlcmVyLGU9dGhpcy5vcHRpb25zLGc9dGhpcy5zeW1ib2xXaWR0aCxkPWUuc3ltYm9sUGFkZGluZyxmPXRoaXMuaXRlbVN0eWxlLGg9dGhpcy5pdGVtSGlkZGVuU3R5bGUsbT1cImhvcml6b250YWxcIj09PWUubGF5b3V0P00oZS5pdGVtRGlzdGFuY2UsMjApOjAsbD0hZS5ydGwsbj1hLmxlZ2VuZEl0ZW0scT0hYS5zZXJpZXMscD0hcSYmYS5zZXJpZXMuZHJhd0xlZ2VuZFN5bWJvbD9hLnNlcmllczphLHI9cC5vcHRpb25zO3I9dGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0mJnImJnIuc2hvd0NoZWNrYm94O209ZytkK20rKHI/MjA6MCk7dmFyIGs9ZS51c2VIVE1MLHk9YS5vcHRpb25zLmNsYXNzTmFtZTtufHwoYS5sZWdlbmRHcm91cD1jLmcoXCJsZWdlbmQtaXRlbVwiKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrcC50eXBlK1wiLXNlcmllcyBoaWdoY2hhcnRzLWNvbG9yLVwiK2EuY29sb3JJbmRleCsoeT9cIiBcIit5OlwiXCIpKyhxP1wiIGhpZ2hjaGFydHMtc2VyaWVzLVwiK1xuYS5pbmRleDpcIlwiKSkuYXR0cih7ekluZGV4OjF9KS5hZGQodGhpcy5zY3JvbGxHcm91cCksYS5sZWdlbmRJdGVtPW49Yy50ZXh0KFwiXCIsbD9nK2Q6LWQsdGhpcy5iYXNlbGluZXx8MCxrKSxiLnN0eWxlZE1vZGV8fG4uY3NzKEEoYS52aXNpYmxlP2Y6aCkpLG4uYXR0cih7YWxpZ246bD9cImxlZnRcIjpcInJpZ2h0XCIsekluZGV4OjJ9KS5hZGQoYS5sZWdlbmRHcm91cCksdGhpcy5iYXNlbGluZXx8KHRoaXMuZm9udE1ldHJpY3M9Yy5mb250TWV0cmljcyhiLnN0eWxlZE1vZGU/MTI6Zi5mb250U2l6ZSxuKSx0aGlzLmJhc2VsaW5lPXRoaXMuZm9udE1ldHJpY3MuZiszK3RoaXMuaXRlbU1hcmdpblRvcCxuLmF0dHIoXCJ5XCIsdGhpcy5iYXNlbGluZSkpLHRoaXMuc3ltYm9sSGVpZ2h0PWUuc3ltYm9sSGVpZ2h0fHx0aGlzLmZvbnRNZXRyaWNzLmYscC5kcmF3TGVnZW5kU3ltYm9sKHRoaXMsYSksdGhpcy5zZXRJdGVtRXZlbnRzJiZ0aGlzLnNldEl0ZW1FdmVudHMoYSxuLGspKTtyJiYhYS5jaGVja2JveCYmXG50aGlzLmNyZWF0ZUNoZWNrYm94Rm9ySXRlbSYmdGhpcy5jcmVhdGVDaGVja2JveEZvckl0ZW0oYSk7dGhpcy5jb2xvcml6ZUl0ZW0oYSxhLnZpc2libGUpOyFiLnN0eWxlZE1vZGUmJmYud2lkdGh8fG4uY3NzKHt3aWR0aDooZS5pdGVtV2lkdGh8fHRoaXMud2lkdGhPcHRpb258fGIuc3BhY2luZ0JveC53aWR0aCktbStcInB4XCJ9KTt0aGlzLnNldFRleHQoYSk7Yj1uLmdldEJCb3goKTthLml0ZW1XaWR0aD1hLmNoZWNrYm94T2Zmc2V0PWUuaXRlbVdpZHRofHxhLmxlZ2VuZEl0ZW1XaWR0aHx8Yi53aWR0aCttO3RoaXMubWF4SXRlbVdpZHRoPU1hdGgubWF4KHRoaXMubWF4SXRlbVdpZHRoLGEuaXRlbVdpZHRoKTt0aGlzLnRvdGFsSXRlbVdpZHRoKz1hLml0ZW1XaWR0aDt0aGlzLml0ZW1IZWlnaHQ9YS5pdGVtSGVpZ2h0PU1hdGgucm91bmQoYS5sZWdlbmRJdGVtSGVpZ2h0fHxiLmhlaWdodHx8dGhpcy5zeW1ib2xIZWlnaHQpfTtlLnByb3RvdHlwZS5sYXlvdXRJdGVtPWZ1bmN0aW9uKGEpe3ZhciBiPVxudGhpcy5vcHRpb25zLGM9dGhpcy5wYWRkaW5nLGU9XCJob3Jpem9udGFsXCI9PT1iLmxheW91dCxnPWEuaXRlbUhlaWdodCxkPXRoaXMuaXRlbU1hcmdpbkJvdHRvbSxmPXRoaXMuaXRlbU1hcmdpblRvcCxoPWU/TShiLml0ZW1EaXN0YW5jZSwyMCk6MCxtPXRoaXMubWF4TGVnZW5kV2lkdGg7Yj1iLmFsaWduQ29sdW1ucyYmdGhpcy50b3RhbEl0ZW1XaWR0aD5tP3RoaXMubWF4SXRlbVdpZHRoOmEuaXRlbVdpZHRoO2UmJnRoaXMuaXRlbVgtYytiPm0mJih0aGlzLml0ZW1YPWMsdGhpcy5sYXN0TGluZUhlaWdodCYmKHRoaXMuaXRlbVkrPWYrdGhpcy5sYXN0TGluZUhlaWdodCtkKSx0aGlzLmxhc3RMaW5lSGVpZ2h0PTApO3RoaXMubGFzdEl0ZW1ZPWYrdGhpcy5pdGVtWStkO3RoaXMubGFzdExpbmVIZWlnaHQ9TWF0aC5tYXgoZyx0aGlzLmxhc3RMaW5lSGVpZ2h0KTthLl9sZWdlbmRJdGVtUG9zPVt0aGlzLml0ZW1YLHRoaXMuaXRlbVldO2U/dGhpcy5pdGVtWCs9YjoodGhpcy5pdGVtWSs9XG5mK2crZCx0aGlzLmxhc3RMaW5lSGVpZ2h0PWcpO3RoaXMub2Zmc2V0V2lkdGg9dGhpcy53aWR0aE9wdGlvbnx8TWF0aC5tYXgoKGU/dGhpcy5pdGVtWC1jLShhLmNoZWNrYm94PzA6aCk6YikrYyx0aGlzLm9mZnNldFdpZHRoKX07ZS5wcm90b3R5cGUuZ2V0QWxsSXRlbXM9ZnVuY3Rpb24oKXt2YXIgYT1bXTt0aGlzLmNoYXJ0LnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGIpe3ZhciBjPWImJmIub3B0aW9ucztiJiZNKGMuc2hvd0luTGVnZW5kLEUoYy5saW5rZWRUbyk/ITE6dm9pZCAwLCEwKSYmKGE9YS5jb25jYXQoYi5sZWdlbmRJdGVtc3x8KFwicG9pbnRcIj09PWMubGVnZW5kVHlwZT9iLmRhdGE6YikpKX0pO2ModGhpcyxcImFmdGVyR2V0QWxsSXRlbXNcIix7YWxsSXRlbXM6YX0pO3JldHVybiBhfTtlLnByb3RvdHlwZS5nZXRBbGlnbm1lbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnM7cmV0dXJuIHRoaXMucHJveGltYXRlP2EuYWxpZ24uY2hhckF0KDApK1widHZcIjphLmZsb2F0aW5nP1xuXCJcIjphLmFsaWduLmNoYXJBdCgwKSthLnZlcnRpY2FsQWxpZ24uY2hhckF0KDApK2EubGF5b3V0LmNoYXJBdCgwKX07ZS5wcm90b3R5cGUuYWRqdXN0TWFyZ2lucz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY2hhcnQsZT10aGlzLm9wdGlvbnMsZz10aGlzLmdldEFsaWdubWVudCgpO2cmJlsvKGx0aHxjdHxydGgpLywvKHJ0dnxybXxyYnYpLywvKHJiaHxjYnxsYmgpLywvKGxidnxsbXxsdHYpL10uZm9yRWFjaChmdW5jdGlvbihkLGYpe2QudGVzdChnKSYmIUUoYVtmXSkmJihjW0RbZl1dPU1hdGgubWF4KGNbRFtmXV0sYy5sZWdlbmRbKGYrMSklMj9cImxlZ2VuZEhlaWdodFwiOlwibGVnZW5kV2lkdGhcIl0rWzEsLTEsLTEsMV1bZl0qZVtmJTI/XCJ4XCI6XCJ5XCJdK00oZS5tYXJnaW4sMTIpK2JbZl0rKGMudGl0bGVPZmZzZXRbZl18fDApKSl9KX07ZS5wcm90b3R5cGUucHJveGltYXRlUG9zaXRpb25zPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxiPVtdLGM9XCJsZWZ0XCI9PT10aGlzLm9wdGlvbnMuYWxpZ247XG50aGlzLmFsbEl0ZW1zLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIGc7dmFyIGQ9YztpZihlLnlBeGlzKXtlLnhBeGlzLm9wdGlvbnMucmV2ZXJzZWQmJihkPSFkKTtlLnBvaW50cyYmKGc9eShkP2UucG9pbnRzOmUucG9pbnRzLnNsaWNlKDApLnJldmVyc2UoKSxmdW5jdGlvbihhKXtyZXR1cm4gbihhLnBsb3RZKX0pKTtkPXRoaXMuaXRlbU1hcmdpblRvcCtlLmxlZ2VuZEl0ZW0uZ2V0QkJveCgpLmhlaWdodCt0aGlzLml0ZW1NYXJnaW5Cb3R0b207dmFyIGY9ZS55QXhpcy50b3AtYS5wbG90VG9wO2UudmlzaWJsZT8oZz1nP2cucGxvdFk6ZS55QXhpcy5oZWlnaHQsZys9Zi0uMypkKTpnPWYrZS55QXhpcy5oZWlnaHQ7Yi5wdXNoKHt0YXJnZXQ6ZyxzaXplOmQsaXRlbTplfSl9fSx0aGlzKTtkLmRpc3RyaWJ1dGUoYixhLnBsb3RIZWlnaHQpO2IuZm9yRWFjaChmdW5jdGlvbihiKXtiLml0ZW0uX2xlZ2VuZEl0ZW1Qb3NbMV09YS5wbG90VG9wLWEuc3BhY2luZ1swXStiLnBvc30pfTtlLnByb3RvdHlwZS5yZW5kZXI9XG5mdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj1hLnJlbmRlcmVyLGU9dGhpcy5ncm91cCxnPXRoaXMuYm94LGQ9dGhpcy5vcHRpb25zLGY9dGhpcy5wYWRkaW5nO3RoaXMuaXRlbVg9Zjt0aGlzLml0ZW1ZPXRoaXMuaW5pdGlhbEl0ZW1ZO3RoaXMubGFzdEl0ZW1ZPXRoaXMub2Zmc2V0V2lkdGg9MDt0aGlzLndpZHRoT3B0aW9uPXooZC53aWR0aCxhLnNwYWNpbmdCb3gud2lkdGgtZik7dmFyIGg9YS5zcGFjaW5nQm94LndpZHRoLTIqZi1kLng7LTE8W1wicm1cIixcImxtXCJdLmluZGV4T2YodGhpcy5nZXRBbGlnbm1lbnQoKS5zdWJzdHJpbmcoMCwyKSkmJihoLz0yKTt0aGlzLm1heExlZ2VuZFdpZHRoPXRoaXMud2lkdGhPcHRpb258fGg7ZXx8KHRoaXMuZ3JvdXA9ZT1iLmcoXCJsZWdlbmRcIikuYXR0cih7ekluZGV4Ojd9KS5hZGQoKSx0aGlzLmNvbnRlbnRHcm91cD1iLmcoKS5hdHRyKHt6SW5kZXg6MX0pLmFkZChlKSx0aGlzLnNjcm9sbEdyb3VwPWIuZygpLmFkZCh0aGlzLmNvbnRlbnRHcm91cCkpO1xudGhpcy5yZW5kZXJUaXRsZSgpO3ZhciBuPXRoaXMuZ2V0QWxsSXRlbXMoKTttKG4sZnVuY3Rpb24oYSxiKXtyZXR1cm4oYS5vcHRpb25zJiZhLm9wdGlvbnMubGVnZW5kSW5kZXh8fDApLShiLm9wdGlvbnMmJmIub3B0aW9ucy5sZWdlbmRJbmRleHx8MCl9KTtkLnJldmVyc2VkJiZuLnJldmVyc2UoKTt0aGlzLmFsbEl0ZW1zPW47dGhpcy5kaXNwbGF5PWg9ISFuLmxlbmd0aDt0aGlzLml0ZW1IZWlnaHQ9dGhpcy50b3RhbEl0ZW1XaWR0aD10aGlzLm1heEl0ZW1XaWR0aD10aGlzLmxhc3RMaW5lSGVpZ2h0PTA7bi5mb3JFYWNoKHRoaXMucmVuZGVySXRlbSx0aGlzKTtuLmZvckVhY2godGhpcy5sYXlvdXRJdGVtLHRoaXMpO249KHRoaXMud2lkdGhPcHRpb258fHRoaXMub2Zmc2V0V2lkdGgpK2Y7dmFyIGw9dGhpcy5sYXN0SXRlbVkrdGhpcy5sYXN0TGluZUhlaWdodCt0aGlzLnRpdGxlSGVpZ2h0O2w9dGhpcy5oYW5kbGVPdmVyZmxvdyhsKTtsKz1mO2d8fCh0aGlzLmJveD1nPWIucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1sZWdlbmQtYm94XCIpLmF0dHIoe3I6ZC5ib3JkZXJSYWRpdXN9KS5hZGQoZSksXG5nLmlzTmV3PSEwKTthLnN0eWxlZE1vZGV8fGcuYXR0cih7c3Ryb2tlOmQuYm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpkLmJvcmRlcldpZHRofHwwLGZpbGw6ZC5iYWNrZ3JvdW5kQ29sb3J8fFwibm9uZVwifSkuc2hhZG93KGQuc2hhZG93KTswPG4mJjA8bCYmKGdbZy5pc05ldz9cImF0dHJcIjpcImFuaW1hdGVcIl0oZy5jcmlzcC5jYWxsKHt9LHt4OjAseTowLHdpZHRoOm4saGVpZ2h0Omx9LGcuc3Ryb2tlV2lkdGgoKSkpLGcuaXNOZXc9ITEpO2dbaD9cInNob3dcIjpcImhpZGVcIl0oKTthLnN0eWxlZE1vZGUmJlwibm9uZVwiPT09ZS5nZXRTdHlsZShcImRpc3BsYXlcIikmJihuPWw9MCk7dGhpcy5sZWdlbmRXaWR0aD1uO3RoaXMubGVnZW5kSGVpZ2h0PWw7aCYmdGhpcy5hbGlnbigpO3RoaXMucHJveGltYXRlfHx0aGlzLnBvc2l0aW9uSXRlbXMoKTtjKHRoaXMsXCJhZnRlclJlbmRlclwiKX07ZS5wcm90b3R5cGUuYWxpZ249ZnVuY3Rpb24oYSl7dm9pZCAwPT09YSYmKGE9dGhpcy5jaGFydC5zcGFjaW5nQm94KTtcbnZhciBiPXRoaXMuY2hhcnQsYz10aGlzLm9wdGlvbnMsZT1hLnk7LyhsdGh8Y3R8cnRoKS8udGVzdCh0aGlzLmdldEFsaWdubWVudCgpKSYmMDxiLnRpdGxlT2Zmc2V0WzBdP2UrPWIudGl0bGVPZmZzZXRbMF06LyhsYmh8Y2J8cmJoKS8udGVzdCh0aGlzLmdldEFsaWdubWVudCgpKSYmMDxiLnRpdGxlT2Zmc2V0WzJdJiYoZS09Yi50aXRsZU9mZnNldFsyXSk7ZSE9PWEueSYmKGE9QShhLHt5OmV9KSk7dGhpcy5ncm91cC5hbGlnbihBKGMse3dpZHRoOnRoaXMubGVnZW5kV2lkdGgsaGVpZ2h0OnRoaXMubGVnZW5kSGVpZ2h0LHZlcnRpY2FsQWxpZ246dGhpcy5wcm94aW1hdGU/XCJ0b3BcIjpjLnZlcnRpY2FsQWxpZ259KSwhMCxhKX07ZS5wcm90b3R5cGUuaGFuZGxlT3ZlcmZsb3c9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMuY2hhcnQsZT1jLnJlbmRlcmVyLGc9dGhpcy5vcHRpb25zLGQ9Zy55LGY9dGhpcy5wYWRkaW5nO2Q9Yy5zcGFjaW5nQm94LmhlaWdodCsoXCJ0b3BcIj09PWcudmVydGljYWxBbGlnbj9cbi1kOmQpLWY7dmFyIGg9Zy5tYXhIZWlnaHQsbSxuPXRoaXMuY2xpcFJlY3QsbD1nLm5hdmlnYXRpb24scT1NKGwuYW5pbWF0aW9uLCEwKSxwPWwuYXJyb3dTaXplfHwxMixyPXRoaXMubmF2LGs9dGhpcy5wYWdlcyx5LHU9dGhpcy5hbGxJdGVtcyx0PWZ1bmN0aW9uKGEpe1wibnVtYmVyXCI9PT10eXBlb2YgYT9uLmF0dHIoe2hlaWdodDphfSk6biYmKGIuY2xpcFJlY3Q9bi5kZXN0cm95KCksYi5jb250ZW50R3JvdXAuY2xpcCgpKTtiLmNvbnRlbnRHcm91cC5kaXYmJihiLmNvbnRlbnRHcm91cC5kaXYuc3R5bGUuY2xpcD1hP1wicmVjdChcIitmK1wicHgsOTk5OXB4LFwiKyhmK2EpK1wicHgsMClcIjpcImF1dG9cIil9LEk9ZnVuY3Rpb24oYSl7YlthXT1lLmNpcmNsZSgwLDAsMS4zKnApLnRyYW5zbGF0ZShwLzIscC8yKS5hZGQocik7Yy5zdHlsZWRNb2RlfHxiW2FdLmF0dHIoXCJmaWxsXCIsXCJyZ2JhKDAsMCwwLDAuMDAwMSlcIik7cmV0dXJuIGJbYV19O1wiaG9yaXpvbnRhbFwiIT09Zy5sYXlvdXR8fFwibWlkZGxlXCI9PT1cbmcudmVydGljYWxBbGlnbnx8Zy5mbG9hdGluZ3x8KGQvPTIpO2gmJihkPU1hdGgubWluKGQsaCkpO2subGVuZ3RoPTA7YT5kJiYhMSE9PWwuZW5hYmxlZD8odGhpcy5jbGlwSGVpZ2h0PW09TWF0aC5tYXgoZC0yMC10aGlzLnRpdGxlSGVpZ2h0LWYsMCksdGhpcy5jdXJyZW50UGFnZT1NKHRoaXMuY3VycmVudFBhZ2UsMSksdGhpcy5mdWxsSGVpZ2h0PWEsdS5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7dmFyIGM9YS5fbGVnZW5kSXRlbVBvc1sxXSxlPU1hdGgucm91bmQoYS5sZWdlbmRJdGVtLmdldEJCb3goKS5oZWlnaHQpLGc9ay5sZW5ndGg7aWYoIWd8fGMta1tnLTFdPm0mJih5fHxjKSE9PWtbZy0xXSlrLnB1c2goeXx8YyksZysrO2EucGFnZUl4PWctMTt5JiYodVtiLTFdLnBhZ2VJeD1nLTEpO2I9PT11Lmxlbmd0aC0xJiZjK2Uta1tnLTFdPm0mJmMhPT15JiYoay5wdXNoKGMpLGEucGFnZUl4PWcpO2MhPT15JiYoeT1jKX0pLG58fChuPWIuY2xpcFJlY3Q9ZS5jbGlwUmVjdCgwLGYsOTk5OSxcbjApLGIuY29udGVudEdyb3VwLmNsaXAobikpLHQobSkscnx8KHRoaXMubmF2PXI9ZS5nKCkuYXR0cih7ekluZGV4OjF9KS5hZGQodGhpcy5ncm91cCksdGhpcy51cD1lLnN5bWJvbChcInRyaWFuZ2xlXCIsMCwwLHAscCkuYWRkKHIpLEkoXCJ1cFRyYWNrZXJcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7Yi5zY3JvbGwoLTEscSl9KSx0aGlzLnBhZ2VyPWUudGV4dChcIlwiLDE1LDEwKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbGVnZW5kLW5hdmlnYXRpb25cIiksYy5zdHlsZWRNb2RlfHx0aGlzLnBhZ2VyLmNzcyhsLnN0eWxlKSx0aGlzLnBhZ2VyLmFkZChyKSx0aGlzLmRvd249ZS5zeW1ib2woXCJ0cmlhbmdsZS1kb3duXCIsMCwwLHAscCkuYWRkKHIpLEkoXCJkb3duVHJhY2tlclwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oKXtiLnNjcm9sbCgxLHEpfSkpLGIuc2Nyb2xsKDApLGE9ZCk6ciYmKHQoKSx0aGlzLm5hdj1yLmRlc3Ryb3koKSx0aGlzLnNjcm9sbEdyb3VwLmF0dHIoe3RyYW5zbGF0ZVk6MX0pLHRoaXMuY2xpcEhlaWdodD1cbjApO3JldHVybiBhfTtlLnByb3RvdHlwZS5zY3JvbGw9ZnVuY3Rpb24oYSxiKXt2YXIgZT10aGlzLGc9dGhpcy5jaGFydCxkPXRoaXMucGFnZXMsZj1kLmxlbmd0aCxoPXRoaXMuY3VycmVudFBhZ2UrYTthPXRoaXMuY2xpcEhlaWdodDt2YXIgbT10aGlzLm9wdGlvbnMubmF2aWdhdGlvbixuPXRoaXMucGFnZXIsbD10aGlzLnBhZGRpbmc7aD5mJiYoaD1mKTswPGgmJihcInVuZGVmaW5lZFwiIT09dHlwZW9mIGImJkcoYixnKSx0aGlzLm5hdi5hdHRyKHt0cmFuc2xhdGVYOmwsdHJhbnNsYXRlWTphK3RoaXMucGFkZGluZys3K3RoaXMudGl0bGVIZWlnaHQsdmlzaWJpbGl0eTpcInZpc2libGVcIn0pLFt0aGlzLnVwLHRoaXMudXBUcmFja2VyXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuYXR0cih7XCJjbGFzc1wiOjE9PT1oP1wiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWluYWN0aXZlXCI6XCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtYWN0aXZlXCJ9KX0pLG4uYXR0cih7dGV4dDpoK1wiL1wiK2Z9KSxbdGhpcy5kb3duLFxudGhpcy5kb3duVHJhY2tlcl0uZm9yRWFjaChmdW5jdGlvbihhKXthLmF0dHIoe3g6MTgrdGhpcy5wYWdlci5nZXRCQm94KCkud2lkdGgsXCJjbGFzc1wiOmg9PT1mP1wiaGlnaGNoYXJ0cy1sZWdlbmQtbmF2LWluYWN0aXZlXCI6XCJoaWdoY2hhcnRzLWxlZ2VuZC1uYXYtYWN0aXZlXCJ9KX0sdGhpcyksZy5zdHlsZWRNb2RlfHwodGhpcy51cC5hdHRyKHtmaWxsOjE9PT1oP20uaW5hY3RpdmVDb2xvcjptLmFjdGl2ZUNvbG9yfSksdGhpcy51cFRyYWNrZXIuY3NzKHtjdXJzb3I6MT09PWg/XCJkZWZhdWx0XCI6XCJwb2ludGVyXCJ9KSx0aGlzLmRvd24uYXR0cih7ZmlsbDpoPT09Zj9tLmluYWN0aXZlQ29sb3I6bS5hY3RpdmVDb2xvcn0pLHRoaXMuZG93blRyYWNrZXIuY3NzKHtjdXJzb3I6aD09PWY/XCJkZWZhdWx0XCI6XCJwb2ludGVyXCJ9KSksdGhpcy5zY3JvbGxPZmZzZXQ9LWRbaC0xXSt0aGlzLmluaXRpYWxJdGVtWSx0aGlzLnNjcm9sbEdyb3VwLmFuaW1hdGUoe3RyYW5zbGF0ZVk6dGhpcy5zY3JvbGxPZmZzZXR9KSxcbnRoaXMuY3VycmVudFBhZ2U9aCx0aGlzLnBvc2l0aW9uQ2hlY2tib3hlcygpLGI9QihNKGIsZy5yZW5kZXJlci5nbG9iYWxBbmltYXRpb24sITApKSxyKGZ1bmN0aW9uKCl7YyhlLFwiYWZ0ZXJTY3JvbGxcIix7Y3VycmVudFBhZ2U6aH0pfSxiLmR1cmF0aW9uKSl9O2UucHJvdG90eXBlLnNldEl0ZW1FdmVudHM9ZnVuY3Rpb24oYSxiLGUpe3ZhciBnPXRoaXMsZD1nLmNoYXJ0LnJlbmRlcmVyLmJveFdyYXBwZXIsZj1hIGluc3RhbmNlb2YgayxoPVwiaGlnaGNoYXJ0cy1sZWdlbmQtXCIrKGY/XCJwb2ludFwiOlwic2VyaWVzXCIpK1wiLWFjdGl2ZVwiLG09Zy5jaGFydC5zdHlsZWRNb2RlOyhlP1tiLGEubGVnZW5kU3ltYm9sXTpbYS5sZWdlbmRHcm91cF0pLmZvckVhY2goZnVuY3Rpb24oZSl7aWYoZSllLm9uKFwibW91c2VvdmVyXCIsZnVuY3Rpb24oKXthLnZpc2libGUmJmcuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbihiKXthIT09YiYmYi5zZXRTdGF0ZShcImluYWN0aXZlXCIsIWYpfSk7YS5zZXRTdGF0ZShcImhvdmVyXCIpO1xuYS52aXNpYmxlJiZkLmFkZENsYXNzKGgpO218fGIuY3NzKGcub3B0aW9ucy5pdGVtSG92ZXJTdHlsZSl9KS5vbihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oKXtnLmNoYXJ0LnN0eWxlZE1vZGV8fGIuY3NzKEEoYS52aXNpYmxlP2cuaXRlbVN0eWxlOmcuaXRlbUhpZGRlblN0eWxlKSk7Zy5hbGxJdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2EhPT1iJiZiLnNldFN0YXRlKFwiXCIsIWYpfSk7ZC5yZW1vdmVDbGFzcyhoKTthLnNldFN0YXRlKCl9KS5vbihcImNsaWNrXCIsZnVuY3Rpb24oYil7dmFyIGU9ZnVuY3Rpb24oKXthLnNldFZpc2libGUmJmEuc2V0VmlzaWJsZSgpO2cuYWxsSXRlbXMuZm9yRWFjaChmdW5jdGlvbihiKXthIT09YiYmYi5zZXRTdGF0ZShhLnZpc2libGU/XCJpbmFjdGl2ZVwiOlwiXCIsIWYpfSl9O2QucmVtb3ZlQ2xhc3MoaCk7Yj17YnJvd3NlckV2ZW50OmJ9O2EuZmlyZVBvaW50RXZlbnQ/YS5maXJlUG9pbnRFdmVudChcImxlZ2VuZEl0ZW1DbGlja1wiLGIsZSk6YyhhLFwibGVnZW5kSXRlbUNsaWNrXCIsXG5iLGUpfSl9KX07ZS5wcm90b3R5cGUuY3JlYXRlQ2hlY2tib3hGb3JJdGVtPWZ1bmN0aW9uKGEpe2EuY2hlY2tib3g9QyhcImlucHV0XCIse3R5cGU6XCJjaGVja2JveFwiLGNsYXNzTmFtZTpcImhpZ2hjaGFydHMtbGVnZW5kLWNoZWNrYm94XCIsY2hlY2tlZDphLnNlbGVjdGVkLGRlZmF1bHRDaGVja2VkOmEuc2VsZWN0ZWR9LHRoaXMub3B0aW9ucy5pdGVtQ2hlY2tib3hTdHlsZSx0aGlzLmNoYXJ0LmNvbnRhaW5lcik7dChhLmNoZWNrYm94LFwiY2xpY2tcIixmdW5jdGlvbihiKXtjKGEuc2VyaWVzfHxhLFwiY2hlY2tib3hDbGlja1wiLHtjaGVja2VkOmIudGFyZ2V0LmNoZWNrZWQsaXRlbTphfSxmdW5jdGlvbigpe2Euc2VsZWN0KCl9KX0pfTtyZXR1cm4gZX0oKTsoL1RyaWRlbnRcXC83XFwuMC8udGVzdChILm5hdmlnYXRvciYmSC5uYXZpZ2F0b3IudXNlckFnZW50KXx8ZikmJngoZS5wcm90b3R5cGUsXCJwb3NpdGlvbkl0ZW1cIixmdW5jdGlvbihlLGEpe3ZhciBiPXRoaXMsYz1mdW5jdGlvbigpe2EuX2xlZ2VuZEl0ZW1Qb3MmJlxuZS5jYWxsKGIsYSl9O2MoKTtiLmJ1YmJsZUxlZ2VuZHx8c2V0VGltZW91dChjKX0pO2QuTGVnZW5kPWU7cmV0dXJuIGQuTGVnZW5kfSk7UChrLFwiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIixba1tcIkNvcmUvR2xvYmFscy5qc1wiXSxrW1wiQ29yZS9PcHRpb25zLmpzXCJdLGtbXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCxrLHgpe3ZhciBCPWQuZGVmYXVsdE9wdGlvbnMsRz14LmVycm9yLEQ9eC5leHRlbmRDbGFzcyxIPXgubWVyZ2UsdDsoZnVuY3Rpb24oZCl7ZnVuY3Rpb24gZihmLGcpe3ZhciBsPUIucGxvdE9wdGlvbnN8fHt9LGM9Zy5kZWZhdWx0T3B0aW9ucztnLnByb3RvdHlwZS5wb2ludENsYXNzfHwoZy5wcm90b3R5cGUucG9pbnRDbGFzcz1rKTtnLnByb3RvdHlwZS50eXBlPWY7YyYmKGxbZl09Yyk7ZC5zZXJpZXNUeXBlc1tmXT1nfWQuc2VyaWVzVHlwZXM9e307ZC5nZXRTZXJpZXM9ZnVuY3Rpb24oZixnKXt2b2lkIDA9PT1cbmcmJihnPXt9KTt2YXIgbD1mLm9wdGlvbnMuY2hhcnQ7bD1nLnR5cGV8fGwudHlwZXx8bC5kZWZhdWx0U2VyaWVzVHlwZXx8XCJcIjt2YXIgYz1kLnNlcmllc1R5cGVzW2xdO2R8fEcoMTcsITAsZix7bWlzc2luZ01vZHVsZUZvcjpsfSk7bD1uZXcgYztcImZ1bmN0aW9uXCI9PT10eXBlb2YgbC5pbml0JiZsLmluaXQoZixnKTtyZXR1cm4gbH07ZC5yZWdpc3RlclNlcmllc1R5cGU9ZjtkLnNlcmllc1R5cGU9ZnVuY3Rpb24obCxnLHksYyxxKXt2YXIgbj1CLnBsb3RPcHRpb25zfHx7fTtnPWd8fFwiXCI7bltsXT1IKG5bZ10seSk7ZihsLEQoZC5zZXJpZXNUeXBlc1tnXXx8ZnVuY3Rpb24oKXt9LGMpKTtkLnNlcmllc1R5cGVzW2xdLnByb3RvdHlwZS50eXBlPWw7cSYmKGQuc2VyaWVzVHlwZXNbbF0ucHJvdG90eXBlLnBvaW50Q2xhc3M9RChrLHEpKTtyZXR1cm4gZC5zZXJpZXNUeXBlc1tsXX19KSh0fHwodD17fSkpO2Yuc2VyaWVzVHlwZT10LnNlcmllc1R5cGU7Zi5zZXJpZXNUeXBlcz10LnNlcmllc1R5cGVzO1xucmV0dXJuIHR9KTtQKGssXCJDb3JlL0NoYXJ0L0NoYXJ0LmpzXCIsW2tbXCJDb3JlL0FuaW1hdGlvbi9BbmltYXRpb25VdGlsaXRpZXMuanNcIl0sa1tcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvTGVnZW5kLmpzXCJdLGtbXCJDb3JlL01TUG9pbnRlci5qc1wiXSxrW1wiQ29yZS9PcHRpb25zLmpzXCJdLGtbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sa1tcIkNvcmUvUG9pbnRlci5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sa1tcIkNvcmUvVGltZS5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl0sa1tcIkNvcmUvUmVuZGVyZXIvSFRNTC9BU1QuanNcIl1dLGZ1bmN0aW9uKGYsZCxrLHgsQixHLEQsSCx0LEMsbCxFKXt2YXIgZz1mLmFuaW1hdGUseT1mLmFuaW1PYmplY3QsYz1mLnNldEFuaW1hdGlvbixxPWsuY2hhcnRzLG49ay5kb2MsQT1rLndpbixNPUcuZGVmYXVsdE9wdGlvbnMsej1HLnRpbWUsbT10LnNlcmllc1R5cGVzLHI9bC5hZGRFdmVudCxcbmU9bC5hdHRyLGg9bC5jbGVhblJlY3Vyc2l2ZWx5LGE9bC5jcmVhdGVFbGVtZW50LGI9bC5jc3Msdz1sLmRlZmluZWQsSj1sLmRpc2NhcmRFbGVtZW50LE89bC5lcmFzZSxGPWwuZXJyb3IsTj1sLmV4dGVuZCxSPWwuZmluZCxRPWwuZmlyZUV2ZW50LFQ9bC5nZXRTdHlsZSx2PWwuaXNBcnJheSxMPWwuaXNGdW5jdGlvbixwPWwuaXNOdW1iZXIsSz1sLmlzT2JqZWN0LFM9bC5pc1N0cmluZyxiYT1sLm1lcmdlLHU9bC5udW1iZXJGb3JtYXQsYWE9bC5vYmplY3RFYWNoLEk9bC5waWNrLFg9bC5wSW50LFU9bC5yZWxhdGl2ZUxlbmd0aCxlYT1sLnJlbW92ZUV2ZW50LFk9bC5zcGxhdCxkYT1sLnN5bmNUaW1lb3V0LGhhPWwudW5pcXVlS2V5LGZhPWsubWFyZ2luTmFtZXMsY2E9ZnVuY3Rpb24oKXtmdW5jdGlvbiBmKGEsYixjKXt0aGlzLnlBeGlzPXRoaXMueEF4aXM9dGhpcy51c2VyT3B0aW9ucz10aGlzLnRpdGxlT2Zmc2V0PXRoaXMudGltZT10aGlzLnN5bWJvbENvdW50ZXI9dGhpcy5zcGFjaW5nQm94PVxudGhpcy5zcGFjaW5nPXRoaXMuc2VyaWVzPXRoaXMucmVuZGVyVG89dGhpcy5yZW5kZXJlcj10aGlzLnBvaW50ZXI9dGhpcy5wb2ludENvdW50PXRoaXMucGxvdFdpZHRoPXRoaXMucGxvdFRvcD10aGlzLnBsb3RMZWZ0PXRoaXMucGxvdEhlaWdodD10aGlzLnBsb3RCb3g9dGhpcy5vcHRpb25zPXRoaXMubnVtYmVyRm9ybWF0dGVyPXRoaXMubWFyZ2luPXRoaXMubGVnZW5kPXRoaXMubGFiZWxDb2xsZWN0b3JzPXRoaXMuaXNSZXNpemluZz10aGlzLmluZGV4PXRoaXMuY29udGFpbmVyPXRoaXMuY29sb3JDb3VudGVyPXRoaXMuY2xpcEJveD10aGlzLmNoYXJ0V2lkdGg9dGhpcy5jaGFydEhlaWdodD10aGlzLmJvdW5kcz10aGlzLmF4aXNPZmZzZXQ9dGhpcy5heGVzPXZvaWQgMDt0aGlzLmdldEFyZ3MoYSxiLGMpfWYucHJvdG90eXBlLmdldEFyZ3M9ZnVuY3Rpb24oYSxiLGMpe1MoYSl8fGEubm9kZU5hbWU/KHRoaXMucmVuZGVyVG89YSx0aGlzLmluaXQoYixjKSk6dGhpcy5pbml0KGEsXG5iKX07Zi5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhLGIpe3ZhciBjLGU9YS5zZXJpZXMsZz1hLnBsb3RPcHRpb25zfHx7fTtRKHRoaXMsXCJpbml0XCIse2FyZ3M6YXJndW1lbnRzfSxmdW5jdGlvbigpe2Euc2VyaWVzPW51bGw7Yz1iYShNLGEpO3ZhciBkPWMuY2hhcnR8fHt9O2FhKGMucGxvdE9wdGlvbnMsZnVuY3Rpb24oYSxiKXtLKGEpJiYoYS50b29sdGlwPWdbYl0mJmJhKGdbYl0udG9vbHRpcCl8fHZvaWQgMCl9KTtjLnRvb2x0aXAudXNlck9wdGlvbnM9YS5jaGFydCYmYS5jaGFydC5mb3JFeHBvcnQmJmEudG9vbHRpcC51c2VyT3B0aW9uc3x8YS50b29sdGlwO2Muc2VyaWVzPWEuc2VyaWVzPWU7dGhpcy51c2VyT3B0aW9ucz1hO3ZhciBmPWQuZXZlbnRzO3RoaXMubWFyZ2luPVtdO3RoaXMuc3BhY2luZz1bXTt0aGlzLmJvdW5kcz17aDp7fSx2Ont9fTt0aGlzLmxhYmVsQ29sbGVjdG9ycz1bXTt0aGlzLmNhbGxiYWNrPWI7dGhpcy5pc1Jlc2l6aW5nPTA7dGhpcy5vcHRpb25zPVxuYzt0aGlzLmF4ZXM9W107dGhpcy5zZXJpZXM9W107dGhpcy50aW1lPWEudGltZSYmT2JqZWN0LmtleXMoYS50aW1lKS5sZW5ndGg/bmV3IEMoYS50aW1lKTprLnRpbWU7dGhpcy5udW1iZXJGb3JtYXR0ZXI9ZC5udW1iZXJGb3JtYXR0ZXJ8fHU7dGhpcy5zdHlsZWRNb2RlPWQuc3R5bGVkTW9kZTt0aGlzLmhhc0NhcnRlc2lhblNlcmllcz1kLnNob3dBeGVzO3ZhciBoPXRoaXM7aC5pbmRleD1xLmxlbmd0aDtxLnB1c2goaCk7ay5jaGFydENvdW50Kys7ZiYmYWEoZixmdW5jdGlvbihhLGIpe0woYSkmJnIoaCxiLGEpfSk7aC54QXhpcz1bXTtoLnlBeGlzPVtdO2gucG9pbnRDb3VudD1oLmNvbG9yQ291bnRlcj1oLnN5bWJvbENvdW50ZXI9MDtRKGgsXCJhZnRlckluaXRcIik7aC5maXJzdFJlbmRlcigpfSl9O2YucHJvdG90eXBlLmluaXRTZXJpZXM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zLmNoYXJ0O2I9YS50eXBlfHxiLnR5cGV8fGIuZGVmYXVsdFNlcmllc1R5cGU7dmFyIGM9XG5tW2JdO2N8fEYoMTcsITAsdGhpcyx7bWlzc2luZ01vZHVsZUZvcjpifSk7Yj1uZXcgYztcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5pbml0JiZiLmluaXQodGhpcyxhKTtyZXR1cm4gYn07Zi5wcm90b3R5cGUuc2V0U2VyaWVzRGF0YT1mdW5jdGlvbigpe3RoaXMuZ2V0U2VyaWVzT3JkZXJCeUxpbmtzKCkuZm9yRWFjaChmdW5jdGlvbihhKXthLnBvaW50c3x8YS5kYXRhfHwhYS5lbmFibGVkRGF0YVNvcnRpbmd8fGEuc2V0RGF0YShhLm9wdGlvbnMuZGF0YSwhMSl9KX07Zi5wcm90b3R5cGUuZ2V0U2VyaWVzT3JkZXJCeUxpbmtzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VyaWVzLmNvbmNhdCgpLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5saW5rZWRTZXJpZXMubGVuZ3RofHxiLmxpbmtlZFNlcmllcy5sZW5ndGg/Yi5saW5rZWRTZXJpZXMubGVuZ3RoLWEubGlua2VkU2VyaWVzLmxlbmd0aDowfSl9O2YucHJvdG90eXBlLm9yZGVyU2VyaWVzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuc2VyaWVzO1xuZm9yKGE9YXx8MDthPGIubGVuZ3RoO2ErKyliW2FdJiYoYlthXS5pbmRleD1hLGJbYV0ubmFtZT1iW2FdLmdldE5hbWUoKSl9O2YucHJvdG90eXBlLmlzSW5zaWRlUGxvdD1mdW5jdGlvbihhLGIsYyl7dmFyIGU9Yz9iOmE7YT1jP2E6YjtlPXt4OmUseTphLGlzSW5zaWRlUGxvdDowPD1lJiZlPD10aGlzLnBsb3RXaWR0aCYmMDw9YSYmYTw9dGhpcy5wbG90SGVpZ2h0fTtRKHRoaXMsXCJhZnRlcklzSW5zaWRlUGxvdFwiLGUpO3JldHVybiBlLmlzSW5zaWRlUGxvdH07Zi5wcm90b3R5cGUucmVkcmF3PWZ1bmN0aW9uKGEpe1EodGhpcyxcImJlZm9yZVJlZHJhd1wiKTt2YXIgYj10aGlzLmhhc0NhcnRlc2lhblNlcmllcz90aGlzLmF4ZXM6dGhpcy5jb2xvckF4aXN8fFtdLGU9dGhpcy5zZXJpZXMsZz10aGlzLnBvaW50ZXIsZD10aGlzLmxlZ2VuZCxmPXRoaXMudXNlck9wdGlvbnMubGVnZW5kLGg9dGhpcy5pc0RpcnR5TGVnZW5kLG09dGhpcy5pc0RpcnR5Qm94LHU9dGhpcy5yZW5kZXJlcixsPVxudS5pc0hpZGRlbigpLG49W107dGhpcy5zZXRSZXNwb25zaXZlJiZ0aGlzLnNldFJlc3BvbnNpdmUoITEpO2ModGhpcy5oYXNSZW5kZXJlZD9hOiExLHRoaXMpO2wmJnRoaXMudGVtcG9yYXJ5RGlzcGxheSgpO3RoaXMubGF5T3V0VGl0bGVzKCk7Zm9yKGE9ZS5sZW5ndGg7YS0tOyl7dmFyIHA9ZVthXTtpZihwLm9wdGlvbnMuc3RhY2tpbmd8fHAub3B0aW9ucy5jZW50ZXJJbkNhdGVnb3J5KXt2YXIgcT0hMDtpZihwLmlzRGlydHkpe3ZhciByPSEwO2JyZWFrfX19aWYocilmb3IoYT1lLmxlbmd0aDthLS07KXA9ZVthXSxwLm9wdGlvbnMuc3RhY2tpbmcmJihwLmlzRGlydHk9ITApO2UuZm9yRWFjaChmdW5jdGlvbihhKXthLmlzRGlydHkmJihcInBvaW50XCI9PT1hLm9wdGlvbnMubGVnZW5kVHlwZT8oXCJmdW5jdGlvblwiPT09dHlwZW9mIGEudXBkYXRlVG90YWxzJiZhLnVwZGF0ZVRvdGFscygpLGg9ITApOmYmJihmLmxhYmVsRm9ybWF0dGVyfHxmLmxhYmVsRm9ybWF0KSYmKGg9ITApKTthLmlzRGlydHlEYXRhJiZcblEoYSxcInVwZGF0ZWREYXRhXCIpfSk7aCYmZCYmZC5vcHRpb25zLmVuYWJsZWQmJihkLnJlbmRlcigpLHRoaXMuaXNEaXJ0eUxlZ2VuZD0hMSk7cSYmdGhpcy5nZXRTdGFja3MoKTtiLmZvckVhY2goZnVuY3Rpb24oYSl7YS51cGRhdGVOYW1lcygpO2Euc2V0U2NhbGUoKX0pO3RoaXMuZ2V0TWFyZ2lucygpO2IuZm9yRWFjaChmdW5jdGlvbihhKXthLmlzRGlydHkmJihtPSEwKX0pO2IuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hLm1pbitcIixcIithLm1heDthLmV4dEtleSE9PWImJihhLmV4dEtleT1iLG4ucHVzaChmdW5jdGlvbigpe1EoYSxcImFmdGVyU2V0RXh0cmVtZXNcIixOKGEuZXZlbnRBcmdzLGEuZ2V0RXh0cmVtZXMoKSkpO2RlbGV0ZSBhLmV2ZW50QXJnc30pKTsobXx8cSkmJmEucmVkcmF3KCl9KTttJiZ0aGlzLmRyYXdDaGFydEJveCgpO1EodGhpcyxcInByZWRyYXdcIik7ZS5mb3JFYWNoKGZ1bmN0aW9uKGEpeyhtfHxhLmlzRGlydHkpJiZhLnZpc2libGUmJmEucmVkcmF3KCk7XG5hLmlzRGlydHlEYXRhPSExfSk7ZyYmZy5yZXNldCghMCk7dS5kcmF3KCk7USh0aGlzLFwicmVkcmF3XCIpO1EodGhpcyxcInJlbmRlclwiKTtsJiZ0aGlzLnRlbXBvcmFyeURpc3BsYXkoITApO24uZm9yRWFjaChmdW5jdGlvbihhKXthLmNhbGwoKX0pfTtmLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihiKXtyZXR1cm4gYi5pZD09PWF8fGIub3B0aW9ucyYmYi5vcHRpb25zLmlkPT09YX12YXIgYz10aGlzLnNlcmllcyxlO3ZhciBnPVIodGhpcy5heGVzLGIpfHxSKHRoaXMuc2VyaWVzLGIpO2ZvcihlPTA7IWcmJmU8Yy5sZW5ndGg7ZSsrKWc9UihjW2VdLnBvaW50c3x8W10sYik7cmV0dXJuIGd9O2YucHJvdG90eXBlLmdldEF4ZXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9dGhpcy5vcHRpb25zLGU9Yi54QXhpcz1ZKGIueEF4aXN8fHt9KTtiPWIueUF4aXM9WShiLnlBeGlzfHx7fSk7USh0aGlzLFwiZ2V0QXhlc1wiKTtlLmZvckVhY2goZnVuY3Rpb24oYSxiKXthLmluZGV4PVxuYjthLmlzWD0hMH0pO2IuZm9yRWFjaChmdW5jdGlvbihhLGIpe2EuaW5kZXg9Yn0pO2UuY29uY2F0KGIpLmZvckVhY2goZnVuY3Rpb24oYil7bmV3IGQoYSxiKX0pO1EodGhpcyxcImFmdGVyR2V0QXhlc1wiKX07Zi5wcm90b3R5cGUuZ2V0U2VsZWN0ZWRQb2ludHM9ZnVuY3Rpb24oKXt2YXIgYT1bXTt0aGlzLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2E9YS5jb25jYXQoYi5nZXRQb2ludHNDb2xsZWN0aW9uKCkuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBJKGEuc2VsZWN0ZWRTdGFnaW5nLGEuc2VsZWN0ZWQpfSkpfSk7cmV0dXJuIGF9O2YucHJvdG90eXBlLmdldFNlbGVjdGVkU2VyaWVzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VyaWVzLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYS5zZWxlY3RlZH0pfTtmLnByb3RvdHlwZS5zZXRUaXRsZT1mdW5jdGlvbihhLGIsZSl7dGhpcy5hcHBseURlc2NyaXB0aW9uKFwidGl0bGVcIixhKTt0aGlzLmFwcGx5RGVzY3JpcHRpb24oXCJzdWJ0aXRsZVwiLFxuYik7dGhpcy5hcHBseURlc2NyaXB0aW9uKFwiY2FwdGlvblwiLHZvaWQgMCk7dGhpcy5sYXlPdXRUaXRsZXMoZSl9O2YucHJvdG90eXBlLmFwcGx5RGVzY3JpcHRpb249ZnVuY3Rpb24oYSxiKXt2YXIgZT10aGlzLGM9XCJ0aXRsZVwiPT09YT97Y29sb3I6RC5uZXV0cmFsQ29sb3I4MCxmb250U2l6ZTp0aGlzLm9wdGlvbnMuaXNTdG9jaz9cIjE2cHhcIjpcIjE4cHhcIn06e2NvbG9yOkQubmV1dHJhbENvbG9yNjB9O2M9dGhpcy5vcHRpb25zW2FdPWJhKCF0aGlzLnN0eWxlZE1vZGUmJntzdHlsZTpjfSx0aGlzLm9wdGlvbnNbYV0sYik7dmFyIGc9dGhpc1thXTtnJiZiJiYodGhpc1thXT1nPWcuZGVzdHJveSgpKTtjJiYhZyYmKGc9dGhpcy5yZW5kZXJlci50ZXh0KGMudGV4dCwwLDAsYy51c2VIVE1MKS5hdHRyKHthbGlnbjpjLmFsaWduLFwiY2xhc3NcIjpcImhpZ2hjaGFydHMtXCIrYSx6SW5kZXg6Yy56SW5kZXh8fDR9KS5hZGQoKSxnLnVwZGF0ZT1mdW5jdGlvbihiKXtlW3t0aXRsZTpcInNldFRpdGxlXCIsXG5zdWJ0aXRsZTpcInNldFN1YnRpdGxlXCIsY2FwdGlvbjpcInNldENhcHRpb25cIn1bYV1dKGIpfSx0aGlzLnN0eWxlZE1vZGV8fGcuY3NzKGMuc3R5bGUpLHRoaXNbYV09Zyl9O2YucHJvdG90eXBlLmxheU91dFRpdGxlcz1mdW5jdGlvbihhKXt2YXIgYj1bMCwwLDBdLGM9dGhpcy5yZW5kZXJlcixlPXRoaXMuc3BhY2luZ0JveDtbXCJ0aXRsZVwiLFwic3VidGl0bGVcIixcImNhcHRpb25cIl0uZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgZz10aGlzW2FdLGQ9dGhpcy5vcHRpb25zW2FdLGY9ZC52ZXJ0aWNhbEFsaWdufHxcInRvcFwiO2E9XCJ0aXRsZVwiPT09YT8tMzpcInRvcFwiPT09Zj9iWzBdKzI6MDtpZihnKXtpZighdGhpcy5zdHlsZWRNb2RlKXZhciBoPWQuc3R5bGUuZm9udFNpemU7aD1jLmZvbnRNZXRyaWNzKGgsZykuYjtnLmNzcyh7d2lkdGg6KGQud2lkdGh8fGUud2lkdGgrKGQud2lkdGhBZGp1c3R8fDApKStcInB4XCJ9KTt2YXIgbT1NYXRoLnJvdW5kKGcuZ2V0QkJveChkLnVzZUhUTUwpLmhlaWdodCk7XG5nLmFsaWduKE4oe3k6XCJib3R0b21cIj09PWY/aDphK2gsaGVpZ2h0Om19LGQpLCExLFwic3BhY2luZ0JveFwiKTtkLmZsb2F0aW5nfHwoXCJ0b3BcIj09PWY/YlswXT1NYXRoLmNlaWwoYlswXSttKTpcImJvdHRvbVwiPT09ZiYmKGJbMl09TWF0aC5jZWlsKGJbMl0rbSkpKX19LHRoaXMpO2JbMF0mJlwidG9wXCI9PT0odGhpcy5vcHRpb25zLnRpdGxlLnZlcnRpY2FsQWxpZ258fFwidG9wXCIpJiYoYlswXSs9dGhpcy5vcHRpb25zLnRpdGxlLm1hcmdpbik7YlsyXSYmXCJib3R0b21cIj09PXRoaXMub3B0aW9ucy5jYXB0aW9uLnZlcnRpY2FsQWxpZ24mJihiWzJdKz10aGlzLm9wdGlvbnMuY2FwdGlvbi5tYXJnaW4pO3ZhciBnPSF0aGlzLnRpdGxlT2Zmc2V0fHx0aGlzLnRpdGxlT2Zmc2V0LmpvaW4oXCIsXCIpIT09Yi5qb2luKFwiLFwiKTt0aGlzLnRpdGxlT2Zmc2V0PWI7USh0aGlzLFwiYWZ0ZXJMYXlPdXRUaXRsZXNcIik7IXRoaXMuaXNEaXJ0eUJveCYmZyYmKHRoaXMuaXNEaXJ0eUJveD10aGlzLmlzRGlydHlMZWdlbmQ9XG5nLHRoaXMuaGFzUmVuZGVyZWQmJkkoYSwhMCkmJnRoaXMuaXNEaXJ0eUJveCYmdGhpcy5yZWRyYXcoKSl9O2YucHJvdG90eXBlLmdldENoYXJ0U2l6ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucy5jaGFydCxiPWEud2lkdGg7YT1hLmhlaWdodDt2YXIgYz10aGlzLnJlbmRlclRvO3coYil8fCh0aGlzLmNvbnRhaW5lcldpZHRoPVQoYyxcIndpZHRoXCIpKTt3KGEpfHwodGhpcy5jb250YWluZXJIZWlnaHQ9VChjLFwiaGVpZ2h0XCIpKTt0aGlzLmNoYXJ0V2lkdGg9TWF0aC5tYXgoMCxifHx0aGlzLmNvbnRhaW5lcldpZHRofHw2MDApO3RoaXMuY2hhcnRIZWlnaHQ9TWF0aC5tYXgoMCxVKGEsdGhpcy5jaGFydFdpZHRoKXx8KDE8dGhpcy5jb250YWluZXJIZWlnaHQ/dGhpcy5jb250YWluZXJIZWlnaHQ6NDAwKSl9O2YucHJvdG90eXBlLnRlbXBvcmFyeURpc3BsYXk9ZnVuY3Rpb24oYSl7dmFyIGM9dGhpcy5yZW5kZXJUbztpZihhKWZvcig7YyYmYy5zdHlsZTspYy5oY09yaWdTdHlsZSYmXG4oYihjLGMuaGNPcmlnU3R5bGUpLGRlbGV0ZSBjLmhjT3JpZ1N0eWxlKSxjLmhjT3JpZ0RldGFjaGVkJiYobi5ib2R5LnJlbW92ZUNoaWxkKGMpLGMuaGNPcmlnRGV0YWNoZWQ9ITEpLGM9Yy5wYXJlbnROb2RlO2Vsc2UgZm9yKDtjJiZjLnN0eWxlOyl7bi5ib2R5LmNvbnRhaW5zKGMpfHxjLnBhcmVudE5vZGV8fChjLmhjT3JpZ0RldGFjaGVkPSEwLG4uYm9keS5hcHBlbmRDaGlsZChjKSk7aWYoXCJub25lXCI9PT1UKGMsXCJkaXNwbGF5XCIsITEpfHxjLmhjT3JpY0RldGFjaGVkKWMuaGNPcmlnU3R5bGU9e2Rpc3BsYXk6Yy5zdHlsZS5kaXNwbGF5LGhlaWdodDpjLnN0eWxlLmhlaWdodCxvdmVyZmxvdzpjLnN0eWxlLm92ZXJmbG93fSxhPXtkaXNwbGF5OlwiYmxvY2tcIixvdmVyZmxvdzpcImhpZGRlblwifSxjIT09dGhpcy5yZW5kZXJUbyYmKGEuaGVpZ2h0PTApLGIoYyxhKSxjLm9mZnNldFdpZHRofHxjLnN0eWxlLnNldFByb3BlcnR5KFwiZGlzcGxheVwiLFwiYmxvY2tcIixcImltcG9ydGFudFwiKTtjPVxuYy5wYXJlbnROb2RlO2lmKGM9PT1uLmJvZHkpYnJlYWt9fTtmLnByb3RvdHlwZS5zZXRDbGFzc05hbWU9ZnVuY3Rpb24oYSl7dGhpcy5jb250YWluZXIuY2xhc3NOYW1lPVwiaGlnaGNoYXJ0cy1jb250YWluZXIgXCIrKGF8fFwiXCIpfTtmLnByb3RvdHlwZS5nZXRDb250YWluZXI9ZnVuY3Rpb24oKXt2YXIgZz10aGlzLm9wdGlvbnMsZD1nLmNoYXJ0O3ZhciBmPXRoaXMucmVuZGVyVG87dmFyIGg9aGEoKSxtLHU7Znx8KHRoaXMucmVuZGVyVG89Zj1kLnJlbmRlclRvKTtTKGYpJiYodGhpcy5yZW5kZXJUbz1mPW4uZ2V0RWxlbWVudEJ5SWQoZikpO2Z8fEYoMTMsITAsdGhpcyk7dmFyIGw9WChlKGYsXCJkYXRhLWhpZ2hjaGFydHMtY2hhcnRcIikpO3AobCkmJnFbbF0mJnFbbF0uaGFzUmVuZGVyZWQmJnFbbF0uZGVzdHJveSgpO2UoZixcImRhdGEtaGlnaGNoYXJ0cy1jaGFydFwiLHRoaXMuaW5kZXgpO2YuaW5uZXJIVE1MPVwiXCI7ZC5za2lwQ2xvbmV8fGYub2Zmc2V0V2lkdGh8fHRoaXMudGVtcG9yYXJ5RGlzcGxheSgpO1xudGhpcy5nZXRDaGFydFNpemUoKTtsPXRoaXMuY2hhcnRXaWR0aDt2YXIgcj10aGlzLmNoYXJ0SGVpZ2h0O2IoZix7b3ZlcmZsb3c6XCJoaWRkZW5cIn0pO3RoaXMuc3R5bGVkTW9kZXx8KG09Tih7cG9zaXRpb246XCJyZWxhdGl2ZVwiLG92ZXJmbG93OlwiaGlkZGVuXCIsd2lkdGg6bCtcInB4XCIsaGVpZ2h0OnIrXCJweFwiLHRleHRBbGlnbjpcImxlZnRcIixsaW5lSGVpZ2h0Olwibm9ybWFsXCIsekluZGV4OjAsXCItd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3JcIjpcInJnYmEoMCwwLDAsMClcIix1c2VyU2VsZWN0Olwibm9uZVwifSxkLnN0eWxlKSk7dGhpcy5jb250YWluZXI9Zj1hKFwiZGl2XCIse2lkOmh9LG0sZik7dGhpcy5fY3Vyc29yPWYuc3R5bGUuY3Vyc29yO3RoaXMucmVuZGVyZXI9bmV3IChrW2QucmVuZGVyZXJdfHxrLlJlbmRlcmVyKShmLGwscixudWxsLGQuZm9yRXhwb3J0LGcuZXhwb3J0aW5nJiZnLmV4cG9ydGluZy5hbGxvd0hUTUwsdGhpcy5zdHlsZWRNb2RlKTtjKHZvaWQgMCx0aGlzKTt0aGlzLnNldENsYXNzTmFtZShkLmNsYXNzTmFtZSk7XG5pZih0aGlzLnN0eWxlZE1vZGUpZm9yKHUgaW4gZy5kZWZzKXRoaXMucmVuZGVyZXIuZGVmaW5pdGlvbihnLmRlZnNbdV0pO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShkLnN0eWxlKTt0aGlzLnJlbmRlcmVyLmNoYXJ0SW5kZXg9dGhpcy5pbmRleDtRKHRoaXMsXCJhZnRlckdldENvbnRhaW5lclwiKX07Zi5wcm90b3R5cGUuZ2V0TWFyZ2lucz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnNwYWNpbmcsYz10aGlzLm1hcmdpbixlPXRoaXMudGl0bGVPZmZzZXQ7dGhpcy5yZXNldE1hcmdpbnMoKTtlWzBdJiYhdyhjWzBdKSYmKHRoaXMucGxvdFRvcD1NYXRoLm1heCh0aGlzLnBsb3RUb3AsZVswXStiWzBdKSk7ZVsyXSYmIXcoY1syXSkmJih0aGlzLm1hcmdpbkJvdHRvbT1NYXRoLm1heCh0aGlzLm1hcmdpbkJvdHRvbSxlWzJdK2JbMl0pKTt0aGlzLmxlZ2VuZCYmdGhpcy5sZWdlbmQuZGlzcGxheSYmdGhpcy5sZWdlbmQuYWRqdXN0TWFyZ2lucyhjLGIpO1EodGhpcyxcImdldE1hcmdpbnNcIik7XG5hfHx0aGlzLmdldEF4aXNNYXJnaW5zKCl9O2YucHJvdG90eXBlLmdldEF4aXNNYXJnaW5zPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuYXhpc09mZnNldD1bMCwwLDAsMF0sYz1hLmNvbG9yQXhpcyxlPWEubWFyZ2luLGc9ZnVuY3Rpb24oYSl7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EudmlzaWJsZSYmYS5nZXRPZmZzZXQoKX0pfTthLmhhc0NhcnRlc2lhblNlcmllcz9nKGEuYXhlcyk6YyYmYy5sZW5ndGgmJmcoYyk7ZmEuZm9yRWFjaChmdW5jdGlvbihjLGcpe3coZVtnXSl8fChhW2NdKz1iW2ddKX0pO2Euc2V0Q2hhcnRTaXplKCl9O2YucHJvdG90eXBlLnJlZmxvdz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9Yi5vcHRpb25zLmNoYXJ0LGU9Yi5yZW5kZXJUbyxnPXcoYy53aWR0aCkmJncoYy5oZWlnaHQpLGQ9Yy53aWR0aHx8VChlLFwid2lkdGhcIik7Yz1jLmhlaWdodHx8VChlLFwiaGVpZ2h0XCIpO2U9YT9hLnRhcmdldDpBO2RlbGV0ZSBiLnBvaW50ZXIuY2hhcnRQb3NpdGlvbjtpZighZyYmXG4hYi5pc1ByaW50aW5nJiZkJiZjJiYoZT09PUF8fGU9PT1uKSl7aWYoZCE9PWIuY29udGFpbmVyV2lkdGh8fGMhPT1iLmNvbnRhaW5lckhlaWdodClsLmNsZWFyVGltZW91dChiLnJlZmxvd1RpbWVvdXQpLGIucmVmbG93VGltZW91dD1kYShmdW5jdGlvbigpe2IuY29udGFpbmVyJiZiLnNldFNpemUodm9pZCAwLHZvaWQgMCwhMSl9LGE/MTAwOjApO2IuY29udGFpbmVyV2lkdGg9ZDtiLmNvbnRhaW5lckhlaWdodD1jfX07Zi5wcm90b3R5cGUuc2V0UmVmbG93PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7ITE9PT1hfHx0aGlzLnVuYmluZFJlZmxvdz8hMT09PWEmJnRoaXMudW5iaW5kUmVmbG93JiYodGhpcy51bmJpbmRSZWZsb3c9dGhpcy51bmJpbmRSZWZsb3coKSk6KHRoaXMudW5iaW5kUmVmbG93PXIoQSxcInJlc2l6ZVwiLGZ1bmN0aW9uKGEpe2Iub3B0aW9ucyYmYi5yZWZsb3coYSl9KSxyKHRoaXMsXCJkZXN0cm95XCIsdGhpcy51bmJpbmRSZWZsb3cpKX07Zi5wcm90b3R5cGUuc2V0U2l6ZT1cbmZ1bmN0aW9uKGEsZSxkKXt2YXIgZj10aGlzLGg9Zi5yZW5kZXJlcjtmLmlzUmVzaXppbmcrPTE7YyhkLGYpO2Q9aC5nbG9iYWxBbmltYXRpb247Zi5vbGRDaGFydEhlaWdodD1mLmNoYXJ0SGVpZ2h0O2Yub2xkQ2hhcnRXaWR0aD1mLmNoYXJ0V2lkdGg7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhJiYoZi5vcHRpb25zLmNoYXJ0LndpZHRoPWEpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgZSYmKGYub3B0aW9ucy5jaGFydC5oZWlnaHQ9ZSk7Zi5nZXRDaGFydFNpemUoKTtmLnN0eWxlZE1vZGV8fChkP2c6YikoZi5jb250YWluZXIse3dpZHRoOmYuY2hhcnRXaWR0aCtcInB4XCIsaGVpZ2h0OmYuY2hhcnRIZWlnaHQrXCJweFwifSxkKTtmLnNldENoYXJ0U2l6ZSghMCk7aC5zZXRTaXplKGYuY2hhcnRXaWR0aCxmLmNoYXJ0SGVpZ2h0LGQpO2YuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuaXNEaXJ0eT0hMDthLnNldFNjYWxlKCl9KTtmLmlzRGlydHlMZWdlbmQ9ITA7Zi5pc0RpcnR5Qm94PSEwO2YubGF5T3V0VGl0bGVzKCk7XG5mLmdldE1hcmdpbnMoKTtmLnJlZHJhdyhkKTtmLm9sZENoYXJ0SGVpZ2h0PW51bGw7UShmLFwicmVzaXplXCIpO2RhKGZ1bmN0aW9uKCl7ZiYmUShmLFwiZW5kUmVzaXplXCIsbnVsbCxmdW5jdGlvbigpey0tZi5pc1Jlc2l6aW5nfSl9LHkoZCkuZHVyYXRpb24pfTtmLnByb3RvdHlwZS5zZXRDaGFydFNpemU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5pbnZlcnRlZCxjPXRoaXMucmVuZGVyZXIsZT10aGlzLmNoYXJ0V2lkdGgsZz10aGlzLmNoYXJ0SGVpZ2h0LGQ9dGhpcy5vcHRpb25zLmNoYXJ0LGY9dGhpcy5zcGFjaW5nLGg9dGhpcy5jbGlwT2Zmc2V0LG0sdSxsLG47dGhpcy5wbG90TGVmdD1tPU1hdGgucm91bmQodGhpcy5wbG90TGVmdCk7dGhpcy5wbG90VG9wPXU9TWF0aC5yb3VuZCh0aGlzLnBsb3RUb3ApO3RoaXMucGxvdFdpZHRoPWw9TWF0aC5tYXgoMCxNYXRoLnJvdW5kKGUtbS10aGlzLm1hcmdpblJpZ2h0KSk7dGhpcy5wbG90SGVpZ2h0PW49TWF0aC5tYXgoMCxNYXRoLnJvdW5kKGctXG51LXRoaXMubWFyZ2luQm90dG9tKSk7dGhpcy5wbG90U2l6ZVg9Yj9uOmw7dGhpcy5wbG90U2l6ZVk9Yj9sOm47dGhpcy5wbG90Qm9yZGVyV2lkdGg9ZC5wbG90Qm9yZGVyV2lkdGh8fDA7dGhpcy5zcGFjaW5nQm94PWMuc3BhY2luZ0JveD17eDpmWzNdLHk6ZlswXSx3aWR0aDplLWZbM10tZlsxXSxoZWlnaHQ6Zy1mWzBdLWZbMl19O3RoaXMucGxvdEJveD1jLnBsb3RCb3g9e3g6bSx5OnUsd2lkdGg6bCxoZWlnaHQ6bn07ZT0yKk1hdGguZmxvb3IodGhpcy5wbG90Qm9yZGVyV2lkdGgvMik7Yj1NYXRoLmNlaWwoTWF0aC5tYXgoZSxoWzNdKS8yKTtjPU1hdGguY2VpbChNYXRoLm1heChlLGhbMF0pLzIpO3RoaXMuY2xpcEJveD17eDpiLHk6Yyx3aWR0aDpNYXRoLmZsb29yKHRoaXMucGxvdFNpemVYLU1hdGgubWF4KGUsaFsxXSkvMi1iKSxoZWlnaHQ6TWF0aC5tYXgoMCxNYXRoLmZsb29yKHRoaXMucGxvdFNpemVZLU1hdGgubWF4KGUsaFsyXSkvMi1jKSl9O2F8fHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2Euc2V0QXhpc1NpemUoKTtcbmEuc2V0QXhpc1RyYW5zbGF0aW9uKCl9KTtRKHRoaXMsXCJhZnRlclNldENoYXJ0U2l6ZVwiLHtza2lwQXhlczphfSl9O2YucHJvdG90eXBlLnJlc2V0TWFyZ2lucz1mdW5jdGlvbigpe1EodGhpcyxcInJlc2V0TWFyZ2luc1wiKTt2YXIgYT10aGlzLGI9YS5vcHRpb25zLmNoYXJ0O1tcIm1hcmdpblwiLFwic3BhY2luZ1wiXS5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBlPWJbY10sZz1LKGUpP2U6W2UsZSxlLGVdO1tcIlRvcFwiLFwiUmlnaHRcIixcIkJvdHRvbVwiLFwiTGVmdFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGUsZCl7YVtjXVtkXT1JKGJbYytlXSxnW2RdKX0pfSk7ZmEuZm9yRWFjaChmdW5jdGlvbihiLGMpe2FbYl09SShhLm1hcmdpbltjXSxhLnNwYWNpbmdbY10pfSk7YS5heGlzT2Zmc2V0PVswLDAsMCwwXTthLmNsaXBPZmZzZXQ9WzAsMCwwLDBdfTtmLnByb3RvdHlwZS5kcmF3Q2hhcnRCb3g9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMuY2hhcnQsYj10aGlzLnJlbmRlcmVyLGM9dGhpcy5jaGFydFdpZHRoLFxuZT10aGlzLmNoYXJ0SGVpZ2h0LGc9dGhpcy5jaGFydEJhY2tncm91bmQsZD10aGlzLnBsb3RCYWNrZ3JvdW5kLGY9dGhpcy5wbG90Qm9yZGVyLGg9dGhpcy5zdHlsZWRNb2RlLG09dGhpcy5wbG90QkdJbWFnZSx1PWEuYmFja2dyb3VuZENvbG9yLGw9YS5wbG90QmFja2dyb3VuZENvbG9yLG49YS5wbG90QmFja2dyb3VuZEltYWdlLHAscT10aGlzLnBsb3RMZWZ0LHI9dGhpcy5wbG90VG9wLGs9dGhpcy5wbG90V2lkdGgsST10aGlzLnBsb3RIZWlnaHQsdz10aGlzLnBsb3RCb3gseT10aGlzLmNsaXBSZWN0LHQ9dGhpcy5jbGlwQm94LHY9XCJhbmltYXRlXCI7Z3x8KHRoaXMuY2hhcnRCYWNrZ3JvdW5kPWc9Yi5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWJhY2tncm91bmRcIikuYWRkKCksdj1cImF0dHJcIik7aWYoaCl2YXIgej1wPWcuc3Ryb2tlV2lkdGgoKTtlbHNle3o9YS5ib3JkZXJXaWR0aHx8MDtwPXorKGEuc2hhZG93Pzg6MCk7dT17ZmlsbDp1fHxcIm5vbmVcIn07aWYoenx8Z1tcInN0cm9rZS13aWR0aFwiXSl1LnN0cm9rZT1cbmEuYm9yZGVyQ29sb3IsdVtcInN0cm9rZS13aWR0aFwiXT16O2cuYXR0cih1KS5zaGFkb3coYS5zaGFkb3cpfWdbdl0oe3g6cC8yLHk6cC8yLHdpZHRoOmMtcC16JTIsaGVpZ2h0OmUtcC16JTIscjphLmJvcmRlclJhZGl1c30pO3Y9XCJhbmltYXRlXCI7ZHx8KHY9XCJhdHRyXCIsdGhpcy5wbG90QmFja2dyb3VuZD1kPWIucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wbG90LWJhY2tncm91bmRcIikuYWRkKCkpO2Rbdl0odyk7aHx8KGQuYXR0cih7ZmlsbDpsfHxcIm5vbmVcIn0pLnNoYWRvdyhhLnBsb3RTaGFkb3cpLG4mJihtPyhuIT09bS5hdHRyKFwiaHJlZlwiKSYmbS5hdHRyKFwiaHJlZlwiLG4pLG0uYW5pbWF0ZSh3KSk6dGhpcy5wbG90QkdJbWFnZT1iLmltYWdlKG4scSxyLGssSSkuYWRkKCkpKTt5P3kuYW5pbWF0ZSh7d2lkdGg6dC53aWR0aCxoZWlnaHQ6dC5oZWlnaHR9KTp0aGlzLmNsaXBSZWN0PWIuY2xpcFJlY3QodCk7dj1cImFuaW1hdGVcIjtmfHwodj1cImF0dHJcIix0aGlzLnBsb3RCb3JkZXI9XG5mPWIucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wbG90LWJvcmRlclwiKS5hdHRyKHt6SW5kZXg6MX0pLmFkZCgpKTtofHxmLmF0dHIoe3N0cm9rZTphLnBsb3RCb3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOmEucGxvdEJvcmRlcldpZHRofHwwLGZpbGw6XCJub25lXCJ9KTtmW3ZdKGYuY3Jpc3Aoe3g6cSx5OnIsd2lkdGg6ayxoZWlnaHQ6SX0sLWYuc3Ryb2tlV2lkdGgoKSkpO3RoaXMuaXNEaXJ0eUJveD0hMTtRKHRoaXMsXCJhZnRlckRyYXdDaGFydEJveFwiKX07Zi5wcm90b3R5cGUucHJvcEZyb21TZXJpZXM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5vcHRpb25zLmNoYXJ0LGMsZT1hLm9wdGlvbnMuc2VyaWVzLGcsZDtbXCJpbnZlcnRlZFwiLFwiYW5ndWxhclwiLFwicG9sYXJcIl0uZm9yRWFjaChmdW5jdGlvbihmKXtjPW1bYi50eXBlfHxiLmRlZmF1bHRTZXJpZXNUeXBlXTtkPWJbZl18fGMmJmMucHJvdG90eXBlW2ZdO2ZvcihnPWUmJmUubGVuZ3RoOyFkJiZnLS07KShjPW1bZVtnXS50eXBlXSkmJlxuYy5wcm90b3R5cGVbZl0mJihkPSEwKTthW2ZdPWR9KX07Zi5wcm90b3R5cGUubGlua1Nlcmllcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLnNlcmllcztiLmZvckVhY2goZnVuY3Rpb24oYSl7YS5saW5rZWRTZXJpZXMubGVuZ3RoPTB9KTtiLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGM9Yi5vcHRpb25zLmxpbmtlZFRvO1MoYykmJihjPVwiOnByZXZpb3VzXCI9PT1jP2Euc2VyaWVzW2IuaW5kZXgtMV06YS5nZXQoYykpJiZjLmxpbmtlZFBhcmVudCE9PWImJihjLmxpbmtlZFNlcmllcy5wdXNoKGIpLGIubGlua2VkUGFyZW50PWMsYy5lbmFibGVkRGF0YVNvcnRpbmcmJmIuc2V0RGF0YVNvcnRpbmdPcHRpb25zKCksYi52aXNpYmxlPUkoYi5vcHRpb25zLnZpc2libGUsYy5vcHRpb25zLnZpc2libGUsYi52aXNpYmxlKSl9KTtRKHRoaXMsXCJhZnRlckxpbmtTZXJpZXNcIil9O2YucHJvdG90eXBlLnJlbmRlclNlcmllcz1mdW5jdGlvbigpe3RoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYSl7YS50cmFuc2xhdGUoKTtcbmEucmVuZGVyKCl9KX07Zi5wcm90b3R5cGUucmVuZGVyTGFiZWxzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucy5sYWJlbHM7Yi5pdGVtcyYmYi5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBlPU4oYi5zdHlsZSxjLnN0eWxlKSxnPVgoZS5sZWZ0KSthLnBsb3RMZWZ0LGQ9WChlLnRvcCkrYS5wbG90VG9wKzEyO2RlbGV0ZSBlLmxlZnQ7ZGVsZXRlIGUudG9wO2EucmVuZGVyZXIudGV4dChjLmh0bWwsZyxkKS5hdHRyKHt6SW5kZXg6Mn0pLmNzcyhlKS5hZGQoKX0pfTtmLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmF4ZXMsYj10aGlzLmNvbG9yQXhpcyxjPXRoaXMucmVuZGVyZXIsZT10aGlzLm9wdGlvbnMsZz0wLGQ9ZnVuY3Rpb24oYSl7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EudmlzaWJsZSYmYS5yZW5kZXIoKX0pfTt0aGlzLnNldFRpdGxlKCk7dGhpcy5sZWdlbmQ9bmV3IHgodGhpcyxlLmxlZ2VuZCk7dGhpcy5nZXRTdGFja3MmJlxudGhpcy5nZXRTdGFja3MoKTt0aGlzLmdldE1hcmdpbnMoITApO3RoaXMuc2V0Q2hhcnRTaXplKCk7ZT10aGlzLnBsb3RXaWR0aDthLnNvbWUoZnVuY3Rpb24oYSl7aWYoYS5ob3JpeiYmYS52aXNpYmxlJiZhLm9wdGlvbnMubGFiZWxzLmVuYWJsZWQmJmEuc2VyaWVzLmxlbmd0aClyZXR1cm4gZz0yMSwhMH0pO3ZhciBmPXRoaXMucGxvdEhlaWdodD1NYXRoLm1heCh0aGlzLnBsb3RIZWlnaHQtZywwKTthLmZvckVhY2goZnVuY3Rpb24oYSl7YS5zZXRTY2FsZSgpfSk7dGhpcy5nZXRBeGlzTWFyZ2lucygpO3ZhciBoPTEuMTxlL3RoaXMucGxvdFdpZHRoO3ZhciBtPTEuMDU8Zi90aGlzLnBsb3RIZWlnaHQ7aWYoaHx8bSlhLmZvckVhY2goZnVuY3Rpb24oYSl7KGEuaG9yaXomJmh8fCFhLmhvcml6JiZtKSYmYS5zZXRUaWNrSW50ZXJ2YWwoITApfSksdGhpcy5nZXRNYXJnaW5zKCk7dGhpcy5kcmF3Q2hhcnRCb3goKTt0aGlzLmhhc0NhcnRlc2lhblNlcmllcz9kKGEpOmImJmIubGVuZ3RoJiZcbmQoYik7dGhpcy5zZXJpZXNHcm91cHx8KHRoaXMuc2VyaWVzR3JvdXA9Yy5nKFwic2VyaWVzLWdyb3VwXCIpLmF0dHIoe3pJbmRleDozfSkuYWRkKCkpO3RoaXMucmVuZGVyU2VyaWVzKCk7dGhpcy5yZW5kZXJMYWJlbHMoKTt0aGlzLmFkZENyZWRpdHMoKTt0aGlzLnNldFJlc3BvbnNpdmUmJnRoaXMuc2V0UmVzcG9uc2l2ZSgpO3RoaXMuaGFzUmVuZGVyZWQ9ITB9O2YucHJvdG90eXBlLmFkZENyZWRpdHM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWJhKCEwLHRoaXMub3B0aW9ucy5jcmVkaXRzLGEpO2MuZW5hYmxlZCYmIXRoaXMuY3JlZGl0cyYmKHRoaXMuY3JlZGl0cz10aGlzLnJlbmRlcmVyLnRleHQoYy50ZXh0Kyh0aGlzLm1hcENyZWRpdHN8fFwiXCIpLDAsMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWNyZWRpdHNcIikub24oXCJjbGlja1wiLGZ1bmN0aW9uKCl7Yy5ocmVmJiYoQS5sb2NhdGlvbi5ocmVmPWMuaHJlZil9KS5hdHRyKHthbGlnbjpjLnBvc2l0aW9uLmFsaWduLHpJbmRleDo4fSksXG5iLnN0eWxlZE1vZGV8fHRoaXMuY3JlZGl0cy5jc3MoYy5zdHlsZSksdGhpcy5jcmVkaXRzLmFkZCgpLmFsaWduKGMucG9zaXRpb24pLHRoaXMuY3JlZGl0cy51cGRhdGU9ZnVuY3Rpb24oYSl7Yi5jcmVkaXRzPWIuY3JlZGl0cy5kZXN0cm95KCk7Yi5hZGRDcmVkaXRzKGEpfSl9O2YucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5heGVzLGM9YS5zZXJpZXMsZT1hLmNvbnRhaW5lcixnLGQ9ZSYmZS5wYXJlbnROb2RlO1EoYSxcImRlc3Ryb3lcIik7YS5yZW5kZXJlci5mb3JFeHBvcnQ/TyhxLGEpOnFbYS5pbmRleF09dm9pZCAwO2suY2hhcnRDb3VudC0tO2EucmVuZGVyVG8ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1oaWdoY2hhcnRzLWNoYXJ0XCIpO2VhKGEpO2ZvcihnPWIubGVuZ3RoO2ctLTspYltnXT1iW2ddLmRlc3Ryb3koKTt0aGlzLnNjcm9sbGVyJiZ0aGlzLnNjcm9sbGVyLmRlc3Ryb3kmJnRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO2ZvcihnPWMubGVuZ3RoO2ctLTspY1tnXT1cbmNbZ10uZGVzdHJveSgpO1widGl0bGUgc3VidGl0bGUgY2hhcnRCYWNrZ3JvdW5kIHBsb3RCYWNrZ3JvdW5kIHBsb3RCR0ltYWdlIHBsb3RCb3JkZXIgc2VyaWVzR3JvdXAgY2xpcFJlY3QgY3JlZGl0cyBwb2ludGVyIHJhbmdlU2VsZWN0b3IgbGVnZW5kIHJlc2V0Wm9vbUJ1dHRvbiB0b29sdGlwIHJlbmRlcmVyXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGM9YVtiXTtjJiZjLmRlc3Ryb3kmJihhW2JdPWMuZGVzdHJveSgpKX0pO2UmJihlLmlubmVySFRNTD1cIlwiLGVhKGUpLGQmJkooZSkpO2FhKGEsZnVuY3Rpb24oYixjKXtkZWxldGUgYVtjXX0pfTtmLnByb3RvdHlwZS5maXJzdFJlbmRlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnM7aWYoIWEuaXNSZWFkeVRvUmVuZGVyfHxhLmlzUmVhZHlUb1JlbmRlcigpKXthLmdldENvbnRhaW5lcigpO2EucmVzZXRNYXJnaW5zKCk7YS5zZXRDaGFydFNpemUoKTthLnByb3BGcm9tU2VyaWVzKCk7YS5nZXRBeGVzKCk7XG4odihiLnNlcmllcyk/Yi5zZXJpZXM6W10pLmZvckVhY2goZnVuY3Rpb24oYil7YS5pbml0U2VyaWVzKGIpfSk7YS5saW5rU2VyaWVzKCk7YS5zZXRTZXJpZXNEYXRhKCk7UShhLFwiYmVmb3JlUmVuZGVyXCIpO0gmJihhLnBvaW50ZXI9ay5oYXNUb3VjaHx8IUEuUG9pbnRlckV2ZW50JiYhQS5NU1BvaW50ZXJFdmVudD9uZXcgSChhLGIpOm5ldyBCKGEsYikpO2EucmVuZGVyKCk7YS5wb2ludGVyLmdldENoYXJ0UG9zaXRpb24oKTtpZighYS5yZW5kZXJlci5pbWdDb3VudCYmIWEuaGFzTG9hZGVkKWEub25sb2FkKCk7YS50ZW1wb3JhcnlEaXNwbGF5KCEwKX19O2YucHJvdG90eXBlLm9ubG9hZD1mdW5jdGlvbigpe3RoaXMuY2FsbGJhY2tzLmNvbmNhdChbdGhpcy5jYWxsYmFja10pLmZvckVhY2goZnVuY3Rpb24oYSl7YSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLmluZGV4JiZhLmFwcGx5KHRoaXMsW3RoaXNdKX0sdGhpcyk7USh0aGlzLFwibG9hZFwiKTtRKHRoaXMsXCJyZW5kZXJcIik7dyh0aGlzLmluZGV4KSYmXG50aGlzLnNldFJlZmxvdyh0aGlzLm9wdGlvbnMuY2hhcnQucmVmbG93KTt0aGlzLmhhc0xvYWRlZD0hMH07Zi5wcm90b3R5cGUuYWRkU2VyaWVzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZSxnPXRoaXM7YSYmKGI9SShiLCEwKSxRKGcsXCJhZGRTZXJpZXNcIix7b3B0aW9uczphfSxmdW5jdGlvbigpe2U9Zy5pbml0U2VyaWVzKGEpO2cuaXNEaXJ0eUxlZ2VuZD0hMDtnLmxpbmtTZXJpZXMoKTtlLmVuYWJsZWREYXRhU29ydGluZyYmZS5zZXREYXRhKGEuZGF0YSwhMSk7UShnLFwiYWZ0ZXJBZGRTZXJpZXNcIix7c2VyaWVzOmV9KTtiJiZnLnJlZHJhdyhjKX0pKTtyZXR1cm4gZX07Zi5wcm90b3R5cGUuYWRkQXhpcz1mdW5jdGlvbihhLGIsYyxlKXtyZXR1cm4gdGhpcy5jcmVhdGVBeGlzKGI/XCJ4QXhpc1wiOlwieUF4aXNcIix7YXhpczphLHJlZHJhdzpjLGFuaW1hdGlvbjplfSl9O2YucHJvdG90eXBlLmFkZENvbG9yQXhpcz1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIHRoaXMuY3JlYXRlQXhpcyhcImNvbG9yQXhpc1wiLFxue2F4aXM6YSxyZWRyYXc6YixhbmltYXRpb246Y30pfTtmLnByb3RvdHlwZS5jcmVhdGVBeGlzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLGU9XCJjb2xvckF4aXNcIj09PWEsZz1iLnJlZHJhdyxmPWIuYW5pbWF0aW9uO2I9YmEoYi5heGlzLHtpbmRleDp0aGlzW2FdLmxlbmd0aCxpc1g6XCJ4QXhpc1wiPT09YX0pO3ZhciBoPWU/bmV3IGsuQ29sb3JBeGlzKHRoaXMsYik6bmV3IGQodGhpcyxiKTtjW2FdPVkoY1thXXx8e30pO2NbYV0ucHVzaChiKTtlJiYodGhpcy5pc0RpcnR5TGVnZW5kPSEwLHRoaXMuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2Euc2VyaWVzPVtdfSksdGhpcy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihhKXthLmJpbmRBeGVzKCk7YS5pc0RpcnR5RGF0YT0hMH0pKTtJKGcsITApJiZ0aGlzLnJlZHJhdyhmKTtyZXR1cm4gaH07Zi5wcm90b3R5cGUuc2hvd0xvYWRpbmc9ZnVuY3Rpb24oYyl7dmFyIGU9dGhpcyxkPWUub3B0aW9ucyxmPWUubG9hZGluZ0Rpdixcbmg9ZS5sb2FkaW5nU3BhbixtPWQubG9hZGluZyx1PWZ1bmN0aW9uKCl7ZiYmYihmLHtsZWZ0OmUucGxvdExlZnQrXCJweFwiLHRvcDplLnBsb3RUb3ArXCJweFwiLHdpZHRoOmUucGxvdFdpZHRoK1wicHhcIixoZWlnaHQ6ZS5wbG90SGVpZ2h0K1wicHhcIn0pfTtmfHwoZS5sb2FkaW5nRGl2PWY9YShcImRpdlwiLHtjbGFzc05hbWU6XCJoaWdoY2hhcnRzLWxvYWRpbmcgaGlnaGNoYXJ0cy1sb2FkaW5nLWhpZGRlblwifSxudWxsLGUuY29udGFpbmVyKSk7aHx8KGUubG9hZGluZ1NwYW49aD1hKFwic3BhblwiLHtjbGFzc05hbWU6XCJoaWdoY2hhcnRzLWxvYWRpbmctaW5uZXJcIn0sbnVsbCxmKSxyKGUsXCJyZWRyYXdcIix1KSk7Zi5jbGFzc05hbWU9XCJoaWdoY2hhcnRzLWxvYWRpbmdcIjtFLnNldEVsZW1lbnRIVE1MKGgsSShjLGQubGFuZy5sb2FkaW5nLFwiXCIpKTtlLnN0eWxlZE1vZGV8fChiKGYsTihtLnN0eWxlLHt6SW5kZXg6MTB9KSksYihoLG0ubGFiZWxTdHlsZSksZS5sb2FkaW5nU2hvd258fChiKGYse29wYWNpdHk6MCxcbmRpc3BsYXk6XCJcIn0pLGcoZix7b3BhY2l0eTptLnN0eWxlLm9wYWNpdHl8fC41fSx7ZHVyYXRpb246bS5zaG93RHVyYXRpb258fDB9KSkpO2UubG9hZGluZ1Nob3duPSEwO3UoKX07Zi5wcm90b3R5cGUuaGlkZUxvYWRpbmc9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYz10aGlzLmxvYWRpbmdEaXY7YyYmKGMuY2xhc3NOYW1lPVwiaGlnaGNoYXJ0cy1sb2FkaW5nIGhpZ2hjaGFydHMtbG9hZGluZy1oaWRkZW5cIix0aGlzLnN0eWxlZE1vZGV8fGcoYyx7b3BhY2l0eTowfSx7ZHVyYXRpb246YS5sb2FkaW5nLmhpZGVEdXJhdGlvbnx8MTAwLGNvbXBsZXRlOmZ1bmN0aW9uKCl7YihjLHtkaXNwbGF5Olwibm9uZVwifSl9fSkpO3RoaXMubG9hZGluZ1Nob3duPSExfTtmLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSxiLGMsZSl7dmFyIGc9dGhpcyxkPXtjcmVkaXRzOlwiYWRkQ3JlZGl0c1wiLHRpdGxlOlwic2V0VGl0bGVcIixzdWJ0aXRsZTpcInNldFN1YnRpdGxlXCIsY2FwdGlvbjpcInNldENhcHRpb25cIn0sXG5mLG0sdSxsPWEuaXNSZXNwb25zaXZlT3B0aW9ucyxuPVtdO1EoZyxcInVwZGF0ZVwiLHtvcHRpb25zOmF9KTtsfHxnLnNldFJlc3BvbnNpdmUoITEsITApO2E9aChhLGcub3B0aW9ucyk7Zy51c2VyT3B0aW9ucz1iYShnLnVzZXJPcHRpb25zLGEpO2lmKGY9YS5jaGFydCl7YmEoITAsZy5vcHRpb25zLmNoYXJ0LGYpO1wiY2xhc3NOYW1lXCJpbiBmJiZnLnNldENsYXNzTmFtZShmLmNsYXNzTmFtZSk7XCJyZWZsb3dcImluIGYmJmcuc2V0UmVmbG93KGYucmVmbG93KTtpZihcImludmVydGVkXCJpbiBmfHxcInBvbGFyXCJpbiBmfHxcInR5cGVcImluIGYpe2cucHJvcEZyb21TZXJpZXMoKTt2YXIgcT0hMH1cImFsaWduVGlja3NcImluIGYmJihxPSEwKTthYShmLGZ1bmN0aW9uKGEsYil7LTEhPT1nLnByb3BzUmVxdWlyZVVwZGF0ZVNlcmllcy5pbmRleE9mKFwiY2hhcnQuXCIrYikmJihtPSEwKTstMSE9PWcucHJvcHNSZXF1aXJlRGlydHlCb3guaW5kZXhPZihiKSYmKGcuaXNEaXJ0eUJveD0hMCk7LTEhPT1nLnByb3BzUmVxdWlyZVJlZmxvdy5pbmRleE9mKGIpJiZcbihsP2cuaXNEaXJ0eUJveD0hMDp1PSEwKX0pOyFnLnN0eWxlZE1vZGUmJlwic3R5bGVcImluIGYmJmcucmVuZGVyZXIuc2V0U3R5bGUoZi5zdHlsZSl9IWcuc3R5bGVkTW9kZSYmYS5jb2xvcnMmJih0aGlzLm9wdGlvbnMuY29sb3JzPWEuY29sb3JzKTthLnRpbWUmJih0aGlzLnRpbWU9PT16JiYodGhpcy50aW1lPW5ldyBDKGEudGltZSkpLGJhKCEwLGcub3B0aW9ucy50aW1lLGEudGltZSkpO2FhKGEsZnVuY3Rpb24oYixjKXtpZihnW2NdJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZ1tjXS51cGRhdGUpZ1tjXS51cGRhdGUoYiwhMSk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZ1tkW2NdXSlnW2RbY11dKGIpO2Vsc2VcImNvbG9yXCIhPT1jJiYtMT09PWcuY29sbGVjdGlvbnNXaXRoVXBkYXRlLmluZGV4T2YoYykmJmJhKCEwLGcub3B0aW9uc1tjXSxhW2NdKTtcImNoYXJ0XCIhPT1jJiYtMSE9PWcucHJvcHNSZXF1aXJlVXBkYXRlU2VyaWVzLmluZGV4T2YoYykmJihtPSEwKX0pO3RoaXMuY29sbGVjdGlvbnNXaXRoVXBkYXRlLmZvckVhY2goZnVuY3Rpb24oYil7aWYoYVtiXSl7aWYoXCJzZXJpZXNcIj09PVxuYil7dmFyIGU9W107Z1tiXS5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7YS5vcHRpb25zLmlzSW50ZXJuYWx8fGUucHVzaChJKGEub3B0aW9ucy5pbmRleCxiKSl9KX1ZKGFbYl0pLmZvckVhY2goZnVuY3Rpb24oYSxkKXt2YXIgZj13KGEuaWQpLGg7ZiYmKGg9Zy5nZXQoYS5pZCkpOyFoJiZnW2JdJiYoaD1nW2JdW2U/ZVtkXTpkXSkmJmYmJncoaC5vcHRpb25zLmlkKSYmKGg9dm9pZCAwKTtoJiZoLmNvbGw9PT1iJiYoaC51cGRhdGUoYSwhMSksYyYmKGgudG91Y2hlZD0hMCkpOyFoJiZjJiZnLmNvbGxlY3Rpb25zV2l0aEluaXRbYl0mJihnLmNvbGxlY3Rpb25zV2l0aEluaXRbYl1bMF0uYXBwbHkoZyxbYV0uY29uY2F0KGcuY29sbGVjdGlvbnNXaXRoSW5pdFtiXVsxXXx8W10pLmNvbmNhdChbITFdKSkudG91Y2hlZD0hMCl9KTtjJiZnW2JdLmZvckVhY2goZnVuY3Rpb24oYSl7YS50b3VjaGVkfHxhLm9wdGlvbnMuaXNJbnRlcm5hbD9kZWxldGUgYS50b3VjaGVkOm4ucHVzaChhKX0pfX0pO1xubi5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuY2hhcnQmJmEucmVtb3ZlKCExKX0pO3EmJmcuYXhlcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EudXBkYXRlKHt9LCExKX0pO20mJmcuZ2V0U2VyaWVzT3JkZXJCeUxpbmtzKCkuZm9yRWFjaChmdW5jdGlvbihhKXthLmNoYXJ0JiZhLnVwZGF0ZSh7fSwhMSl9LHRoaXMpO3E9ZiYmZi53aWR0aDtmPWYmJmYuaGVpZ2h0O1MoZikmJihmPVUoZixxfHxnLmNoYXJ0V2lkdGgpKTt1fHxwKHEpJiZxIT09Zy5jaGFydFdpZHRofHxwKGYpJiZmIT09Zy5jaGFydEhlaWdodD9nLnNldFNpemUocSxmLGUpOkkoYiwhMCkmJmcucmVkcmF3KGUpO1EoZyxcImFmdGVyVXBkYXRlXCIse29wdGlvbnM6YSxyZWRyYXc6YixhbmltYXRpb246ZX0pfTtmLnByb3RvdHlwZS5zZXRTdWJ0aXRsZT1mdW5jdGlvbihhLGIpe3RoaXMuYXBwbHlEZXNjcmlwdGlvbihcInN1YnRpdGxlXCIsYSk7dGhpcy5sYXlPdXRUaXRsZXMoYil9O2YucHJvdG90eXBlLnNldENhcHRpb249ZnVuY3Rpb24oYSxcbmIpe3RoaXMuYXBwbHlEZXNjcmlwdGlvbihcImNhcHRpb25cIixhKTt0aGlzLmxheU91dFRpdGxlcyhiKX07Zi5wcm90b3R5cGUuc2hvd1Jlc2V0Wm9vbT1mdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXtiLnpvb21PdXQoKX12YXIgYj10aGlzLGM9TS5sYW5nLGU9Yi5vcHRpb25zLmNoYXJ0LnJlc2V0Wm9vbUJ1dHRvbixnPWUudGhlbWUsZD1nLnN0YXRlcyxmPVwiY2hhcnRcIj09PWUucmVsYXRpdmVUb3x8XCJzcGFjZUJveFwiPT09ZS5yZWxhdGl2ZVRvP251bGw6dGhpcy5zY3JvbGxhYmxlUGxvdEJveHx8XCJwbG90Qm94XCI7USh0aGlzLFwiYmVmb3JlU2hvd1Jlc2V0Wm9vbVwiLG51bGwsZnVuY3Rpb24oKXtiLnJlc2V0Wm9vbUJ1dHRvbj1iLnJlbmRlcmVyLmJ1dHRvbihjLnJlc2V0Wm9vbSxudWxsLG51bGwsYSxnLGQmJmQuaG92ZXIpLmF0dHIoe2FsaWduOmUucG9zaXRpb24uYWxpZ24sdGl0bGU6Yy5yZXNldFpvb21UaXRsZX0pLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1yZXNldC16b29tXCIpLmFkZCgpLmFsaWduKGUucG9zaXRpb24sXG4hMSxmKX0pO1EodGhpcyxcImFmdGVyU2hvd1Jlc2V0Wm9vbVwiKX07Zi5wcm90b3R5cGUuem9vbU91dD1mdW5jdGlvbigpe1EodGhpcyxcInNlbGVjdGlvblwiLHtyZXNldFNlbGVjdGlvbjohMH0sdGhpcy56b29tKX07Zi5wcm90b3R5cGUuem9vbT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGMsZT1iLnBvaW50ZXIsZz0hMSxkPWIuaW52ZXJ0ZWQ/ZS5tb3VzZURvd25YOmUubW91c2VEb3duWTshYXx8YS5yZXNldFNlbGVjdGlvbj8oYi5heGVzLmZvckVhY2goZnVuY3Rpb24oYSl7Yz1hLnpvb20oKX0pLGUuaW5pdGlhdGVkPSExKTphLnhBeGlzLmNvbmNhdChhLnlBeGlzKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBmPWEuYXhpcyxoPWIuaW52ZXJ0ZWQ/Zi5sZWZ0OmYudG9wLG09Yi5pbnZlcnRlZD9oK2Yud2lkdGg6aCtmLmhlaWdodCx1PWYuaXNYQXhpcyxsPSExO2lmKCF1JiZkPj1oJiZkPD1tfHx1fHwhdyhkKSlsPSEwO2VbdT9cInpvb21YXCI6XCJ6b29tWVwiXSYmbCYmKGM9Zi56b29tKGEubWluLFxuYS5tYXgpLGYuZGlzcGxheUJ0biYmKGc9ITApKX0pO3ZhciBmPWIucmVzZXRab29tQnV0dG9uO2cmJiFmP2Iuc2hvd1Jlc2V0Wm9vbSgpOiFnJiZLKGYpJiYoYi5yZXNldFpvb21CdXR0b249Zi5kZXN0cm95KCkpO2MmJmIucmVkcmF3KEkoYi5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbixhJiZhLmFuaW1hdGlvbiwxMDA+Yi5wb2ludENvdW50KSl9O2YucHJvdG90eXBlLnBhbj1mdW5jdGlvbihhLGMpe3ZhciBlPXRoaXMsZz1lLmhvdmVyUG9pbnRzLGQ9ZS5vcHRpb25zLmNoYXJ0LGY9ZS5vcHRpb25zLm1hcE5hdmlnYXRpb24mJmUub3B0aW9ucy5tYXBOYXZpZ2F0aW9uLmVuYWJsZWQsaDtjPVwib2JqZWN0XCI9PT10eXBlb2YgYz9jOntlbmFibGVkOmMsdHlwZTpcInhcIn07ZCYmZC5wYW5uaW5nJiYoZC5wYW5uaW5nPWMpO3ZhciBtPWMudHlwZTtRKHRoaXMsXCJwYW5cIix7b3JpZ2luYWxFdmVudDphfSxmdW5jdGlvbigpe2cmJmcuZm9yRWFjaChmdW5jdGlvbihhKXthLnNldFN0YXRlKCl9KTt2YXIgYz1cblsxXTtcInh5XCI9PT1tP2M9WzEsMF06XCJ5XCI9PT1tJiYoYz1bMF0pO2MuZm9yRWFjaChmdW5jdGlvbihiKXt2YXIgYz1lW2I/XCJ4QXhpc1wiOlwieUF4aXNcIl1bMF0sZz1jLmhvcml6LGQ9YVtnP1wiY2hhcnRYXCI6XCJjaGFydFlcIl07Zz1nP1wibW91c2VEb3duWFwiOlwibW91c2VEb3duWVwiO3ZhciB1PWVbZ10sbD0oYy5wb2ludFJhbmdlfHwwKS8yLG49Yy5yZXZlcnNlZCYmIWUuaW52ZXJ0ZWR8fCFjLnJldmVyc2VkJiZlLmludmVydGVkPy0xOjEscT1jLmdldEV4dHJlbWVzKCkscj1jLnRvVmFsdWUodS1kLCEwKStsKm47bj1jLnRvVmFsdWUodStjLmxlbi1kLCEwKS1sKm47dmFyIGs9bjxyO3U9az9uOnI7cj1rP3I6bjtuPWMuaGFzVmVydGljYWxQYW5uaW5nKCk7dmFyIHc9Yy5wYW5uaW5nU3RhdGU7IW58fGJ8fHcmJiF3LmlzRGlydHl8fGMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5nZXRQcm9jZXNzZWREYXRhKCEwKTtiPWEuZ2V0RXh0cmVtZXMoYi55RGF0YSwhMCk7d3x8KHc9XG57c3RhcnRNaW46TnVtYmVyLk1BWF9WQUxVRSxzdGFydE1heDotTnVtYmVyLk1BWF9WQUxVRX0pO3AoYi5kYXRhTWluKSYmcChiLmRhdGFNYXgpJiYody5zdGFydE1pbj1NYXRoLm1pbihJKGEub3B0aW9ucy50aHJlc2hvbGQsSW5maW5pdHkpLGIuZGF0YU1pbix3LnN0YXJ0TWluKSx3LnN0YXJ0TWF4PU1hdGgubWF4KEkoYS5vcHRpb25zLnRocmVzaG9sZCwtSW5maW5pdHkpLGIuZGF0YU1heCx3LnN0YXJ0TWF4KSl9KTtiPU1hdGgubWluKEkobnVsbD09PXd8fHZvaWQgMD09PXc/dm9pZCAwOncuc3RhcnRNaW4scS5kYXRhTWluKSxsP3EubWluOmMudG9WYWx1ZShjLnRvUGl4ZWxzKHEubWluKS1jLm1pblBpeGVsUGFkZGluZykpO2w9TWF0aC5tYXgoSShudWxsPT09d3x8dm9pZCAwPT09dz92b2lkIDA6dy5zdGFydE1heCxxLmRhdGFNYXgpLGw/cS5tYXg6Yy50b1ZhbHVlKGMudG9QaXhlbHMocS5tYXgpK2MubWluUGl4ZWxQYWRkaW5nKSk7Yy5wYW5uaW5nU3RhdGU9dztjLmlzT3JkaW5hbHx8XG4obj1iLXUsMDxuJiYocis9bix1PWIpLG49ci1sLDA8biYmKHI9bCx1LT1uKSxjLnNlcmllcy5sZW5ndGgmJnUhPT1xLm1pbiYmciE9PXEubWF4JiZ1Pj1iJiZyPD1sJiYoYy5zZXRFeHRyZW1lcyh1LHIsITEsITEse3RyaWdnZXI6XCJwYW5cIn0pLGUucmVzZXRab29tQnV0dG9ufHxmfHx1PT09Ynx8cj09PWx8fCFtLm1hdGNoKFwieVwiKXx8KGUuc2hvd1Jlc2V0Wm9vbSgpLGMuZGlzcGxheUJ0bj0hMSksaD0hMCksZVtnXT1kKX0pO2gmJmUucmVkcmF3KCExKTtiKGUuY29udGFpbmVyLHtjdXJzb3I6XCJtb3ZlXCJ9KX0pfTtyZXR1cm4gZn0oKTtOKGNhLnByb3RvdHlwZSx7Y2FsbGJhY2tzOltdLGNvbGxlY3Rpb25zV2l0aEluaXQ6e3hBeGlzOltjYS5wcm90b3R5cGUuYWRkQXhpcyxbITBdXSx5QXhpczpbY2EucHJvdG90eXBlLmFkZEF4aXMsWyExXV0sc2VyaWVzOltjYS5wcm90b3R5cGUuYWRkU2VyaWVzXX0sY29sbGVjdGlvbnNXaXRoVXBkYXRlOltcInhBeGlzXCIsXCJ5QXhpc1wiLFwiekF4aXNcIixcblwic2VyaWVzXCJdLHByb3BzUmVxdWlyZURpcnR5Qm94OlwiYmFja2dyb3VuZENvbG9yIGJvcmRlckNvbG9yIGJvcmRlcldpZHRoIGJvcmRlclJhZGl1cyBwbG90QmFja2dyb3VuZENvbG9yIHBsb3RCYWNrZ3JvdW5kSW1hZ2UgcGxvdEJvcmRlckNvbG9yIHBsb3RCb3JkZXJXaWR0aCBwbG90U2hhZG93IHNoYWRvd1wiLnNwbGl0KFwiIFwiKSxwcm9wc1JlcXVpcmVSZWZsb3c6XCJtYXJnaW4gbWFyZ2luVG9wIG1hcmdpblJpZ2h0IG1hcmdpbkJvdHRvbSBtYXJnaW5MZWZ0IHNwYWNpbmcgc3BhY2luZ1RvcCBzcGFjaW5nUmlnaHQgc3BhY2luZ0JvdHRvbSBzcGFjaW5nTGVmdFwiLnNwbGl0KFwiIFwiKSxwcm9wc1JlcXVpcmVVcGRhdGVTZXJpZXM6XCJjaGFydC5pbnZlcnRlZCBjaGFydC5wb2xhciBjaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMgY2hhcnQudHlwZSBjb2xvcnMgcGxvdE9wdGlvbnMgdGltZSB0b29sdGlwXCIuc3BsaXQoXCIgXCIpfSk7ay5jaGFydD1mdW5jdGlvbihhLGIsYyl7cmV0dXJuIG5ldyBjYShhLFxuYixjKX07ay5DaGFydD1jYTtcIlwiO3JldHVybiBjYX0pO1AoayxcIk1peGlucy9MZWdlbmRTeW1ib2wuanNcIixba1tcIkNvcmUvR2xvYmFscy5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCl7dmFyIGs9ZC5tZXJnZSx4PWQucGljaztyZXR1cm4gZi5MZWdlbmRTeW1ib2xNaXhpbj17ZHJhd1JlY3RhbmdsZTpmdW5jdGlvbihkLGYpe3ZhciBrPWQuc3ltYm9sSGVpZ2h0LEg9ZC5vcHRpb25zLnNxdWFyZVN5bWJvbDtmLmxlZ2VuZFN5bWJvbD10aGlzLmNoYXJ0LnJlbmRlcmVyLnJlY3QoSD8oZC5zeW1ib2xXaWR0aC1rKS8yOjAsZC5iYXNlbGluZS1rKzEsSD9rOmQuc3ltYm9sV2lkdGgsayx4KGQub3B0aW9ucy5zeW1ib2xSYWRpdXMsay8yKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBvaW50XCIpLmF0dHIoe3pJbmRleDozfSkuYWRkKGYubGVnZW5kR3JvdXApfSxkcmF3TGluZU1hcmtlcjpmdW5jdGlvbihkKXt2YXIgZj10aGlzLm9wdGlvbnMsRD1mLm1hcmtlcixIPVxuZC5zeW1ib2xXaWR0aCx0PWQuc3ltYm9sSGVpZ2h0LEM9dC8yLGw9dGhpcy5jaGFydC5yZW5kZXJlcixFPXRoaXMubGVnZW5kR3JvdXA7ZD1kLmJhc2VsaW5lLU1hdGgucm91bmQoLjMqZC5mb250TWV0cmljcy5iKTt2YXIgZz17fTt0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fChnPXtcInN0cm9rZS13aWR0aFwiOmYubGluZVdpZHRofHwwfSxmLmRhc2hTdHlsZSYmKGcuZGFzaHN0eWxlPWYuZGFzaFN0eWxlKSk7dGhpcy5sZWdlbmRMaW5lPWwucGF0aChbW1wiTVwiLDAsZF0sW1wiTFwiLEgsZF1dKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZ3JhcGhcIikuYXR0cihnKS5hZGQoRSk7RCYmITEhPT1ELmVuYWJsZWQmJkgmJihmPU1hdGgubWluKHgoRC5yYWRpdXMsQyksQyksMD09PXRoaXMuc3ltYm9sLmluZGV4T2YoXCJ1cmxcIikmJihEPWsoRCx7d2lkdGg6dCxoZWlnaHQ6dH0pLGY9MCksdGhpcy5sZWdlbmRTeW1ib2w9RD1sLnN5bWJvbCh0aGlzLnN5bWJvbCxILzItZixkLWYsMipmLDIqZixEKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcG9pbnRcIikuYWRkKEUpLFxuRC5pc01hcmtlcj0hMCl9fX0pO1AoayxcIkNvcmUvU2VyaWVzL1Nlcmllcy5qc1wiLFtrW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIk1peGlucy9MZWdlbmRTeW1ib2wuanNcIl0sa1tcIkNvcmUvT3B0aW9ucy5qc1wiXSxrW1wiQ29yZS9Db2xvci9QYWxldHRlLmpzXCJdLGtbXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sa1tcIkNvcmUvUmVuZGVyZXIvU1ZHL1NWR0VsZW1lbnQuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4LEIsRyxELEgsdCl7dmFyIEM9Zi5hbmltT2JqZWN0LGw9Zi5zZXRBbmltYXRpb24sRT1kLmhhc1RvdWNoLGc9ZC5zdmcseT1kLndpbixjPXguZGVmYXVsdE9wdGlvbnMscT1ELnNlcmllc1R5cGVzLG49dC5hZGRFdmVudCxBPXQuYXJyYXlNYXgsTT10LmFycmF5TWluLHo9dC5jbGFtcCxtPXQuY2xlYW5SZWN1cnNpdmVseSxcbnI9dC5jb3JyZWN0RmxvYXQsZT10LmRlZmluZWQsaD10LmVyYXNlLGE9dC5lcnJvcixiPXQuZXh0ZW5kLHc9dC5maW5kLEo9dC5maXJlRXZlbnQsTz10LmdldE5lc3RlZFByb3BlcnR5LEY9dC5pc0FycmF5LE49dC5pc0Z1bmN0aW9uLFI9dC5pc051bWJlcixRPXQuaXNTdHJpbmcsVD10Lm1lcmdlLHY9dC5vYmplY3RFYWNoLEw9dC5waWNrLHA9dC5yZW1vdmVFdmVudCxLPXQuc3BsYXQsUz10LnN5bmNUaW1lb3V0O2Y9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKCl7dGhpcy56b25lcz10aGlzLnlBeGlzPXRoaXMueEF4aXM9dGhpcy51c2VyT3B0aW9ucz10aGlzLnRvb2x0aXBPcHRpb25zPXRoaXMucHJvY2Vzc2VkWURhdGE9dGhpcy5wcm9jZXNzZWRYRGF0YT10aGlzLnBvaW50cz10aGlzLm9wdGlvbnM9dGhpcy5saW5rZWRTZXJpZXM9dGhpcy5pbmRleD10aGlzLmV2ZW50c1RvVW5iaW5kPXRoaXMuZXZlbnRPcHRpb25zPXRoaXMuZGF0YT10aGlzLmNoYXJ0PXRoaXMuX2k9dm9pZCAwfWQucHJvdG90eXBlLmluaXQ9XG5mdW5jdGlvbihhLGMpe0oodGhpcyxcImluaXRcIix7b3B0aW9uczpjfSk7dmFyIGU9dGhpcyxnPWEuc2VyaWVzLGQ7dGhpcy5ldmVudE9wdGlvbnM9dGhpcy5ldmVudE9wdGlvbnN8fHt9O3RoaXMuZXZlbnRzVG9VbmJpbmQ9W107ZS5jaGFydD1hO2Uub3B0aW9ucz1jPWUuc2V0T3B0aW9ucyhjKTtlLmxpbmtlZFNlcmllcz1bXTtlLmJpbmRBeGVzKCk7YihlLHtuYW1lOmMubmFtZSxzdGF0ZTpcIlwiLHZpc2libGU6ITEhPT1jLnZpc2libGUsc2VsZWN0ZWQ6ITA9PT1jLnNlbGVjdGVkfSk7dmFyIGY9Yy5ldmVudHM7dihmLGZ1bmN0aW9uKGEsYil7TihhKSYmZS5ldmVudE9wdGlvbnNbYl0hPT1hJiYoTihlLmV2ZW50T3B0aW9uc1tiXSkmJnAoZSxiLGUuZXZlbnRPcHRpb25zW2JdKSxlLmV2ZW50T3B0aW9uc1tiXT1hLG4oZSxiLGEpKX0pO2lmKGYmJmYuY2xpY2t8fGMucG9pbnQmJmMucG9pbnQuZXZlbnRzJiZjLnBvaW50LmV2ZW50cy5jbGlja3x8Yy5hbGxvd1BvaW50U2VsZWN0KWEucnVuVHJhY2tlckNsaWNrPVxuITA7ZS5nZXRDb2xvcigpO2UuZ2V0U3ltYm9sKCk7ZS5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2VbYStcIkRhdGFcIl18fChlW2ErXCJEYXRhXCJdPVtdKX0pO2UuaXNDYXJ0ZXNpYW4mJihhLmhhc0NhcnRlc2lhblNlcmllcz0hMCk7Zy5sZW5ndGgmJihkPWdbZy5sZW5ndGgtMV0pO2UuX2k9TChkJiZkLl9pLC0xKSsxO2Uub3BhY2l0eT1lLm9wdGlvbnMub3BhY2l0eTthLm9yZGVyU2VyaWVzKHRoaXMuaW5zZXJ0KGcpKTtjLmRhdGFTb3J0aW5nJiZjLmRhdGFTb3J0aW5nLmVuYWJsZWQ/ZS5zZXREYXRhU29ydGluZ09wdGlvbnMoKTplLnBvaW50c3x8ZS5kYXRhfHxlLnNldERhdGEoYy5kYXRhLCExKTtKKHRoaXMsXCJhZnRlckluaXRcIil9O2QucHJvdG90eXBlLmlzPWZ1bmN0aW9uKGEpe3JldHVybiBxW2FdJiZ0aGlzIGluc3RhbmNlb2YgcVthXX07ZC5wcm90b3R5cGUuaW5zZXJ0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMub3B0aW9ucy5pbmRleCxjO2lmKFIoYikpe2ZvcihjPVxuYS5sZW5ndGg7Yy0tOylpZihiPj1MKGFbY10ub3B0aW9ucy5pbmRleCxhW2NdLl9pKSl7YS5zcGxpY2UoYysxLDAsdGhpcyk7YnJlYWt9LTE9PT1jJiZhLnVuc2hpZnQodGhpcyk7Yys9MX1lbHNlIGEucHVzaCh0aGlzKTtyZXR1cm4gTChjLGEubGVuZ3RoLTEpfTtkLnByb3RvdHlwZS5iaW5kQXhlcz1mdW5jdGlvbigpe3ZhciBiPXRoaXMsYz1iLm9wdGlvbnMsZT1iLmNoYXJ0LGc7Sih0aGlzLFwiYmluZEF4ZXNcIixudWxsLGZ1bmN0aW9uKCl7KGIuYXhpc1R5cGVzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihkKXtlW2RdLmZvckVhY2goZnVuY3Rpb24oYSl7Zz1hLm9wdGlvbnM7aWYoY1tkXT09PWcuaW5kZXh8fFwidW5kZWZpbmVkXCIhPT10eXBlb2YgY1tkXSYmY1tkXT09PWcuaWR8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgY1tkXSYmMD09PWcuaW5kZXgpYi5pbnNlcnQoYS5zZXJpZXMpLGJbZF09YSxhLmlzRGlydHk9ITB9KTtiW2RdfHxiLm9wdGlvbmFsQXhpcz09PWR8fGEoMTgsITAsZSl9KX0pO1xuSih0aGlzLFwiYWZ0ZXJCaW5kQXhlc1wiKX07ZC5wcm90b3R5cGUudXBkYXRlUGFyYWxsZWxBcnJheXM9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnNlcmllcyxlPWFyZ3VtZW50cyxnPVIoYik/ZnVuY3Rpb24oZSl7dmFyIGc9XCJ5XCI9PT1lJiZjLnRvWURhdGE/Yy50b1lEYXRhKGEpOmFbZV07Y1tlK1wiRGF0YVwiXVtiXT1nfTpmdW5jdGlvbihhKXtBcnJheS5wcm90b3R5cGVbYl0uYXBwbHkoY1thK1wiRGF0YVwiXSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChlLDIpKX07Yy5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGcpfTtkLnByb3RvdHlwZS5oYXNEYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmlzaWJsZSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB0aGlzLmRhdGFNYXgmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgdGhpcy5kYXRhTWlufHx0aGlzLnZpc2libGUmJnRoaXMueURhdGEmJjA8dGhpcy55RGF0YS5sZW5ndGh9O2QucHJvdG90eXBlLmF1dG9JbmNyZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgYT1cbnRoaXMub3B0aW9ucyxiPXRoaXMueEluY3JlbWVudCxjLGU9YS5wb2ludEludGVydmFsVW5pdCxnPXRoaXMuY2hhcnQudGltZTtiPUwoYixhLnBvaW50U3RhcnQsMCk7dGhpcy5wb2ludEludGVydmFsPWM9TCh0aGlzLnBvaW50SW50ZXJ2YWwsYS5wb2ludEludGVydmFsLDEpO2UmJihhPW5ldyBnLkRhdGUoYiksXCJkYXlcIj09PWU/Zy5zZXQoXCJEYXRlXCIsYSxnLmdldChcIkRhdGVcIixhKStjKTpcIm1vbnRoXCI9PT1lP2cuc2V0KFwiTW9udGhcIixhLGcuZ2V0KFwiTW9udGhcIixhKStjKTpcInllYXJcIj09PWUmJmcuc2V0KFwiRnVsbFllYXJcIixhLGcuZ2V0KFwiRnVsbFllYXJcIixhKStjKSxjPWEuZ2V0VGltZSgpLWIpO3RoaXMueEluY3JlbWVudD1iK2M7cmV0dXJuIGJ9O2QucHJvdG90eXBlLnNldERhdGFTb3J0aW5nT3B0aW9ucz1mdW5jdGlvbigpe3ZhciBhPXRoaXMub3B0aW9ucztiKHRoaXMse3JlcXVpcmVTb3J0aW5nOiExLHNvcnRlZDohMSxlbmFibGVkRGF0YVNvcnRpbmc6ITAsYWxsb3dERzohMX0pO1xuZShhLnBvaW50UmFuZ2UpfHwoYS5wb2ludFJhbmdlPTEpfTtkLnByb3RvdHlwZS5zZXRPcHRpb25zPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuY2hhcnQsZz1iLm9wdGlvbnMsZD1nLnBsb3RPcHRpb25zLGY9Yi51c2VyT3B0aW9uc3x8e307YT1UKGEpO2I9Yi5zdHlsZWRNb2RlO3ZhciBoPXtwbG90T3B0aW9uczpkLHVzZXJPcHRpb25zOmF9O0oodGhpcyxcInNldE9wdGlvbnNcIixoKTt2YXIgbT1oLnBsb3RPcHRpb25zW3RoaXMudHlwZV0sbD1mLnBsb3RPcHRpb25zfHx7fTt0aGlzLnVzZXJPcHRpb25zPWgudXNlck9wdGlvbnM7Zj1UKG0sZC5zZXJpZXMsZi5wbG90T3B0aW9ucyYmZi5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLGEpO3RoaXMudG9vbHRpcE9wdGlvbnM9VChjLnRvb2x0aXAsYy5wbG90T3B0aW9ucy5zZXJpZXMmJmMucGxvdE9wdGlvbnMuc2VyaWVzLnRvb2x0aXAsYy5wbG90T3B0aW9uc1t0aGlzLnR5cGVdLnRvb2x0aXAsZy50b29sdGlwLnVzZXJPcHRpb25zLGQuc2VyaWVzJiZcbmQuc2VyaWVzLnRvb2x0aXAsZFt0aGlzLnR5cGVdLnRvb2x0aXAsYS50b29sdGlwKTt0aGlzLnN0aWNreVRyYWNraW5nPUwoYS5zdGlja3lUcmFja2luZyxsW3RoaXMudHlwZV0mJmxbdGhpcy50eXBlXS5zdGlja3lUcmFja2luZyxsLnNlcmllcyYmbC5zZXJpZXMuc3RpY2t5VHJhY2tpbmcsdGhpcy50b29sdGlwT3B0aW9ucy5zaGFyZWQmJiF0aGlzLm5vU2hhcmVkVG9vbHRpcD8hMDpmLnN0aWNreVRyYWNraW5nKTtudWxsPT09bS5tYXJrZXImJmRlbGV0ZSBmLm1hcmtlcjt0aGlzLnpvbmVBeGlzPWYuem9uZUF4aXM7Zz10aGlzLnpvbmVzPShmLnpvbmVzfHxbXSkuc2xpY2UoKTshZi5uZWdhdGl2ZUNvbG9yJiYhZi5uZWdhdGl2ZUZpbGxDb2xvcnx8Zi56b25lc3x8KGQ9e3ZhbHVlOmZbdGhpcy56b25lQXhpcytcIlRocmVzaG9sZFwiXXx8Zi50aHJlc2hvbGR8fDAsY2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1uZWdhdGl2ZVwifSxifHwoZC5jb2xvcj1mLm5lZ2F0aXZlQ29sb3IsZC5maWxsQ29sb3I9XG5mLm5lZ2F0aXZlRmlsbENvbG9yKSxnLnB1c2goZCkpO2cubGVuZ3RoJiZlKGdbZy5sZW5ndGgtMV0udmFsdWUpJiZnLnB1c2goYj97fTp7Y29sb3I6dGhpcy5jb2xvcixmaWxsQ29sb3I6dGhpcy5maWxsQ29sb3J9KTtKKHRoaXMsXCJhZnRlclNldE9wdGlvbnNcIix7b3B0aW9uczpmfSk7cmV0dXJuIGZ9O2QucHJvdG90eXBlLmdldE5hbWU9ZnVuY3Rpb24oKXtyZXR1cm4gTCh0aGlzLm9wdGlvbnMubmFtZSxcIlNlcmllcyBcIisodGhpcy5pbmRleCsxKSl9O2QucHJvdG90eXBlLmdldEN5Y2xpYz1mdW5jdGlvbihhLGIsYyl7dmFyIGc9dGhpcy5jaGFydCxkPXRoaXMudXNlck9wdGlvbnMsZj1hK1wiSW5kZXhcIixoPWErXCJDb3VudGVyXCIsbT1jP2MubGVuZ3RoOkwoZy5vcHRpb25zLmNoYXJ0W2ErXCJDb3VudFwiXSxnW2ErXCJDb3VudFwiXSk7aWYoIWIpe3ZhciBsPUwoZFtmXSxkW1wiX1wiK2ZdKTtlKGwpfHwoZy5zZXJpZXMubGVuZ3RofHwoZ1toXT0wKSxkW1wiX1wiK2ZdPWw9Z1toXSVtLGdbaF0rPTEpO1xuYyYmKGI9Y1tsXSl9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsJiYodGhpc1tmXT1sKTt0aGlzW2FdPWJ9O2QucHJvdG90eXBlLmdldENvbG9yPWZ1bmN0aW9uKCl7dGhpcy5jaGFydC5zdHlsZWRNb2RlP3RoaXMuZ2V0Q3ljbGljKFwiY29sb3JcIik6dGhpcy5vcHRpb25zLmNvbG9yQnlQb2ludD90aGlzLm9wdGlvbnMuY29sb3I9bnVsbDp0aGlzLmdldEN5Y2xpYyhcImNvbG9yXCIsdGhpcy5vcHRpb25zLmNvbG9yfHxjLnBsb3RPcHRpb25zW3RoaXMudHlwZV0uY29sb3IsdGhpcy5jaGFydC5vcHRpb25zLmNvbG9ycyl9O2QucHJvdG90eXBlLmdldFBvaW50c0NvbGxlY3Rpb249ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5oYXNHcm91cGVkRGF0YT90aGlzLnBvaW50czp0aGlzLmRhdGEpfHxbXX07ZC5wcm90b3R5cGUuZ2V0U3ltYm9sPWZ1bmN0aW9uKCl7dGhpcy5nZXRDeWNsaWMoXCJzeW1ib2xcIix0aGlzLm9wdGlvbnMubWFya2VyLnN5bWJvbCx0aGlzLmNoYXJ0Lm9wdGlvbnMuc3ltYm9scyl9O2QucHJvdG90eXBlLmZpbmRQb2ludEluZGV4PVxuZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmlkLGU9YS54LGc9dGhpcy5wb2ludHMsZCxmPXRoaXMub3B0aW9ucy5kYXRhU29ydGluZztpZihjKXZhciBoPXRoaXMuY2hhcnQuZ2V0KGMpO2Vsc2UgaWYodGhpcy5saW5rZWRQYXJlbnR8fHRoaXMuZW5hYmxlZERhdGFTb3J0aW5nKXt2YXIgbT1mJiZmLm1hdGNoQnlOYW1lP1wibmFtZVwiOlwiaW5kZXhcIjtoPXcoZyxmdW5jdGlvbihiKXtyZXR1cm4hYi50b3VjaGVkJiZiW21dPT09YVttXX0pO2lmKCFoKXJldHVybn1pZihoKXt2YXIgbD1oJiZoLmluZGV4O1widW5kZWZpbmVkXCIhPT10eXBlb2YgbCYmKGQ9ITApfVwidW5kZWZpbmVkXCI9PT10eXBlb2YgbCYmUihlKSYmKGw9dGhpcy54RGF0YS5pbmRleE9mKGUsYikpOy0xIT09bCYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBsJiZ0aGlzLmNyb3BwZWQmJihsPWw+PXRoaXMuY3JvcFN0YXJ0P2wtdGhpcy5jcm9wU3RhcnQ6bCk7IWQmJmdbbF0mJmdbbF0udG91Y2hlZCYmKGw9dm9pZCAwKTtyZXR1cm4gbH07ZC5wcm90b3R5cGUudXBkYXRlRGF0YT1cbmZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLGc9Yy5kYXRhU29ydGluZyxkPXRoaXMucG9pbnRzLGY9W10saCxtLGwsbj10aGlzLnJlcXVpcmVTb3J0aW5nLHU9YS5sZW5ndGg9PT1kLmxlbmd0aCxwPSEwO3RoaXMueEluY3JlbWVudD1udWxsO2EuZm9yRWFjaChmdW5jdGlvbihhLGIpe3ZhciBtPWUoYSkmJnRoaXMucG9pbnRDbGFzcy5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwoe3Nlcmllczp0aGlzfSxhKXx8e307dmFyIHA9bS54O2lmKG0uaWR8fFIocCkpe2lmKHA9dGhpcy5maW5kUG9pbnRJbmRleChtLGwpLC0xPT09cHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBwP2YucHVzaChhKTpkW3BdJiZhIT09Yy5kYXRhW3BdPyhkW3BdLnVwZGF0ZShhLCExLG51bGwsITEpLGRbcF0udG91Y2hlZD0hMCxuJiYobD1wKzEpKTpkW3BdJiYoZFtwXS50b3VjaGVkPSEwKSwhdXx8YiE9PXB8fGcmJmcuZW5hYmxlZHx8dGhpcy5oYXNEZXJpdmVkRGF0YSloPSEwfWVsc2UgZi5wdXNoKGEpfSxcbnRoaXMpO2lmKGgpZm9yKGE9ZC5sZW5ndGg7YS0tOykobT1kW2FdKSYmIW0udG91Y2hlZCYmbS5yZW1vdmUmJm0ucmVtb3ZlKCExLGIpO2Vsc2UhdXx8ZyYmZy5lbmFibGVkP3A9ITE6KGEuZm9yRWFjaChmdW5jdGlvbihhLGIpe2RbYl0udXBkYXRlJiZhIT09ZFtiXS55JiZkW2JdLnVwZGF0ZShhLCExLG51bGwsITEpfSksZi5sZW5ndGg9MCk7ZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EmJihhLnRvdWNoZWQ9ITEpfSk7aWYoIXApcmV0dXJuITE7Zi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RoaXMuYWRkUG9pbnQoYSwhMSxudWxsLG51bGwsITEpfSx0aGlzKTtudWxsPT09dGhpcy54SW5jcmVtZW50JiZ0aGlzLnhEYXRhJiZ0aGlzLnhEYXRhLmxlbmd0aCYmKHRoaXMueEluY3JlbWVudD1BKHRoaXMueERhdGEpLHRoaXMuYXV0b0luY3JlbWVudCgpKTtyZXR1cm4hMH07ZC5wcm90b3R5cGUuc2V0RGF0YT1mdW5jdGlvbihiLGMsZSxnKXt2YXIgZD10aGlzLGY9ZC5wb2ludHMsaD1mJiZmLmxlbmd0aHx8XG4wLG0sbD1kLm9wdGlvbnMsbj1kLmNoYXJ0LHU9bC5kYXRhU29ydGluZyxwPW51bGwscT1kLnhBeGlzO3A9bC50dXJib1RocmVzaG9sZDt2YXIgcj10aGlzLnhEYXRhLGs9dGhpcy55RGF0YSx3PShtPWQucG9pbnRBcnJheU1hcCkmJm0ubGVuZ3RoLHk9bC5rZXlzLHQ9MCxJPTEsdjtiPWJ8fFtdO209Yi5sZW5ndGg7Yz1MKGMsITApO3UmJnUuZW5hYmxlZCYmKGI9dGhpcy5zb3J0RGF0YShiKSk7ITEhPT1nJiZtJiZoJiYhZC5jcm9wcGVkJiYhZC5oYXNHcm91cGVkRGF0YSYmZC52aXNpYmxlJiYhZC5pc1Nlcmllc0Jvb3N0aW5nJiYodj10aGlzLnVwZGF0ZURhdGEoYixlKSk7aWYoIXYpe2QueEluY3JlbWVudD1udWxsO2QuY29sb3JDb3VudGVyPTA7dGhpcy5wYXJhbGxlbEFycmF5cy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2RbYStcIkRhdGFcIl0ubGVuZ3RoPTB9KTtpZihwJiZtPnApaWYocD1kLmdldEZpcnN0VmFsaWRQb2ludChiKSxSKHApKWZvcihlPTA7ZTxtO2UrKylyW2VdPXRoaXMuYXV0b0luY3JlbWVudCgpLFxua1tlXT1iW2VdO2Vsc2UgaWYoRihwKSlpZih3KWZvcihlPTA7ZTxtO2UrKylnPWJbZV0scltlXT1nWzBdLGtbZV09Zy5zbGljZSgxLHcrMSk7ZWxzZSBmb3IoeSYmKHQ9eS5pbmRleE9mKFwieFwiKSxJPXkuaW5kZXhPZihcInlcIiksdD0wPD10P3Q6MCxJPTA8PUk/SToxKSxlPTA7ZTxtO2UrKylnPWJbZV0scltlXT1nW3RdLGtbZV09Z1tJXTtlbHNlIGEoMTIsITEsbik7ZWxzZSBmb3IoZT0wO2U8bTtlKyspXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBiW2VdJiYoZz17c2VyaWVzOmR9LGQucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KGcsW2JbZV1dKSxkLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKGcsZSkpO2smJlEoa1swXSkmJmEoMTQsITAsbik7ZC5kYXRhPVtdO2Qub3B0aW9ucy5kYXRhPWQudXNlck9wdGlvbnMuZGF0YT1iO2ZvcihlPWg7ZS0tOylmW2VdJiZmW2VdLmRlc3Ryb3kmJmZbZV0uZGVzdHJveSgpO3EmJihxLm1pblJhbmdlPXEudXNlck1pblJhbmdlKTtkLmlzRGlydHk9XG5uLmlzRGlydHlCb3g9ITA7ZC5pc0RpcnR5RGF0YT0hIWY7ZT0hMX1cInBvaW50XCI9PT1sLmxlZ2VuZFR5cGUmJih0aGlzLnByb2Nlc3NEYXRhKCksdGhpcy5nZW5lcmF0ZVBvaW50cygpKTtjJiZuLnJlZHJhdyhlKX07ZC5wcm90b3R5cGUuc29ydERhdGE9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWIub3B0aW9ucy5kYXRhU29ydGluZy5zb3J0S2V5fHxcInlcIixnPWZ1bmN0aW9uKGEsYil7cmV0dXJuIGUoYikmJmEucG9pbnRDbGFzcy5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwoe3NlcmllczphfSxiKXx8e319O2EuZm9yRWFjaChmdW5jdGlvbihjLGUpe2FbZV09ZyhiLGMpO2FbZV0uaW5kZXg9ZX0sdGhpcyk7YS5jb25jYXQoKS5zb3J0KGZ1bmN0aW9uKGEsYil7YT1PKGMsYSk7Yj1PKGMsYik7cmV0dXJuIGI8YT8tMTpiPmE/MTowfSkuZm9yRWFjaChmdW5jdGlvbihhLGIpe2EueD1ifSx0aGlzKTtiLmxpbmtlZFNlcmllcyYmYi5saW5rZWRTZXJpZXMuZm9yRWFjaChmdW5jdGlvbihiKXt2YXIgYz1cbmIub3B0aW9ucyxlPWMuZGF0YTtjLmRhdGFTb3J0aW5nJiZjLmRhdGFTb3J0aW5nLmVuYWJsZWR8fCFlfHwoZS5mb3JFYWNoKGZ1bmN0aW9uKGMsZCl7ZVtkXT1nKGIsYyk7YVtkXSYmKGVbZF0ueD1hW2RdLngsZVtkXS5pbmRleD1kKX0pLGIuc2V0RGF0YShlLCExKSl9KTtyZXR1cm4gYX07ZC5wcm90b3R5cGUuZ2V0UHJvY2Vzc2VkRGF0YT1mdW5jdGlvbihiKXt2YXIgYz10aGlzLnhEYXRhLGU9dGhpcy55RGF0YSxnPWMubGVuZ3RoO3ZhciBkPTA7dmFyIGY9dGhpcy54QXhpcyxoPXRoaXMub3B0aW9uczt2YXIgbT1oLmNyb3BUaHJlc2hvbGQ7dmFyIGw9Ynx8dGhpcy5nZXRFeHRyZW1lc0Zyb21BbGx8fGguZ2V0RXh0cmVtZXNGcm9tQWxsLG49dGhpcy5pc0NhcnRlc2lhbjtiPWYmJmYudmFsMmxpbjtoPSEoIWZ8fCFmLmxvZ2FyaXRobWljKTt2YXIgcD10aGlzLnJlcXVpcmVTb3J0aW5nO2lmKGYpe2Y9Zi5nZXRFeHRyZW1lcygpO3ZhciB1PWYubWluO3ZhciBxPWYubWF4fWlmKG4mJlxudGhpcy5zb3J0ZWQmJiFsJiYoIW18fGc+bXx8dGhpcy5mb3JjZUNyb3ApKWlmKGNbZy0xXTx1fHxjWzBdPnEpYz1bXSxlPVtdO2Vsc2UgaWYodGhpcy55RGF0YSYmKGNbMF08dXx8Y1tnLTFdPnEpKXtkPXRoaXMuY3JvcERhdGEodGhpcy54RGF0YSx0aGlzLnlEYXRhLHUscSk7Yz1kLnhEYXRhO2U9ZC55RGF0YTtkPWQuc3RhcnQ7dmFyIHI9ITB9Zm9yKG09Yy5sZW5ndGh8fDE7LS1tOylpZihnPWg/YihjW21dKS1iKGNbbS0xXSk6Y1ttXS1jW20tMV0sMDxnJiYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBrfHxnPGspKXZhciBrPWc7ZWxzZSAwPmcmJnAmJihhKDE1LCExLHRoaXMuY2hhcnQpLHA9ITEpO3JldHVybnt4RGF0YTpjLHlEYXRhOmUsY3JvcHBlZDpyLGNyb3BTdGFydDpkLGNsb3Nlc3RQb2ludFJhbmdlOmt9fTtkLnByb3RvdHlwZS5wcm9jZXNzRGF0YT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLnhBeGlzO2lmKHRoaXMuaXNDYXJ0ZXNpYW4mJiF0aGlzLmlzRGlydHkmJiFiLmlzRGlydHkmJlxuIXRoaXMueUF4aXMuaXNEaXJ0eSYmIWEpcmV0dXJuITE7YT10aGlzLmdldFByb2Nlc3NlZERhdGEoKTt0aGlzLmNyb3BwZWQ9YS5jcm9wcGVkO3RoaXMuY3JvcFN0YXJ0PWEuY3JvcFN0YXJ0O3RoaXMucHJvY2Vzc2VkWERhdGE9YS54RGF0YTt0aGlzLnByb2Nlc3NlZFlEYXRhPWEueURhdGE7dGhpcy5jbG9zZXN0UG9pbnRSYW5nZT10aGlzLmJhc2VQb2ludFJhbmdlPWEuY2xvc2VzdFBvaW50UmFuZ2V9O2QucHJvdG90eXBlLmNyb3BEYXRhPWZ1bmN0aW9uKGEsYixjLGUsZyl7dmFyIGQ9YS5sZW5ndGgsZj0wLGg9ZCxtO2c9TChnLHRoaXMuY3JvcFNob3VsZGVyKTtmb3IobT0wO208ZDttKyspaWYoYVttXT49Yyl7Zj1NYXRoLm1heCgwLG0tZyk7YnJlYWt9Zm9yKGM9bTtjPGQ7YysrKWlmKGFbY10+ZSl7aD1jK2c7YnJlYWt9cmV0dXJue3hEYXRhOmEuc2xpY2UoZixoKSx5RGF0YTpiLnNsaWNlKGYsaCksc3RhcnQ6ZixlbmQ6aH19O2QucHJvdG90eXBlLmdlbmVyYXRlUG9pbnRzPWZ1bmN0aW9uKCl7dmFyIGE9XG50aGlzLm9wdGlvbnMsYz1hLmRhdGEsZT10aGlzLmRhdGEsZyxkPXRoaXMucHJvY2Vzc2VkWERhdGEsZj10aGlzLnByb2Nlc3NlZFlEYXRhLGg9dGhpcy5wb2ludENsYXNzLG09ZC5sZW5ndGgsbD10aGlzLmNyb3BTdGFydHx8MCxuPXRoaXMuaGFzR3JvdXBlZERhdGE7YT1hLmtleXM7dmFyIHA9W10scTtlfHxufHwoZT1bXSxlLmxlbmd0aD1jLmxlbmd0aCxlPXRoaXMuZGF0YT1lKTthJiZuJiYodGhpcy5vcHRpb25zLmtleXM9ITEpO2ZvcihxPTA7cTxtO3ErKyl7dmFyIHI9bCtxO2lmKG4pe3ZhciBrPShuZXcgaCkuaW5pdCh0aGlzLFtkW3FdXS5jb25jYXQoSyhmW3FdKSkpO2suZGF0YUdyb3VwPXRoaXMuZ3JvdXBNYXBbcV07ay5kYXRhR3JvdXAub3B0aW9ucyYmKGsub3B0aW9ucz1rLmRhdGFHcm91cC5vcHRpb25zLGIoayxrLmRhdGFHcm91cC5vcHRpb25zKSxkZWxldGUgay5kYXRhTGFiZWxzKX1lbHNlKGs9ZVtyXSl8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgY1tyXXx8KGVbcl09az1cbihuZXcgaCkuaW5pdCh0aGlzLGNbcl0sZFtxXSkpO2smJihrLmluZGV4PXIscFtxXT1rKX10aGlzLm9wdGlvbnMua2V5cz1hO2lmKGUmJihtIT09KGc9ZS5sZW5ndGgpfHxuKSlmb3IocT0wO3E8ZztxKyspcSE9PWx8fG58fChxKz1tKSxlW3FdJiYoZVtxXS5kZXN0cm95RWxlbWVudHMoKSxlW3FdLnBsb3RYPXZvaWQgMCk7dGhpcy5kYXRhPWU7dGhpcy5wb2ludHM9cDtKKHRoaXMsXCJhZnRlckdlbmVyYXRlUG9pbnRzXCIpfTtkLnByb3RvdHlwZS5nZXRYRXh0cmVtZXM9ZnVuY3Rpb24oYSl7cmV0dXJue21pbjpNKGEpLG1heDpBKGEpfX07ZC5wcm90b3R5cGUuZ2V0RXh0cmVtZXM9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzLnhBeGlzLGU9dGhpcy55QXhpcyxnPXRoaXMucHJvY2Vzc2VkWERhdGF8fHRoaXMueERhdGEsZD1bXSxmPTAsaD0wO3ZhciBtPTA7dmFyIGw9dGhpcy5yZXF1aXJlU29ydGluZz90aGlzLmNyb3BTaG91bGRlcjowLG49ZT9lLnBvc2l0aXZlVmFsdWVzT25seTohMSxwO1xuYT1hfHx0aGlzLnN0YWNrZWRZRGF0YXx8dGhpcy5wcm9jZXNzZWRZRGF0YXx8W107ZT1hLmxlbmd0aDtjJiYobT1jLmdldEV4dHJlbWVzKCksaD1tLm1pbixtPW0ubWF4KTtmb3IocD0wO3A8ZTtwKyspe3ZhciB1PWdbcF07dmFyIHE9YVtwXTt2YXIgcj0oUihxKXx8RihxKSkmJihxLmxlbmd0aHx8MDxxfHwhbik7dT1ifHx0aGlzLmdldEV4dHJlbWVzRnJvbUFsbHx8dGhpcy5vcHRpb25zLmdldEV4dHJlbWVzRnJvbUFsbHx8dGhpcy5jcm9wcGVkfHwhY3x8KGdbcCtsXXx8dSk+PWgmJihnW3AtbF18fHUpPD1tO2lmKHImJnUpaWYocj1xLmxlbmd0aClmb3IoO3ItLTspUihxW3JdKSYmKGRbZisrXT1xW3JdKTtlbHNlIGRbZisrXT1xfWE9e2RhdGFNaW46TShkKSxkYXRhTWF4OkEoZCl9O0oodGhpcyxcImFmdGVyR2V0RXh0cmVtZXNcIix7ZGF0YUV4dHJlbWVzOmF9KTtyZXR1cm4gYX07ZC5wcm90b3R5cGUuYXBwbHlFeHRyZW1lcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuZ2V0RXh0cmVtZXMoKTtcbnRoaXMuZGF0YU1pbj1hLmRhdGFNaW47dGhpcy5kYXRhTWF4PWEuZGF0YU1heDtyZXR1cm4gYX07ZC5wcm90b3R5cGUuZ2V0Rmlyc3RWYWxpZFBvaW50PWZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1udWxsLGM9YS5sZW5ndGgsZT0wO251bGw9PT1iJiZlPGM7KWI9YVtlXSxlKys7cmV0dXJuIGJ9O2QucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbigpe3RoaXMucHJvY2Vzc2VkWERhdGF8fHRoaXMucHJvY2Vzc0RhdGEoKTt0aGlzLmdlbmVyYXRlUG9pbnRzKCk7dmFyIGE9dGhpcy5vcHRpb25zLGI9YS5zdGFja2luZyxjPXRoaXMueEF4aXMsZz1jLmNhdGVnb3JpZXMsZD10aGlzLmVuYWJsZWREYXRhU29ydGluZyxmPXRoaXMueUF4aXMsaD10aGlzLnBvaW50cyxtPWgubGVuZ3RoLGw9ISF0aGlzLm1vZGlmeVZhbHVlLG4scD10aGlzLnBvaW50UGxhY2VtZW50VG9YVmFsdWUoKSxxPSEhcCxrPWEudGhyZXNob2xkLHc9YS5zdGFydEZyb21UaHJlc2hvbGQ/azowLHksdD10aGlzLnpvbmVBeGlzfHxcblwieVwiLHY9TnVtYmVyLk1BWF9WQUxVRTtmb3Iobj0wO248bTtuKyspe3ZhciBBPWhbbl0sQz1BLngsRT1BLnkseD1BLmxvdyxNPWImJmYuc3RhY2tpbmcmJmYuc3RhY2tpbmcuc3RhY2tzWyh0aGlzLm5lZ1N0YWNrcyYmRTwodz8wOmspP1wiLVwiOlwiXCIpK3RoaXMuc3RhY2tLZXldO2lmKGYucG9zaXRpdmVWYWx1ZXNPbmx5JiYhZi52YWxpZGF0ZVBvc2l0aXZlVmFsdWUoRSl8fGMucG9zaXRpdmVWYWx1ZXNPbmx5JiYhYy52YWxpZGF0ZVBvc2l0aXZlVmFsdWUoQykpQS5pc051bGw9ITA7QS5wbG90WD15PXIoeihjLnRyYW5zbGF0ZShDLDAsMCwwLDEscCxcImZsYWdzXCI9PT10aGlzLnR5cGUpLC0xRTUsMUU1KSk7aWYoYiYmdGhpcy52aXNpYmxlJiZNJiZNW0NdKXt2YXIgTj10aGlzLmdldFN0YWNrSW5kaWNhdG9yKE4sQyx0aGlzLmluZGV4KTtpZighQS5pc051bGwpe3ZhciBIPU1bQ107dmFyIFE9SC5wb2ludHNbTi5rZXldfX1GKFEpJiYoeD1RWzBdLEU9UVsxXSx4PT09dyYmTi5rZXk9PT1NW0NdLmJhc2UmJlxuKHg9TChSKGspJiZrLGYubWluKSksZi5wb3NpdGl2ZVZhbHVlc09ubHkmJjA+PXgmJih4PW51bGwpLEEudG90YWw9QS5zdGFja1RvdGFsPUgudG90YWwsQS5wZXJjZW50YWdlPUgudG90YWwmJkEueS9ILnRvdGFsKjEwMCxBLnN0YWNrWT1FLHRoaXMuaXJyZWd1bGFyV2lkdGhzfHxILnNldE9mZnNldCh0aGlzLnBvaW50WE9mZnNldHx8MCx0aGlzLmJhcld8fDApKTtBLnlCb3R0b209ZSh4KT96KGYudHJhbnNsYXRlKHgsMCwxLDAsMSksLTFFNSwxRTUpOm51bGw7bCYmKEU9dGhpcy5tb2RpZnlWYWx1ZShFLEEpKTtBLnBsb3RZPXZvaWQgMDtSKEUpJiYoRT1mLnRyYW5zbGF0ZShFLCExLCEwLCExLCEwKSxcInVuZGVmaW5lZFwiIT09dHlwZW9mIEUmJihBLnBsb3RZPXooRSwtMUU1LDFFNSkpKTtBLmlzSW5zaWRlPXRoaXMuaXNQb2ludEluc2lkZShBKTtBLmNsaWVudFg9cT9yKGMudHJhbnNsYXRlKEMsMCwwLDAsMSxwKSk6eTtBLm5lZ2F0aXZlPUFbdF08KGFbdCtcIlRocmVzaG9sZFwiXXx8a3x8XG4wKTtBLmNhdGVnb3J5PWcmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgZ1tBLnhdP2dbQS54XTpBLng7aWYoIUEuaXNOdWxsJiYhMSE9PUEudmlzaWJsZSl7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBEJiYodj1NYXRoLm1pbih2LE1hdGguYWJzKHktRCkpKTt2YXIgRD15fUEuem9uZT10aGlzLnpvbmVzLmxlbmd0aCYmQS5nZXRab25lKCk7IUEuZ3JhcGhpYyYmdGhpcy5ncm91cCYmZCYmKEEuaXNOZXc9ITApfXRoaXMuY2xvc2VzdFBvaW50UmFuZ2VQeD12O0oodGhpcyxcImFmdGVyVHJhbnNsYXRlXCIpfTtkLnByb3RvdHlwZS5nZXRWYWxpZFBvaW50cz1mdW5jdGlvbihhLGIsYyl7dmFyIGU9dGhpcy5jaGFydDtyZXR1cm4oYXx8dGhpcy5wb2ludHN8fFtdKS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGImJiFlLmlzSW5zaWRlUGxvdChhLnBsb3RYLGEucGxvdFksZS5pbnZlcnRlZCk/ITE6ITEhPT1hLnZpc2libGUmJihjfHwhYS5pc051bGwpfSl9O2QucHJvdG90eXBlLmdldENsaXBCb3g9ZnVuY3Rpb24oYSxcbmIpe3ZhciBjPXRoaXMub3B0aW9ucyxlPXRoaXMuY2hhcnQsZz1lLmludmVydGVkLGQ9dGhpcy54QXhpcyxmPWQmJnRoaXMueUF4aXMsaD1lLm9wdGlvbnMuY2hhcnQuc2Nyb2xsYWJsZVBsb3RBcmVhfHx7fTthJiYhMT09PWMuY2xpcCYmZj9hPWc/e3k6LWUuY2hhcnRXaWR0aCtmLmxlbitmLnBvcyxoZWlnaHQ6ZS5jaGFydFdpZHRoLHdpZHRoOmUuY2hhcnRIZWlnaHQseDotZS5jaGFydEhlaWdodCtkLmxlbitkLnBvc306e3k6LWYucG9zLGhlaWdodDplLmNoYXJ0SGVpZ2h0LHdpZHRoOmUuY2hhcnRXaWR0aCx4Oi1kLnBvc306KGE9dGhpcy5jbGlwQm94fHxlLmNsaXBCb3gsYiYmKGEud2lkdGg9ZS5wbG90U2l6ZVgsYS54PShlLnNjcm9sbGFibGVQaXhlbHNYfHwwKSooaC5zY3JvbGxQb3NpdGlvblh8fDApKSk7cmV0dXJuIGI/e3dpZHRoOmEud2lkdGgseDphLnh9OmF9O2QucHJvdG90eXBlLnNldENsaXA9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydCxjPXRoaXMub3B0aW9ucyxcbmU9Yi5yZW5kZXJlcixnPWIuaW52ZXJ0ZWQsZD10aGlzLmNsaXBCb3gsZj10aGlzLmdldENsaXBCb3goYSksaD10aGlzLnNoYXJlZENsaXBLZXl8fFtcIl9zaGFyZWRDbGlwXCIsYSYmYS5kdXJhdGlvbixhJiZhLmVhc2luZyxhJiZhLmRlZmVyLGYuaGVpZ2h0LGMueEF4aXMsYy55QXhpc10uam9pbigpLG09YltoXSxsPWJbaCtcIm1cIl07YSYmKGYud2lkdGg9MCxnJiYoZi54PWIucGxvdEhlaWdodCsoITEhPT1jLmNsaXA/MDpiLnBsb3RUb3ApKSk7bT9iLmhhc0xvYWRlZHx8bS5hdHRyKGYpOihhJiYoYltoK1wibVwiXT1sPWUuY2xpcFJlY3QoZz9iLnBsb3RTaXplWCs5OTotOTksZz8tYi5wbG90TGVmdDotYi5wbG90VG9wLDk5LGc/Yi5jaGFydFdpZHRoOmIuY2hhcnRIZWlnaHQpKSxiW2hdPW09ZS5jbGlwUmVjdChmKSxtLmNvdW50PXtsZW5ndGg6MH0pO2EmJiFtLmNvdW50W3RoaXMuaW5kZXhdJiYobS5jb3VudFt0aGlzLmluZGV4XT0hMCxtLmNvdW50Lmxlbmd0aCs9MSk7aWYoITEhPT1jLmNsaXB8fFxuYSl0aGlzLmdyb3VwLmNsaXAoYXx8ZD9tOmIuY2xpcFJlY3QpLHRoaXMubWFya2VyR3JvdXAuY2xpcChsKSx0aGlzLnNoYXJlZENsaXBLZXk9aDthfHwobS5jb3VudFt0aGlzLmluZGV4XSYmKGRlbGV0ZSBtLmNvdW50W3RoaXMuaW5kZXhdLC0tbS5jb3VudC5sZW5ndGgpLDA9PT1tLmNvdW50Lmxlbmd0aCYmaCYmYltoXSYmKGR8fChiW2hdPWJbaF0uZGVzdHJveSgpKSxiW2grXCJtXCJdJiYoYltoK1wibVwiXT1iW2grXCJtXCJdLmRlc3Ryb3koKSkpKX07ZC5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9Qyh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKTtpZihhKXRoaXMuc2V0Q2xpcChjKTtlbHNle3ZhciBlPXRoaXMuc2hhcmVkQ2xpcEtleTthPWJbZV07dmFyIGc9dGhpcy5nZXRDbGlwQm94KGMsITApO2EmJmEuYW5pbWF0ZShnLGMpO2JbZStcIm1cIl0mJmJbZStcIm1cIl0uYW5pbWF0ZSh7d2lkdGg6Zy53aWR0aCs5OSx4OmcueC0oYi5pbnZlcnRlZD8wOjk5KX0sXG5jKX19O2QucHJvdG90eXBlLmFmdGVyQW5pbWF0ZT1mdW5jdGlvbigpe3RoaXMuc2V0Q2xpcCgpO0oodGhpcyxcImFmdGVyQW5pbWF0ZVwiKTt0aGlzLmZpbmlzaGVkQW5pbWF0aW5nPSEwfTtkLnByb3RvdHlwZS5kcmF3UG9pbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5wb2ludHMsYj10aGlzLmNoYXJ0LGMsZSxnPXRoaXMub3B0aW9ucy5tYXJrZXIsZD10aGlzW3RoaXMuc3BlY2lhbEdyb3VwXXx8dGhpcy5tYXJrZXJHcm91cCxmPXRoaXMueEF4aXMsaD1MKGcuZW5hYmxlZCwhZnx8Zi5pc1JhZGlhbD8hMDpudWxsLHRoaXMuY2xvc2VzdFBvaW50UmFuZ2VQeD49Zy5lbmFibGVkVGhyZXNob2xkKmcucmFkaXVzKTtpZighMSE9PWcuZW5hYmxlZHx8dGhpcy5faGFzUG9pbnRNYXJrZXJzKWZvcihjPTA7YzxhLmxlbmd0aDtjKyspe3ZhciBtPWFbY107dmFyIGw9KGU9bS5ncmFwaGljKT9cImFuaW1hdGVcIjpcImF0dHJcIjt2YXIgbj1tLm1hcmtlcnx8e307dmFyIHA9ISFtLm1hcmtlcjtpZigoaCYmXG5cInVuZGVmaW5lZFwiPT09dHlwZW9mIG4uZW5hYmxlZHx8bi5lbmFibGVkKSYmIW0uaXNOdWxsJiYhMSE9PW0udmlzaWJsZSl7dmFyIHE9TChuLnN5bWJvbCx0aGlzLnN5bWJvbCk7dmFyIHI9dGhpcy5tYXJrZXJBdHRyaWJzKG0sbS5zZWxlY3RlZCYmXCJzZWxlY3RcIik7dGhpcy5lbmFibGVkRGF0YVNvcnRpbmcmJihtLnN0YXJ0WFBvcz1mLnJldmVyc2VkPy1yLndpZHRoOmYud2lkdGgpO3ZhciBrPSExIT09bS5pc0luc2lkZTtlP2Vbaz9cInNob3dcIjpcImhpZGVcIl0oaykuYW5pbWF0ZShyKTprJiYoMDxyLndpZHRofHxtLmhhc0ltYWdlKSYmKG0uZ3JhcGhpYz1lPWIucmVuZGVyZXIuc3ltYm9sKHEsci54LHIueSxyLndpZHRoLHIuaGVpZ2h0LHA/bjpnKS5hZGQoZCksdGhpcy5lbmFibGVkRGF0YVNvcnRpbmcmJmIuaGFzUmVuZGVyZWQmJihlLmF0dHIoe3g6bS5zdGFydFhQb3N9KSxsPVwiYW5pbWF0ZVwiKSk7ZSYmXCJhbmltYXRlXCI9PT1sJiZlW2s/XCJzaG93XCI6XCJoaWRlXCJdKGspLmFuaW1hdGUocik7XG5pZihlJiYhYi5zdHlsZWRNb2RlKWVbbF0odGhpcy5wb2ludEF0dHJpYnMobSxtLnNlbGVjdGVkJiZcInNlbGVjdFwiKSk7ZSYmZS5hZGRDbGFzcyhtLmdldENsYXNzTmFtZSgpLCEwKX1lbHNlIGUmJihtLmdyYXBoaWM9ZS5kZXN0cm95KCkpfX07ZC5wcm90b3R5cGUubWFya2VyQXR0cmlicz1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMub3B0aW9ucyxlPWMubWFya2VyLGc9YS5tYXJrZXJ8fHt9LGQ9Zy5zeW1ib2x8fGUuc3ltYm9sLGY9TChnLnJhZGl1cyxlLnJhZGl1cyk7YiYmKGU9ZS5zdGF0ZXNbYl0sYj1nLnN0YXRlcyYmZy5zdGF0ZXNbYl0sZj1MKGImJmIucmFkaXVzLGUmJmUucmFkaXVzLGYrKGUmJmUucmFkaXVzUGx1c3x8MCkpKTthLmhhc0ltYWdlPWQmJjA9PT1kLmluZGV4T2YoXCJ1cmxcIik7YS5oYXNJbWFnZSYmKGY9MCk7YT17eDpjLmNyaXNwP01hdGguZmxvb3IoYS5wbG90WCktZjphLnBsb3RYLWYseTphLnBsb3RZLWZ9O2YmJihhLndpZHRoPWEuaGVpZ2h0PTIqZik7cmV0dXJuIGF9O1xuZC5wcm90b3R5cGUucG9pbnRBdHRyaWJzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLm1hcmtlcixlPWEmJmEub3B0aW9ucyxnPWUmJmUubWFya2VyfHx7fSxkPXRoaXMuY29sb3IsZj1lJiZlLmNvbG9yLGg9YSYmYS5jb2xvcjtlPUwoZy5saW5lV2lkdGgsYy5saW5lV2lkdGgpO3ZhciBtPWEmJmEuem9uZSYmYS56b25lLmNvbG9yO2E9MTtkPWZ8fG18fGh8fGQ7Zj1nLmZpbGxDb2xvcnx8Yy5maWxsQ29sb3J8fGQ7ZD1nLmxpbmVDb2xvcnx8Yy5saW5lQ29sb3J8fGQ7Yj1ifHxcIm5vcm1hbFwiO2M9Yy5zdGF0ZXNbYl07Yj1nLnN0YXRlcyYmZy5zdGF0ZXNbYl18fHt9O2U9TChiLmxpbmVXaWR0aCxjLmxpbmVXaWR0aCxlK0woYi5saW5lV2lkdGhQbHVzLGMubGluZVdpZHRoUGx1cywwKSk7Zj1iLmZpbGxDb2xvcnx8Yy5maWxsQ29sb3J8fGY7ZD1iLmxpbmVDb2xvcnx8Yy5saW5lQ29sb3J8fGQ7YT1MKGIub3BhY2l0eSxjLm9wYWNpdHksYSk7cmV0dXJue3N0cm9rZTpkLFwic3Ryb2tlLXdpZHRoXCI6ZSxcbmZpbGw6ZixvcGFjaXR5OmF9fTtkLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1iLmNoYXJ0LGU9L0FwcGxlV2ViS2l0XFwvNTMzLy50ZXN0KHkubmF2aWdhdG9yLnVzZXJBZ2VudCksZyxkLGY9Yi5kYXRhfHxbXSxtLGw7SihiLFwiZGVzdHJveVwiKTt0aGlzLnJlbW92ZUV2ZW50cyhhKTsoYi5heGlzVHlwZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGEpeyhsPWJbYV0pJiZsLnNlcmllcyYmKGgobC5zZXJpZXMsYiksbC5pc0RpcnR5PWwuZm9yY2VSZWRyYXc9ITApfSk7Yi5sZWdlbmRJdGVtJiZiLmNoYXJ0LmxlZ2VuZC5kZXN0cm95SXRlbShiKTtmb3IoZD1mLmxlbmd0aDtkLS07KShtPWZbZF0pJiZtLmRlc3Ryb3kmJm0uZGVzdHJveSgpO2IucG9pbnRzPW51bGw7dC5jbGVhclRpbWVvdXQoYi5hbmltYXRpb25UaW1lb3V0KTt2KGIsZnVuY3Rpb24oYSxiKXthIGluc3RhbmNlb2YgSCYmIWEuc3Vydml2ZSYmKGc9ZSYmXCJncm91cFwiPT09Yj9cImhpZGVcIjpcImRlc3Ryb3lcIixcbmFbZ10oKSl9KTtjLmhvdmVyU2VyaWVzPT09YiYmKGMuaG92ZXJTZXJpZXM9bnVsbCk7aChjLnNlcmllcyxiKTtjLm9yZGVyU2VyaWVzKCk7dihiLGZ1bmN0aW9uKGMsZSl7YSYmXCJoY0V2ZW50c1wiPT09ZXx8ZGVsZXRlIGJbZV19KX07ZC5wcm90b3R5cGUuYXBwbHlab25lcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmNoYXJ0LGM9Yi5yZW5kZXJlcixlPXRoaXMuem9uZXMsZyxkLGY9dGhpcy5jbGlwc3x8W10saCxtPXRoaXMuZ3JhcGgsbD10aGlzLmFyZWEsbj1NYXRoLm1heChiLmNoYXJ0V2lkdGgsYi5jaGFydEhlaWdodCkscD10aGlzWyh0aGlzLnpvbmVBeGlzfHxcInlcIikrXCJBeGlzXCJdLHE9Yi5pbnZlcnRlZCxyLGssdyx5PSExLHQsdjtpZihlLmxlbmd0aCYmKG18fGwpJiZwJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHAubWluKXt2YXIgQT1wLnJldmVyc2VkO3ZhciBGPXAuaG9yaXo7bSYmIXRoaXMuc2hvd0xpbmUmJm0uaGlkZSgpO2wmJmwuaGlkZSgpO3ZhciBFPXAuZ2V0RXh0cmVtZXMoKTtcbmUuZm9yRWFjaChmdW5jdGlvbihlLHUpe2c9QT9GP2IucGxvdFdpZHRoOjA6Rj8wOnAudG9QaXhlbHMoRS5taW4pfHwwO2c9eihMKGQsZyksMCxuKTtkPXooTWF0aC5yb3VuZChwLnRvUGl4ZWxzKEwoZS52YWx1ZSxFLm1heCksITApfHwwKSwwLG4pO3kmJihnPWQ9cC50b1BpeGVscyhFLm1heCkpO3I9TWF0aC5hYnMoZy1kKTtrPU1hdGgubWluKGcsZCk7dz1NYXRoLm1heChnLGQpO3AuaXNYQXhpcz8oaD17eDpxP3c6ayx5OjAsd2lkdGg6cixoZWlnaHQ6bn0sRnx8KGgueD1iLnBsb3RIZWlnaHQtaC54KSk6KGg9e3g6MCx5OnE/dzprLHdpZHRoOm4saGVpZ2h0OnJ9LEYmJihoLnk9Yi5wbG90V2lkdGgtaC55KSk7cSYmYy5pc1ZNTCYmKGg9cC5pc1hBeGlzP3t4OjAseTpBP2s6dyxoZWlnaHQ6aC53aWR0aCx3aWR0aDpiLmNoYXJ0V2lkdGh9Ont4OmgueS1iLnBsb3RMZWZ0LWIuc3BhY2luZ0JveC54LHk6MCx3aWR0aDpoLmhlaWdodCxoZWlnaHQ6Yi5jaGFydEhlaWdodH0pO2ZbdV0/Zlt1XS5hbmltYXRlKGgpOlxuZlt1XT1jLmNsaXBSZWN0KGgpO3Q9YVtcInpvbmUtYXJlYS1cIit1XTt2PWFbXCJ6b25lLWdyYXBoLVwiK3VdO20mJnYmJnYuY2xpcChmW3VdKTtsJiZ0JiZ0LmNsaXAoZlt1XSk7eT1lLnZhbHVlPkUubWF4O2EucmVzZXRab25lcyYmMD09PWQmJihkPXZvaWQgMCl9KTt0aGlzLmNsaXBzPWZ9ZWxzZSBhLnZpc2libGUmJihtJiZtLnNob3coITApLGwmJmwuc2hvdyghMCkpfTtkLnByb3RvdHlwZS5pbnZlcnRHcm91cHM9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe1tcImdyb3VwXCIsXCJtYXJrZXJHcm91cFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2NbYl0mJihlLnJlbmRlcmVyLmlzVk1MJiZjW2JdLmF0dHIoe3dpZHRoOmMueUF4aXMubGVuLGhlaWdodDpjLnhBeGlzLmxlbn0pLGNbYl0ud2lkdGg9Yy55QXhpcy5sZW4sY1tiXS5oZWlnaHQ9Yy54QXhpcy5sZW4sY1tiXS5pbnZlcnQoYy5pc1JhZGlhbFNlcmllcz8hMTphKSl9KX12YXIgYz10aGlzLGU9Yy5jaGFydDtjLnhBeGlzJiYoYy5ldmVudHNUb1VuYmluZC5wdXNoKG4oZSxcblwicmVzaXplXCIsYikpLGIoKSxjLmludmVydEdyb3Vwcz1iKX07ZC5wcm90b3R5cGUucGxvdEdyb3VwPWZ1bmN0aW9uKGEsYixjLGcsZCl7dmFyIGY9dGhpc1thXSxoPSFmO2M9e3Zpc2liaWxpdHk6Yyx6SW5kZXg6Z3x8LjF9O1widW5kZWZpbmVkXCI9PT10eXBlb2YgdGhpcy5vcGFjaXR5fHx0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fFwiaW5hY3RpdmVcIj09PXRoaXMuc3RhdGV8fChjLm9wYWNpdHk9dGhpcy5vcGFjaXR5KTtoJiYodGhpc1thXT1mPXRoaXMuY2hhcnQucmVuZGVyZXIuZygpLmFkZChkKSk7Zi5hZGRDbGFzcyhcImhpZ2hjaGFydHMtXCIrYitcIiBoaWdoY2hhcnRzLXNlcmllcy1cIit0aGlzLmluZGV4K1wiIGhpZ2hjaGFydHMtXCIrdGhpcy50eXBlK1wiLXNlcmllcyBcIisoZSh0aGlzLmNvbG9ySW5kZXgpP1wiaGlnaGNoYXJ0cy1jb2xvci1cIit0aGlzLmNvbG9ySW5kZXgrXCIgXCI6XCJcIikrKHRoaXMub3B0aW9ucy5jbGFzc05hbWV8fFwiXCIpKyhmLmhhc0NsYXNzKFwiaGlnaGNoYXJ0cy10cmFja2VyXCIpP1xuXCIgaGlnaGNoYXJ0cy10cmFja2VyXCI6XCJcIiksITApO2YuYXR0cihjKVtoP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh0aGlzLmdldFBsb3RCb3goKSk7cmV0dXJuIGZ9O2QucHJvdG90eXBlLmdldFBsb3RCb3g9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9dGhpcy54QXhpcyxjPXRoaXMueUF4aXM7YS5pbnZlcnRlZCYmKGI9YyxjPXRoaXMueEF4aXMpO3JldHVybnt0cmFuc2xhdGVYOmI/Yi5sZWZ0OmEucGxvdExlZnQsdHJhbnNsYXRlWTpjP2MudG9wOmEucGxvdFRvcCxzY2FsZVg6MSxzY2FsZVk6MX19O2QucHJvdG90eXBlLnJlbW92ZUV2ZW50cz1mdW5jdGlvbihhKXthfHxwKHRoaXMpO3RoaXMuZXZlbnRzVG9VbmJpbmQubGVuZ3RoJiYodGhpcy5ldmVudHNUb1VuYmluZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EoKX0pLHRoaXMuZXZlbnRzVG9VbmJpbmQubGVuZ3RoPTApfTtkLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5jaGFydCxjPWEub3B0aW9ucyxcbmU9QyhjLmFuaW1hdGlvbiksZz0hYS5maW5pc2hlZEFuaW1hdGluZyYmYi5yZW5kZXJlci5pc1NWRyYmZS5kdXJhdGlvbixkPWEudmlzaWJsZT9cImluaGVyaXRcIjpcImhpZGRlblwiLGY9Yy56SW5kZXgsaD1hLmhhc1JlbmRlcmVkLG09Yi5zZXJpZXNHcm91cCxsPWIuaW52ZXJ0ZWQ7Sih0aGlzLFwicmVuZGVyXCIpO3ZhciBuPWEucGxvdEdyb3VwKFwiZ3JvdXBcIixcInNlcmllc1wiLGQsZixtKTthLm1hcmtlckdyb3VwPWEucGxvdEdyb3VwKFwibWFya2VyR3JvdXBcIixcIm1hcmtlcnNcIixkLGYsbSk7ZyYmYS5hbmltYXRlJiZhLmFuaW1hdGUoITApO24uaW52ZXJ0ZWQ9TChhLmludmVydGlibGUsYS5pc0NhcnRlc2lhbik/bDohMTthLmRyYXdHcmFwaCYmKGEuZHJhd0dyYXBoKCksYS5hcHBseVpvbmVzKCkpO2EudmlzaWJsZSYmYS5kcmF3UG9pbnRzKCk7YS5kcmF3RGF0YUxhYmVscyYmYS5kcmF3RGF0YUxhYmVscygpO2EucmVkcmF3UG9pbnRzJiZhLnJlZHJhd1BvaW50cygpO2EuZHJhd1RyYWNrZXImJlxuITEhPT1hLm9wdGlvbnMuZW5hYmxlTW91c2VUcmFja2luZyYmYS5kcmF3VHJhY2tlcigpO2EuaW52ZXJ0R3JvdXBzKGwpOyExPT09Yy5jbGlwfHxhLnNoYXJlZENsaXBLZXl8fGh8fG4uY2xpcChiLmNsaXBSZWN0KTtnJiZhLmFuaW1hdGUmJmEuYW5pbWF0ZSgpO2h8fChnJiZlLmRlZmVyJiYoZys9ZS5kZWZlciksYS5hbmltYXRpb25UaW1lb3V0PVMoZnVuY3Rpb24oKXthLmFmdGVyQW5pbWF0ZSgpfSxnfHwwKSk7YS5pc0RpcnR5PSExO2EuaGFzUmVuZGVyZWQ9ITA7SihhLFwiYWZ0ZXJSZW5kZXJcIil9O2QucHJvdG90eXBlLnJlZHJhdz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQsYj10aGlzLmlzRGlydHl8fHRoaXMuaXNEaXJ0eURhdGEsYz10aGlzLmdyb3VwLGU9dGhpcy54QXhpcyxnPXRoaXMueUF4aXM7YyYmKGEuaW52ZXJ0ZWQmJmMuYXR0cih7d2lkdGg6YS5wbG90V2lkdGgsaGVpZ2h0OmEucGxvdEhlaWdodH0pLGMuYW5pbWF0ZSh7dHJhbnNsYXRlWDpMKGUmJmUubGVmdCxcbmEucGxvdExlZnQpLHRyYW5zbGF0ZVk6TChnJiZnLnRvcCxhLnBsb3RUb3ApfSkpO3RoaXMudHJhbnNsYXRlKCk7dGhpcy5yZW5kZXIoKTtiJiZkZWxldGUgdGhpcy5rZFRyZWV9O2QucHJvdG90eXBlLnNlYXJjaFBvaW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy54QXhpcyxlPXRoaXMueUF4aXMsZz10aGlzLmNoYXJ0LmludmVydGVkO3JldHVybiB0aGlzLnNlYXJjaEtEVHJlZSh7Y2xpZW50WDpnP2MubGVuLWEuY2hhcnRZK2MucG9zOmEuY2hhcnRYLWMucG9zLHBsb3RZOmc/ZS5sZW4tYS5jaGFydFgrZS5wb3M6YS5jaGFydFktZS5wb3N9LGIsYSl9O2QucHJvdG90eXBlLmJ1aWxkS0RUcmVlPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxlLGcpe3ZhciBkO2lmKGQ9YSYmYS5sZW5ndGgpe3ZhciBmPWMua2RBeGlzQXJyYXlbZSVnXTthLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYVtmXS1iW2ZdfSk7ZD1NYXRoLmZsb29yKGQvMik7cmV0dXJue3BvaW50OmFbZF0sbGVmdDpiKGEuc2xpY2UoMCxcbmQpLGUrMSxnKSxyaWdodDpiKGEuc2xpY2UoZCsxKSxlKzEsZyl9fX10aGlzLmJ1aWxkaW5nS2RUcmVlPSEwO3ZhciBjPXRoaXMsZT0tMTxjLm9wdGlvbnMuZmluZE5lYXJlc3RQb2ludEJ5LmluZGV4T2YoXCJ5XCIpPzI6MTtkZWxldGUgYy5rZFRyZWU7UyhmdW5jdGlvbigpe2Mua2RUcmVlPWIoYy5nZXRWYWxpZFBvaW50cyhudWxsLCFjLmRpcmVjdFRvdWNoKSxlLGUpO2MuYnVpbGRpbmdLZFRyZWU9ITF9LGMub3B0aW9ucy5rZE5vd3x8YSYmXCJ0b3VjaHN0YXJ0XCI9PT1hLnR5cGU/MDoxKX07ZC5wcm90b3R5cGUuc2VhcmNoS0RUcmVlPWZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBnKGEsYixjLGwpe3ZhciBuPWIucG9pbnQscD1kLmtkQXhpc0FycmF5W2MlbF0scT1uO3ZhciByPWUoYVtmXSkmJmUobltmXSk/TWF0aC5wb3coYVtmXS1uW2ZdLDIpOm51bGw7dmFyIGs9ZShhW2hdKSYmZShuW2hdKT9NYXRoLnBvdyhhW2hdLW5baF0sMik6bnVsbDtrPShyfHwwKSsoa3x8MCk7bi5kaXN0PWUoayk/XG5NYXRoLnNxcnQoayk6TnVtYmVyLk1BWF9WQUxVRTtuLmRpc3RYPWUocik/TWF0aC5zcXJ0KHIpOk51bWJlci5NQVhfVkFMVUU7cD1hW3BdLW5bcF07az0wPnA/XCJsZWZ0XCI6XCJyaWdodFwiO3I9MD5wP1wicmlnaHRcIjpcImxlZnRcIjtiW2tdJiYoaz1nKGEsYltrXSxjKzEsbCkscT1rW21dPHFbbV0/azpuKTtiW3JdJiZNYXRoLnNxcnQocCpwKTxxW21dJiYoYT1nKGEsYltyXSxjKzEsbCkscT1hW21dPHFbbV0/YTpxKTtyZXR1cm4gcX12YXIgZD10aGlzLGY9dGhpcy5rZEF4aXNBcnJheVswXSxoPXRoaXMua2RBeGlzQXJyYXlbMV0sbT1iP1wiZGlzdFhcIjpcImRpc3RcIjtiPS0xPGQub3B0aW9ucy5maW5kTmVhcmVzdFBvaW50QnkuaW5kZXhPZihcInlcIik/MjoxO3RoaXMua2RUcmVlfHx0aGlzLmJ1aWxkaW5nS2RUcmVlfHx0aGlzLmJ1aWxkS0RUcmVlKGMpO2lmKHRoaXMua2RUcmVlKXJldHVybiBnKGEsdGhpcy5rZFRyZWUsYixiKX07ZC5wcm90b3R5cGUucG9pbnRQbGFjZW1lbnRUb1hWYWx1ZT1mdW5jdGlvbigpe3ZhciBhPVxudGhpcy5vcHRpb25zLGI9YS5wb2ludFJhbmdlLGM9dGhpcy54QXhpczthPWEucG9pbnRQbGFjZW1lbnQ7XCJiZXR3ZWVuXCI9PT1hJiYoYT1jLnJldmVyc2VkPy0uNTouNSk7cmV0dXJuIFIoYSk/YSooYnx8Yy5wb2ludFJhbmdlKTowfTtkLnByb3RvdHlwZS5pc1BvaW50SW5zaWRlPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgYS5wbG90WSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhLnBsb3RYJiYwPD1hLnBsb3RZJiZhLnBsb3RZPD10aGlzLnlBeGlzLmxlbiYmMDw9YS5wbG90WCYmYS5wbG90WDw9dGhpcy54QXhpcy5sZW59O2QucHJvdG90eXBlLmRyYXdUcmFja2VyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEub3B0aW9ucyxjPWIudHJhY2tCeUFyZWEsZT1bXS5jb25jYXQoYz9hLmFyZWFQYXRoOmEuZ3JhcGhQYXRoKSxkPWEuY2hhcnQsZj1kLnBvaW50ZXIsaD1kLnJlbmRlcmVyLG09ZC5vcHRpb25zLnRvb2x0aXAuc25hcCxsPWEudHJhY2tlcixuPWZ1bmN0aW9uKGIpe2lmKGQuaG92ZXJTZXJpZXMhPT1cbmEpYS5vbk1vdXNlT3ZlcigpfSxwPVwicmdiYSgxOTIsMTkyLDE5MixcIisoZz8uMDAwMTouMDAyKStcIilcIjtsP2wuYXR0cih7ZDplfSk6YS5ncmFwaCYmKGEudHJhY2tlcj1oLnBhdGgoZSkuYXR0cih7dmlzaWJpbGl0eTphLnZpc2libGU/XCJ2aXNpYmxlXCI6XCJoaWRkZW5cIix6SW5kZXg6Mn0pLmFkZENsYXNzKGM/XCJoaWdoY2hhcnRzLXRyYWNrZXItYXJlYVwiOlwiaGlnaGNoYXJ0cy10cmFja2VyLWxpbmVcIikuYWRkKGEuZ3JvdXApLGQuc3R5bGVkTW9kZXx8YS50cmFja2VyLmF0dHIoe1wic3Ryb2tlLWxpbmVjYXBcIjpcInJvdW5kXCIsXCJzdHJva2UtbGluZWpvaW5cIjpcInJvdW5kXCIsc3Ryb2tlOnAsZmlsbDpjP3A6XCJub25lXCIsXCJzdHJva2Utd2lkdGhcIjphLmdyYXBoLnN0cm9rZVdpZHRoKCkrKGM/MDoyKm0pfSksW2EudHJhY2tlcixhLm1hcmtlckdyb3VwXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikub24oXCJtb3VzZW92ZXJcIixuKS5vbihcIm1vdXNlb3V0XCIsXG5mdW5jdGlvbihhKXtmLm9uVHJhY2tlck1vdXNlT3V0KGEpfSk7Yi5jdXJzb3ImJiFkLnN0eWxlZE1vZGUmJmEuY3NzKHtjdXJzb3I6Yi5jdXJzb3J9KTtpZihFKWEub24oXCJ0b3VjaHN0YXJ0XCIsbil9KSk7Sih0aGlzLFwiYWZ0ZXJEcmF3VHJhY2tlclwiKX07ZC5wcm90b3R5cGUuYWRkUG9pbnQ9ZnVuY3Rpb24oYSxiLGMsZSxnKXt2YXIgZD10aGlzLm9wdGlvbnMsZj10aGlzLmRhdGEsaD10aGlzLmNoYXJ0LG09dGhpcy54QXhpczttPW0mJm0uaGFzTmFtZXMmJm0ubmFtZXM7dmFyIGw9ZC5kYXRhLG49dGhpcy54RGF0YSxwO2I9TChiLCEwKTt2YXIgcT17c2VyaWVzOnRoaXN9O3RoaXMucG9pbnRDbGFzcy5wcm90b3R5cGUuYXBwbHlPcHRpb25zLmFwcGx5KHEsW2FdKTt2YXIgcj1xLng7dmFyIGs9bi5sZW5ndGg7aWYodGhpcy5yZXF1aXJlU29ydGluZyYmcjxuW2stMV0pZm9yKHA9ITA7ayYmbltrLTFdPnI7KWstLTt0aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHEsXCJzcGxpY2VcIixrLDAsXG4wKTt0aGlzLnVwZGF0ZVBhcmFsbGVsQXJyYXlzKHEsayk7bSYmcS5uYW1lJiYobVtyXT1xLm5hbWUpO2wuc3BsaWNlKGssMCxhKTtwJiYodGhpcy5kYXRhLnNwbGljZShrLDAsbnVsbCksdGhpcy5wcm9jZXNzRGF0YSgpKTtcInBvaW50XCI9PT1kLmxlZ2VuZFR5cGUmJnRoaXMuZ2VuZXJhdGVQb2ludHMoKTtjJiYoZlswXSYmZlswXS5yZW1vdmU/ZlswXS5yZW1vdmUoITEpOihmLnNoaWZ0KCksdGhpcy51cGRhdGVQYXJhbGxlbEFycmF5cyhxLFwic2hpZnRcIiksbC5zaGlmdCgpKSk7ITEhPT1nJiZKKHRoaXMsXCJhZGRQb2ludFwiLHtwb2ludDpxfSk7dGhpcy5pc0RpcnR5RGF0YT10aGlzLmlzRGlydHk9ITA7YiYmaC5yZWRyYXcoZSl9O2QucHJvdG90eXBlLnJlbW92ZVBvaW50PWZ1bmN0aW9uKGEsYixjKXt2YXIgZT10aGlzLGc9ZS5kYXRhLGQ9Z1thXSxmPWUucG9pbnRzLGg9ZS5jaGFydCxtPWZ1bmN0aW9uKCl7ZiYmZi5sZW5ndGg9PT1nLmxlbmd0aCYmZi5zcGxpY2UoYSwxKTtnLnNwbGljZShhLFxuMSk7ZS5vcHRpb25zLmRhdGEuc3BsaWNlKGEsMSk7ZS51cGRhdGVQYXJhbGxlbEFycmF5cyhkfHx7c2VyaWVzOmV9LFwic3BsaWNlXCIsYSwxKTtkJiZkLmRlc3Ryb3koKTtlLmlzRGlydHk9ITA7ZS5pc0RpcnR5RGF0YT0hMDtiJiZoLnJlZHJhdygpfTtsKGMsaCk7Yj1MKGIsITApO2Q/ZC5maXJlUG9pbnRFdmVudChcInJlbW92ZVwiLG51bGwsbSk6bSgpfTtkLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oYSxiLGMsZSl7ZnVuY3Rpb24gZygpe2QuZGVzdHJveShlKTtmLmlzRGlydHlMZWdlbmQ9Zi5pc0RpcnR5Qm94PSEwO2YubGlua1NlcmllcygpO0woYSwhMCkmJmYucmVkcmF3KGIpfXZhciBkPXRoaXMsZj1kLmNoYXJ0OyExIT09Yz9KKGQsXCJyZW1vdmVcIixudWxsLGcpOmcoKX07ZC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGMsZSl7Yz1tKGMsdGhpcy51c2VyT3B0aW9ucyk7Sih0aGlzLFwidXBkYXRlXCIse29wdGlvbnM6Y30pO3ZhciBnPXRoaXMsZD1nLmNoYXJ0LGY9Zy51c2VyT3B0aW9ucyxcbmg9Zy5pbml0aWFsVHlwZXx8Zy50eXBlLGw9ZC5vcHRpb25zLnBsb3RPcHRpb25zLG49Yy50eXBlfHxmLnR5cGV8fGQub3B0aW9ucy5jaGFydC50eXBlLHA9ISh0aGlzLmhhc0Rlcml2ZWREYXRhfHxuJiZuIT09dGhpcy50eXBlfHxcInVuZGVmaW5lZFwiIT09dHlwZW9mIGMucG9pbnRTdGFydHx8XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBjLnBvaW50SW50ZXJ2YWx8fGcuaGFzT3B0aW9uQ2hhbmdlZChcImRhdGFHcm91cGluZ1wiKXx8Zy5oYXNPcHRpb25DaGFuZ2VkKFwicG9pbnRTdGFydFwiKXx8Zy5oYXNPcHRpb25DaGFuZ2VkKFwicG9pbnRJbnRlcnZhbFwiKXx8Zy5oYXNPcHRpb25DaGFuZ2VkKFwicG9pbnRJbnRlcnZhbFVuaXRcIil8fGcuaGFzT3B0aW9uQ2hhbmdlZChcImtleXNcIikpLHI9cVtoXS5wcm90b3R5cGUsayx3PVtcImV2ZW50T3B0aW9uc1wiLFwibmF2aWdhdG9yU2VyaWVzXCIsXCJiYXNlU2VyaWVzXCJdLHU9Zy5maW5pc2hlZEFuaW1hdGluZyYme2FuaW1hdGlvbjohMX0seT17fTtwJiYody5wdXNoKFwiZGF0YVwiLFxuXCJpc0RpcnR5RGF0YVwiLFwicG9pbnRzXCIsXCJwcm9jZXNzZWRYRGF0YVwiLFwicHJvY2Vzc2VkWURhdGFcIixcInhJbmNyZW1lbnRcIixcImNyb3BwZWRcIixcIl9oYXNQb2ludE1hcmtlcnNcIixcIl9oYXNQb2ludExhYmVsc1wiLFwibm9kZXNcIixcImxheW91dFwiLFwibWFwTWFwXCIsXCJtYXBEYXRhXCIsXCJtaW5ZXCIsXCJtYXhZXCIsXCJtaW5YXCIsXCJtYXhYXCIpLCExIT09Yy52aXNpYmxlJiZ3LnB1c2goXCJhcmVhXCIsXCJncmFwaFwiKSxnLnBhcmFsbGVsQXJyYXlzLmZvckVhY2goZnVuY3Rpb24oYSl7dy5wdXNoKGErXCJEYXRhXCIpfSksYy5kYXRhJiYoYy5kYXRhU29ydGluZyYmYihnLm9wdGlvbnMuZGF0YVNvcnRpbmcsYy5kYXRhU29ydGluZyksdGhpcy5zZXREYXRhKGMuZGF0YSwhMSkpKTtjPVQoZix1LHtpbmRleDpcInVuZGVmaW5lZFwiPT09dHlwZW9mIGYuaW5kZXg/Zy5pbmRleDpmLmluZGV4LHBvaW50U3RhcnQ6TChsJiZsLnNlcmllcyYmbC5zZXJpZXMucG9pbnRTdGFydCxmLnBvaW50U3RhcnQsZy54RGF0YVswXSl9LCFwJiZcbntkYXRhOmcub3B0aW9ucy5kYXRhfSxjKTtwJiZjLmRhdGEmJihjLmRhdGE9Zy5vcHRpb25zLmRhdGEpO3c9W1wiZ3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIixcInRyYW5zZm9ybUdyb3VwXCJdLmNvbmNhdCh3KTt3LmZvckVhY2goZnVuY3Rpb24oYSl7d1thXT1nW2FdO2RlbGV0ZSBnW2FdfSk7aWYocVtufHxoXSl7aWYoZj1uIT09Zy50eXBlLGcucmVtb3ZlKCExLCExLCExLCEwKSxmKWlmKE9iamVjdC5zZXRQcm90b3R5cGVPZilPYmplY3Quc2V0UHJvdG90eXBlT2YoZyxxW258fGhdLnByb3RvdHlwZSk7ZWxzZXtmPU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGcsXCJoY0V2ZW50c1wiKSYmZy5oY0V2ZW50cztmb3IoayBpbiByKWdba109dm9pZCAwO2IoZyxxW258fGhdLnByb3RvdHlwZSk7Zj9nLmhjRXZlbnRzPWY6ZGVsZXRlIGcuaGNFdmVudHN9fWVsc2UgYSgxNywhMCxkLHttaXNzaW5nTW9kdWxlRm9yOm58fGh9KTt3LmZvckVhY2goZnVuY3Rpb24oYSl7Z1thXT1cbndbYV19KTtnLmluaXQoZCxjKTtpZihwJiZ0aGlzLnBvaW50cyl7dmFyIHQ9Zy5vcHRpb25zOyExPT09dC52aXNpYmxlPyh5LmdyYXBoaWM9MSx5LmRhdGFMYWJlbD0xKTpnLl9oYXNQb2ludExhYmVsc3x8KGM9dC5tYXJrZXIsbj10LmRhdGFMYWJlbHMsYyYmKCExPT09Yy5lbmFibGVkfHxcInN5bWJvbFwiaW4gYykmJih5LmdyYXBoaWM9MSksbiYmITE9PT1uLmVuYWJsZWQmJih5LmRhdGFMYWJlbD0xKSk7dGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihhKXthJiZhLnNlcmllcyYmKGEucmVzb2x2ZUNvbG9yKCksT2JqZWN0LmtleXMoeSkubGVuZ3RoJiZhLmRlc3Ryb3lFbGVtZW50cyh5KSwhMT09PXQuc2hvd0luTGVnZW5kJiZhLmxlZ2VuZEl0ZW0mJmQubGVnZW5kLmRlc3Ryb3lJdGVtKGEpKX0sdGhpcyl9Zy5pbml0aWFsVHlwZT1oO2QubGlua1NlcmllcygpO0oodGhpcyxcImFmdGVyVXBkYXRlXCIpO0woZSwhMCkmJmQucmVkcmF3KHA/dm9pZCAwOiExKX07ZC5wcm90b3R5cGUuc2V0TmFtZT1cbmZ1bmN0aW9uKGEpe3RoaXMubmFtZT10aGlzLm9wdGlvbnMubmFtZT10aGlzLnVzZXJPcHRpb25zLm5hbWU9YTt0aGlzLmNoYXJ0LmlzRGlydHlMZWdlbmQ9ITB9O2QucHJvdG90eXBlLmhhc09wdGlvbkNoYW5nZWQ9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5vcHRpb25zW2FdLGM9dGhpcy5jaGFydC5vcHRpb25zLnBsb3RPcHRpb25zLGU9dGhpcy51c2VyT3B0aW9uc1thXTtyZXR1cm4gZT9iIT09ZTpiIT09TChjJiZjW3RoaXMudHlwZV0mJmNbdGhpcy50eXBlXVthXSxjJiZjLnNlcmllcyYmYy5zZXJpZXNbYV0sYil9O2QucHJvdG90eXBlLm9uTW91c2VPdmVyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydCxiPWEuaG92ZXJTZXJpZXM7YS5wb2ludGVyLnNldEhvdmVyQ2hhcnRJbmRleCgpO2lmKGImJmIhPT10aGlzKWIub25Nb3VzZU91dCgpO3RoaXMub3B0aW9ucy5ldmVudHMubW91c2VPdmVyJiZKKHRoaXMsXCJtb3VzZU92ZXJcIik7dGhpcy5zZXRTdGF0ZShcImhvdmVyXCIpO2EuaG92ZXJTZXJpZXM9XG50aGlzfTtkLnByb3RvdHlwZS5vbk1vdXNlT3V0PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9dGhpcy5jaGFydCxjPWIudG9vbHRpcCxlPWIuaG92ZXJQb2ludDtiLmhvdmVyU2VyaWVzPW51bGw7aWYoZSllLm9uTW91c2VPdXQoKTt0aGlzJiZhLmV2ZW50cy5tb3VzZU91dCYmSih0aGlzLFwibW91c2VPdXRcIik7IWN8fHRoaXMuc3RpY2t5VHJhY2tpbmd8fGMuc2hhcmVkJiYhdGhpcy5ub1NoYXJlZFRvb2x0aXB8fGMuaGlkZSgpO2Iuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYSl7YS5zZXRTdGF0ZShcIlwiLCEwKX0pfTtkLnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMsZT1jLm9wdGlvbnMsZz1jLmdyYXBoLGQ9ZS5pbmFjdGl2ZU90aGVyUG9pbnRzLGY9ZS5zdGF0ZXMsaD1lLmxpbmVXaWR0aCxtPWUub3BhY2l0eSxsPUwoZlthfHxcIm5vcm1hbFwiXSYmZlthfHxcIm5vcm1hbFwiXS5hbmltYXRpb24sYy5jaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbik7XG5lPTA7YT1hfHxcIlwiO2lmKGMuc3RhdGUhPT1hJiYoW2MuZ3JvdXAsYy5tYXJrZXJHcm91cCxjLmRhdGFMYWJlbHNHcm91cF0uZm9yRWFjaChmdW5jdGlvbihiKXtiJiYoYy5zdGF0ZSYmYi5yZW1vdmVDbGFzcyhcImhpZ2hjaGFydHMtc2VyaWVzLVwiK2Muc3RhdGUpLGEmJmIuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNlcmllcy1cIithKSl9KSxjLnN0YXRlPWEsIWMuY2hhcnQuc3R5bGVkTW9kZSkpe2lmKGZbYV0mJiExPT09ZlthXS5lbmFibGVkKXJldHVybjthJiYoaD1mW2FdLmxpbmVXaWR0aHx8aCsoZlthXS5saW5lV2lkdGhQbHVzfHwwKSxtPUwoZlthXS5vcGFjaXR5LG0pKTtpZihnJiYhZy5kYXNoc3R5bGUpZm9yKGY9e1wic3Ryb2tlLXdpZHRoXCI6aH0sZy5hbmltYXRlKGYsbCk7Y1tcInpvbmUtZ3JhcGgtXCIrZV07KWNbXCJ6b25lLWdyYXBoLVwiK2VdLmFuaW1hdGUoZixsKSxlKz0xO2R8fFtjLmdyb3VwLGMubWFya2VyR3JvdXAsYy5kYXRhTGFiZWxzR3JvdXAsYy5sYWJlbEJ5U2VyaWVzXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EmJlxuYS5hbmltYXRlKHtvcGFjaXR5Om19LGwpfSl9YiYmZCYmYy5wb2ludHMmJmMuc2V0QWxsUG9pbnRzVG9TdGF0ZShhfHx2b2lkIDApfTtkLnByb3RvdHlwZS5zZXRBbGxQb2ludHNUb1N0YXRlPWZ1bmN0aW9uKGEpe3RoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24oYil7Yi5zZXRTdGF0ZSYmYi5zZXRTdGF0ZShhKX0pfTtkLnByb3RvdHlwZS5zZXRWaXNpYmxlPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcyxlPWMuY2hhcnQsZz1jLmxlZ2VuZEl0ZW0sZD1lLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzLGY9Yy52aXNpYmxlO3ZhciBoPShjLnZpc2libGU9YT1jLm9wdGlvbnMudmlzaWJsZT1jLnVzZXJPcHRpb25zLnZpc2libGU9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhPyFmOmEpP1wic2hvd1wiOlwiaGlkZVwiO1tcImdyb3VwXCIsXCJkYXRhTGFiZWxzR3JvdXBcIixcIm1hcmtlckdyb3VwXCIsXCJ0cmFja2VyXCIsXCJ0dFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2lmKGNbYV0pY1thXVtoXSgpfSk7XG5pZihlLmhvdmVyU2VyaWVzPT09Y3x8KGUuaG92ZXJQb2ludCYmZS5ob3ZlclBvaW50LnNlcmllcyk9PT1jKWMub25Nb3VzZU91dCgpO2cmJmUubGVnZW5kLmNvbG9yaXplSXRlbShjLGEpO2MuaXNEaXJ0eT0hMDtjLm9wdGlvbnMuc3RhY2tpbmcmJmUuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYSl7YS5vcHRpb25zLnN0YWNraW5nJiZhLnZpc2libGUmJihhLmlzRGlydHk9ITApfSk7Yy5saW5rZWRTZXJpZXMuZm9yRWFjaChmdW5jdGlvbihiKXtiLnNldFZpc2libGUoYSwhMSl9KTtkJiYoZS5pc0RpcnR5Qm94PSEwKTtKKGMsaCk7ITEhPT1iJiZlLnJlZHJhdygpfTtkLnByb3RvdHlwZS5zaG93PWZ1bmN0aW9uKCl7dGhpcy5zZXRWaXNpYmxlKCEwKX07ZC5wcm90b3R5cGUuaGlkZT1mdW5jdGlvbigpe3RoaXMuc2V0VmlzaWJsZSghMSl9O2QucHJvdG90eXBlLnNlbGVjdD1mdW5jdGlvbihhKXt0aGlzLnNlbGVjdGVkPWE9dGhpcy5vcHRpb25zLnNlbGVjdGVkPVwidW5kZWZpbmVkXCI9PT1cbnR5cGVvZiBhPyF0aGlzLnNlbGVjdGVkOmE7dGhpcy5jaGVja2JveCYmKHRoaXMuY2hlY2tib3guY2hlY2tlZD1hKTtKKHRoaXMsYT9cInNlbGVjdFwiOlwidW5zZWxlY3RcIil9O2QuZGVmYXVsdE9wdGlvbnM9e2xpbmVXaWR0aDoyLGFsbG93UG9pbnRTZWxlY3Q6ITEsY3Jpc3A6ITAsc2hvd0NoZWNrYm94OiExLGFuaW1hdGlvbjp7ZHVyYXRpb246MUUzfSxldmVudHM6e30sbWFya2VyOntlbmFibGVkVGhyZXNob2xkOjIsbGluZUNvbG9yOkIuYmFja2dyb3VuZENvbG9yLGxpbmVXaWR0aDowLHJhZGl1czo0LHN0YXRlczp7bm9ybWFsOnthbmltYXRpb246ITB9LGhvdmVyOnthbmltYXRpb246e2R1cmF0aW9uOjUwfSxlbmFibGVkOiEwLHJhZGl1c1BsdXM6MixsaW5lV2lkdGhQbHVzOjF9LHNlbGVjdDp7ZmlsbENvbG9yOkIubmV1dHJhbENvbG9yMjAsbGluZUNvbG9yOkIubmV1dHJhbENvbG9yMTAwLGxpbmVXaWR0aDoyfX19LHBvaW50OntldmVudHM6e319LGRhdGFMYWJlbHM6e2FuaW1hdGlvbjp7fSxcbmFsaWduOlwiY2VudGVyXCIsZGVmZXI6ITAsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5zZXJpZXMuY2hhcnQubnVtYmVyRm9ybWF0dGVyO3JldHVyblwibnVtYmVyXCIhPT10eXBlb2YgdGhpcy55P1wiXCI6YSh0aGlzLnksLTEpfSxwYWRkaW5nOjUsc3R5bGU6e2ZvbnRTaXplOlwiMTFweFwiLGZvbnRXZWlnaHQ6XCJib2xkXCIsY29sb3I6XCJjb250cmFzdFwiLHRleHRPdXRsaW5lOlwiMXB4IGNvbnRyYXN0XCJ9LHZlcnRpY2FsQWxpZ246XCJib3R0b21cIix4OjAseTowfSxjcm9wVGhyZXNob2xkOjMwMCxvcGFjaXR5OjEscG9pbnRSYW5nZTowLHNvZnRUaHJlc2hvbGQ6ITAsc3RhdGVzOntub3JtYWw6e2FuaW1hdGlvbjohMH0saG92ZXI6e2FuaW1hdGlvbjp7ZHVyYXRpb246NTB9LGxpbmVXaWR0aFBsdXM6MSxtYXJrZXI6e30saGFsbzp7c2l6ZToxMCxvcGFjaXR5Oi4yNX19LHNlbGVjdDp7YW5pbWF0aW9uOntkdXJhdGlvbjowfX0saW5hY3RpdmU6e2FuaW1hdGlvbjp7ZHVyYXRpb246NTB9LG9wYWNpdHk6LjJ9fSxcbnN0aWNreVRyYWNraW5nOiEwLHR1cmJvVGhyZXNob2xkOjFFMyxmaW5kTmVhcmVzdFBvaW50Qnk6XCJ4XCJ9O3JldHVybiBkfSgpO2IoZi5wcm90b3R5cGUse2F4aXNUeXBlczpbXCJ4QXhpc1wiLFwieUF4aXNcIl0sY29sbDpcInNlcmllc1wiLGNvbG9yQ291bnRlcjowLGNyb3BTaG91bGRlcjoxLGRpcmVjdFRvdWNoOiExLGRyYXdMZWdlbmRTeW1ib2w6ay5kcmF3TGluZU1hcmtlcixpc0NhcnRlc2lhbjohMCxrZEF4aXNBcnJheTpbXCJjbGllbnRYXCIsXCJwbG90WVwiXSxwYXJhbGxlbEFycmF5czpbXCJ4XCIsXCJ5XCJdLHBvaW50Q2xhc3M6RyxyZXF1aXJlU29ydGluZzohMCxzb3J0ZWQ6ITB9KTtELnNlcmllcz1mO1wiXCI7XCJcIjtyZXR1cm4gZn0pO1AoayxcIkV4dGVuc2lvbnMvU2Nyb2xsYWJsZVBsb3RBcmVhLmpzXCIsW2tbXCJDb3JlL0FuaW1hdGlvbi9BbmltYXRpb25VdGlsaXRpZXMuanNcIl0sa1tcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLGtbXCJDb3JlL0NoYXJ0L0NoYXJ0LmpzXCJdLGtbXCJDb3JlL1Nlcmllcy9TZXJpZXMuanNcIl0sXG5rW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCxCLEcpe3ZhciBEPWYuc3RvcCxIPUcuYWRkRXZlbnQsdD1HLmNyZWF0ZUVsZW1lbnQsQz1HLm1lcmdlLGw9Ry5waWNrO1wiXCI7SChrLFwiYWZ0ZXJTZXRDaGFydFNpemVcIixmdW5jdGlvbihkKXt2YXIgZz10aGlzLm9wdGlvbnMuY2hhcnQuc2Nyb2xsYWJsZVBsb3RBcmVhLGY9ZyYmZy5taW5XaWR0aDtnPWcmJmcubWluSGVpZ2h0O2lmKCF0aGlzLnJlbmRlcmVyLmZvckV4cG9ydCl7aWYoZil7aWYodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWD1mPU1hdGgubWF4KDAsZi10aGlzLmNoYXJ0V2lkdGgpKXt0aGlzLnNjcm9sbGFibGVQbG90Qm94PUModGhpcy5wbG90Qm94KTt0aGlzLnBsb3RXaWR0aCs9Zjt0aGlzLmludmVydGVkPyh0aGlzLmNsaXBCb3guaGVpZ2h0Kz1mLHRoaXMucGxvdEJveC5oZWlnaHQrPWYpOih0aGlzLmNsaXBCb3gud2lkdGgrPWYsdGhpcy5wbG90Qm94LndpZHRoKz1cbmYpO3ZhciBjPXsxOntuYW1lOlwicmlnaHRcIix2YWx1ZTpmfX19fWVsc2UgZyYmKHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1k9Zj1NYXRoLm1heCgwLGctdGhpcy5jaGFydEhlaWdodCkpJiYodGhpcy5zY3JvbGxhYmxlUGxvdEJveD1DKHRoaXMucGxvdEJveCksdGhpcy5wbG90SGVpZ2h0Kz1mLHRoaXMuaW52ZXJ0ZWQ/KHRoaXMuY2xpcEJveC53aWR0aCs9Zix0aGlzLnBsb3RCb3gud2lkdGgrPWYpOih0aGlzLmNsaXBCb3guaGVpZ2h0Kz1mLHRoaXMucGxvdEJveC5oZWlnaHQrPWYpLGM9ezI6e25hbWU6XCJib3R0b21cIix2YWx1ZTpmfX0pO2MmJiFkLnNraXBBeGVzJiZ0aGlzLmF4ZXMuZm9yRWFjaChmdW5jdGlvbihnKXtjW2cuc2lkZV0/Zy5nZXRQbG90TGluZVBhdGg9ZnVuY3Rpb24oKXt2YXIgZD1jW2cuc2lkZV0ubmFtZSxmPXRoaXNbZF07dGhpc1tkXT1mLWNbZy5zaWRlXS52YWx1ZTt2YXIgbD1CLkF4aXMucHJvdG90eXBlLmdldFBsb3RMaW5lUGF0aC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XG50aGlzW2RdPWY7cmV0dXJuIGx9OihnLnNldEF4aXNTaXplKCksZy5zZXRBeGlzVHJhbnNsYXRpb24oKSl9KX19KTtIKGssXCJyZW5kZXJcIixmdW5jdGlvbigpe3RoaXMuc2Nyb2xsYWJsZVBpeGVsc1h8fHRoaXMuc2Nyb2xsYWJsZVBpeGVsc1k/KHRoaXMuc2V0VXBTY3JvbGxpbmcmJnRoaXMuc2V0VXBTY3JvbGxpbmcoKSx0aGlzLmFwcGx5Rml4ZWQoKSk6dGhpcy5maXhlZERpdiYmdGhpcy5hcHBseUZpeGVkKCl9KTtrLnByb3RvdHlwZS5zZXRVcFNjcm9sbGluZz1mdW5jdGlvbigpe3ZhciBkPXRoaXMsZz17V2Via2l0T3ZlcmZsb3dTY3JvbGxpbmc6XCJ0b3VjaFwiLG92ZXJmbG93WDpcImhpZGRlblwiLG92ZXJmbG93WTpcImhpZGRlblwifTt0aGlzLnNjcm9sbGFibGVQaXhlbHNYJiYoZy5vdmVyZmxvd1g9XCJhdXRvXCIpO3RoaXMuc2Nyb2xsYWJsZVBpeGVsc1kmJihnLm92ZXJmbG93WT1cImF1dG9cIik7dGhpcy5zY3JvbGxpbmdQYXJlbnQ9dChcImRpdlwiLHtjbGFzc05hbWU6XCJoaWdoY2hhcnRzLXNjcm9sbGluZy1wYXJlbnRcIn0sXG57cG9zaXRpb246XCJyZWxhdGl2ZVwifSx0aGlzLnJlbmRlclRvKTt0aGlzLnNjcm9sbGluZ0NvbnRhaW5lcj10KFwiZGl2XCIse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtc2Nyb2xsaW5nXCJ9LGcsdGhpcy5zY3JvbGxpbmdQYXJlbnQpO0godGhpcy5zY3JvbGxpbmdDb250YWluZXIsXCJzY3JvbGxcIixmdW5jdGlvbigpe2QucG9pbnRlciYmZGVsZXRlIGQucG9pbnRlci5jaGFydFBvc2l0aW9ufSk7dGhpcy5pbm5lckNvbnRhaW5lcj10KFwiZGl2XCIse2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtaW5uZXItY29udGFpbmVyXCJ9LG51bGwsdGhpcy5zY3JvbGxpbmdDb250YWluZXIpO3RoaXMuaW5uZXJDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5jb250YWluZXIpO3RoaXMuc2V0VXBTY3JvbGxpbmc9bnVsbH07ay5wcm90b3R5cGUubW92ZUZpeGVkRWxlbWVudHM9ZnVuY3Rpb24oKXt2YXIgZD10aGlzLmNvbnRhaW5lcixnPXRoaXMuZml4ZWRSZW5kZXJlcixmPVwiLmhpZ2hjaGFydHMtY29udGV4dGJ1dHRvbiAuaGlnaGNoYXJ0cy1jcmVkaXRzIC5oaWdoY2hhcnRzLWxlZ2VuZCAuaGlnaGNoYXJ0cy1sZWdlbmQtY2hlY2tib3ggLmhpZ2hjaGFydHMtbmF2aWdhdG9yLXNlcmllcyAuaGlnaGNoYXJ0cy1uYXZpZ2F0b3IteGF4aXMgLmhpZ2hjaGFydHMtbmF2aWdhdG9yLXlheGlzIC5oaWdoY2hhcnRzLW5hdmlnYXRvciAuaGlnaGNoYXJ0cy1yZXNldC16b29tIC5oaWdoY2hhcnRzLXNjcm9sbGJhciAuaGlnaGNoYXJ0cy1zdWJ0aXRsZSAuaGlnaGNoYXJ0cy10aXRsZVwiLnNwbGl0KFwiIFwiKSxcbmM7dGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCYmIXRoaXMuaW52ZXJ0ZWQ/Yz1cIi5oaWdoY2hhcnRzLXlheGlzXCI6dGhpcy5zY3JvbGxhYmxlUGl4ZWxzWCYmdGhpcy5pbnZlcnRlZD9jPVwiLmhpZ2hjaGFydHMteGF4aXNcIjp0aGlzLnNjcm9sbGFibGVQaXhlbHNZJiYhdGhpcy5pbnZlcnRlZD9jPVwiLmhpZ2hjaGFydHMteGF4aXNcIjp0aGlzLnNjcm9sbGFibGVQaXhlbHNZJiZ0aGlzLmludmVydGVkJiYoYz1cIi5oaWdoY2hhcnRzLXlheGlzXCIpO2MmJmYucHVzaChjK1wiOm5vdCguaGlnaGNoYXJ0cy1yYWRpYWwtYXhpcylcIixjK1wiLWxhYmVsczpub3QoLmhpZ2hjaGFydHMtcmFkaWFsLWF4aXMtbGFiZWxzKVwiKTtmLmZvckVhY2goZnVuY3Rpb24oYyl7W10uZm9yRWFjaC5jYWxsKGQucXVlcnlTZWxlY3RvckFsbChjKSxmdW5jdGlvbihjKXsoYy5uYW1lc3BhY2VVUkk9PT1nLlNWR19OUz9nLmJveDpnLmJveC5wYXJlbnROb2RlKS5hcHBlbmRDaGlsZChjKTtjLnN0eWxlLnBvaW50ZXJFdmVudHM9XCJhdXRvXCJ9KX0pfTtcbmsucHJvdG90eXBlLmFwcGx5Rml4ZWQ9ZnVuY3Rpb24oKXt2YXIgZj10aGlzLGcsayxjLHE9IXRoaXMuZml4ZWREaXYsbj10aGlzLm9wdGlvbnMuY2hhcnQsQT1uLnNjcm9sbGFibGVQbG90QXJlYTtxPyh0aGlzLmZpeGVkRGl2PXQoXCJkaXZcIix7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1maXhlZFwifSx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLG92ZXJmbG93OlwiaGlkZGVuXCIscG9pbnRlckV2ZW50czpcIm5vbmVcIix6SW5kZXg6KChudWxsPT09KGc9bi5zdHlsZSl8fHZvaWQgMD09PWc/dm9pZCAwOmcuekluZGV4KXx8MCkrMix0b3A6MH0sbnVsbCwhMCksbnVsbD09PShrPXRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyKXx8dm9pZCAwPT09az92b2lkIDA6ay5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLmZpeGVkRGl2LHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyKSx0aGlzLnJlbmRlclRvLnN0eWxlLm92ZXJmbG93PVwidmlzaWJsZVwiLHRoaXMuZml4ZWRSZW5kZXJlcj1nPW5ldyBCLlJlbmRlcmVyKHRoaXMuZml4ZWREaXYsXG50aGlzLmNoYXJ0V2lkdGgsdGhpcy5jaGFydEhlaWdodCxudWxsPT09KGM9dGhpcy5vcHRpb25zLmNoYXJ0KXx8dm9pZCAwPT09Yz92b2lkIDA6Yy5zdHlsZSksdGhpcy5zY3JvbGxhYmxlTWFzaz1nLnBhdGgoKS5hdHRyKHtmaWxsOnRoaXMub3B0aW9ucy5jaGFydC5iYWNrZ3JvdW5kQ29sb3J8fFwiI2ZmZlwiLFwiZmlsbC1vcGFjaXR5XCI6bChBLm9wYWNpdHksLjg1KSx6SW5kZXg6LTF9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2Nyb2xsYWJsZS1tYXNrXCIpLmFkZCgpLEgodGhpcyxcImFmdGVyU2hvd1Jlc2V0Wm9vbVwiLHRoaXMubW92ZUZpeGVkRWxlbWVudHMpLEgodGhpcyxcImFmdGVyTGF5T3V0VGl0bGVzXCIsdGhpcy5tb3ZlRml4ZWRFbGVtZW50cyksSChkLFwiYWZ0ZXJJbml0XCIsZnVuY3Rpb24oKXtmLnNjcm9sbGFibGVEaXJ0eT0hMH0pLEgoeCxcInNob3dcIixmdW5jdGlvbigpe2Yuc2Nyb2xsYWJsZURpcnR5PSEwfSkpOnRoaXMuZml4ZWRSZW5kZXJlci5zZXRTaXplKHRoaXMuY2hhcnRXaWR0aCxcbnRoaXMuY2hhcnRIZWlnaHQpO2lmKHRoaXMuc2Nyb2xsYWJsZURpcnR5fHxxKXRoaXMuc2Nyb2xsYWJsZURpcnR5PSExLHRoaXMubW92ZUZpeGVkRWxlbWVudHMoKTtjPXRoaXMuY2hhcnRXaWR0aCsodGhpcy5zY3JvbGxhYmxlUGl4ZWxzWHx8MCk7Zz10aGlzLmNoYXJ0SGVpZ2h0Kyh0aGlzLnNjcm9sbGFibGVQaXhlbHNZfHwwKTtEKHRoaXMuY29udGFpbmVyKTt0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aD1jK1wicHhcIjt0aGlzLmNvbnRhaW5lci5zdHlsZS5oZWlnaHQ9ZytcInB4XCI7dGhpcy5yZW5kZXJlci5ib3hXcmFwcGVyLmF0dHIoe3dpZHRoOmMsaGVpZ2h0Omcsdmlld0JveDpbMCwwLGMsZ10uam9pbihcIiBcIil9KTt0aGlzLmNoYXJ0QmFja2dyb3VuZC5hdHRyKHt3aWR0aDpjLGhlaWdodDpnfSk7dGhpcy5zY3JvbGxpbmdDb250YWluZXIuc3R5bGUuaGVpZ2h0PXRoaXMuY2hhcnRIZWlnaHQrXCJweFwiO3EmJihBLnNjcm9sbFBvc2l0aW9uWCYmKHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbExlZnQ9XG50aGlzLnNjcm9sbGFibGVQaXhlbHNYKkEuc2Nyb2xsUG9zaXRpb25YKSxBLnNjcm9sbFBvc2l0aW9uWSYmKHRoaXMuc2Nyb2xsaW5nQ29udGFpbmVyLnNjcm9sbFRvcD10aGlzLnNjcm9sbGFibGVQaXhlbHNZKkEuc2Nyb2xsUG9zaXRpb25ZKSk7Zz10aGlzLmF4aXNPZmZzZXQ7cT10aGlzLnBsb3RUb3AtZ1swXS0xO0E9dGhpcy5wbG90TGVmdC1nWzNdLTE7Yz10aGlzLnBsb3RUb3ArdGhpcy5wbG90SGVpZ2h0K2dbMl0rMTtnPXRoaXMucGxvdExlZnQrdGhpcy5wbG90V2lkdGgrZ1sxXSsxO2s9dGhpcy5wbG90TGVmdCt0aGlzLnBsb3RXaWR0aC0odGhpcy5zY3JvbGxhYmxlUGl4ZWxzWHx8MCk7bj10aGlzLnBsb3RUb3ArdGhpcy5wbG90SGVpZ2h0LSh0aGlzLnNjcm9sbGFibGVQaXhlbHNZfHwwKTtxPXRoaXMuc2Nyb2xsYWJsZVBpeGVsc1g/W1tcIk1cIiwwLHFdLFtcIkxcIix0aGlzLnBsb3RMZWZ0LTEscV0sW1wiTFwiLHRoaXMucGxvdExlZnQtMSxjXSxbXCJMXCIsMCxjXSxbXCJaXCJdLFtcIk1cIixcbmsscV0sW1wiTFwiLHRoaXMuY2hhcnRXaWR0aCxxXSxbXCJMXCIsdGhpcy5jaGFydFdpZHRoLGNdLFtcIkxcIixrLGNdLFtcIlpcIl1dOnRoaXMuc2Nyb2xsYWJsZVBpeGVsc1k/W1tcIk1cIixBLDBdLFtcIkxcIixBLHRoaXMucGxvdFRvcC0xXSxbXCJMXCIsZyx0aGlzLnBsb3RUb3AtMV0sW1wiTFwiLGcsMF0sW1wiWlwiXSxbXCJNXCIsQSxuXSxbXCJMXCIsQSx0aGlzLmNoYXJ0SGVpZ2h0XSxbXCJMXCIsZyx0aGlzLmNoYXJ0SGVpZ2h0XSxbXCJMXCIsZyxuXSxbXCJaXCJdXTpbW1wiTVwiLDAsMF1dO1wiYWRqdXN0SGVpZ2h0XCIhPT10aGlzLnJlZHJhd1RyaWdnZXImJnRoaXMuc2Nyb2xsYWJsZU1hc2suYXR0cih7ZDpxfSl9fSk7UChrLFwiQ29yZS9BeGlzL1N0YWNraW5nQXhpcy5qc1wiLFtrW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkKXt2YXIgaz1mLmdldERlZmVycmVkQW5pbWF0aW9uLHg9ZC5hZGRFdmVudCxCPWQuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsXG5HPWQuZmlyZUV2ZW50LEQ9ZC5vYmplY3RFYWNoLEg9ZC5waWNrLHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBkKGQpe3RoaXMub2xkU3RhY2tzPXt9O3RoaXMuc3RhY2tzPXt9O3RoaXMuc3RhY2tzVG91Y2hlZD0wO3RoaXMuYXhpcz1kfWQucHJvdG90eXBlLmJ1aWxkU3RhY2tzPWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5heGlzLGY9ZC5zZXJpZXMsZz1IKGQub3B0aW9ucy5yZXZlcnNlZFN0YWNrcywhMCksaz1mLmxlbmd0aCxjO2lmKCFkLmlzWEF4aXMpe3RoaXMudXNlUGVyY2VudGFnZT0hMTtmb3IoYz1rO2MtLTspe3ZhciBxPWZbZz9jOmstYy0xXTtxLnNldFN0YWNrZWRQb2ludHMoKTtxLnNldEdyb3VwZWRQb2ludHMoKX1mb3IoYz0wO2M8aztjKyspZltjXS5tb2RpZnlTdGFja3MoKTtHKGQsXCJhZnRlckJ1aWxkU3RhY2tzXCIpfX07ZC5wcm90b3R5cGUuY2xlYW5TdGFja3M9ZnVuY3Rpb24oKXtpZighdGhpcy5heGlzLmlzWEF4aXMpe2lmKHRoaXMub2xkU3RhY2tzKXZhciBkPXRoaXMuc3RhY2tzPVxudGhpcy5vbGRTdGFja3M7RChkLGZ1bmN0aW9uKGQpe0QoZCxmdW5jdGlvbihnKXtnLmN1bXVsYXRpdmU9Zy50b3RhbH0pfSl9fTtkLnByb3RvdHlwZS5yZXNldFN0YWNrcz1mdW5jdGlvbigpe3ZhciBkPXRoaXMsZj1kLnN0YWNrcztkLmF4aXMuaXNYQXhpc3x8RChmLGZ1bmN0aW9uKGcpe0QoZyxmdW5jdGlvbihmLGMpe2YudG91Y2hlZDxkLnN0YWNrc1RvdWNoZWQ/KGYuZGVzdHJveSgpLGRlbGV0ZSBnW2NdKTooZi50b3RhbD1udWxsLGYuY3VtdWxhdGl2ZT1udWxsKX0pfSl9O2QucHJvdG90eXBlLnJlbmRlclN0YWNrVG90YWxzPWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5heGlzLGY9ZC5jaGFydCxnPWYucmVuZGVyZXIsdD10aGlzLnN0YWNrcztkPWsoZixkLm9wdGlvbnMuc3RhY2tMYWJlbHMuYW5pbWF0aW9uKTt2YXIgYz10aGlzLnN0YWNrVG90YWxHcm91cD10aGlzLnN0YWNrVG90YWxHcm91cHx8Zy5nKFwic3RhY2stbGFiZWxzXCIpLmF0dHIoe3Zpc2liaWxpdHk6XCJ2aXNpYmxlXCIsekluZGV4OjYsXG5vcGFjaXR5OjB9KS5hZGQoKTtjLnRyYW5zbGF0ZShmLnBsb3RMZWZ0LGYucGxvdFRvcCk7RCh0LGZ1bmN0aW9uKGcpe0QoZyxmdW5jdGlvbihnKXtnLnJlbmRlcihjKX0pfSk7Yy5hbmltYXRlKHtvcGFjaXR5OjF9LGQpfTtyZXR1cm4gZH0oKTtyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBkKCl7fWQuY29tcG9zZT1mdW5jdGlvbihmKXt4KGYsXCJpbml0XCIsZC5vbkluaXQpO3goZixcImRlc3Ryb3lcIixkLm9uRGVzdHJveSl9O2Qub25EZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5zdGFja2luZztpZihkKXt2YXIgZj1kLnN0YWNrcztEKGYsZnVuY3Rpb24oZyxkKXtCKGcpO2ZbZF09bnVsbH0pO2QmJmQuc3RhY2tUb3RhbEdyb3VwJiZkLnN0YWNrVG90YWxHcm91cC5kZXN0cm95KCl9fTtkLm9uSW5pdD1mdW5jdGlvbigpe3RoaXMuc3RhY2tpbmd8fCh0aGlzLnN0YWNraW5nPW5ldyB0KHRoaXMpKX07cmV0dXJuIGR9KCl9KTtQKGssXCJFeHRlbnNpb25zL1N0YWNraW5nLmpzXCIsW2tbXCJDb3JlL0F4aXMvQXhpcy5qc1wiXSxcbmtbXCJDb3JlL0NoYXJ0L0NoYXJ0LmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1Nlcmllcy5qc1wiXSxrW1wiQ29yZS9BeGlzL1N0YWNraW5nQXhpcy5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGYsZCxrLHgsQixHKXt2YXIgRD1HLmNvcnJlY3RGbG9hdCxIPUcuZGVmaW5lZCx0PUcuZGVzdHJveU9iamVjdFByb3BlcnRpZXMsQz1HLmZvcm1hdCxsPUcuaXNBcnJheSxFPUcuaXNOdW1iZXIsZz1HLnBpY2s7XCJcIjt2YXIgeT1mdW5jdGlvbigpe2Z1bmN0aW9uIGMoYyxnLGQsZixsKXt2YXIgbT1jLmNoYXJ0LmludmVydGVkO3RoaXMuYXhpcz1jO3RoaXMuaXNOZWdhdGl2ZT1kO3RoaXMub3B0aW9ucz1nPWd8fHt9O3RoaXMueD1mO3RoaXMudG90YWw9bnVsbDt0aGlzLnBvaW50cz17fTt0aGlzLmhhc1ZhbGlkUG9pbnRzPSExO3RoaXMuc3RhY2s9bDt0aGlzLnJpZ2h0Q2xpZmY9dGhpcy5sZWZ0Q2xpZmY9MDt0aGlzLmFsaWduT3B0aW9ucz17YWxpZ246Zy5hbGlnbnx8XG4obT9kP1wibGVmdFwiOlwicmlnaHRcIjpcImNlbnRlclwiKSx2ZXJ0aWNhbEFsaWduOmcudmVydGljYWxBbGlnbnx8KG0/XCJtaWRkbGVcIjpkP1wiYm90dG9tXCI6XCJ0b3BcIikseTpnLnkseDpnLnh9O3RoaXMudGV4dEFsaWduPWcudGV4dEFsaWdufHwobT9kP1wicmlnaHRcIjpcImxlZnRcIjpcImNlbnRlclwiKX1jLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dCh0aGlzLHRoaXMuYXhpcyl9O2MucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihjKXt2YXIgZD10aGlzLmF4aXMuY2hhcnQsZj10aGlzLm9wdGlvbnMsbD1mLmZvcm1hdDtsPWw/QyhsLHRoaXMsZCk6Zi5mb3JtYXR0ZXIuY2FsbCh0aGlzKTt0aGlzLmxhYmVsP3RoaXMubGFiZWwuYXR0cih7dGV4dDpsLHZpc2liaWxpdHk6XCJoaWRkZW5cIn0pOih0aGlzLmxhYmVsPWQucmVuZGVyZXIubGFiZWwobCxudWxsLG51bGwsZi5zaGFwZSxudWxsLG51bGwsZi51c2VIVE1MLCExLFwic3RhY2stbGFiZWxzXCIpLGw9e3I6Zi5ib3JkZXJSYWRpdXN8fDAsdGV4dDpsLFxucm90YXRpb246Zi5yb3RhdGlvbixwYWRkaW5nOmcoZi5wYWRkaW5nLDUpLHZpc2liaWxpdHk6XCJoaWRkZW5cIn0sZC5zdHlsZWRNb2RlfHwobC5maWxsPWYuYmFja2dyb3VuZENvbG9yLGwuc3Ryb2tlPWYuYm9yZGVyQ29sb3IsbFtcInN0cm9rZS13aWR0aFwiXT1mLmJvcmRlcldpZHRoLHRoaXMubGFiZWwuY3NzKGYuc3R5bGUpKSx0aGlzLmxhYmVsLmF0dHIobCksdGhpcy5sYWJlbC5hZGRlZHx8dGhpcy5sYWJlbC5hZGQoYykpO3RoaXMubGFiZWwubGFiZWxyYW5rPWQucGxvdFNpemVZfTtjLnByb3RvdHlwZS5zZXRPZmZzZXQ9ZnVuY3Rpb24oYyxkLGYsbCxrKXt2YXIgbT10aGlzLmF4aXMsbj1tLmNoYXJ0O2w9bS50cmFuc2xhdGUobS5zdGFja2luZy51c2VQZXJjZW50YWdlPzEwMDpsP2w6dGhpcy50b3RhbCwwLDAsMCwxKTtmPW0udHJhbnNsYXRlKGY/ZjowKTtmPUgobCkmJk1hdGguYWJzKGwtZik7Yz1nKGssbi54QXhpc1swXS50cmFuc2xhdGUodGhpcy54KSkrYzttPUgobCkmJnRoaXMuZ2V0U3RhY2tCb3gobixcbnRoaXMsYyxsLGQsZixtKTtkPXRoaXMubGFiZWw7Zj10aGlzLmlzTmVnYXRpdmU7Yz1cImp1c3RpZnlcIj09PWcodGhpcy5vcHRpb25zLm92ZXJmbG93LFwianVzdGlmeVwiKTt2YXIgZT10aGlzLnRleHRBbGlnbjtkJiZtJiYoaz1kLmdldEJCb3goKSxsPWQucGFkZGluZyxlPVwibGVmdFwiPT09ZT9uLmludmVydGVkPy1sOmw6XCJyaWdodFwiPT09ZT9rLndpZHRoOm4uaW52ZXJ0ZWQmJlwiY2VudGVyXCI9PT1lP2sud2lkdGgvMjpuLmludmVydGVkP2Y/ay53aWR0aCtsOi1sOmsud2lkdGgvMixmPW4uaW52ZXJ0ZWQ/ay5oZWlnaHQvMjpmPy1sOmsuaGVpZ2h0LHRoaXMuYWxpZ25PcHRpb25zLng9Zyh0aGlzLm9wdGlvbnMueCwwKSx0aGlzLmFsaWduT3B0aW9ucy55PWcodGhpcy5vcHRpb25zLnksMCksbS54LT1lLG0ueS09ZixkLmFsaWduKHRoaXMuYWxpZ25PcHRpb25zLG51bGwsbSksbi5pc0luc2lkZVBsb3QoZC5hbGlnbkF0dHIueCtlLXRoaXMuYWxpZ25PcHRpb25zLngsZC5hbGlnbkF0dHIueStcbmYtdGhpcy5hbGlnbk9wdGlvbnMueSk/ZC5zaG93KCk6KGQuYWxpZ25BdHRyLnk9LTk5OTksYz0hMSksYyYmeC5wcm90b3R5cGUuanVzdGlmeURhdGFMYWJlbC5jYWxsKHRoaXMuYXhpcyxkLHRoaXMuYWxpZ25PcHRpb25zLGQuYWxpZ25BdHRyLGssbSksZC5hdHRyKHt4OmQuYWxpZ25BdHRyLngseTpkLmFsaWduQXR0ci55fSksZyghYyYmdGhpcy5vcHRpb25zLmNyb3AsITApJiYoKG49RShkLngpJiZFKGQueSkmJm4uaXNJbnNpZGVQbG90KGQueC1sK2Qud2lkdGgsZC55KSYmbi5pc0luc2lkZVBsb3QoZC54K2wsZC55KSl8fGQuaGlkZSgpKSl9O2MucHJvdG90eXBlLmdldFN0YWNrQm94PWZ1bmN0aW9uKGMsZyxkLGYsbCxtLGspe3ZhciBlPWcuYXhpcy5yZXZlcnNlZCxoPWMuaW52ZXJ0ZWQsYT1rLmhlaWdodCtrLnBvcy0oaD9jLnBsb3RMZWZ0OmMucGxvdFRvcCk7Zz1nLmlzTmVnYXRpdmUmJiFlfHwhZy5pc05lZ2F0aXZlJiZlO3JldHVybnt4Omg/Zz9mLWsucmlnaHQ6Zi1tK2sucG9zLVxuYy5wbG90TGVmdDpkK2MueEF4aXNbMF0udHJhbnNCLWMucGxvdExlZnQseTpoP2suaGVpZ2h0LWQtbDpnP2EtZi1tOmEtZix3aWR0aDpoP206bCxoZWlnaHQ6aD9sOm19fTtyZXR1cm4gY30oKTtkLnByb3RvdHlwZS5nZXRTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYz10aGlzLGQ9Yy5pbnZlcnRlZDtjLnlBeGlzLmZvckVhY2goZnVuY3Rpb24oYyl7Yy5zdGFja2luZyYmYy5zdGFja2luZy5zdGFja3MmJmMuaGFzVmlzaWJsZVNlcmllcyYmKGMuc3RhY2tpbmcub2xkU3RhY2tzPWMuc3RhY2tpbmcuc3RhY2tzKX0pO2Muc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oZil7dmFyIGw9Zi54QXhpcyYmZi54QXhpcy5vcHRpb25zfHx7fTshZi5vcHRpb25zLnN0YWNraW5nfHwhMCE9PWYudmlzaWJsZSYmITEhPT1jLm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzfHwoZi5zdGFja0tleT1bZi50eXBlLGcoZi5vcHRpb25zLnN0YWNrLFwiXCIpLGQ/bC50b3A6bC5sZWZ0LGQ/bC5oZWlnaHQ6bC53aWR0aF0uam9pbigpKX0pfTtcbkIuY29tcG9zZShmKTt4LnByb3RvdHlwZS5zZXRHcm91cGVkUG9pbnRzPWZ1bmN0aW9uKCl7dGhpcy5vcHRpb25zLmNlbnRlckluQ2F0ZWdvcnkmJih0aGlzLmlzKFwiY29sdW1uXCIpfHx0aGlzLmlzKFwiY29sdW1ucmFuZ2VcIikpJiYhdGhpcy5vcHRpb25zLnN0YWNraW5nJiYxPHRoaXMuY2hhcnQuc2VyaWVzLmxlbmd0aCYmeC5wcm90b3R5cGUuc2V0U3RhY2tlZFBvaW50cy5jYWxsKHRoaXMsXCJncm91cFwiKX07eC5wcm90b3R5cGUuc2V0U3RhY2tlZFBvaW50cz1mdW5jdGlvbihjKXt2YXIgZD1jfHx0aGlzLm9wdGlvbnMuc3RhY2tpbmc7aWYoZCYmKCEwPT09dGhpcy52aXNpYmxlfHwhMT09PXRoaXMuY2hhcnQub3B0aW9ucy5jaGFydC5pZ25vcmVIaWRkZW5TZXJpZXMpKXt2YXIgZj10aGlzLnByb2Nlc3NlZFhEYXRhLGs9dGhpcy5wcm9jZXNzZWRZRGF0YSx0PVtdLHo9ay5sZW5ndGgsbT10aGlzLm9wdGlvbnMscj1tLnRocmVzaG9sZCxlPWcobS5zdGFydEZyb21UaHJlc2hvbGQmJnIsMCk7XG5tPW0uc3RhY2s7Yz1jP3RoaXMudHlwZStcIixcIitkOnRoaXMuc3RhY2tLZXk7dmFyIGg9XCItXCIrYyxhPXRoaXMubmVnU3RhY2tzLGI9dGhpcy55QXhpcyx3PWIuc3RhY2tpbmcuc3RhY2tzLEM9Yi5zdGFja2luZy5vbGRTdGFja3MsRSxGO2Iuc3RhY2tpbmcuc3RhY2tzVG91Y2hlZCs9MTtmb3IoRj0wO0Y8ejtGKyspe3ZhciB4PWZbRl07dmFyIFI9a1tGXTt2YXIgUT10aGlzLmdldFN0YWNrSW5kaWNhdG9yKFEseCx0aGlzLmluZGV4KTt2YXIgQj1RLmtleTt2YXIgdj0oRT1hJiZSPChlPzA6cikpP2g6Yzt3W3ZdfHwod1t2XT17fSk7d1t2XVt4XXx8KENbdl0mJkNbdl1beF0/KHdbdl1beF09Q1t2XVt4XSx3W3ZdW3hdLnRvdGFsPW51bGwpOndbdl1beF09bmV3IHkoYixiLm9wdGlvbnMuc3RhY2tMYWJlbHMsRSx4LG0pKTt2PXdbdl1beF07bnVsbCE9PVI/KHYucG9pbnRzW0JdPXYucG9pbnRzW3RoaXMuaW5kZXhdPVtnKHYuY3VtdWxhdGl2ZSxlKV0sSCh2LmN1bXVsYXRpdmUpfHwodi5iYXNlPVxuQiksdi50b3VjaGVkPWIuc3RhY2tpbmcuc3RhY2tzVG91Y2hlZCwwPFEuaW5kZXgmJiExPT09dGhpcy5zaW5nbGVTdGFja3MmJih2LnBvaW50c1tCXVswXT12LnBvaW50c1t0aGlzLmluZGV4K1wiLFwiK3grXCIsMFwiXVswXSkpOnYucG9pbnRzW0JdPXYucG9pbnRzW3RoaXMuaW5kZXhdPW51bGw7XCJwZXJjZW50XCI9PT1kPyhFPUU/YzpoLGEmJndbRV0mJndbRV1beF0/KEU9d1tFXVt4XSx2LnRvdGFsPUUudG90YWw9TWF0aC5tYXgoRS50b3RhbCx2LnRvdGFsKStNYXRoLmFicyhSKXx8MCk6di50b3RhbD1EKHYudG90YWwrKE1hdGguYWJzKFIpfHwwKSkpOlwiZ3JvdXBcIj09PWQ/KGwoUikmJihSPVJbMF0pLG51bGwhPT1SJiYodi50b3RhbD0odi50b3RhbHx8MCkrMSkpOnYudG90YWw9RCh2LnRvdGFsKyhSfHwwKSk7di5jdW11bGF0aXZlPVwiZ3JvdXBcIj09PWQ/KHYudG90YWx8fDEpLTE6Zyh2LmN1bXVsYXRpdmUsZSkrKFJ8fDApO251bGwhPT1SJiYodi5wb2ludHNbQl0ucHVzaCh2LmN1bXVsYXRpdmUpLFxudFtGXT12LmN1bXVsYXRpdmUsdi5oYXNWYWxpZFBvaW50cz0hMCl9XCJwZXJjZW50XCI9PT1kJiYoYi5zdGFja2luZy51c2VQZXJjZW50YWdlPSEwKTtcImdyb3VwXCIhPT1kJiYodGhpcy5zdGFja2VkWURhdGE9dCk7Yi5zdGFja2luZy5vbGRTdGFja3M9e319fTt4LnByb3RvdHlwZS5tb2RpZnlTdGFja3M9ZnVuY3Rpb24oKXt2YXIgYz10aGlzLGc9Yy5zdGFja0tleSxkPWMueUF4aXMuc3RhY2tpbmcuc3RhY2tzLGY9Yy5wcm9jZXNzZWRYRGF0YSxsLGs9Yy5vcHRpb25zLnN0YWNraW5nO2NbaytcIlN0YWNrZXJcIl0mJltnLFwiLVwiK2ddLmZvckVhY2goZnVuY3Rpb24oZyl7Zm9yKHZhciBtPWYubGVuZ3RoLGUsaDttLS07KWlmKGU9ZlttXSxsPWMuZ2V0U3RhY2tJbmRpY2F0b3IobCxlLGMuaW5kZXgsZyksaD0oZT1kW2ddJiZkW2ddW2VdKSYmZS5wb2ludHNbbC5rZXldKWNbaytcIlN0YWNrZXJcIl0oaCxlLG0pfSl9O3gucHJvdG90eXBlLnBlcmNlbnRTdGFja2VyPWZ1bmN0aW9uKGMsZyxkKXtnPVxuZy50b3RhbD8xMDAvZy50b3RhbDowO2NbMF09RChjWzBdKmcpO2NbMV09RChjWzFdKmcpO3RoaXMuc3RhY2tlZFlEYXRhW2RdPWNbMV19O3gucHJvdG90eXBlLmdldFN0YWNrSW5kaWNhdG9yPWZ1bmN0aW9uKGMsZyxkLGYpeyFIKGMpfHxjLnghPT1nfHxmJiZjLmtleSE9PWY/Yz17eDpnLGluZGV4OjAsa2V5OmZ9OmMuaW5kZXgrKztjLmtleT1bZCxnLGMuaW5kZXhdLmpvaW4oKTtyZXR1cm4gY307ay5TdGFja0l0ZW09eTtyZXR1cm4gay5TdGFja0l0ZW19KTtQKGssXCJTZXJpZXMvTGluZS9MaW5lU2VyaWVzLmpzXCIsW2tbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1Nlcmllcy5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4KXt2YXIgQj10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgZD1mdW5jdGlvbihmLGspe2Q9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxcbntfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZCxmKXtkLl9fcHJvdG9fXz1mfXx8ZnVuY3Rpb24oZCxmKXtmb3IodmFyIGcgaW4gZilmLmhhc093blByb3BlcnR5KGcpJiYoZFtnXT1mW2ddKX07cmV0dXJuIGQoZixrKX07cmV0dXJuIGZ1bmN0aW9uKGYsayl7ZnVuY3Rpb24gbCgpe3RoaXMuY29uc3RydWN0b3I9Zn1kKGYsayk7Zi5wcm90b3R5cGU9bnVsbD09PWs/T2JqZWN0LmNyZWF0ZShrKToobC5wcm90b3R5cGU9ay5wcm90b3R5cGUsbmV3IGwpfX0oKSxHPXguZGVmaW5lZCxEPXgubWVyZ2U7eD1mdW5jdGlvbihrKXtmdW5jdGlvbiB0KCl7dmFyIGQ9bnVsbCE9PWsmJmsuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO2QuZGF0YT12b2lkIDA7ZC5vcHRpb25zPXZvaWQgMDtkLnBvaW50cz12b2lkIDA7cmV0dXJuIGR9Qih0LGspO3QucHJvdG90eXBlLmRyYXdHcmFwaD1mdW5jdGlvbigpe3ZhciBkPXRoaXMsbD10aGlzLm9wdGlvbnMsaz0odGhpcy5nYXBwZWRQYXRofHxcbnRoaXMuZ2V0R3JhcGhQYXRoKS5jYWxsKHRoaXMpLGc9dGhpcy5jaGFydC5zdHlsZWRNb2RlLHQ9W1tcImdyYXBoXCIsXCJoaWdoY2hhcnRzLWdyYXBoXCJdXTtnfHx0WzBdLnB1c2gobC5saW5lQ29sb3J8fHRoaXMuY29sb3J8fGYubmV1dHJhbENvbG9yMjAsbC5kYXNoU3R5bGUpO3Q9ZC5nZXRab25lc0dyYXBocyh0KTt0LmZvckVhY2goZnVuY3Rpb24oYyxmKXt2YXIgbj1jWzBdLHE9ZFtuXSx0PXE/XCJhbmltYXRlXCI6XCJhdHRyXCI7cT8ocS5lbmRYPWQucHJldmVudEdyYXBoQW5pbWF0aW9uP251bGw6ay54TWFwLHEuYW5pbWF0ZSh7ZDprfSkpOmsubGVuZ3RoJiYoZFtuXT1xPWQuY2hhcnQucmVuZGVyZXIucGF0aChrKS5hZGRDbGFzcyhjWzFdKS5hdHRyKHt6SW5kZXg6MX0pLmFkZChkLmdyb3VwKSk7cSYmIWcmJihuPXtzdHJva2U6Y1syXSxcInN0cm9rZS13aWR0aFwiOmwubGluZVdpZHRoLGZpbGw6ZC5maWxsR3JhcGgmJmQuY29sb3J8fFwibm9uZVwifSxjWzNdP24uZGFzaHN0eWxlPWNbM106XCJzcXVhcmVcIiE9PVxubC5saW5lY2FwJiYobltcInN0cm9rZS1saW5lY2FwXCJdPW5bXCJzdHJva2UtbGluZWpvaW5cIl09XCJyb3VuZFwiKSxxW3RdKG4pLnNoYWRvdygyPmYmJmwuc2hhZG93KSk7cSYmKHEuc3RhcnRYPWsueE1hcCxxLmlzQXJlYT1rLmlzQXJlYSl9KX07dC5wcm90b3R5cGUuZ2V0R3JhcGhQYXRoPWZ1bmN0aW9uKGQsZixrKXt2YXIgZz10aGlzLGw9Zy5vcHRpb25zLGM9bC5zdGVwLHEsbj1bXSx0PVtdLEU7ZD1kfHxnLnBvaW50czsocT1kLnJldmVyc2VkKSYmZC5yZXZlcnNlKCk7KGM9e3JpZ2h0OjEsY2VudGVyOjJ9W2NdfHxjJiYzKSYmcSYmKGM9NC1jKTtkPXRoaXMuZ2V0VmFsaWRQb2ludHMoZCwhMSwhKGwuY29ubmVjdE51bGxzJiYhZiYmIWspKTtkLmZvckVhY2goZnVuY3Rpb24ocSxtKXt2YXIgcj1xLnBsb3RYLGU9cS5wbG90WSxoPWRbbS0xXTsocS5sZWZ0Q2xpZmZ8fGgmJmgucmlnaHRDbGlmZikmJiFrJiYoRT0hMCk7cS5pc051bGwmJiFHKGYpJiYwPG0/RT0hbC5jb25uZWN0TnVsbHM6XG5xLmlzTnVsbCYmIWY/RT0hMDooMD09PW18fEU/bT1bW1wiTVwiLHEucGxvdFgscS5wbG90WV1dOmcuZ2V0UG9pbnRTcGxpbmU/bT1bZy5nZXRQb2ludFNwbGluZShkLHEsbSldOmM/KG09MT09PWM/W1tcIkxcIixoLnBsb3RYLGVdXToyPT09Yz9bW1wiTFwiLChoLnBsb3RYK3IpLzIsaC5wbG90WV0sW1wiTFwiLChoLnBsb3RYK3IpLzIsZV1dOltbXCJMXCIscixoLnBsb3RZXV0sbS5wdXNoKFtcIkxcIixyLGVdKSk6bT1bW1wiTFwiLHIsZV1dLHQucHVzaChxLngpLGMmJih0LnB1c2gocS54KSwyPT09YyYmdC5wdXNoKHEueCkpLG4ucHVzaC5hcHBseShuLG0pLEU9ITEpfSk7bi54TWFwPXQ7cmV0dXJuIGcuZ3JhcGhQYXRoPW59O3QucHJvdG90eXBlLmdldFpvbmVzR3JhcGhzPWZ1bmN0aW9uKGQpe3RoaXMuem9uZXMuZm9yRWFjaChmdW5jdGlvbihmLGspe2s9W1wiem9uZS1ncmFwaC1cIitrLFwiaGlnaGNoYXJ0cy1ncmFwaCBoaWdoY2hhcnRzLXpvbmUtZ3JhcGgtXCIraytcIiBcIisoZi5jbGFzc05hbWV8fFwiXCIpXTt0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fFxuay5wdXNoKGYuY29sb3J8fHRoaXMuY29sb3IsZi5kYXNoU3R5bGV8fHRoaXMub3B0aW9ucy5kYXNoU3R5bGUpO2QucHVzaChrKX0sdGhpcyk7cmV0dXJuIGR9O3QuZGVmYXVsdE9wdGlvbnM9RChkLmRlZmF1bHRPcHRpb25zLHt9KTtyZXR1cm4gdH0oZCk7ay5yZWdpc3RlclNlcmllc1R5cGUoXCJsaW5lXCIseCk7XCJcIjtyZXR1cm4geH0pO1AoayxcIlNlcmllcy9BcmVhL0FyZWFTZXJpZXMuanNcIixba1tcIkNvcmUvQ29sb3IvQ29sb3IuanNcIl0sa1tcIk1peGlucy9MZWdlbmRTeW1ib2wuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCl7dmFyIEI9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIGQ9ZnVuY3Rpb24oZixnKXtkPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihnLGMpe2cuX19wcm90b19fPWN9fHxmdW5jdGlvbihnLFxuYyl7Zm9yKHZhciBkIGluIGMpYy5oYXNPd25Qcm9wZXJ0eShkKSYmKGdbZF09Y1tkXSl9O3JldHVybiBkKGYsZyl9O3JldHVybiBmdW5jdGlvbihmLGcpe2Z1bmN0aW9uIGwoKXt0aGlzLmNvbnN0cnVjdG9yPWZ9ZChmLGcpO2YucHJvdG90eXBlPW51bGw9PT1nP09iamVjdC5jcmVhdGUoZyk6KGwucHJvdG90eXBlPWcucHJvdG90eXBlLG5ldyBsKX19KCksRz1mLnBhcnNlLEQ9ay5zZXJpZXNUeXBlcy5saW5lO2Y9eC5leHRlbmQ7dmFyIEg9eC5tZXJnZSx0PXgub2JqZWN0RWFjaCxDPXgucGljazt4PWZ1bmN0aW9uKGQpe2Z1bmN0aW9uIGYoKXt2YXIgZz1udWxsIT09ZCYmZC5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7Zy5kYXRhPXZvaWQgMDtnLm9wdGlvbnM9dm9pZCAwO2cucG9pbnRzPXZvaWQgMDtyZXR1cm4gZ31CKGYsZCk7Zi5wcm90b3R5cGUuZHJhd0dyYXBoPWZ1bmN0aW9uKCl7dGhpcy5hcmVhUGF0aD1bXTtkLnByb3RvdHlwZS5kcmF3R3JhcGguYXBwbHkodGhpcyk7XG52YXIgZz10aGlzLGY9dGhpcy5hcmVhUGF0aCxjPXRoaXMub3B0aW9ucyxsPVtbXCJhcmVhXCIsXCJoaWdoY2hhcnRzLWFyZWFcIix0aGlzLmNvbG9yLGMuZmlsbENvbG9yXV07dGhpcy56b25lcy5mb3JFYWNoKGZ1bmN0aW9uKGQsZil7bC5wdXNoKFtcInpvbmUtYXJlYS1cIitmLFwiaGlnaGNoYXJ0cy1hcmVhIGhpZ2hjaGFydHMtem9uZS1hcmVhLVwiK2YrXCIgXCIrZC5jbGFzc05hbWUsZC5jb2xvcnx8Zy5jb2xvcixkLmZpbGxDb2xvcnx8Yy5maWxsQ29sb3JdKX0pO2wuZm9yRWFjaChmdW5jdGlvbihkKXt2YXIgbD1kWzBdLG49Z1tsXSxrPW4/XCJhbmltYXRlXCI6XCJhdHRyXCIsbT17fTtuPyhuLmVuZFg9Zy5wcmV2ZW50R3JhcGhBbmltYXRpb24/bnVsbDpmLnhNYXAsbi5hbmltYXRlKHtkOmZ9KSk6KG0uekluZGV4PTAsbj1nW2xdPWcuY2hhcnQucmVuZGVyZXIucGF0aChmKS5hZGRDbGFzcyhkWzFdKS5hZGQoZy5ncm91cCksbi5pc0FyZWE9ITApO2cuY2hhcnQuc3R5bGVkTW9kZXx8KG0uZmlsbD1DKGRbM10sXG5HKGRbMl0pLnNldE9wYWNpdHkoQyhjLmZpbGxPcGFjaXR5LC43NSkpLmdldCgpKSk7bltrXShtKTtuLnN0YXJ0WD1mLnhNYXA7bi5zaGlmdFVuaXQ9Yy5zdGVwPzI6MX0pfTtmLnByb3RvdHlwZS5nZXRHcmFwaFBhdGg9ZnVuY3Rpb24oZyl7dmFyIGQ9RC5wcm90b3R5cGUuZ2V0R3JhcGhQYXRoLGM9dGhpcy5vcHRpb25zLGY9Yy5zdGFja2luZyxsPXRoaXMueUF4aXMsayx0PVtdLHo9W10sbT10aGlzLmluZGV4LHI9bC5zdGFja2luZy5zdGFja3NbdGhpcy5zdGFja0tleV0sZT1jLnRocmVzaG9sZCxoPU1hdGgucm91bmQobC5nZXRUaHJlc2hvbGQoYy50aHJlc2hvbGQpKTtjPUMoYy5jb25uZWN0TnVsbHMsXCJwZXJjZW50XCI9PT1mKTt2YXIgYT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9Z1thXTthPWYmJnJbZC54XS5wb2ludHNbbV07dmFyIGs9ZFtjK1wiTnVsbFwiXXx8MDtjPWRbYytcIkNsaWZmXCJdfHwwO2Q9ITA7aWYoY3x8ayl7dmFyIG49KGs/YVswXTphWzFdKStjO3ZhciBxPWFbMF0rYztcbmQ9ISFrfWVsc2UhZiYmZ1tiXSYmZ1tiXS5pc051bGwmJihuPXE9ZSk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBuJiYoei5wdXNoKHtwbG90WDp3LHBsb3RZOm51bGw9PT1uP2g6bC5nZXRUaHJlc2hvbGQobiksaXNOdWxsOmQsaXNDbGlmZjohMH0pLHQucHVzaCh7cGxvdFg6dyxwbG90WTpudWxsPT09cT9oOmwuZ2V0VGhyZXNob2xkKHEpLGRvQ3VydmU6ITF9KSl9O2c9Z3x8dGhpcy5wb2ludHM7ZiYmKGc9dGhpcy5nZXRTdGFja1BvaW50cyhnKSk7Zm9yKGs9MDtrPGcubGVuZ3RoO2srKyl7Znx8KGdba10ubGVmdENsaWZmPWdba10ucmlnaHRDbGlmZj1nW2tdLmxlZnROdWxsPWdba10ucmlnaHROdWxsPXZvaWQgMCk7dmFyIGI9Z1trXS5pc051bGw7dmFyIHc9QyhnW2tdLnJlY3RQbG90WCxnW2tdLnBsb3RYKTt2YXIgRT1mP0MoZ1trXS55Qm90dG9tLGgpOmg7aWYoIWJ8fGMpY3x8YShrLGstMSxcImxlZnRcIiksYiYmIWYmJmN8fCh6LnB1c2goZ1trXSksdC5wdXNoKHt4OmsscGxvdFg6dyxcbnBsb3RZOkV9KSksY3x8YShrLGsrMSxcInJpZ2h0XCIpfWs9ZC5jYWxsKHRoaXMseiwhMCwhMCk7dC5yZXZlcnNlZD0hMDtiPWQuY2FsbCh0aGlzLHQsITAsITApOyhFPWJbMF0pJiZcIk1cIj09PUVbMF0mJihiWzBdPVtcIkxcIixFWzFdLEVbMl1dKTtiPWsuY29uY2F0KGIpO2Q9ZC5jYWxsKHRoaXMseiwhMSxjKTtiLnhNYXA9ay54TWFwO3RoaXMuYXJlYVBhdGg9YjtyZXR1cm4gZH07Zi5wcm90b3R5cGUuZ2V0U3RhY2tQb2ludHM9ZnVuY3Rpb24oZCl7dmFyIGc9W10sYz1bXSxmPXRoaXMueEF4aXMsbD10aGlzLnlBeGlzLGs9bC5zdGFja2luZy5zdGFja3NbdGhpcy5zdGFja0tleV0sRT17fSx6PXRoaXMuaW5kZXgsbT1sLnNlcmllcyxyPW0ubGVuZ3RoLGU9QyhsLm9wdGlvbnMucmV2ZXJzZWRTdGFja3MsITApPzE6LTEsaDtkPWR8fHRoaXMucG9pbnRzO2lmKHRoaXMub3B0aW9ucy5zdGFja2luZyl7Zm9yKGg9MDtoPGQubGVuZ3RoO2grKylkW2hdLmxlZnROdWxsPWRbaF0ucmlnaHROdWxsPVxudm9pZCAwLEVbZFtoXS54XT1kW2hdO3QoayxmdW5jdGlvbihhLGUpe251bGwhPT1hLnRvdGFsJiZjLnB1c2goZSl9KTtjLnNvcnQoZnVuY3Rpb24oYSxjKXtyZXR1cm4gYS1jfSk7dmFyIGE9bS5tYXAoZnVuY3Rpb24oYSl7cmV0dXJuIGEudmlzaWJsZX0pO2MuZm9yRWFjaChmdW5jdGlvbihiLGQpe3ZhciBtPTAsbixxO2lmKEVbYl0mJiFFW2JdLmlzTnVsbClnLnB1c2goRVtiXSksWy0xLDFdLmZvckVhY2goZnVuY3Rpb24oZyl7dmFyIGY9MT09PWc/XCJyaWdodE51bGxcIjpcImxlZnROdWxsXCIsbT0wLGw9a1tjW2QrZ11dO2lmKGwpZm9yKGg9ejswPD1oJiZoPHI7KW49bC5wb2ludHNbaF0sbnx8KGg9PT16P0VbYl1bZl09ITA6YVtoXSYmKHE9a1tiXS5wb2ludHNbaF0pJiYobS09cVsxXS1xWzBdKSksaCs9ZTtFW2JdWzE9PT1nP1wicmlnaHRDbGlmZlwiOlwibGVmdENsaWZmXCJdPW19KTtlbHNle2ZvcihoPXo7MDw9aCYmaDxyOyl7aWYobj1rW2JdLnBvaW50c1toXSl7bT1uWzFdO2JyZWFrfWgrPVxuZX1tPWwudHJhbnNsYXRlKG0sMCwxLDAsMSk7Zy5wdXNoKHtpc051bGw6ITAscGxvdFg6Zi50cmFuc2xhdGUoYiwwLDAsMCwxKSx4OmIscGxvdFk6bSx5Qm90dG9tOm19KX19KX1yZXR1cm4gZ307Zi5kZWZhdWx0T3B0aW9ucz1IKEQuZGVmYXVsdE9wdGlvbnMse3RocmVzaG9sZDowfSk7cmV0dXJuIGZ9KEQpO2YoeC5wcm90b3R5cGUse3NpbmdsZVN0YWNrczohMSxkcmF3TGVnZW5kU3ltYm9sOmQuZHJhd1JlY3RhbmdsZX0pO2sucmVnaXN0ZXJTZXJpZXNUeXBlKFwiYXJlYVwiLHgpO1wiXCI7cmV0dXJuIHh9KTtQKGssXCJTZXJpZXMvU3BsaW5lL1NwbGluZVNlcmllcy5qc1wiLFtrW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQpe3ZhciBrPXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBkPWZ1bmN0aW9uKGYsayl7ZD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZlxuQXJyYXkmJmZ1bmN0aW9uKGQsZil7ZC5fX3Byb3RvX189Zn18fGZ1bmN0aW9uKGQsZil7Zm9yKHZhciBsIGluIGYpZi5oYXNPd25Qcm9wZXJ0eShsKSYmKGRbbF09ZltsXSl9O3JldHVybiBkKGYsayl9O3JldHVybiBmdW5jdGlvbihmLGspe2Z1bmN0aW9uIHQoKXt0aGlzLmNvbnN0cnVjdG9yPWZ9ZChmLGspO2YucHJvdG90eXBlPW51bGw9PT1rP09iamVjdC5jcmVhdGUoayk6KHQucHJvdG90eXBlPWsucHJvdG90eXBlLG5ldyB0KX19KCkseD1mLnNlcmllc1R5cGVzLmxpbmUsQj1kLm1lcmdlLEc9ZC5waWNrO2Q9ZnVuY3Rpb24oZCl7ZnVuY3Rpb24gZigpe3ZhciBmPW51bGwhPT1kJiZkLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztmLmRhdGE9dm9pZCAwO2Yub3B0aW9ucz12b2lkIDA7Zi5wb2ludHM9dm9pZCAwO3JldHVybiBmfWsoZixkKTtmLnByb3RvdHlwZS5nZXRQb2ludFNwbGluZT1mdW5jdGlvbihkLGYsbCl7dmFyIGs9Zi5wbG90WHx8MCxnPWYucGxvdFl8fDAsdD1kW2wtXG4xXTtsPWRbbCsxXTtpZih0JiYhdC5pc051bGwmJiExIT09dC5kb0N1cnZlJiYhZi5pc0NsaWZmJiZsJiYhbC5pc051bGwmJiExIT09bC5kb0N1cnZlJiYhZi5pc0NsaWZmKXtkPXQucGxvdFl8fDA7dmFyIGM9bC5wbG90WHx8MDtsPWwucGxvdFl8fDA7dmFyIHE9MDt2YXIgbj0oMS41KmsrKHQucGxvdFh8fDApKS8yLjU7dmFyIHg9KDEuNSpnK2QpLzIuNTtjPSgxLjUqaytjKS8yLjU7dmFyIEM9KDEuNSpnK2wpLzIuNTtjIT09biYmKHE9KEMteCkqKGMtaykvKGMtbikrZy1DKTt4Kz1xO0MrPXE7eD5kJiZ4Pmc/KHg9TWF0aC5tYXgoZCxnKSxDPTIqZy14KTp4PGQmJng8ZyYmKHg9TWF0aC5taW4oZCxnKSxDPTIqZy14KTtDPmwmJkM+Zz8oQz1NYXRoLm1heChsLGcpLHg9MipnLUMpOkM8bCYmQzxnJiYoQz1NYXRoLm1pbihsLGcpLHg9MipnLUMpO2YucmlnaHRDb250WD1jO2YucmlnaHRDb250WT1DfWY9W1wiQ1wiLEcodC5yaWdodENvbnRYLHQucGxvdFgsMCksRyh0LnJpZ2h0Q29udFksdC5wbG90WSxcbjApLEcobixrLDApLEcoeCxnLDApLGssZ107dC5yaWdodENvbnRYPXQucmlnaHRDb250WT12b2lkIDA7cmV0dXJuIGZ9O2YuZGVmYXVsdE9wdGlvbnM9Qih4LmRlZmF1bHRPcHRpb25zKTtyZXR1cm4gZn0oeCk7Zi5yZWdpc3RlclNlcmllc1R5cGUoXCJzcGxpbmVcIixkKTtcIlwiO3JldHVybiBkfSk7UChrLFwiU2VyaWVzL0FyZWFTcGxpbmUvQXJlYVNwbGluZVNlcmllcy5qc1wiLFtrW1wiU2VyaWVzL0FyZWEvQXJlYVNlcmllcy5qc1wiXSxrW1wiU2VyaWVzL1NwbGluZS9TcGxpbmVTZXJpZXMuanNcIl0sa1tcIk1peGlucy9MZWdlbmRTeW1ib2wuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCxCKXt2YXIgRz10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgZD1mdW5jdGlvbihmLGspe2Q9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGQsXG5mKXtkLl9fcHJvdG9fXz1mfXx8ZnVuY3Rpb24oZCxmKXtmb3IodmFyIGMgaW4gZilmLmhhc093blByb3BlcnR5KGMpJiYoZFtjXT1mW2NdKX07cmV0dXJuIGQoZixrKX07cmV0dXJuIGZ1bmN0aW9uKGYsayl7ZnVuY3Rpb24gZygpe3RoaXMuY29uc3RydWN0b3I9Zn1kKGYsayk7Zi5wcm90b3R5cGU9bnVsbD09PWs/T2JqZWN0LmNyZWF0ZShrKTooZy5wcm90b3R5cGU9ay5wcm90b3R5cGUsbmV3IGcpfX0oKSxEPWYucHJvdG90eXBlLEg9Qi5leHRlbmQsdD1CLm1lcmdlO0I9ZnVuY3Rpb24oayl7ZnVuY3Rpb24gbCgpe3ZhciBkPW51bGwhPT1rJiZrLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztkLmRhdGE9dm9pZCAwO2QucG9pbnRzPXZvaWQgMDtkLm9wdGlvbnM9dm9pZCAwO3JldHVybiBkfUcobCxrKTtsLmRlZmF1bHRPcHRpb25zPXQoZC5kZWZhdWx0T3B0aW9ucyxmLmRlZmF1bHRPcHRpb25zKTtyZXR1cm4gbH0oZCk7SChCLnByb3RvdHlwZSx7Z2V0R3JhcGhQYXRoOkQuZ2V0R3JhcGhQYXRoLFxuZ2V0U3RhY2tQb2ludHM6RC5nZXRTdGFja1BvaW50cyxkcmF3R3JhcGg6RC5kcmF3R3JhcGgsZHJhd0xlZ2VuZFN5bWJvbDprLmRyYXdSZWN0YW5nbGV9KTt4LnJlZ2lzdGVyU2VyaWVzVHlwZShcImFyZWFzcGxpbmVcIixCKTtcIlwiO3JldHVybiBCfSk7UChrLFwiU2VyaWVzL0NvbHVtbi9Db2x1bW5TZXJpZXMuanNcIixba1tcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxrW1wiQ29yZS9Db2xvci9Db2xvci5qc1wiXSxrW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGtbXCJNaXhpbnMvTGVnZW5kU3ltYm9sLmpzXCJdLGtbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1Nlcmllcy5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4LEIsRyxELEgpe3ZhciB0PXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBjPWZ1bmN0aW9uKGUsYSl7Yz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fFxue19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihhLGMpe2EuX19wcm90b19fPWN9fHxmdW5jdGlvbihhLGMpe2Zvcih2YXIgYiBpbiBjKWMuaGFzT3duUHJvcGVydHkoYikmJihhW2JdPWNbYl0pfTtyZXR1cm4gYyhlLGEpfTtyZXR1cm4gZnVuY3Rpb24oZSxhKXtmdW5jdGlvbiBiKCl7dGhpcy5jb25zdHJ1Y3Rvcj1lfWMoZSxhKTtlLnByb3RvdHlwZT1udWxsPT09YT9PYmplY3QuY3JlYXRlKGEpOihiLnByb3RvdHlwZT1hLnByb3RvdHlwZSxuZXcgYil9fSgpLEM9Zi5hbmltT2JqZWN0LGw9ZC5wYXJzZSxFPWsuaGFzVG91Y2g7Zj1rLm5vb3A7dmFyIGc9SC5jbGFtcCx5PUguY3NzLGM9SC5kZWZpbmVkLHE9SC5leHRlbmQsbj1ILmZpcmVFdmVudCxBPUguaXNBcnJheSxNPUguaXNOdW1iZXIsej1ILm1lcmdlLG09SC5waWNrLHI9SC5vYmplY3RFYWNoO0g9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gZCgpe3ZhciBhPW51bGwhPT1lJiZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8XG50aGlzO2EuYm9yZGVyV2lkdGg9dm9pZCAwO2EuZGF0YT12b2lkIDA7YS5ncm91cD12b2lkIDA7YS5vcHRpb25zPXZvaWQgMDthLnBvaW50cz12b2lkIDA7cmV0dXJuIGF9dChkLGUpO2QucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPXRoaXMueUF4aXMsZT1iLm9wdGlvbnMsZD10aGlzLmNoYXJ0LmludmVydGVkLGY9e30saD1kP1widHJhbnNsYXRlWFwiOlwidHJhbnNsYXRlWVwiO2lmKGEpZi5zY2FsZVk9LjAwMSxhPWcoYy50b1BpeGVscyhlLnRocmVzaG9sZCksYy5wb3MsYy5wb3MrYy5sZW4pLGQ/Zi50cmFuc2xhdGVYPWEtYy5sZW46Zi50cmFuc2xhdGVZPWEsYi5jbGlwQm94JiZiLnNldENsaXAoKSxiLmdyb3VwLmF0dHIoZik7ZWxzZXt2YXIgbT1iLmdyb3VwLmF0dHIoaCk7Yi5ncm91cC5hbmltYXRlKHtzY2FsZVk6MX0scShDKGIub3B0aW9ucy5hbmltYXRpb24pLHtzdGVwOmZ1bmN0aW9uKGEsZSl7Yi5ncm91cCYmKGZbaF09bStlLnBvcyooYy5wb3MtXG5tKSxiLmdyb3VwLmF0dHIoZikpfX0pKX19O2QucHJvdG90eXBlLmluaXQ9ZnVuY3Rpb24oYSxiKXtlLnByb3RvdHlwZS5pbml0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgYz10aGlzO2E9Yy5jaGFydDthLmhhc1JlbmRlcmVkJiZhLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EudHlwZT09PWMudHlwZSYmKGEuaXNEaXJ0eT0hMCl9KX07ZC5wcm90b3R5cGUuZ2V0Q29sdW1uTWV0cmljcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLm9wdGlvbnMsYz1hLnhBeGlzLGU9YS55QXhpcyxkPWMub3B0aW9ucy5yZXZlcnNlZFN0YWNrcztkPWMucmV2ZXJzZWQmJiFkfHwhYy5yZXZlcnNlZCYmZDt2YXIgZyxmPXt9LGg9MDshMT09PWIuZ3JvdXBpbmc/aD0xOmEuY2hhcnQuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGM9Yi55QXhpcyxkPWIub3B0aW9ucztpZihiLnR5cGU9PT1hLnR5cGUmJihiLnZpc2libGV8fCFhLmNoYXJ0Lm9wdGlvbnMuY2hhcnQuaWdub3JlSGlkZGVuU2VyaWVzKSYmXG5lLmxlbj09PWMubGVuJiZlLnBvcz09PWMucG9zKXtpZihkLnN0YWNraW5nJiZcImdyb3VwXCIhPT1kLnN0YWNraW5nKXtnPWIuc3RhY2tLZXk7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBmW2ddJiYoZltnXT1oKyspO3ZhciBtPWZbZ119ZWxzZSExIT09ZC5ncm91cGluZyYmKG09aCsrKTtiLmNvbHVtbkluZGV4PW19fSk7dmFyIGw9TWF0aC5taW4oTWF0aC5hYnMoYy50cmFuc0EpKihjLm9yZGluYWwmJmMub3JkaW5hbC5zbG9wZXx8Yi5wb2ludFJhbmdlfHxjLmNsb3Nlc3RQb2ludFJhbmdlfHxjLnRpY2tJbnRlcnZhbHx8MSksYy5sZW4pLGs9bCpiLmdyb3VwUGFkZGluZyxuPShsLTIqaykvKGh8fDEpO2I9TWF0aC5taW4oYi5tYXhQb2ludFdpZHRofHxjLmxlbixtKGIucG9pbnRXaWR0aCxuKigxLTIqYi5wb2ludFBhZGRpbmcpKSk7YS5jb2x1bW5NZXRyaWNzPXt3aWR0aDpiLG9mZnNldDoobi1iKS8yKyhrKygoYS5jb2x1bW5JbmRleHx8MCkrKGQ/MTowKSkqbi1sLzIpKihkPy0xOjEpLHBhZGRlZFdpZHRoOm4sXG5jb2x1bW5Db3VudDpofTtyZXR1cm4gYS5jb2x1bW5NZXRyaWNzfTtkLnByb3RvdHlwZS5jcmlzcENvbD1mdW5jdGlvbihhLGIsYyxlKXt2YXIgZD10aGlzLmNoYXJ0LGc9dGhpcy5ib3JkZXJXaWR0aCxmPS0oZyUyPy41OjApO2c9ZyUyPy41OjE7ZC5pbnZlcnRlZCYmZC5yZW5kZXJlci5pc1ZNTCYmKGcrPTEpO3RoaXMub3B0aW9ucy5jcmlzcCYmKGM9TWF0aC5yb3VuZChhK2MpK2YsYT1NYXRoLnJvdW5kKGEpK2YsYy09YSk7ZT1NYXRoLnJvdW5kKGIrZSkrZztmPS41Pj1NYXRoLmFicyhiKSYmLjU8ZTtiPU1hdGgucm91bmQoYikrZztlLT1iO2YmJmUmJigtLWIsZSs9MSk7cmV0dXJue3g6YSx5OmIsd2lkdGg6YyxoZWlnaHQ6ZX19O2QucHJvdG90eXBlLmFkanVzdEZvck1pc3NpbmdDb2x1bW5zPWZ1bmN0aW9uKGEsYixjLGUpe3ZhciBkPXRoaXMsZz10aGlzLm9wdGlvbnMuc3RhY2tpbmc7aWYoIWMuaXNOdWxsJiYxPGUuY29sdW1uQ291bnQpe3ZhciBmPTAsaD0wO3IodGhpcy55QXhpcy5zdGFja2luZyYmXG50aGlzLnlBeGlzLnN0YWNraW5nLnN0YWNrcyxmdW5jdGlvbihhKXtpZihcIm51bWJlclwiPT09dHlwZW9mIGMueCYmKGE9YVtjLngudG9TdHJpbmcoKV0pKXt2YXIgYj1hLnBvaW50c1tkLmluZGV4XSxlPWEudG90YWw7Zz8oYiYmKGY9aCksYS5oYXNWYWxpZFBvaW50cyYmaCsrKTpBKGIpJiYoZj1iWzFdLGg9ZXx8MCl9fSk7YT0oYy5wbG90WHx8MCkrKChoLTEpKmUucGFkZGVkV2lkdGgrYikvMi1iLWYqZS5wYWRkZWRXaWR0aH1yZXR1cm4gYX07ZC5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEuY2hhcnQsZT1hLm9wdGlvbnMsZD1hLmRlbnNlPTI+YS5jbG9zZXN0UG9pbnRSYW5nZSphLnhBeGlzLnRyYW5zQTtkPWEuYm9yZGVyV2lkdGg9bShlLmJvcmRlcldpZHRoLGQ/MDoxKTt2YXIgZj1hLnhBeGlzLGg9YS55QXhpcyxsPWUudGhyZXNob2xkLGs9YS50cmFuc2xhdGVkVGhyZXNob2xkPWguZ2V0VGhyZXNob2xkKGwpLG49bShlLm1pblBvaW50TGVuZ3RoLFxuNSkscT1hLmdldENvbHVtbk1ldHJpY3MoKSxyPXEud2lkdGgsdD1hLmJhclc9TWF0aC5tYXgociwxKzIqZCkscD1hLnBvaW50WE9mZnNldD1xLm9mZnNldCx5PWEuZGF0YU1pbix6PWEuZGF0YU1heDtiLmludmVydGVkJiYoay09LjUpO2UucG9pbnRQYWRkaW5nJiYodD1NYXRoLmNlaWwodCkpO0cucHJvdG90eXBlLnRyYW5zbGF0ZS5hcHBseShhKTthLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGQpe3ZhciB3PW0oZC55Qm90dG9tLGspLHY9OTk5K01hdGguYWJzKHcpLEY9cix4PWQucGxvdFh8fDA7dj1nKGQucGxvdFksLXYsaC5sZW4rdik7dmFyIEU9eCtwLEM9dCxBPU1hdGgubWluKHYsdyksQj1NYXRoLm1heCh2LHcpLUE7aWYobiYmTWF0aC5hYnMoQik8bil7Qj1uO3ZhciBIPSFoLnJldmVyc2VkJiYhZC5uZWdhdGl2ZXx8aC5yZXZlcnNlZCYmZC5uZWdhdGl2ZTtNKGwpJiZNKHopJiZkLnk9PT1sJiZ6PD1sJiYoaC5taW58fDApPGwmJih5IT09enx8KGgubWF4fHwwKTw9bCkmJihIPVxuIUgpO0E9TWF0aC5hYnMoQS1rKT5uP3ctbjprLShIP246MCl9YyhkLm9wdGlvbnMucG9pbnRXaWR0aCkmJihGPUM9TWF0aC5jZWlsKGQub3B0aW9ucy5wb2ludFdpZHRoKSxFLT1NYXRoLnJvdW5kKChGLXIpLzIpKTtlLmNlbnRlckluQ2F0ZWdvcnkmJihFPWEuYWRqdXN0Rm9yTWlzc2luZ0NvbHVtbnMoRSxGLGQscSkpO2QuYmFyWD1FO2QucG9pbnRXaWR0aD1GO2QudG9vbHRpcFBvcz1iLmludmVydGVkP1tnKGgubGVuK2gucG9zLWIucGxvdExlZnQtdixoLnBvcy1iLnBsb3RMZWZ0LGgubGVuK2gucG9zLWIucGxvdExlZnQpLGYubGVuK2YucG9zLWIucGxvdFRvcC0oeHx8MCktcC1DLzIsQl06W2YubGVmdC1iLnBsb3RMZWZ0K0UrQy8yLGcoditoLnBvcy1iLnBsb3RUb3AsaC5wb3MtYi5wbG90VG9wLGgubGVuK2gucG9zLWIucGxvdFRvcCksQl07ZC5zaGFwZVR5cGU9YS5wb2ludENsYXNzLnByb3RvdHlwZS5zaGFwZVR5cGV8fFwicmVjdFwiO2Quc2hhcGVBcmdzPWEuY3Jpc3BDb2wuYXBwbHkoYSxcbmQuaXNOdWxsP1tFLGssQywwXTpbRSxBLEMsQl0pfSl9O2QucHJvdG90eXBlLmRyYXdHcmFwaD1mdW5jdGlvbigpe3RoaXMuZ3JvdXBbdGhpcy5kZW5zZT9cImFkZENsYXNzXCI6XCJyZW1vdmVDbGFzc1wiXShcImhpZ2hjaGFydHMtZGVuc2UtZGF0YVwiKX07ZC5wcm90b3R5cGUucG9pbnRBdHRyaWJzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5vcHRpb25zLGU9dGhpcy5wb2ludEF0dHJUb09wdGlvbnN8fHt9O3ZhciBkPWUuc3Ryb2tlfHxcImJvcmRlckNvbG9yXCI7dmFyIGc9ZVtcInN0cm9rZS13aWR0aFwiXXx8XCJib3JkZXJXaWR0aFwiLGY9YSYmYS5jb2xvcnx8dGhpcy5jb2xvcixoPWEmJmFbZF18fGNbZF18fHRoaXMuY29sb3J8fGYsaz1hJiZhW2ddfHxjW2ddfHx0aGlzW2ddfHwwO2U9YSYmYS5vcHRpb25zLmRhc2hTdHlsZXx8Yy5kYXNoU3R5bGU7dmFyIG49bShhJiZhLm9wYWNpdHksYy5vcGFjaXR5LDEpO2lmKGEmJnRoaXMuem9uZXMubGVuZ3RoKXt2YXIgcT1hLmdldFpvbmUoKTtmPWEub3B0aW9ucy5jb2xvcnx8XG5xJiYocS5jb2xvcnx8YS5ub25ab25lZENvbG9yKXx8dGhpcy5jb2xvcjtxJiYoaD1xLmJvcmRlckNvbG9yfHxoLGU9cS5kYXNoU3R5bGV8fGUsaz1xLmJvcmRlcldpZHRofHxrKX1iJiZhJiYoYT16KGMuc3RhdGVzW2JdLGEub3B0aW9ucy5zdGF0ZXMmJmEub3B0aW9ucy5zdGF0ZXNbYl18fHt9KSxiPWEuYnJpZ2h0bmVzcyxmPWEuY29sb3J8fFwidW5kZWZpbmVkXCIhPT10eXBlb2YgYiYmbChmKS5icmlnaHRlbihhLmJyaWdodG5lc3MpLmdldCgpfHxmLGg9YVtkXXx8aCxrPWFbZ118fGssZT1hLmRhc2hTdHlsZXx8ZSxuPW0oYS5vcGFjaXR5LG4pKTtkPXtmaWxsOmYsc3Ryb2tlOmgsXCJzdHJva2Utd2lkdGhcIjprLG9wYWNpdHk6bn07ZSYmKGQuZGFzaHN0eWxlPWUpO3JldHVybiBkfTtkLnByb3RvdHlwZS5kcmF3UG9pbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPXRoaXMuY2hhcnQsYz1hLm9wdGlvbnMsZT1iLnJlbmRlcmVyLGQ9Yy5hbmltYXRpb25MaW1pdHx8MjUwLGc7YS5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihmKXt2YXIgaD1cbmYuZ3JhcGhpYyxtPSEhaCxsPWgmJmIucG9pbnRDb3VudDxkP1wiYW5pbWF0ZVwiOlwiYXR0clwiO2lmKE0oZi5wbG90WSkmJm51bGwhPT1mLnkpe2c9Zi5zaGFwZUFyZ3M7aCYmZi5oYXNOZXdTaGFwZVR5cGUoKSYmKGg9aC5kZXN0cm95KCkpO2EuZW5hYmxlZERhdGFTb3J0aW5nJiYoZi5zdGFydFhQb3M9YS54QXhpcy5yZXZlcnNlZD8tKGc/Zy53aWR0aDowKTphLnhBeGlzLndpZHRoKTtofHwoZi5ncmFwaGljPWg9ZVtmLnNoYXBlVHlwZV0oZykuYWRkKGYuZ3JvdXB8fGEuZ3JvdXApKSYmYS5lbmFibGVkRGF0YVNvcnRpbmcmJmIuaGFzUmVuZGVyZWQmJmIucG9pbnRDb3VudDxkJiYoaC5hdHRyKHt4OmYuc3RhcnRYUG9zfSksbT0hMCxsPVwiYW5pbWF0ZVwiKTtpZihoJiZtKWhbbF0oeihnKSk7aWYoYy5ib3JkZXJSYWRpdXMpaFtsXSh7cjpjLmJvcmRlclJhZGl1c30pO2Iuc3R5bGVkTW9kZXx8aFtsXShhLnBvaW50QXR0cmlicyhmLGYuc2VsZWN0ZWQmJlwic2VsZWN0XCIpKS5zaGFkb3coITEhPT1cbmYuYWxsb3dTaGFkb3cmJmMuc2hhZG93LG51bGwsYy5zdGFja2luZyYmIWMuYm9yZGVyUmFkaXVzKTtoJiYoaC5hZGRDbGFzcyhmLmdldENsYXNzTmFtZSgpLCEwKSxoLmF0dHIoe3Zpc2liaWxpdHk6Zi52aXNpYmxlP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCJ9KSl9ZWxzZSBoJiYoZi5ncmFwaGljPWguZGVzdHJveSgpKX0pfTtkLnByb3RvdHlwZS5kcmF3VHJhY2tlcj1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LGM9Yi5wb2ludGVyLGU9ZnVuY3Rpb24oYSl7dmFyIGI9Yy5nZXRQb2ludEZyb21FdmVudChhKTtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGImJihjLmlzRGlyZWN0VG91Y2g9ITAsYi5vbk1vdXNlT3ZlcihhKSl9LGQ7YS5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihhKXtkPUEoYS5kYXRhTGFiZWxzKT9hLmRhdGFMYWJlbHM6YS5kYXRhTGFiZWw/W2EuZGF0YUxhYmVsXTpbXTthLmdyYXBoaWMmJihhLmdyYXBoaWMuZWxlbWVudC5wb2ludD1hKTtkLmZvckVhY2goZnVuY3Rpb24oYil7Yi5kaXY/XG5iLmRpdi5wb2ludD1hOmIuZWxlbWVudC5wb2ludD1hfSl9KTthLl9oYXNUcmFja2luZ3x8KGEudHJhY2tlckdyb3Vwcy5mb3JFYWNoKGZ1bmN0aW9uKGQpe2lmKGFbZF0pe2FbZF0uYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXRyYWNrZXJcIikub24oXCJtb3VzZW92ZXJcIixlKS5vbihcIm1vdXNlb3V0XCIsZnVuY3Rpb24oYSl7Yy5vblRyYWNrZXJNb3VzZU91dChhKX0pO2lmKEUpYVtkXS5vbihcInRvdWNoc3RhcnRcIixlKTshYi5zdHlsZWRNb2RlJiZhLm9wdGlvbnMuY3Vyc29yJiZhW2RdLmNzcyh5KS5jc3Moe2N1cnNvcjphLm9wdGlvbnMuY3Vyc29yfSl9fSksYS5faGFzVHJhY2tpbmc9ITApO24odGhpcyxcImFmdGVyRHJhd1RyYWNrZXJcIil9O2QucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0O2IuaGFzUmVuZGVyZWQmJmIuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYil7Yi50eXBlPT09YS50eXBlJiYoYi5pc0RpcnR5PSEwKX0pO0cucHJvdG90eXBlLnJlbW92ZS5hcHBseShhLFxuYXJndW1lbnRzKX07ZC5kZWZhdWx0T3B0aW9ucz16KEcuZGVmYXVsdE9wdGlvbnMse2JvcmRlclJhZGl1czowLGNlbnRlckluQ2F0ZWdvcnk6ITEsZ3JvdXBQYWRkaW5nOi4yLG1hcmtlcjpudWxsLHBvaW50UGFkZGluZzouMSxtaW5Qb2ludExlbmd0aDowLGNyb3BUaHJlc2hvbGQ6NTAscG9pbnRSYW5nZTpudWxsLHN0YXRlczp7aG92ZXI6e2hhbG86ITEsYnJpZ2h0bmVzczouMX0sc2VsZWN0Ontjb2xvcjpCLm5ldXRyYWxDb2xvcjIwLGJvcmRlckNvbG9yOkIubmV1dHJhbENvbG9yMTAwfX0sZGF0YUxhYmVsczp7YWxpZ246dm9pZCAwLHZlcnRpY2FsQWxpZ246dm9pZCAwLHk6dm9pZCAwfSxzdGFydEZyb21UaHJlc2hvbGQ6ITAsc3RpY2t5VHJhY2tpbmc6ITEsdG9vbHRpcDp7ZGlzdGFuY2U6Nn0sdGhyZXNob2xkOjAsYm9yZGVyQ29sb3I6Qi5iYWNrZ3JvdW5kQ29sb3J9KTtyZXR1cm4gZH0oRyk7cShILnByb3RvdHlwZSx7Y3JvcFNob3VsZGVyOjAsZGlyZWN0VG91Y2g6ITAsZHJhd0xlZ2VuZFN5bWJvbDp4LmRyYXdSZWN0YW5nbGUsXG5nZXRTeW1ib2w6ZixuZWdTdGFja3M6ITAsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCJdfSk7RC5yZWdpc3RlclNlcmllc1R5cGUoXCJjb2x1bW5cIixIKTtcIlwiO1wiXCI7cmV0dXJuIEh9KTtQKGssXCJTZXJpZXMvQmFyL0JhclNlcmllcy5qc1wiLFtrW1wiU2VyaWVzL0NvbHVtbi9Db2x1bW5TZXJpZXMuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGspe3ZhciB4PXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBkPWZ1bmN0aW9uKGYsayl7ZD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oZCxmKXtkLl9fcHJvdG9fXz1mfXx8ZnVuY3Rpb24oZCxmKXtmb3IodmFyIGwgaW4gZilmLmhhc093blByb3BlcnR5KGwpJiYoZFtsXT1mW2xdKX07cmV0dXJuIGQoZixrKX07cmV0dXJuIGZ1bmN0aW9uKGYsXG5rKXtmdW5jdGlvbiB0KCl7dGhpcy5jb25zdHJ1Y3Rvcj1mfWQoZixrKTtmLnByb3RvdHlwZT1udWxsPT09az9PYmplY3QuY3JlYXRlKGspOih0LnByb3RvdHlwZT1rLnByb3RvdHlwZSxuZXcgdCl9fSgpLEI9ay5leHRlbmQsRz1rLm1lcmdlO2s9ZnVuY3Rpb24oZCl7ZnVuY3Rpb24gaygpe3ZhciBmPW51bGwhPT1kJiZkLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztmLmRhdGE9dm9pZCAwO2Yub3B0aW9ucz12b2lkIDA7Zi5wb2ludHM9dm9pZCAwO3JldHVybiBmfXgoayxkKTtrLmRlZmF1bHRPcHRpb25zPUcoZi5kZWZhdWx0T3B0aW9ucyx7fSk7cmV0dXJuIGt9KGYpO0Ioay5wcm90b3R5cGUse2ludmVydGVkOiEwfSk7ZC5yZWdpc3RlclNlcmllc1R5cGUoXCJiYXJcIixrKTtcIlwiO3JldHVybiBrfSk7UChrLFwiU2VyaWVzL1NjYXR0ZXIvU2NhdHRlclNlcmllcy5qc1wiLFtrW1wiU2VyaWVzL0NvbHVtbi9Db2x1bW5TZXJpZXMuanNcIl0sa1tcIlNlcmllcy9MaW5lL0xpbmVTZXJpZXMuanNcIl0sXG5rW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4KXt2YXIgQj10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgZD1mdW5jdGlvbihmLGwpe2Q9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGQsZyl7ZC5fX3Byb3RvX189Z318fGZ1bmN0aW9uKGQsZyl7Zm9yKHZhciBmIGluIGcpZy5oYXNPd25Qcm9wZXJ0eShmKSYmKGRbZl09Z1tmXSl9O3JldHVybiBkKGYsbCl9O3JldHVybiBmdW5jdGlvbihmLGwpe2Z1bmN0aW9uIGsoKXt0aGlzLmNvbnN0cnVjdG9yPWZ9ZChmLGwpO2YucHJvdG90eXBlPW51bGw9PT1sP09iamVjdC5jcmVhdGUobCk6KGsucHJvdG90eXBlPWwucHJvdG90eXBlLG5ldyBrKX19KCksRz14LmFkZEV2ZW50LEQ9eC5leHRlbmQsSD14Lm1lcmdlO3g9ZnVuY3Rpb24oZil7ZnVuY3Rpb24gaygpe3ZhciBkPVxubnVsbCE9PWYmJmYuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO2QuZGF0YT12b2lkIDA7ZC5vcHRpb25zPXZvaWQgMDtkLnBvaW50cz12b2lkIDA7cmV0dXJuIGR9QihrLGYpO2sucHJvdG90eXBlLmFwcGx5Sml0dGVyPWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcyxmPXRoaXMub3B0aW9ucy5qaXR0ZXIsZz10aGlzLnBvaW50cy5sZW5ndGg7ZiYmdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihsLGMpe1tcInhcIixcInlcIl0uZm9yRWFjaChmdW5jdGlvbihrLG4pe3ZhciBxPVwicGxvdFwiK2sudG9VcHBlckNhc2UoKTtpZihmW2tdJiYhbC5pc051bGwpe3ZhciB0PWRbaytcIkF4aXNcIl07dmFyIHo9ZltrXSp0LnRyYW5zQTtpZih0JiYhdC5pc0xvZyl7dmFyIG09TWF0aC5tYXgoMCxsW3FdLXopO3Q9TWF0aC5taW4odC5sZW4sbFtxXSt6KTtuPTFFNCpNYXRoLnNpbihjK24qZyk7bFtxXT1tKyh0LW0pKihuLU1hdGguZmxvb3IobikpO1wieFwiPT09ayYmKGwuY2xpZW50WD1sLnBsb3RYKX19fSl9KX07XG5rLnByb3RvdHlwZS5kcmF3R3JhcGg9ZnVuY3Rpb24oKXsodGhpcy5vcHRpb25zLmxpbmVXaWR0aHx8MD09PXRoaXMub3B0aW9ucy5saW5lV2lkdGgmJnRoaXMuZ3JhcGgmJnRoaXMuZ3JhcGguc3Ryb2tlV2lkdGgoKSkmJmYucHJvdG90eXBlLmRyYXdHcmFwaC5jYWxsKHRoaXMpfTtrLmRlZmF1bHRPcHRpb25zPUgoZC5kZWZhdWx0T3B0aW9ucyx7bGluZVdpZHRoOjAsZmluZE5lYXJlc3RQb2ludEJ5OlwieHlcIixqaXR0ZXI6e3g6MCx5OjB9LG1hcmtlcjp7ZW5hYmxlZDohMH0sdG9vbHRpcDp7aGVhZGVyRm9ybWF0Oic8c3BhbiBzdHlsZT1cImNvbG9yOntwb2ludC5jb2xvcn1cIj5cXHUyNWNmPC9zcGFuPiA8c3BhbiBzdHlsZT1cImZvbnQtc2l6ZTogMTBweFwiPiB7c2VyaWVzLm5hbWV9PC9zcGFuPjxici8+Jyxwb2ludEZvcm1hdDpcIng6IDxiPntwb2ludC54fTwvYj48YnIvPnk6IDxiPntwb2ludC55fTwvYj48YnIvPlwifX0pO3JldHVybiBrfShkKTtEKHgucHJvdG90eXBlLHtkcmF3VHJhY2tlcjpmLnByb3RvdHlwZS5kcmF3VHJhY2tlcixcbnNvcnRlZDohMSxyZXF1aXJlU29ydGluZzohMSxub1NoYXJlZFRvb2x0aXA6ITAsdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwibWFya2VyR3JvdXBcIixcImRhdGFMYWJlbHNHcm91cFwiXSx0YWtlT3JkaW5hbFBvc2l0aW9uOiExfSk7Ryh4LFwiYWZ0ZXJUcmFuc2xhdGVcIixmdW5jdGlvbigpe3RoaXMuYXBwbHlKaXR0ZXIoKX0pO2sucmVnaXN0ZXJTZXJpZXNUeXBlKFwic2NhdHRlclwiLHgpO1wiXCI7cmV0dXJuIHh9KTtQKGssXCJNaXhpbnMvQ2VudGVyZWRTZXJpZXMuanNcIixba1tcIkNvcmUvR2xvYmFscy5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvU2VyaWVzLmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGspe3ZhciB4PWsuaXNOdW1iZXIsQj1rLnBpY2ssRz1rLnJlbGF0aXZlTGVuZ3RoLEQ9Zi5kZWcycmFkO3JldHVybiBmLkNlbnRlcmVkU2VyaWVzTWl4aW49e2dldENlbnRlcjpmdW5jdGlvbigpe3ZhciBmPXRoaXMub3B0aW9ucyxrPXRoaXMuY2hhcnQseD0yKihmLnNsaWNlZE9mZnNldHx8XG4wKSxsPWsucGxvdFdpZHRoLTIqeCxFPWsucGxvdEhlaWdodC0yKngsZz1mLmNlbnRlcix5PU1hdGgubWluKGwsRSksYz1mLnNpemUscT1mLmlubmVyU2l6ZXx8MDtcInN0cmluZ1wiPT09dHlwZW9mIGMmJihjPXBhcnNlRmxvYXQoYykpO1wic3RyaW5nXCI9PT10eXBlb2YgcSYmKHE9cGFyc2VGbG9hdChxKSk7Zj1bQihnWzBdLFwiNTAlXCIpLEIoZ1sxXSxcIjUwJVwiKSxCKGMmJjA+Yz92b2lkIDA6Zi5zaXplLFwiMTAwJVwiKSxCKHEmJjA+cT92b2lkIDA6Zi5pbm5lclNpemV8fDAsXCIwJVwiKV07IWsuYW5ndWxhcnx8dGhpcyBpbnN0YW5jZW9mIGR8fChmWzNdPTApO2ZvcihnPTA7ND5nOysrZyljPWZbZ10saz0yPmd8fDI9PT1nJiYvJSQvLnRlc3QoYyksZltnXT1HKGMsW2wsRSx5LGZbMl1dW2ddKSsoaz94OjApO2ZbM10+ZlsyXSYmKGZbM109ZlsyXSk7cmV0dXJuIGZ9LGdldFN0YXJ0QW5kRW5kUmFkaWFuczpmdW5jdGlvbihkLGYpe2Q9eChkKT9kOjA7Zj14KGYpJiZmPmQmJjM2MD5mLWQ/ZjpkKzM2MDtcbnJldHVybntzdGFydDpEKihkKy05MCksZW5kOkQqKGYrLTkwKX19fX0pO1AoayxcIlNlcmllcy9QaWUvUGllUG9pbnQuanNcIixba1tcIkNvcmUvQW5pbWF0aW9uL0FuaW1hdGlvblV0aWxpdGllcy5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvUG9pbnQuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayl7dmFyIHg9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fGZ1bmN0aW9uKCl7dmFyIGQ9ZnVuY3Rpb24oZixnKXtkPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbihkLGMpe2QuX19wcm90b19fPWN9fHxmdW5jdGlvbihkLGMpe2Zvcih2YXIgZyBpbiBjKWMuaGFzT3duUHJvcGVydHkoZykmJihkW2ddPWNbZ10pfTtyZXR1cm4gZChmLGcpfTtyZXR1cm4gZnVuY3Rpb24oZixnKXtmdW5jdGlvbiBsKCl7dGhpcy5jb25zdHJ1Y3Rvcj1mfWQoZixnKTtmLnByb3RvdHlwZT1udWxsPT09Zz9PYmplY3QuY3JlYXRlKGcpOlxuKGwucHJvdG90eXBlPWcucHJvdG90eXBlLG5ldyBsKX19KCksQj1mLnNldEFuaW1hdGlvbixHPWsuYWRkRXZlbnQsRD1rLmRlZmluZWQ7Zj1rLmV4dGVuZDt2YXIgSD1rLmlzTnVtYmVyLHQ9ay5waWNrLEM9ay5yZWxhdGl2ZUxlbmd0aDtrPWZ1bmN0aW9uKGYpe2Z1bmN0aW9uIGwoKXt2YXIgZD1udWxsIT09ZiYmZi5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7ZC5sYWJlbERpc3RhbmNlPXZvaWQgMDtkLm9wdGlvbnM9dm9pZCAwO2Quc2VyaWVzPXZvaWQgMDtyZXR1cm4gZH14KGwsZik7bC5wcm90b3R5cGUuZ2V0Q29ubmVjdG9yUGF0aD1mdW5jdGlvbigpe3ZhciBkPXRoaXMubGFiZWxQb3NpdGlvbixmPXRoaXMuc2VyaWVzLm9wdGlvbnMuZGF0YUxhYmVscyxjPWYuY29ubmVjdG9yU2hhcGUsbD10aGlzLmNvbm5lY3RvclNoYXBlcztsW2NdJiYoYz1sW2NdKTtyZXR1cm4gYy5jYWxsKHRoaXMse3g6ZC5maW5hbC54LHk6ZC5maW5hbC55LGFsaWdubWVudDpkLmFsaWdubWVudH0sXG5kLmNvbm5lY3RvclBvc2l0aW9uLGYpfTtsLnByb3RvdHlwZS5nZXRUcmFuc2xhdGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zbGljZWQ/dGhpcy5zbGljZWRUcmFuc2xhdGlvbjp7dHJhbnNsYXRlWDowLHRyYW5zbGF0ZVk6MH19O2wucHJvdG90eXBlLmhhbG9QYXRoPWZ1bmN0aW9uKGQpe3ZhciBmPXRoaXMuc2hhcGVBcmdzO3JldHVybiB0aGlzLnNsaWNlZHx8IXRoaXMudmlzaWJsZT9bXTp0aGlzLnNlcmllcy5jaGFydC5yZW5kZXJlci5zeW1ib2xzLmFyYyhmLngsZi55LGYucitkLGYucitkLHtpbm5lclI6Zi5yLTEsc3RhcnQ6Zi5zdGFydCxlbmQ6Zi5lbmR9KX07bC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe2QucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciBmPXRoaXM7Zi5uYW1lPXQoZi5uYW1lLFwiU2xpY2VcIik7dmFyIGw9ZnVuY3Rpb24oYyl7Zi5zbGljZShcInNlbGVjdFwiPT09Yy50eXBlKX07RyhmLFwic2VsZWN0XCIsbCk7RyhmLFwidW5zZWxlY3RcIixcbmwpO3JldHVybiBmfTtsLnByb3RvdHlwZS5pc1ZhbGlkPWZ1bmN0aW9uKCl7cmV0dXJuIEgodGhpcy55KSYmMDw9dGhpcy55fTtsLnByb3RvdHlwZS5zZXRWaXNpYmxlPWZ1bmN0aW9uKGQsZil7dmFyIGM9dGhpcyxnPWMuc2VyaWVzLGw9Zy5jaGFydCxrPWcub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtmPXQoZixrKTtkIT09Yy52aXNpYmxlJiYoYy52aXNpYmxlPWMub3B0aW9ucy52aXNpYmxlPWQ9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBkPyFjLnZpc2libGU6ZCxnLm9wdGlvbnMuZGF0YVtnLmRhdGEuaW5kZXhPZihjKV09Yy5vcHRpb25zLFtcImdyYXBoaWNcIixcImRhdGFMYWJlbFwiLFwiY29ubmVjdG9yXCIsXCJzaGFkb3dHcm91cFwiXS5mb3JFYWNoKGZ1bmN0aW9uKGYpe2lmKGNbZl0pY1tmXVtkP1wic2hvd1wiOlwiaGlkZVwiXShkKX0pLGMubGVnZW5kSXRlbSYmbC5sZWdlbmQuY29sb3JpemVJdGVtKGMsZCksZHx8XCJob3ZlclwiIT09Yy5zdGF0ZXx8Yy5zZXRTdGF0ZShcIlwiKSxrJiYoZy5pc0RpcnR5PVxuITApLGYmJmwucmVkcmF3KCkpfTtsLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihkLGYsYyl7dmFyIGc9dGhpcy5zZXJpZXM7QihjLGcuY2hhcnQpO3QoZiwhMCk7dGhpcy5zbGljZWQ9dGhpcy5vcHRpb25zLnNsaWNlZD1EKGQpP2Q6IXRoaXMuc2xpY2VkO2cub3B0aW9ucy5kYXRhW2cuZGF0YS5pbmRleE9mKHRoaXMpXT10aGlzLm9wdGlvbnM7dGhpcy5ncmFwaGljJiZ0aGlzLmdyYXBoaWMuYW5pbWF0ZSh0aGlzLmdldFRyYW5zbGF0ZSgpKTt0aGlzLnNoYWRvd0dyb3VwJiZ0aGlzLnNoYWRvd0dyb3VwLmFuaW1hdGUodGhpcy5nZXRUcmFuc2xhdGUoKSl9O3JldHVybiBsfShkKTtmKGsucHJvdG90eXBlLHtjb25uZWN0b3JTaGFwZXM6e2ZpeGVkT2Zmc2V0OmZ1bmN0aW9uKGQsZixnKXt2YXIgbD1mLmJyZWFrQXQ7Zj1mLnRvdWNoaW5nU2xpY2VBdDtyZXR1cm5bW1wiTVwiLGQueCxkLnldLGcuc29mdENvbm5lY3Rvcj9bXCJDXCIsZC54KyhcImxlZnRcIj09PWQuYWxpZ25tZW50Py01OjUpLGQueSxcbjIqbC54LWYueCwyKmwueS1mLnksbC54LGwueV06W1wiTFwiLGwueCxsLnldLFtcIkxcIixmLngsZi55XV19LHN0cmFpZ2h0OmZ1bmN0aW9uKGQsZil7Zj1mLnRvdWNoaW5nU2xpY2VBdDtyZXR1cm5bW1wiTVwiLGQueCxkLnldLFtcIkxcIixmLngsZi55XV19LGNyb29rZWRMaW5lOmZ1bmN0aW9uKGQsZixnKXtmPWYudG91Y2hpbmdTbGljZUF0O3ZhciBsPXRoaXMuc2VyaWVzLGM9bC5jZW50ZXJbMF0saz1sLmNoYXJ0LnBsb3RXaWR0aCxuPWwuY2hhcnQucGxvdExlZnQ7bD1kLmFsaWdubWVudDt2YXIgdD10aGlzLnNoYXBlQXJncy5yO2c9QyhnLmNyb29rRGlzdGFuY2UsMSk7az1cImxlZnRcIj09PWw/Yyt0KyhrK24tYy10KSooMS1nKTpuKyhjLXQpKmc7Zz1bXCJMXCIsayxkLnldO2M9ITA7aWYoXCJsZWZ0XCI9PT1sP2s+ZC54fHxrPGYueDprPGQueHx8az5mLngpYz0hMTtkPVtbXCJNXCIsZC54LGQueV1dO2MmJmQucHVzaChnKTtkLnB1c2goW1wiTFwiLGYueCxmLnldKTtyZXR1cm4gZH19fSk7cmV0dXJuIGt9KTtcblAoayxcIlNlcmllcy9QaWUvUGllU2VyaWVzLmpzXCIsW2tbXCJNaXhpbnMvQ2VudGVyZWRTZXJpZXMuanNcIl0sa1tcIlNlcmllcy9Db2x1bW4vQ29sdW1uU2VyaWVzLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIk1peGlucy9MZWdlbmRTeW1ib2wuanNcIl0sa1tcIkNvcmUvQ29sb3IvUGFsZXR0ZS5qc1wiXSxrW1wiU2VyaWVzL1BpZS9QaWVQb2ludC5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvU2VyaWVzLmpzXCJdLGtbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxrW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHUmVuZGVyZXIuanNcIl0sa1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4LEIsRyxELEgsdCxDKXt2YXIgbD10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgYz1mdW5jdGlvbihkLGYpe2M9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGMsZSl7Yy5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKGMsXG5lKXtmb3IodmFyIGQgaW4gZSllLmhhc093blByb3BlcnR5KGQpJiYoY1tkXT1lW2RdKX07cmV0dXJuIGMoZCxmKX07cmV0dXJuIGZ1bmN0aW9uKGQsZil7ZnVuY3Rpb24gZygpe3RoaXMuY29uc3RydWN0b3I9ZH1jKGQsZik7ZC5wcm90b3R5cGU9bnVsbD09PWY/T2JqZWN0LmNyZWF0ZShmKTooZy5wcm90b3R5cGU9Zi5wcm90b3R5cGUsbmV3IGcpfX0oKSxFPWYuZ2V0U3RhcnRBbmRFbmRSYWRpYW5zO2s9ay5ub29wO3ZhciBnPUMuY2xhbXAseT1DLmV4dGVuZCxjPUMuZmlyZUV2ZW50LHE9Qy5tZXJnZSxuPUMucGljayxBPUMucmVsYXRpdmVMZW5ndGg7Qz1mdW5jdGlvbihkKXtmdW5jdGlvbiBmKCl7dmFyIGM9bnVsbCE9PWQmJmQuYXBwbHkodGhpcyxhcmd1bWVudHMpfHx0aGlzO2MuY2VudGVyPXZvaWQgMDtjLmRhdGE9dm9pZCAwO2MubWF4TGFiZWxEaXN0YW5jZT12b2lkIDA7Yy5vcHRpb25zPXZvaWQgMDtjLnBvaW50cz12b2lkIDA7cmV0dXJuIGN9bChmLGQpO2YucHJvdG90eXBlLmFuaW1hdGU9XG5mdW5jdGlvbihjKXt2YXIgZD10aGlzLGU9ZC5wb2ludHMsZj1kLnN0YXJ0QW5nbGVSYWQ7Y3x8ZS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEuZ3JhcGhpYyxjPWEuc2hhcGVBcmdzO2ImJmMmJihiLmF0dHIoe3I6bihhLnN0YXJ0UixkLmNlbnRlciYmZC5jZW50ZXJbM10vMiksc3RhcnQ6ZixlbmQ6Zn0pLGIuYW5pbWF0ZSh7cjpjLnIsc3RhcnQ6Yy5zdGFydCxlbmQ6Yy5lbmR9LGQub3B0aW9ucy5hbmltYXRpb24pKX0pfTtmLnByb3RvdHlwZS5kcmF3RW1wdHk9ZnVuY3Rpb24oKXt2YXIgYz10aGlzLnN0YXJ0QW5nbGVSYWQsZD10aGlzLmVuZEFuZ2xlUmFkLGU9dGhpcy5vcHRpb25zO2lmKDA9PT10aGlzLnRvdGFsJiZ0aGlzLmNlbnRlcil7dmFyIGY9dGhpcy5jZW50ZXJbMF07dmFyIGE9dGhpcy5jZW50ZXJbMV07dGhpcy5ncmFwaHx8KHRoaXMuZ3JhcGg9dGhpcy5jaGFydC5yZW5kZXJlci5hcmMoZixhLHRoaXMuY2VudGVyWzFdLzIsMCxjLGQpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1lbXB0eS1zZXJpZXNcIikuYWRkKHRoaXMuZ3JvdXApKTtcbnRoaXMuZ3JhcGguYXR0cih7ZDp0LnByb3RvdHlwZS5zeW1ib2xzLmFyYyhmLGEsdGhpcy5jZW50ZXJbMl0vMiwwLHtzdGFydDpjLGVuZDpkLGlubmVyUjp0aGlzLmNlbnRlclszXS8yfSl9KTt0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fHRoaXMuZ3JhcGguYXR0cih7XCJzdHJva2Utd2lkdGhcIjplLmJvcmRlcldpZHRoLGZpbGw6ZS5maWxsQ29sb3J8fFwibm9uZVwiLHN0cm9rZTplLmNvbG9yfHxCLm5ldXRyYWxDb2xvcjIwfSl9ZWxzZSB0aGlzLmdyYXBoJiYodGhpcy5ncmFwaD10aGlzLmdyYXBoLmRlc3Ryb3koKSl9O2YucHJvdG90eXBlLmRyYXdQb2ludHM9ZnVuY3Rpb24oKXt2YXIgYz10aGlzLmNoYXJ0LnJlbmRlcmVyO3RoaXMucG9pbnRzLmZvckVhY2goZnVuY3Rpb24oZCl7ZC5ncmFwaGljJiZkLmhhc05ld1NoYXBlVHlwZSgpJiYoZC5ncmFwaGljPWQuZ3JhcGhpYy5kZXN0cm95KCkpO2QuZ3JhcGhpY3x8KGQuZ3JhcGhpYz1jW2Quc2hhcGVUeXBlXShkLnNoYXBlQXJncykuYWRkKGQuc2VyaWVzLmdyb3VwKSxcbmQuZGVsYXllZFJlbmRlcmluZz0hMCl9KX07Zi5wcm90b3R5cGUuZ2VuZXJhdGVQb2ludHM9ZnVuY3Rpb24oKXtkLnByb3RvdHlwZS5nZW5lcmF0ZVBvaW50cy5jYWxsKHRoaXMpO3RoaXMudXBkYXRlVG90YWxzKCl9O2YucHJvdG90eXBlLmdldFg9ZnVuY3Rpb24oYyxkLGUpe3ZhciBmPXRoaXMuY2VudGVyLGE9dGhpcy5yYWRpaT90aGlzLnJhZGlpW2UuaW5kZXhdfHwwOmZbMl0vMjtjPU1hdGguYXNpbihnKChjLWZbMV0pLyhhK2UubGFiZWxEaXN0YW5jZSksLTEsMSkpO3JldHVybiBmWzBdKyhkPy0xOjEpKk1hdGguY29zKGMpKihhK2UubGFiZWxEaXN0YW5jZSkrKDA8ZS5sYWJlbERpc3RhbmNlPyhkPy0xOjEpKnRoaXMub3B0aW9ucy5kYXRhTGFiZWxzLnBhZGRpbmc6MCl9O2YucHJvdG90eXBlLmhhc0RhdGE9ZnVuY3Rpb24oKXtyZXR1cm4hIXRoaXMucHJvY2Vzc2VkWERhdGEubGVuZ3RofTtmLnByb3RvdHlwZS5yZWRyYXdQb2ludHM9ZnVuY3Rpb24oKXt2YXIgYz10aGlzLGQ9Yy5jaGFydCxcbmU9ZC5yZW5kZXJlcixmLGEsYixnLGw9Yy5vcHRpb25zLnNoYWRvdzt0aGlzLmRyYXdFbXB0eSgpOyFsfHxjLnNoYWRvd0dyb3VwfHxkLnN0eWxlZE1vZGV8fChjLnNoYWRvd0dyb3VwPWUuZyhcInNoYWRvd1wiKS5hdHRyKHt6SW5kZXg6LTF9KS5hZGQoYy5ncm91cCkpO2MucG9pbnRzLmZvckVhY2goZnVuY3Rpb24oaCl7dmFyIG09e307YT1oLmdyYXBoaWM7aWYoIWguaXNOdWxsJiZhKXtnPWguc2hhcGVBcmdzO2Y9aC5nZXRUcmFuc2xhdGUoKTtpZighZC5zdHlsZWRNb2RlKXt2YXIgaz1oLnNoYWRvd0dyb3VwO2wmJiFrJiYoaz1oLnNoYWRvd0dyb3VwPWUuZyhcInNoYWRvd1wiKS5hZGQoYy5zaGFkb3dHcm91cCkpO2smJmsuYXR0cihmKTtiPWMucG9pbnRBdHRyaWJzKGgsaC5zZWxlY3RlZCYmXCJzZWxlY3RcIil9aC5kZWxheWVkUmVuZGVyaW5nPyhhLnNldFJhZGlhbFJlZmVyZW5jZShjLmNlbnRlcikuYXR0cihnKS5hdHRyKGYpLGQuc3R5bGVkTW9kZXx8YS5hdHRyKGIpLmF0dHIoe1wic3Ryb2tlLWxpbmVqb2luXCI6XCJyb3VuZFwifSkuc2hhZG93KGwsXG5rKSxoLmRlbGF5ZWRSZW5kZXJpbmc9ITEpOihhLnNldFJhZGlhbFJlZmVyZW5jZShjLmNlbnRlciksZC5zdHlsZWRNb2RlfHxxKCEwLG0sYikscSghMCxtLGcsZiksYS5hbmltYXRlKG0pKTthLmF0dHIoe3Zpc2liaWxpdHk6aC52aXNpYmxlP1wiaW5oZXJpdFwiOlwiaGlkZGVuXCJ9KTthLmFkZENsYXNzKGguZ2V0Q2xhc3NOYW1lKCksITApfWVsc2UgYSYmKGguZ3JhcGhpYz1hLmRlc3Ryb3koKSl9KX07Zi5wcm90b3R5cGUuc29ydEJ5QW5nbGU9ZnVuY3Rpb24oYyxkKXtjLnNvcnQoZnVuY3Rpb24oYyxmKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGMuYW5nbGUmJihmLmFuZ2xlLWMuYW5nbGUpKmR9KX07Zi5wcm90b3R5cGUudHJhbnNsYXRlPWZ1bmN0aW9uKGQpe3RoaXMuZ2VuZXJhdGVQb2ludHMoKTt2YXIgZj0wLGU9dGhpcy5vcHRpb25zLGc9ZS5zbGljZWRPZmZzZXQsYT1nKyhlLmJvcmRlcldpZHRofHwwKSxiPUUoZS5zdGFydEFuZ2xlLGUuZW5kQW5nbGUpLG09dGhpcy5zdGFydEFuZ2xlUmFkPVxuYi5zdGFydDtiPSh0aGlzLmVuZEFuZ2xlUmFkPWIuZW5kKS1tO3ZhciBsPXRoaXMucG9pbnRzLGs9ZS5kYXRhTGFiZWxzLmRpc3RhbmNlO2U9ZS5pZ25vcmVIaWRkZW5Qb2ludDt2YXIgcSx0PWwubGVuZ3RoO2R8fCh0aGlzLmNlbnRlcj1kPXRoaXMuZ2V0Q2VudGVyKCkpO2ZvcihxPTA7cTx0O3ErKyl7dmFyIHo9bFtxXTt2YXIgeD1tK2YqYjshei5pc1ZhbGlkKCl8fGUmJiF6LnZpc2libGV8fChmKz16LnBlcmNlbnRhZ2UvMTAwKTt2YXIgeT1tK2YqYjt6LnNoYXBlVHlwZT1cImFyY1wiO3ouc2hhcGVBcmdzPXt4OmRbMF0seTpkWzFdLHI6ZFsyXS8yLGlubmVyUjpkWzNdLzIsc3RhcnQ6TWF0aC5yb3VuZCgxRTMqeCkvMUUzLGVuZDpNYXRoLnJvdW5kKDFFMyp5KS8xRTN9O3oubGFiZWxEaXN0YW5jZT1uKHoub3B0aW9ucy5kYXRhTGFiZWxzJiZ6Lm9wdGlvbnMuZGF0YUxhYmVscy5kaXN0YW5jZSxrKTt6LmxhYmVsRGlzdGFuY2U9QSh6LmxhYmVsRGlzdGFuY2Usei5zaGFwZUFyZ3Mucik7XG50aGlzLm1heExhYmVsRGlzdGFuY2U9TWF0aC5tYXgodGhpcy5tYXhMYWJlbERpc3RhbmNlfHwwLHoubGFiZWxEaXN0YW5jZSk7eT0oeSt4KS8yO3k+MS41Kk1hdGguUEk/eS09MipNYXRoLlBJOnk8LU1hdGguUEkvMiYmKHkrPTIqTWF0aC5QSSk7ei5zbGljZWRUcmFuc2xhdGlvbj17dHJhbnNsYXRlWDpNYXRoLnJvdW5kKE1hdGguY29zKHkpKmcpLHRyYW5zbGF0ZVk6TWF0aC5yb3VuZChNYXRoLnNpbih5KSpnKX07dmFyIHY9TWF0aC5jb3MoeSkqZFsyXS8yO3ZhciBDPU1hdGguc2luKHkpKmRbMl0vMjt6LnRvb2x0aXBQb3M9W2RbMF0rLjcqdixkWzFdKy43KkNdO3ouaGFsZj15PC1NYXRoLlBJLzJ8fHk+TWF0aC5QSS8yPzE6MDt6LmFuZ2xlPXk7eD1NYXRoLm1pbihhLHoubGFiZWxEaXN0YW5jZS81KTt6LmxhYmVsUG9zaXRpb249e25hdHVyYWw6e3g6ZFswXSt2K01hdGguY29zKHkpKnoubGFiZWxEaXN0YW5jZSx5OmRbMV0rQytNYXRoLnNpbih5KSp6LmxhYmVsRGlzdGFuY2V9LFwiZmluYWxcIjp7fSxcbmFsaWdubWVudDowPnoubGFiZWxEaXN0YW5jZT9cImNlbnRlclwiOnouaGFsZj9cInJpZ2h0XCI6XCJsZWZ0XCIsY29ubmVjdG9yUG9zaXRpb246e2JyZWFrQXQ6e3g6ZFswXSt2K01hdGguY29zKHkpKngseTpkWzFdK0MrTWF0aC5zaW4oeSkqeH0sdG91Y2hpbmdTbGljZUF0Ont4OmRbMF0rdix5OmRbMV0rQ319fX1jKHRoaXMsXCJhZnRlclRyYW5zbGF0ZVwiKX07Zi5wcm90b3R5cGUudXBkYXRlVG90YWxzPWZ1bmN0aW9uKCl7dmFyIGMsZD0wLGU9dGhpcy5wb2ludHMsZj1lLmxlbmd0aCxhPXRoaXMub3B0aW9ucy5pZ25vcmVIaWRkZW5Qb2ludDtmb3IoYz0wO2M8ZjtjKyspe3ZhciBiPWVbY107IWIuaXNWYWxpZCgpfHxhJiYhYi52aXNpYmxlfHwoZCs9Yi55KX10aGlzLnRvdGFsPWQ7Zm9yKGM9MDtjPGY7YysrKWI9ZVtjXSxiLnBlcmNlbnRhZ2U9MDxkJiYoYi52aXNpYmxlfHwhYSk/Yi55L2QqMTAwOjAsYi50b3RhbD1kfTtmLmRlZmF1bHRPcHRpb25zPXEoRC5kZWZhdWx0T3B0aW9ucyx7Y2VudGVyOltudWxsLFxubnVsbF0sY2xpcDohMSxjb2xvckJ5UG9pbnQ6ITAsZGF0YUxhYmVsczp7YWxsb3dPdmVybGFwOiEwLGNvbm5lY3RvclBhZGRpbmc6NSxjb25uZWN0b3JTaGFwZTpcImZpeGVkT2Zmc2V0XCIsY3Jvb2tEaXN0YW5jZTpcIjcwJVwiLGRpc3RhbmNlOjMwLGVuYWJsZWQ6ITAsZm9ybWF0dGVyOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnQuaXNOdWxsP3ZvaWQgMDp0aGlzLnBvaW50Lm5hbWV9LHNvZnRDb25uZWN0b3I6ITAseDowfSxmaWxsQ29sb3I6dm9pZCAwLGlnbm9yZUhpZGRlblBvaW50OiEwLGluYWN0aXZlT3RoZXJQb2ludHM6ITAsbGVnZW5kVHlwZTpcInBvaW50XCIsbWFya2VyOm51bGwsc2l6ZTpudWxsLHNob3dJbkxlZ2VuZDohMSxzbGljZWRPZmZzZXQ6MTAsc3RpY2t5VHJhY2tpbmc6ITEsdG9vbHRpcDp7Zm9sbG93UG9pbnRlcjohMH0sYm9yZGVyQ29sb3I6Qi5iYWNrZ3JvdW5kQ29sb3IsYm9yZGVyV2lkdGg6MSxsaW5lV2lkdGg6dm9pZCAwLHN0YXRlczp7aG92ZXI6e2JyaWdodG5lc3M6LjF9fX0pO1xucmV0dXJuIGZ9KEQpO3koQy5wcm90b3R5cGUse2F4aXNUeXBlczpbXSxkaXJlY3RUb3VjaDohMCxkcmF3R3JhcGg6bnVsbCxkcmF3TGVnZW5kU3ltYm9sOnguZHJhd1JlY3RhbmdsZSxkcmF3VHJhY2tlcjpkLnByb3RvdHlwZS5kcmF3VHJhY2tlcixnZXRDZW50ZXI6Zi5nZXRDZW50ZXIsZ2V0U3ltYm9sOmssaXNDYXJ0ZXNpYW46ITEsbm9TaGFyZWRUb29sdGlwOiEwLHBvaW50QXR0cmliczpkLnByb3RvdHlwZS5wb2ludEF0dHJpYnMscG9pbnRDbGFzczpHLHJlcXVpcmVTb3J0aW5nOiExLHNlYXJjaFBvaW50OmssdHJhY2tlckdyb3VwczpbXCJncm91cFwiLFwiZGF0YUxhYmVsc0dyb3VwXCJdfSk7SC5yZWdpc3RlclNlcmllc1R5cGUoXCJwaWVcIixDKTtcIlwiO3JldHVybiBDfSk7UChrLFwiQ29yZS9TZXJpZXMvRGF0YUxhYmVscy5qc1wiLFtrW1wiQ29yZS9BbmltYXRpb24vQW5pbWF0aW9uVXRpbGl0aWVzLmpzXCJdLGtbXCJDb3JlL0dsb2JhbHMuanNcIl0sa1tcIkNvcmUvQ29sb3IvUGFsZXR0ZS5qc1wiXSxcbmtbXCJDb3JlL1Nlcmllcy9TZXJpZXMuanNcIl0sa1tcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkLGsseCxCLEcpe3ZhciBEPWYuZ2V0RGVmZXJyZWRBbmltYXRpb247Zj1kLm5vb3A7Qj1CLnNlcmllc1R5cGVzO3ZhciBIPUcuYXJyYXlNYXgsdD1HLmNsYW1wLEM9Ry5kZWZpbmVkLGw9Ry5leHRlbmQsRT1HLmZpcmVFdmVudCxnPUcuZm9ybWF0LHk9Ry5pc0FycmF5LGM9Ry5tZXJnZSxxPUcub2JqZWN0RWFjaCxuPUcucGljayxBPUcucmVsYXRpdmVMZW5ndGgsTT1HLnNwbGF0LHo9Ry5zdGFibGVTb3J0O1wiXCI7ZC5kaXN0cmlidXRlPWZ1bmN0aW9uKGMsZixlKXtmdW5jdGlvbiBnKGEsYil7cmV0dXJuIGEudGFyZ2V0LWIudGFyZ2V0fXZhciBhLGI9ITAsbT1jLGw9W107dmFyIGs9MDt2YXIgcT1tLnJlZHVjZWRMZW58fGY7Zm9yKGE9Yy5sZW5ndGg7YS0tOylrKz1jW2FdLnNpemU7aWYoaz5xKXt6KGMsZnVuY3Rpb24oYSxcbmIpe3JldHVybihiLnJhbmt8fDApLShhLnJhbmt8fDApfSk7Zm9yKGs9YT0wO2s8PXE7KWsrPWNbYV0uc2l6ZSxhKys7bD1jLnNwbGljZShhLTEsYy5sZW5ndGgpfXooYyxnKTtmb3IoYz1jLm1hcChmdW5jdGlvbihhKXtyZXR1cm57c2l6ZTphLnNpemUsdGFyZ2V0czpbYS50YXJnZXRdLGFsaWduOm4oYS5hbGlnbiwuNSl9fSk7Yjspe2ZvcihhPWMubGVuZ3RoO2EtLTspYj1jW2FdLGs9KE1hdGgubWluLmFwcGx5KDAsYi50YXJnZXRzKStNYXRoLm1heC5hcHBseSgwLGIudGFyZ2V0cykpLzIsYi5wb3M9dChrLWIuc2l6ZSpiLmFsaWduLDAsZi1iLnNpemUpO2E9Yy5sZW5ndGg7Zm9yKGI9ITE7YS0tOykwPGEmJmNbYS0xXS5wb3MrY1thLTFdLnNpemU+Y1thXS5wb3MmJihjW2EtMV0uc2l6ZSs9Y1thXS5zaXplLGNbYS0xXS50YXJnZXRzPWNbYS0xXS50YXJnZXRzLmNvbmNhdChjW2FdLnRhcmdldHMpLGNbYS0xXS5hbGlnbj0uNSxjW2EtMV0ucG9zK2NbYS0xXS5zaXplPmYmJihjW2EtMV0ucG9zPVxuZi1jW2EtMV0uc2l6ZSksYy5zcGxpY2UoYSwxKSxiPSEwKX1tLnB1c2guYXBwbHkobSxsKTthPTA7Yy5zb21lKGZ1bmN0aW9uKGIpe3ZhciBjPTA7aWYoYi50YXJnZXRzLnNvbWUoZnVuY3Rpb24oKXttW2FdLnBvcz1iLnBvcytjO2lmKFwidW5kZWZpbmVkXCIhPT10eXBlb2YgZSYmTWF0aC5hYnMobVthXS5wb3MtbVthXS50YXJnZXQpPmUpcmV0dXJuIG0uc2xpY2UoMCxhKzEpLmZvckVhY2goZnVuY3Rpb24oYSl7ZGVsZXRlIGEucG9zfSksbS5yZWR1Y2VkTGVuPShtLnJlZHVjZWRMZW58fGYpLS4xKmYsbS5yZWR1Y2VkTGVuPi4xKmYmJmQuZGlzdHJpYnV0ZShtLGYsZSksITA7Yys9bVthXS5zaXplO2ErK30pKXJldHVybiEwfSk7eihtLGcpfTt4LnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscz1mdW5jdGlvbigpe2Z1bmN0aW9uIGQoYSxiKXt2YXIgYz1iLmZpbHRlcjtyZXR1cm4gYz8oYj1jLm9wZXJhdG9yLGE9YVtjLnByb3BlcnR5XSxjPWMudmFsdWUsXCI+XCI9PT1iJiZhPmN8fFwiPFwiPT09XG5iJiZhPGN8fFwiPj1cIj09PWImJmE+PWN8fFwiPD1cIj09PWImJmE8PWN8fFwiPT1cIj09PWImJmE9PWN8fFwiPT09XCI9PT1iJiZhPT09Yz8hMDohMSk6ITB9ZnVuY3Rpb24gZihhLGIpe3ZhciBkPVtdLGU7aWYoeShhKSYmIXkoYikpZD1hLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYyhhLGIpfSk7ZWxzZSBpZih5KGIpJiYheShhKSlkPWIubWFwKGZ1bmN0aW9uKGIpe3JldHVybiBjKGEsYil9KTtlbHNlIGlmKHkoYSl8fHkoYikpZm9yKGU9TWF0aC5tYXgoYS5sZW5ndGgsYi5sZW5ndGgpO2UtLTspZFtlXT1jKGFbZV0sYltlXSk7ZWxzZSBkPWMoYSxiKTtyZXR1cm4gZH12YXIgZT10aGlzLGg9ZS5jaGFydCxhPWUub3B0aW9ucyxiPWEuZGF0YUxhYmVscyxsPWUucG9pbnRzLHQsej1lLmhhc1JlbmRlcmVkfHwwLHg9Yi5hbmltYXRpb247eD1iLmRlZmVyP0QoaCx4LGUpOntkZWZlcjowLGR1cmF0aW9uOjB9O3ZhciBBPWgucmVuZGVyZXI7Yj1mKGYoaC5vcHRpb25zLnBsb3RPcHRpb25zJiZoLm9wdGlvbnMucGxvdE9wdGlvbnMuc2VyaWVzJiZcbmgub3B0aW9ucy5wbG90T3B0aW9ucy5zZXJpZXMuZGF0YUxhYmVscyxoLm9wdGlvbnMucGxvdE9wdGlvbnMmJmgub3B0aW9ucy5wbG90T3B0aW9uc1tlLnR5cGVdJiZoLm9wdGlvbnMucGxvdE9wdGlvbnNbZS50eXBlXS5kYXRhTGFiZWxzKSxiKTtFKHRoaXMsXCJkcmF3RGF0YUxhYmVsc1wiKTtpZih5KGIpfHxiLmVuYWJsZWR8fGUuX2hhc1BvaW50TGFiZWxzKXt2YXIgQj1lLnBsb3RHcm91cChcImRhdGFMYWJlbHNHcm91cFwiLFwiZGF0YS1sYWJlbHNcIix6P1wiaW5oZXJpdFwiOlwiaGlkZGVuXCIsYi56SW5kZXh8fDYpO0IuYXR0cih7b3BhY2l0eToren0pOyF6JiYoej1lLmRhdGFMYWJlbHNHcm91cCkmJihlLnZpc2libGUmJkIuc2hvdyghMCkselthLmFuaW1hdGlvbj9cImFuaW1hdGVcIjpcImF0dHJcIl0oe29wYWNpdHk6MX0seCkpO2wuZm9yRWFjaChmdW5jdGlvbihjKXt0PU0oZihiLGMuZGxPcHRpb25zfHxjLm9wdGlvbnMmJmMub3B0aW9ucy5kYXRhTGFiZWxzKSk7dC5mb3JFYWNoKGZ1bmN0aW9uKGIsXG5mKXt2YXIgbT1iLmVuYWJsZWQmJighYy5pc051bGx8fGMuZGF0YUxhYmVsT25OdWxsKSYmZChjLGIpLGw9Yy5kYXRhTGFiZWxzP2MuZGF0YUxhYmVsc1tmXTpjLmRhdGFMYWJlbCxyPWMuY29ubmVjdG9ycz9jLmNvbm5lY3RvcnNbZl06Yy5jb25uZWN0b3IsdD1uKGIuZGlzdGFuY2UsYy5sYWJlbERpc3RhbmNlKSx3PSFsO2lmKG0pe3ZhciB1PWMuZ2V0TGFiZWxDb25maWcoKTt2YXIgdj1uKGJbYy5mb3JtYXRQcmVmaXgrXCJGb3JtYXRcIl0sYi5mb3JtYXQpO3U9Qyh2KT9nKHYsdSxoKTooYltjLmZvcm1hdFByZWZpeCtcIkZvcm1hdHRlclwiXXx8Yi5mb3JtYXR0ZXIpLmNhbGwodSxiKTt2PWIuc3R5bGU7dmFyIHo9Yi5yb3RhdGlvbjtoLnN0eWxlZE1vZGV8fCh2LmNvbG9yPW4oYi5jb2xvcix2LmNvbG9yLGUuY29sb3Isay5uZXV0cmFsQ29sb3IxMDApLFwiY29udHJhc3RcIj09PXYuY29sb3I/KGMuY29udHJhc3RDb2xvcj1BLmdldENvbnRyYXN0KGMuY29sb3J8fGUuY29sb3IpLHYuY29sb3I9XG4hQyh0KSYmYi5pbnNpZGV8fDA+dHx8YS5zdGFja2luZz9jLmNvbnRyYXN0Q29sb3I6ay5uZXV0cmFsQ29sb3IxMDApOmRlbGV0ZSBjLmNvbnRyYXN0Q29sb3IsYS5jdXJzb3ImJih2LmN1cnNvcj1hLmN1cnNvcikpO3ZhciB4PXtyOmIuYm9yZGVyUmFkaXVzfHwwLHJvdGF0aW9uOnoscGFkZGluZzpiLnBhZGRpbmcsekluZGV4OjF9O2guc3R5bGVkTW9kZXx8KHguZmlsbD1iLmJhY2tncm91bmRDb2xvcix4LnN0cm9rZT1iLmJvcmRlckNvbG9yLHhbXCJzdHJva2Utd2lkdGhcIl09Yi5ib3JkZXJXaWR0aCk7cSh4LGZ1bmN0aW9uKGEsYil7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhJiZkZWxldGUgeFtiXX0pfSFsfHxtJiZDKHUpP20mJkModSkmJihsP3gudGV4dD11OihjLmRhdGFMYWJlbHM9Yy5kYXRhTGFiZWxzfHxbXSxsPWMuZGF0YUxhYmVsc1tmXT16P0EudGV4dCh1LDAsLTk5OTksYi51c2VIVE1MKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZGF0YS1sYWJlbFwiKTpBLmxhYmVsKHUsMCwtOTk5OSxcbmIuc2hhcGUsbnVsbCxudWxsLGIudXNlSFRNTCxudWxsLFwiZGF0YS1sYWJlbFwiKSxmfHwoYy5kYXRhTGFiZWw9bCksbC5hZGRDbGFzcyhcIiBoaWdoY2hhcnRzLWRhdGEtbGFiZWwtY29sb3ItXCIrYy5jb2xvckluZGV4K1wiIFwiKyhiLmNsYXNzTmFtZXx8XCJcIikrKGIudXNlSFRNTD9cIiBoaWdoY2hhcnRzLXRyYWNrZXJcIjpcIlwiKSkpLGwub3B0aW9ucz1iLGwuYXR0cih4KSxoLnN0eWxlZE1vZGV8fGwuY3NzKHYpLnNoYWRvdyhiLnNoYWRvdyksbC5hZGRlZHx8bC5hZGQoQiksYi50ZXh0UGF0aCYmIWIudXNlSFRNTCYmKGwuc2V0VGV4dFBhdGgoYy5nZXREYXRhTGFiZWxQYXRoJiZjLmdldERhdGFMYWJlbFBhdGgobCl8fGMuZ3JhcGhpYyxiLnRleHRQYXRoKSxjLmRhdGFMYWJlbFBhdGgmJiFiLnRleHRQYXRoLmVuYWJsZWQmJihjLmRhdGFMYWJlbFBhdGg9Yy5kYXRhTGFiZWxQYXRoLmRlc3Ryb3koKSkpLGUuYWxpZ25EYXRhTGFiZWwoYyxsLGIsbnVsbCx3KSk6KGMuZGF0YUxhYmVsPWMuZGF0YUxhYmVsJiZcbmMuZGF0YUxhYmVsLmRlc3Ryb3koKSxjLmRhdGFMYWJlbHMmJigxPT09Yy5kYXRhTGFiZWxzLmxlbmd0aD9kZWxldGUgYy5kYXRhTGFiZWxzOmRlbGV0ZSBjLmRhdGFMYWJlbHNbZl0pLGZ8fGRlbGV0ZSBjLmRhdGFMYWJlbCxyJiYoYy5jb25uZWN0b3I9Yy5jb25uZWN0b3IuZGVzdHJveSgpLGMuY29ubmVjdG9ycyYmKDE9PT1jLmNvbm5lY3RvcnMubGVuZ3RoP2RlbGV0ZSBjLmNvbm5lY3RvcnM6ZGVsZXRlIGMuY29ubmVjdG9yc1tmXSkpKX0pfSl9RSh0aGlzLFwiYWZ0ZXJEcmF3RGF0YUxhYmVsc1wiKX07eC5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWw9ZnVuY3Rpb24oYyxkLGUsZixhKXt2YXIgYj10aGlzLGc9dGhpcy5jaGFydCxoPXRoaXMuaXNDYXJ0ZXNpYW4mJmcuaW52ZXJ0ZWQsbT10aGlzLmVuYWJsZWREYXRhU29ydGluZyxrPW4oYy5kbEJveCYmYy5kbEJveC5jZW50ZXJYLGMucGxvdFgsLTk5OTkpLHE9bihjLnBsb3RZLC05OTk5KSxyPWQuZ2V0QkJveCgpLHQ9ZS5yb3RhdGlvbixcbno9ZS5hbGlnbix2PWcuaXNJbnNpZGVQbG90KGssTWF0aC5yb3VuZChxKSxoKSx4PVwianVzdGlmeVwiPT09bihlLm92ZXJmbG93LG0/XCJub25lXCI6XCJqdXN0aWZ5XCIpLHA9dGhpcy52aXNpYmxlJiYhMSE9PWMudmlzaWJsZSYmKGMuc2VyaWVzLmZvcmNlREx8fG0mJiF4fHx2fHxlLmluc2lkZSYmZiYmZy5pc0luc2lkZVBsb3QoayxoP2YueCsxOmYueStmLmhlaWdodC0xLGgpKTt2YXIgeT1mdW5jdGlvbihlKXttJiZiLnhBeGlzJiYheCYmYi5zZXREYXRhTGFiZWxTdGFydFBvcyhjLGQsYSx2LGUpfTtpZihwKXt2YXIgQz1nLnJlbmRlcmVyLmZvbnRNZXRyaWNzKGcuc3R5bGVkTW9kZT92b2lkIDA6ZS5zdHlsZS5mb250U2l6ZSxkKS5iO2Y9bCh7eDpoP3RoaXMueUF4aXMubGVuLXE6ayx5Ok1hdGgucm91bmQoaD90aGlzLnhBeGlzLmxlbi1rOnEpLHdpZHRoOjAsaGVpZ2h0OjB9LGYpO2woZSx7d2lkdGg6ci53aWR0aCxoZWlnaHQ6ci5oZWlnaHR9KTt0Pyh4PSExLGs9Zy5yZW5kZXJlci5yb3RDb3JyKEMsXG50KSxrPXt4OmYueCsoZS54fHwwKStmLndpZHRoLzIray54LHk6Zi55KyhlLnl8fDApK3t0b3A6MCxtaWRkbGU6LjUsYm90dG9tOjF9W2UudmVydGljYWxBbGlnbl0qZi5oZWlnaHR9LHkoayksZFthP1wiYXR0clwiOlwiYW5pbWF0ZVwiXShrKS5hdHRyKHthbGlnbjp6fSkseT0odCs3MjApJTM2MCx5PTE4MDx5JiYzNjA+eSxcImxlZnRcIj09PXo/ay55LT15P3IuaGVpZ2h0OjA6XCJjZW50ZXJcIj09PXo/KGsueC09ci53aWR0aC8yLGsueS09ci5oZWlnaHQvMik6XCJyaWdodFwiPT09eiYmKGsueC09ci53aWR0aCxrLnktPXk/MDpyLmhlaWdodCksZC5wbGFjZWQ9ITAsZC5hbGlnbkF0dHI9ayk6KHkoZiksZC5hbGlnbihlLG51bGwsZiksaz1kLmFsaWduQXR0cik7eCYmMDw9Zi5oZWlnaHQ/dGhpcy5qdXN0aWZ5RGF0YUxhYmVsKGQsZSxrLHIsZixhKTpuKGUuY3JvcCwhMCkmJihwPWcuaXNJbnNpZGVQbG90KGsueCxrLnkpJiZnLmlzSW5zaWRlUGxvdChrLngrci53aWR0aCxrLnkrci5oZWlnaHQpKTtpZihlLnNoYXBlJiZcbiF0KWRbYT9cImF0dHJcIjpcImFuaW1hdGVcIl0oe2FuY2hvclg6aD9nLnBsb3RXaWR0aC1jLnBsb3RZOmMucGxvdFgsYW5jaG9yWTpoP2cucGxvdEhlaWdodC1jLnBsb3RYOmMucGxvdFl9KX1hJiZtJiYoZC5wbGFjZWQ9ITEpO3B8fG0mJiF4fHwoZC5oaWRlKCEwKSxkLnBsYWNlZD0hMSl9O3gucHJvdG90eXBlLnNldERhdGFMYWJlbFN0YXJ0UG9zPWZ1bmN0aW9uKGMsZCxlLGYsYSl7dmFyIGI9dGhpcy5jaGFydCxnPWIuaW52ZXJ0ZWQsaD10aGlzLnhBeGlzLGs9aC5yZXZlcnNlZCxsPWc/ZC5oZWlnaHQvMjpkLndpZHRoLzI7Yz0oYz1jLnBvaW50V2lkdGgpP2MvMjowO2g9Zz9hLng6az8tbC1jOmgud2lkdGgtbCtjO2E9Zz9rP3RoaXMueUF4aXMuaGVpZ2h0LWwrYzotbC1jOmEueTtkLnN0YXJ0WFBvcz1oO2Quc3RhcnRZUG9zPWE7Zj9cImhpZGRlblwiPT09ZC52aXNpYmlsaXR5JiYoZC5zaG93KCksZC5hdHRyKHtvcGFjaXR5OjB9KS5hbmltYXRlKHtvcGFjaXR5OjF9KSk6ZC5hdHRyKHtvcGFjaXR5OjF9KS5hbmltYXRlKHtvcGFjaXR5OjB9LFxudm9pZCAwLGQuaGlkZSk7Yi5oYXNSZW5kZXJlZCYmKGUmJmQuYXR0cih7eDpkLnN0YXJ0WFBvcyx5OmQuc3RhcnRZUG9zfSksZC5wbGFjZWQ9ITApfTt4LnByb3RvdHlwZS5qdXN0aWZ5RGF0YUxhYmVsPWZ1bmN0aW9uKGMsZCxlLGYsYSxiKXt2YXIgZz10aGlzLmNoYXJ0LGg9ZC5hbGlnbixrPWQudmVydGljYWxBbGlnbixsPWMuYm94PzA6Yy5wYWRkaW5nfHwwLG09ZC54O209dm9pZCAwPT09bT8wOm07dmFyIG49ZC55O3ZhciBxPXZvaWQgMD09PW4/MDpuO249ZS54K2w7aWYoMD5uKXtcInJpZ2h0XCI9PT1oJiYwPD1tPyhkLmFsaWduPVwibGVmdFwiLGQuaW5zaWRlPSEwKTptLT1uO3ZhciByPSEwfW49ZS54K2Yud2lkdGgtbDtuPmcucGxvdFdpZHRoJiYoXCJsZWZ0XCI9PT1oJiYwPj1tPyhkLmFsaWduPVwicmlnaHRcIixkLmluc2lkZT0hMCk6bSs9Zy5wbG90V2lkdGgtbixyPSEwKTtuPWUueStsOzA+biYmKFwiYm90dG9tXCI9PT1rJiYwPD1xPyhkLnZlcnRpY2FsQWxpZ249XCJ0b3BcIixkLmluc2lkZT1cbiEwKTpxLT1uLHI9ITApO249ZS55K2YuaGVpZ2h0LWw7bj5nLnBsb3RIZWlnaHQmJihcInRvcFwiPT09ayYmMD49cT8oZC52ZXJ0aWNhbEFsaWduPVwiYm90dG9tXCIsZC5pbnNpZGU9ITApOnErPWcucGxvdEhlaWdodC1uLHI9ITApO3ImJihkLng9bSxkLnk9cSxjLnBsYWNlZD0hYixjLmFsaWduKGQsdm9pZCAwLGEpKTtyZXR1cm4gcn07Qi5waWUmJihCLnBpZS5wcm90b3R5cGUuZGF0YUxhYmVsUG9zaXRpb25lcnM9e3JhZGlhbERpc3RyaWJ1dGlvblk6ZnVuY3Rpb24oYyl7cmV0dXJuIGMudG9wK2MuZGlzdHJpYnV0ZUJveC5wb3N9LHJhZGlhbERpc3RyaWJ1dGlvblg6ZnVuY3Rpb24oYyxkLGUsZil7cmV0dXJuIGMuZ2V0WChlPGQudG9wKzJ8fGU+ZC5ib3R0b20tMj9mOmUsZC5oYWxmLGQpfSxqdXN0aWZ5OmZ1bmN0aW9uKGMsZCxlKXtyZXR1cm4gZVswXSsoYy5oYWxmPy0xOjEpKihkK2MubGFiZWxEaXN0YW5jZSl9LGFsaWduVG9QbG90RWRnZXM6ZnVuY3Rpb24oYyxkLGUsZil7Yz1jLmdldEJCb3goKS53aWR0aDtcbnJldHVybiBkP2MrZjplLWMtZn0sYWxpZ25Ub0Nvbm5lY3RvcnM6ZnVuY3Rpb24oYyxkLGUsZil7dmFyIGE9MCxiO2MuZm9yRWFjaChmdW5jdGlvbihjKXtiPWMuZGF0YUxhYmVsLmdldEJCb3goKS53aWR0aDtiPmEmJihhPWIpfSk7cmV0dXJuIGQ/YStmOmUtYS1mfX0sQi5waWUucHJvdG90eXBlLmRyYXdEYXRhTGFiZWxzPWZ1bmN0aW9uKCl7dmFyIGY9dGhpcyxnPWYuZGF0YSxlLGg9Zi5jaGFydCxhPWYub3B0aW9ucy5kYXRhTGFiZWxzfHx7fSxiPWEuY29ubmVjdG9yUGFkZGluZyxsLHE9aC5wbG90V2lkdGgsdD1oLnBsb3RIZWlnaHQsej1oLnBsb3RMZWZ0LHk9TWF0aC5yb3VuZChoLmNoYXJ0V2lkdGgvMyksQSxCPWYuY2VudGVyLEU9QlsyXS8yLHY9QlsxXSxELHAsRyxNLFA9W1tdLFtdXSx1LFMsSSxYLFU9WzAsMCwwLDBdLFc9Zi5kYXRhTGFiZWxQb3NpdGlvbmVycyxZO2YudmlzaWJsZSYmKGEuZW5hYmxlZHx8Zi5faGFzUG9pbnRMYWJlbHMpJiYoZy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuZGF0YUxhYmVsJiZcbmEudmlzaWJsZSYmYS5kYXRhTGFiZWwuc2hvcnRlbmVkJiYoYS5kYXRhTGFiZWwuYXR0cih7d2lkdGg6XCJhdXRvXCJ9KS5jc3Moe3dpZHRoOlwiYXV0b1wiLHRleHRPdmVyZmxvdzpcImNsaXBcIn0pLGEuZGF0YUxhYmVsLnNob3J0ZW5lZD0hMSl9KSx4LnByb3RvdHlwZS5kcmF3RGF0YUxhYmVscy5hcHBseShmKSxnLmZvckVhY2goZnVuY3Rpb24oYil7Yi5kYXRhTGFiZWwmJihiLnZpc2libGU/KFBbYi5oYWxmXS5wdXNoKGIpLGIuZGF0YUxhYmVsLl9wb3M9bnVsbCwhQyhhLnN0eWxlLndpZHRoKSYmIUMoYi5vcHRpb25zLmRhdGFMYWJlbHMmJmIub3B0aW9ucy5kYXRhTGFiZWxzLnN0eWxlJiZiLm9wdGlvbnMuZGF0YUxhYmVscy5zdHlsZS53aWR0aCkmJmIuZGF0YUxhYmVsLmdldEJCb3goKS53aWR0aD55JiYoYi5kYXRhTGFiZWwuY3NzKHt3aWR0aDpNYXRoLnJvdW5kKC43KnkpK1wicHhcIn0pLGIuZGF0YUxhYmVsLnNob3J0ZW5lZD0hMCkpOihiLmRhdGFMYWJlbD1iLmRhdGFMYWJlbC5kZXN0cm95KCksXG5iLmRhdGFMYWJlbHMmJjE9PT1iLmRhdGFMYWJlbHMubGVuZ3RoJiZkZWxldGUgYi5kYXRhTGFiZWxzKSl9KSxQLmZvckVhY2goZnVuY3Rpb24oYyxnKXt2YXIgaz1jLmxlbmd0aCxsPVtdLG07aWYoayl7Zi5zb3J0QnlBbmdsZShjLGctLjUpO2lmKDA8Zi5tYXhMYWJlbERpc3RhbmNlKXt2YXIgcj1NYXRoLm1heCgwLHYtRS1mLm1heExhYmVsRGlzdGFuY2UpO3ZhciB3PU1hdGgubWluKHYrRStmLm1heExhYmVsRGlzdGFuY2UsaC5wbG90SGVpZ2h0KTtjLmZvckVhY2goZnVuY3Rpb24oYSl7MDxhLmxhYmVsRGlzdGFuY2UmJmEuZGF0YUxhYmVsJiYoYS50b3A9TWF0aC5tYXgoMCx2LUUtYS5sYWJlbERpc3RhbmNlKSxhLmJvdHRvbT1NYXRoLm1pbih2K0UrYS5sYWJlbERpc3RhbmNlLGgucGxvdEhlaWdodCksbT1hLmRhdGFMYWJlbC5nZXRCQm94KCkuaGVpZ2h0fHwyMSxhLmRpc3RyaWJ1dGVCb3g9e3RhcmdldDphLmxhYmVsUG9zaXRpb24ubmF0dXJhbC55LWEudG9wK20vMixzaXplOm0sXG5yYW5rOmEueX0sbC5wdXNoKGEuZGlzdHJpYnV0ZUJveCkpfSk7cj13K20tcjtkLmRpc3RyaWJ1dGUobCxyLHIvNSl9Zm9yKFg9MDtYPGs7WCsrKXtlPWNbWF07Rz1lLmxhYmVsUG9zaXRpb247RD1lLmRhdGFMYWJlbDtJPSExPT09ZS52aXNpYmxlP1wiaGlkZGVuXCI6XCJpbmhlcml0XCI7Uz1yPUcubmF0dXJhbC55O2wmJkMoZS5kaXN0cmlidXRlQm94KSYmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZS5kaXN0cmlidXRlQm94LnBvcz9JPVwiaGlkZGVuXCI6KE09ZS5kaXN0cmlidXRlQm94LnNpemUsUz1XLnJhZGlhbERpc3RyaWJ1dGlvblkoZSkpKTtkZWxldGUgZS5wb3NpdGlvbkluZGV4O2lmKGEuanVzdGlmeSl1PVcuanVzdGlmeShlLEUsQik7ZWxzZSBzd2l0Y2goYS5hbGlnblRvKXtjYXNlIFwiY29ubmVjdG9yc1wiOnU9Vy5hbGlnblRvQ29ubmVjdG9ycyhjLGcscSx6KTticmVhaztjYXNlIFwicGxvdEVkZ2VzXCI6dT1XLmFsaWduVG9QbG90RWRnZXMoRCxnLHEseik7YnJlYWs7ZGVmYXVsdDp1PVcucmFkaWFsRGlzdHJpYnV0aW9uWChmLFxuZSxTLHIpfUQuX2F0dHI9e3Zpc2liaWxpdHk6SSxhbGlnbjpHLmFsaWdubWVudH07WT1lLm9wdGlvbnMuZGF0YUxhYmVsc3x8e307RC5fcG9zPXt4OnUrbihZLngsYS54KSsoe2xlZnQ6YixyaWdodDotYn1bRy5hbGlnbm1lbnRdfHwwKSx5OlMrbihZLnksYS55KS0xMH07Ry5maW5hbC54PXU7Ry5maW5hbC55PVM7bihhLmNyb3AsITApJiYocD1ELmdldEJCb3goKS53aWR0aCxyPW51bGwsdS1wPGImJjE9PT1nPyhyPU1hdGgucm91bmQocC11K2IpLFVbM109TWF0aC5tYXgocixVWzNdKSk6dStwPnEtYiYmMD09PWcmJihyPU1hdGgucm91bmQodStwLXErYiksVVsxXT1NYXRoLm1heChyLFVbMV0pKSwwPlMtTS8yP1VbMF09TWF0aC5tYXgoTWF0aC5yb3VuZCgtUytNLzIpLFVbMF0pOlMrTS8yPnQmJihVWzJdPU1hdGgubWF4KE1hdGgucm91bmQoUytNLzItdCksVVsyXSkpLEQuc2lkZU92ZXJmbG93PXIpfX19KSwwPT09SChVKXx8dGhpcy52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdyhVKSkmJlxuKHRoaXMucGxhY2VEYXRhTGFiZWxzKCksdGhpcy5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihiKXtZPWMoYSxiLm9wdGlvbnMuZGF0YUxhYmVscyk7aWYobD1uKFkuY29ubmVjdG9yV2lkdGgsMSkpe3ZhciBkO0E9Yi5jb25uZWN0b3I7aWYoKEQ9Yi5kYXRhTGFiZWwpJiZELl9wb3MmJmIudmlzaWJsZSYmMDxiLmxhYmVsRGlzdGFuY2Upe0k9RC5fYXR0ci52aXNpYmlsaXR5O2lmKGQ9IUEpYi5jb25uZWN0b3I9QT1oLnJlbmRlcmVyLnBhdGgoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtZGF0YS1sYWJlbC1jb25uZWN0b3IgIGhpZ2hjaGFydHMtY29sb3ItXCIrYi5jb2xvckluZGV4KyhiLmNsYXNzTmFtZT9cIiBcIitiLmNsYXNzTmFtZTpcIlwiKSkuYWRkKGYuZGF0YUxhYmVsc0dyb3VwKSxoLnN0eWxlZE1vZGV8fEEuYXR0cih7XCJzdHJva2Utd2lkdGhcIjpsLHN0cm9rZTpZLmNvbm5lY3RvckNvbG9yfHxiLmNvbG9yfHxrLm5ldXRyYWxDb2xvcjYwfSk7QVtkP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7ZDpiLmdldENvbm5lY3RvclBhdGgoKX0pO1xuQS5hdHRyKFwidmlzaWJpbGl0eVwiLEkpfWVsc2UgQSYmKGIuY29ubmVjdG9yPUEuZGVzdHJveSgpKX19KSl9LEIucGllLnByb3RvdHlwZS5wbGFjZURhdGFMYWJlbHM9ZnVuY3Rpb24oKXt0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBkPWMuZGF0YUxhYmVsLGU7ZCYmYy52aXNpYmxlJiYoKGU9ZC5fcG9zKT8oZC5zaWRlT3ZlcmZsb3cmJihkLl9hdHRyLndpZHRoPU1hdGgubWF4KGQuZ2V0QkJveCgpLndpZHRoLWQuc2lkZU92ZXJmbG93LDApLGQuY3NzKHt3aWR0aDpkLl9hdHRyLndpZHRoK1wicHhcIix0ZXh0T3ZlcmZsb3c6KHRoaXMub3B0aW9ucy5kYXRhTGFiZWxzLnN0eWxlfHx7fSkudGV4dE92ZXJmbG93fHxcImVsbGlwc2lzXCJ9KSxkLnNob3J0ZW5lZD0hMCksZC5hdHRyKGQuX2F0dHIpLGRbZC5tb3ZlZD9cImFuaW1hdGVcIjpcImF0dHJcIl0oZSksZC5tb3ZlZD0hMCk6ZCYmZC5hdHRyKHt5Oi05OTk5fSkpO2RlbGV0ZSBjLmRpc3RyaWJ1dGVCb3h9LHRoaXMpfSxCLnBpZS5wcm90b3R5cGUuYWxpZ25EYXRhTGFiZWw9XG5mLEIucGllLnByb3RvdHlwZS52ZXJpZnlEYXRhTGFiZWxPdmVyZmxvdz1mdW5jdGlvbihjKXt2YXIgZD10aGlzLmNlbnRlcixlPXRoaXMub3B0aW9ucyxmPWUuY2VudGVyLGE9ZS5taW5TaXplfHw4MCxiPW51bGwhPT1lLnNpemU7aWYoIWIpe2lmKG51bGwhPT1mWzBdKXZhciBnPU1hdGgubWF4KGRbMl0tTWF0aC5tYXgoY1sxXSxjWzNdKSxhKTtlbHNlIGc9TWF0aC5tYXgoZFsyXS1jWzFdLWNbM10sYSksZFswXSs9KGNbM10tY1sxXSkvMjtudWxsIT09ZlsxXT9nPXQoZyxhLGRbMl0tTWF0aC5tYXgoY1swXSxjWzJdKSk6KGc9dChnLGEsZFsyXS1jWzBdLWNbMl0pLGRbMV0rPShjWzBdLWNbMl0pLzIpO2c8ZFsyXT8oZFsyXT1nLGRbM109TWF0aC5taW4oQShlLmlubmVyU2l6ZXx8MCxnKSxnKSx0aGlzLnRyYW5zbGF0ZShkKSx0aGlzLmRyYXdEYXRhTGFiZWxzJiZ0aGlzLmRyYXdEYXRhTGFiZWxzKCkpOmI9ITB9cmV0dXJuIGJ9KTtCLmNvbHVtbiYmKEIuY29sdW1uLnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbD1cbmZ1bmN0aW9uKGQsZixlLGcsYSl7dmFyIGI9dGhpcy5jaGFydC5pbnZlcnRlZCxoPWQuc2VyaWVzLGs9ZC5kbEJveHx8ZC5zaGFwZUFyZ3MsbD1uKGQuYmVsb3csZC5wbG90WT5uKHRoaXMudHJhbnNsYXRlZFRocmVzaG9sZCxoLnlBeGlzLmxlbikpLG09bihlLmluc2lkZSwhIXRoaXMub3B0aW9ucy5zdGFja2luZyk7ayYmKGc9YyhrKSwwPmcueSYmKGcuaGVpZ2h0Kz1nLnksZy55PTApLGs9Zy55K2cuaGVpZ2h0LWgueUF4aXMubGVuLDA8ayYmazxnLmhlaWdodCYmKGcuaGVpZ2h0LT1rKSxiJiYoZz17eDpoLnlBeGlzLmxlbi1nLnktZy5oZWlnaHQseTpoLnhBeGlzLmxlbi1nLngtZy53aWR0aCx3aWR0aDpnLmhlaWdodCxoZWlnaHQ6Zy53aWR0aH0pLG18fChiPyhnLngrPWw/MDpnLndpZHRoLGcud2lkdGg9MCk6KGcueSs9bD9nLmhlaWdodDowLGcuaGVpZ2h0PTApKSk7ZS5hbGlnbj1uKGUuYWxpZ24sIWJ8fG0/XCJjZW50ZXJcIjpsP1wicmlnaHRcIjpcImxlZnRcIik7ZS52ZXJ0aWNhbEFsaWduPVxubihlLnZlcnRpY2FsQWxpZ24sYnx8bT9cIm1pZGRsZVwiOmw/XCJ0b3BcIjpcImJvdHRvbVwiKTt4LnByb3RvdHlwZS5hbGlnbkRhdGFMYWJlbC5jYWxsKHRoaXMsZCxmLGUsZyxhKTtlLmluc2lkZSYmZC5jb250cmFzdENvbG9yJiZmLmNzcyh7Y29sb3I6ZC5jb250cmFzdENvbG9yfSl9KX0pO1AoayxcIkV4dGVuc2lvbnMvT3ZlcmxhcHBpbmdEYXRhTGFiZWxzLmpzXCIsW2tbXCJDb3JlL0NoYXJ0L0NoYXJ0LmpzXCJdLGtbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oZixkKXt2YXIgaz1kLmFkZEV2ZW50LHg9ZC5maXJlRXZlbnQsQj1kLmlzQXJyYXksRz1kLmlzTnVtYmVyLEQ9ZC5vYmplY3RFYWNoLEg9ZC5waWNrO2soZixcInJlbmRlclwiLGZ1bmN0aW9uKCl7dmFyIGQ9W107KHRoaXMubGFiZWxDb2xsZWN0b3JzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihmKXtkPWQuY29uY2F0KGYoKSl9KTsodGhpcy55QXhpc3x8W10pLmZvckVhY2goZnVuY3Rpb24oZil7Zi5zdGFja2luZyYmZi5vcHRpb25zLnN0YWNrTGFiZWxzJiZcbiFmLm9wdGlvbnMuc3RhY2tMYWJlbHMuYWxsb3dPdmVybGFwJiZEKGYuc3RhY2tpbmcuc3RhY2tzLGZ1bmN0aW9uKGYpe0QoZixmdW5jdGlvbihmKXtkLnB1c2goZi5sYWJlbCl9KX0pfSk7KHRoaXMuc2VyaWVzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihmKXt2YXIgaz1mLm9wdGlvbnMuZGF0YUxhYmVscztmLnZpc2libGUmJighMSE9PWsuZW5hYmxlZHx8Zi5faGFzUG9pbnRMYWJlbHMpJiYoaz1mdW5jdGlvbihmKXtyZXR1cm4gZi5mb3JFYWNoKGZ1bmN0aW9uKGYpe2YudmlzaWJsZSYmKEIoZi5kYXRhTGFiZWxzKT9mLmRhdGFMYWJlbHM6Zi5kYXRhTGFiZWw/W2YuZGF0YUxhYmVsXTpbXSkuZm9yRWFjaChmdW5jdGlvbihnKXt2YXIgYz1nLm9wdGlvbnM7Zy5sYWJlbHJhbms9SChjLmxhYmVscmFuayxmLmxhYmVscmFuayxmLnNoYXBlQXJncyYmZi5zaGFwZUFyZ3MuaGVpZ2h0KTtjLmFsbG93T3ZlcmxhcHx8ZC5wdXNoKGcpfSl9KX0sayhmLm5vZGVzfHxbXSksayhmLnBvaW50cykpfSk7XG50aGlzLmhpZGVPdmVybGFwcGluZ0xhYmVscyhkKX0pO2YucHJvdG90eXBlLmhpZGVPdmVybGFwcGluZ0xhYmVscz1mdW5jdGlvbihkKXt2YXIgZj10aGlzLGs9ZC5sZW5ndGgsdD1mLnJlbmRlcmVyLGcseSxjLHE9ITE7dmFyIG49ZnVuY3Rpb24oYyl7dmFyIGQsZj1jLmJveD8wOmMucGFkZGluZ3x8MCxlPWQ9MCxnO2lmKGMmJighYy5hbGlnbkF0dHJ8fGMucGxhY2VkKSl7dmFyIGE9Yy5hbGlnbkF0dHJ8fHt4OmMuYXR0cihcInhcIikseTpjLmF0dHIoXCJ5XCIpfTt2YXIgYj1jLnBhcmVudEdyb3VwO2Mud2lkdGh8fChkPWMuZ2V0QkJveCgpLGMud2lkdGg9ZC53aWR0aCxjLmhlaWdodD1kLmhlaWdodCxkPXQuZm9udE1ldHJpY3MobnVsbCxjLmVsZW1lbnQpLmgpO3ZhciBrPWMud2lkdGgtMipmOyhnPXtsZWZ0OlwiMFwiLGNlbnRlcjpcIjAuNVwiLHJpZ2h0OlwiMVwifVtjLmFsaWduVmFsdWVdKT9lPStnKms6RyhjLngpJiZNYXRoLnJvdW5kKGMueCkhPT1jLnRyYW5zbGF0ZVgmJihlPWMueC1jLnRyYW5zbGF0ZVgpO1xucmV0dXJue3g6YS54KyhiLnRyYW5zbGF0ZVh8fDApK2YtKGV8fDApLHk6YS55KyhiLnRyYW5zbGF0ZVl8fDApK2YtZCx3aWR0aDpjLndpZHRoLTIqZixoZWlnaHQ6Yy5oZWlnaHQtMipmfX19O2Zvcih5PTA7eTxrO3krKylpZihnPWRbeV0pZy5vbGRPcGFjaXR5PWcub3BhY2l0eSxnLm5ld09wYWNpdHk9MSxnLmFic29sdXRlQm94PW4oZyk7ZC5zb3J0KGZ1bmN0aW9uKGMsZCl7cmV0dXJuKGQubGFiZWxyYW5rfHwwKS0oYy5sYWJlbHJhbmt8fDApfSk7Zm9yKHk9MDt5PGs7eSsrKXt2YXIgQT0obj1kW3ldKSYmbi5hYnNvbHV0ZUJveDtmb3IoZz15KzE7ZzxrOysrZyl7dmFyIEI9KGM9ZFtnXSkmJmMuYWJzb2x1dGVCb3g7IUF8fCFCfHxuPT09Y3x8MD09PW4ubmV3T3BhY2l0eXx8MD09PWMubmV3T3BhY2l0eXx8Qi54Pj1BLngrQS53aWR0aHx8Qi54K0Iud2lkdGg8PUEueHx8Qi55Pj1BLnkrQS5oZWlnaHR8fEIueStCLmhlaWdodDw9QS55fHwoKG4ubGFiZWxyYW5rPGMubGFiZWxyYW5rP1xubjpjKS5uZXdPcGFjaXR5PTApfX1kLmZvckVhY2goZnVuY3Rpb24oYyl7aWYoYyl7dmFyIGQ9Yy5uZXdPcGFjaXR5O2Mub2xkT3BhY2l0eSE9PWQmJihjLmFsaWduQXR0ciYmYy5wbGFjZWQ/KGNbZD9cInJlbW92ZUNsYXNzXCI6XCJhZGRDbGFzc1wiXShcImhpZ2hjaGFydHMtZGF0YS1sYWJlbC1oaWRkZW5cIikscT0hMCxjLmFsaWduQXR0ci5vcGFjaXR5PWQsY1tjLmlzT2xkP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShjLmFsaWduQXR0cixudWxsLGZ1bmN0aW9uKCl7Zi5zdHlsZWRNb2RlfHxjLmNzcyh7cG9pbnRlckV2ZW50czpkP1wiYXV0b1wiOlwibm9uZVwifSk7Yy52aXNpYmlsaXR5PWQ/XCJpbmhlcml0XCI6XCJoaWRkZW5cIn0pLHgoZixcImFmdGVySGlkZU92ZXJsYXBwaW5nTGFiZWxcIikpOmMuYXR0cih7b3BhY2l0eTpkfSkpO2MuaXNPbGQ9ITB9fSk7cSYmeChmLFwiYWZ0ZXJIaWRlQWxsT3ZlcmxhcHBpbmdMYWJlbHNcIil9fSk7UChrLFwiQ29yZS9SZXNwb25zaXZlLmpzXCIsW2tbXCJDb3JlL0NoYXJ0L0NoYXJ0LmpzXCJdLFxua1tcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihmLGQpe3ZhciBrPWQuZmluZCx4PWQuaXNBcnJheSxCPWQuaXNPYmplY3QsRz1kLm1lcmdlLEQ9ZC5vYmplY3RFYWNoLEg9ZC5waWNrLHQ9ZC5zcGxhdCxDPWQudW5pcXVlS2V5O2YucHJvdG90eXBlLnNldFJlc3BvbnNpdmU9ZnVuY3Rpb24oZCxmKXt2YXIgZz10aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSxsPVtdLGM9dGhpcy5jdXJyZW50UmVzcG9uc2l2ZTshZiYmZyYmZy5ydWxlcyYmZy5ydWxlcy5mb3JFYWNoKGZ1bmN0aW9uKGMpe1widW5kZWZpbmVkXCI9PT10eXBlb2YgYy5faWQmJihjLl9pZD1DKCkpO3RoaXMubWF0Y2hSZXNwb25zaXZlUnVsZShjLGwpfSx0aGlzKTtmPUcuYXBwbHkoMCxsLm1hcChmdW5jdGlvbihjKXtyZXR1cm4gayhnLnJ1bGVzLGZ1bmN0aW9uKGQpe3JldHVybiBkLl9pZD09PWN9KS5jaGFydE9wdGlvbnN9KSk7Zi5pc1Jlc3BvbnNpdmVPcHRpb25zPSEwO2w9bC50b1N0cmluZygpfHx2b2lkIDA7bCE9PVxuKGMmJmMucnVsZUlkcykmJihjJiZ0aGlzLnVwZGF0ZShjLnVuZG9PcHRpb25zLGQsITApLGw/KGM9dGhpcy5jdXJyZW50T3B0aW9ucyhmKSxjLmlzUmVzcG9uc2l2ZU9wdGlvbnM9ITAsdGhpcy5jdXJyZW50UmVzcG9uc2l2ZT17cnVsZUlkczpsLG1lcmdlZE9wdGlvbnM6Zix1bmRvT3B0aW9uczpjfSx0aGlzLnVwZGF0ZShmLGQsITApKTp0aGlzLmN1cnJlbnRSZXNwb25zaXZlPXZvaWQgMCl9O2YucHJvdG90eXBlLm1hdGNoUmVzcG9uc2l2ZVJ1bGU9ZnVuY3Rpb24oZCxmKXt2YXIgZz1kLmNvbmRpdGlvbjsoZy5jYWxsYmFja3x8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFydFdpZHRoPD1IKGcubWF4V2lkdGgsTnVtYmVyLk1BWF9WQUxVRSkmJnRoaXMuY2hhcnRIZWlnaHQ8PUgoZy5tYXhIZWlnaHQsTnVtYmVyLk1BWF9WQUxVRSkmJnRoaXMuY2hhcnRXaWR0aD49SChnLm1pbldpZHRoLDApJiZ0aGlzLmNoYXJ0SGVpZ2h0Pj1IKGcubWluSGVpZ2h0LDApfSkuY2FsbCh0aGlzKSYmXG5mLnB1c2goZC5faWQpfTtmLnByb3RvdHlwZS5jdXJyZW50T3B0aW9ucz1mdW5jdGlvbihkKXtmdW5jdGlvbiBmKGMsZCxrLGwpe3ZhciBuO0QoYyxmdW5jdGlvbihjLG0pe2lmKCFsJiYtMTxnLmNvbGxlY3Rpb25zV2l0aFVwZGF0ZS5pbmRleE9mKG0pJiZkW21dKWZvcihjPXQoYyksa1ttXT1bXSxuPTA7bjxNYXRoLm1heChjLmxlbmd0aCxkW21dLmxlbmd0aCk7bisrKWRbbV1bbl0mJih2b2lkIDA9PT1jW25dP2tbbV1bbl09ZFttXVtuXTooa1ttXVtuXT17fSxmKGNbbl0sZFttXVtuXSxrW21dW25dLGwrMSkpKTtlbHNlIEIoYyk/KGtbbV09eChjKT9bXTp7fSxmKGMsZFttXXx8e30sa1ttXSxsKzEpKTprW21dPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgZFttXT9udWxsOmRbbV19KX12YXIgZz10aGlzLGs9e307ZihkLHRoaXMub3B0aW9ucyxrLDApO3JldHVybiBrfX0pO1AoayxcIm1hc3RlcnMvaGlnaGNoYXJ0cy5zcmMuanNcIixba1tcIkNvcmUvR2xvYmFscy5qc1wiXSxrW1wiQ29yZS9VdGlsaXRpZXMuanNcIl0sXG5rW1wiQ29yZS9SZW5kZXJlci9IVE1ML0FTVC5qc1wiXSxrW1wiQ29yZS9TZXJpZXMvU2VyaWVzLmpzXCJdXSxmdW5jdGlvbihmLGQsayx4KXtmLmFkZEV2ZW50PWQuYWRkRXZlbnQ7Zi5hcnJheU1heD1kLmFycmF5TWF4O2YuYXJyYXlNaW49ZC5hcnJheU1pbjtmLmF0dHI9ZC5hdHRyO2YuY2xlYXJUaW1lb3V0PWQuY2xlYXJUaW1lb3V0O2YuY29ycmVjdEZsb2F0PWQuY29ycmVjdEZsb2F0O2YuY3JlYXRlRWxlbWVudD1kLmNyZWF0ZUVsZW1lbnQ7Zi5jc3M9ZC5jc3M7Zi5kZWZpbmVkPWQuZGVmaW5lZDtmLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzPWQuZGVzdHJveU9iamVjdFByb3BlcnRpZXM7Zi5kaXNjYXJkRWxlbWVudD1kLmRpc2NhcmRFbGVtZW50O2YuZXJhc2U9ZC5lcmFzZTtmLmVycm9yPWQuZXJyb3I7Zi5leHRlbmQ9ZC5leHRlbmQ7Zi5leHRlbmRDbGFzcz1kLmV4dGVuZENsYXNzO2YuZmluZD1kLmZpbmQ7Zi5maXJlRXZlbnQ9ZC5maXJlRXZlbnQ7Zi5mb3JtYXQ9ZC5mb3JtYXQ7XG5mLmdldE1hZ25pdHVkZT1kLmdldE1hZ25pdHVkZTtmLmdldFN0eWxlPWQuZ2V0U3R5bGU7Zi5pbkFycmF5PWQuaW5BcnJheTtmLmlzQXJyYXk9ZC5pc0FycmF5O2YuaXNDbGFzcz1kLmlzQ2xhc3M7Zi5pc0RPTUVsZW1lbnQ9ZC5pc0RPTUVsZW1lbnQ7Zi5pc0Z1bmN0aW9uPWQuaXNGdW5jdGlvbjtmLmlzTnVtYmVyPWQuaXNOdW1iZXI7Zi5pc09iamVjdD1kLmlzT2JqZWN0O2YuaXNTdHJpbmc9ZC5pc1N0cmluZztmLmtleXM9ZC5rZXlzO2YubWVyZ2U9ZC5tZXJnZTtmLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbD1kLm5vcm1hbGl6ZVRpY2tJbnRlcnZhbDtmLm51bWJlckZvcm1hdD1kLm51bWJlckZvcm1hdDtmLm9iamVjdEVhY2g9ZC5vYmplY3RFYWNoO2Yub2Zmc2V0PWQub2Zmc2V0O2YucGFkPWQucGFkO2YucGljaz1kLnBpY2s7Zi5wSW50PWQucEludDtmLnJlbGF0aXZlTGVuZ3RoPWQucmVsYXRpdmVMZW5ndGg7Zi5yZW1vdmVFdmVudD1kLnJlbW92ZUV2ZW50O2Yuc3BsYXQ9ZC5zcGxhdDtcbmYuc3RhYmxlU29ydD1kLnN0YWJsZVNvcnQ7Zi5zeW5jVGltZW91dD1kLnN5bmNUaW1lb3V0O2YudGltZVVuaXRzPWQudGltZVVuaXRzO2YudW5pcXVlS2V5PWQudW5pcXVlS2V5O2YudXNlU2VyaWFsSWRzPWQudXNlU2VyaWFsSWRzO2Yud3JhcD1kLndyYXA7Zi5BU1Q9aztmLlNlcmllcz14O3JldHVybiBmfSk7a1tcIm1hc3RlcnMvaGlnaGNoYXJ0cy5zcmMuanNcIl0uX21vZHVsZXM9aztyZXR1cm4ga1tcIm1hc3RlcnMvaGlnaGNoYXJ0cy5zcmMuanNcIl19KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpZ2hjaGFydHMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///603\n");

/***/ }),

/***/ 564:
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n Highcharts Gantt JS v9.0.1 (2021-02-15)\n\n Gantt series\n\n (c) 2016-2021 Lars A. V. Cabrera\n\n License: www.highcharts.com/license\n*/\n(function (a) {\n   true && module.exports ? (a[\"default\"] = a, module.exports = a) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(603)], __WEBPACK_AMD_DEFINE_RESULT__ = (function (F) {\n    a(F);\n    a.Highcharts = F;\n    return a;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;\n})(function (a) {\n  function F(a, u, t, r) {\n    a.hasOwnProperty(u) || (a[u] = r.apply(null, t));\n  }\n\n  a = a ? a._modules : {};\n  F(a, \"Series/XRange/XRangePoint.js\", [a[\"Core/Series/Point.js\"], a[\"Core/Series/SeriesRegistry.js\"]], function (a, u) {\n    var t = this && this.__extends || function () {\n      var a = function (n, h) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (h, a) {\n          h.__proto__ = a;\n        } || function (h, a) {\n          for (var D in a) a.hasOwnProperty(D) && (h[D] = a[D]);\n        };\n\n        return a(n, h);\n      };\n\n      return function (n, h) {\n        function r() {\n          this.constructor = n;\n        }\n\n        a(n, h);\n        n.prototype = null === h ? Object.create(h) : (r.prototype = h.prototype, new r());\n      };\n    }();\n\n    return function (r) {\n      function n() {\n        var h = null !== r && r.apply(this, arguments) || this;\n        h.options = void 0;\n        h.series = void 0;\n        h.tooltipDateKeys = [\"x\", \"x2\"];\n        return h;\n      }\n\n      t(n, r);\n\n      n.getColorByCategory = function (h, a) {\n        var n = h.options.colors || h.chart.options.colors;\n        h = a.y % (n ? n.length : h.chart.options.chart.colorCount);\n        return {\n          colorIndex: h,\n          color: n && n[h]\n        };\n      };\n\n      n.prototype.resolveColor = function () {\n        var h = this.series;\n\n        if (h.options.colorByPoint && !this.options.color) {\n          var a = n.getColorByCategory(h, this);\n          h.chart.styledMode || (this.color = a.color);\n          this.options.colorIndex || (this.colorIndex = a.colorIndex);\n        } else this.color || (this.color = h.color);\n      };\n\n      n.prototype.init = function () {\n        a.prototype.init.apply(this, arguments);\n        this.y || (this.y = 0);\n        return this;\n      };\n\n      n.prototype.setState = function () {\n        a.prototype.setState.apply(this, arguments);\n        this.series.drawPoint(this, this.series.getAnimationVerb());\n      };\n\n      n.prototype.getLabelConfig = function () {\n        var h = a.prototype.getLabelConfig.call(this),\n            n = this.series.yAxis.categories;\n        h.x2 = this.x2;\n        h.yCategory = this.yCategory = n && n[this.y];\n        return h;\n      };\n\n      n.prototype.isValid = function () {\n        return \"number\" === typeof this.x && \"number\" === typeof this.x2;\n      };\n\n      return n;\n    }(u.seriesTypes.column.prototype.pointClass);\n  });\n  F(a, \"Series/XRange/XRangeComposition.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Utilities.js\"]], function (a, u) {\n    var t = u.addEvent,\n        r = u.pick;\n    t(a, \"afterGetSeriesExtremes\", function () {\n      var a = this.series,\n          h;\n\n      if (this.isXAxis) {\n        var t = r(this.dataMax, -Number.MAX_VALUE);\n        a.forEach(function (a) {\n          a.x2Data && a.x2Data.forEach(function (a) {\n            a > t && (t = a, h = !0);\n          });\n        });\n        h && (this.dataMax = t);\n      }\n    });\n  });\n  F(a, \"Series/XRange/XRangeSeries.js\", [a[\"Core/Globals.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"], a[\"Series/XRange/XRangePoint.js\"]], function (a, u, t, r, n) {\n    var h = this && this.__extends || function () {\n      var c = function (d, b) {\n        c = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var c in d) d.hasOwnProperty(c) && (b[c] = d[c]);\n        };\n\n        return c(d, b);\n      };\n\n      return function (d, b) {\n        function J() {\n          this.constructor = d;\n        }\n\n        c(d, b);\n        d.prototype = null === b ? Object.create(b) : (J.prototype = b.prototype, new J());\n      };\n    }(),\n        A = u.parse,\n        B = t.series,\n        D = t.seriesTypes.column,\n        p = D.prototype,\n        w = r.clamp,\n        k = r.correctFloat,\n        f = r.defined;\n\n    u = r.extend;\n    var v = r.find,\n        e = r.isNumber,\n        g = r.isObject,\n        m = r.merge,\n        q = r.pick;\n\n    r = function (c) {\n      function d() {\n        var b = null !== c && c.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      h(d, c);\n\n      d.prototype.init = function () {\n        D.prototype.init.apply(this, arguments);\n        this.options.stacking = void 0;\n      };\n\n      d.prototype.getColumnMetrics = function () {\n        function b() {\n          d.series.forEach(function (b) {\n            var d = b.xAxis;\n            b.xAxis = b.yAxis;\n            b.yAxis = d;\n          });\n        }\n\n        var d = this.chart;\n        b();\n        var c = p.getColumnMetrics.call(this);\n        b();\n        return c;\n      };\n\n      d.prototype.cropData = function (b, d, c, g) {\n        d = B.prototype.cropData.call(this, this.x2Data, d, c, g);\n        d.xData = b.slice(d.start, d.end);\n        return d;\n      };\n\n      d.prototype.findPointIndex = function (b) {\n        var d = this.cropped,\n            c = this.cropStart,\n            g = this.points,\n            q = b.id;\n        if (q) var m = (m = v(g, function (b) {\n          return b.id === q;\n        })) ? m.index : void 0;\n        \"undefined\" === typeof m && (m = (m = v(g, function (d) {\n          return d.x === b.x && d.x2 === b.x2 && !d.touched;\n        })) ? m.index : void 0);\n        d && e(m) && e(c) && m >= c && (m -= c);\n        return m;\n      };\n\n      d.prototype.translatePoint = function (b) {\n        var d,\n            c,\n            p = this.xAxis,\n            v = this.yAxis,\n            k = this.columnMetrics,\n            C = this.options,\n            a = C.minPointLength || 0,\n            E = (null === (d = b.shapeArgs) || void 0 === d ? NaN : d.width) / 2,\n            y = this.pointXOffset = k.offset;\n        d = b.plotX;\n        var z = q(b.x2, b.x + (b.len || 0)),\n            l = p.translate(z, 0, 0, 0, 1);\n        z = Math.abs(l - d);\n        var x = this.chart.inverted,\n            G = q(C.borderWidth, 1) % 2 / 2,\n            O = k.offset,\n            N = Math.round(k.width);\n        a && (a -= z, 0 > a && (a = 0), d -= a / 2, l += a / 2);\n        d = Math.max(d, -10);\n        l = w(l, -10, p.len + 10);\n        f(b.options.pointWidth) && (O -= (Math.ceil(b.options.pointWidth) - N) / 2, N = Math.ceil(b.options.pointWidth));\n        C.pointPlacement && e(b.plotY) && v.categories && (b.plotY = v.translate(b.y, 0, 1, 0, 1, C.pointPlacement));\n        b.shapeArgs = {\n          x: Math.floor(Math.min(d, l)) + G,\n          y: Math.floor(b.plotY + O) + G,\n          width: Math.round(Math.abs(l - d)),\n          height: N,\n          r: this.options.borderRadius\n        };\n        x ? b.tooltipPos[1] += y + E : b.tooltipPos[0] -= E + y - (null === (c = b.shapeArgs) || void 0 === c ? NaN : c.width) / 2;\n        c = b.shapeArgs.x;\n        C = c + b.shapeArgs.width;\n        0 > c || C > p.len ? (c = w(c, 0, p.len), C = w(C, 0, p.len), E = C - c, b.dlBox = m(b.shapeArgs, {\n          x: c,\n          width: C - c,\n          centerX: E ? E / 2 : null\n        })) : b.dlBox = null;\n        c = b.tooltipPos;\n        C = x ? 1 : 0;\n        E = x ? 0 : 1;\n        k = this.columnMetrics ? this.columnMetrics.offset : -k.width / 2;\n        c[C] = x ? c[C] + b.shapeArgs.width / 2 : c[C] + (p.reversed ? -1 : 0) * b.shapeArgs.width;\n        c[E] = w(c[E] + (x ? -1 : 1) * k, 0, v.len - 1);\n        if (k = b.partialFill) g(k) && (k = k.amount), e(k) || (k = 0), v = b.shapeArgs, b.partShapeArgs = {\n          x: v.x,\n          y: v.y,\n          width: v.width,\n          height: v.height,\n          r: this.options.borderRadius\n        }, d = Math.max(Math.round(z * k + b.plotX - d), 0), b.clipRectArgs = {\n          x: p.reversed ? v.x + z - d : v.x,\n          y: v.y,\n          width: d,\n          height: v.height\n        };\n      };\n\n      d.prototype.translate = function () {\n        p.translate.apply(this, arguments);\n        this.points.forEach(function (b) {\n          this.translatePoint(b);\n        }, this);\n      };\n\n      d.prototype.drawPoint = function (b, d) {\n        var c = this.options,\n            J = this.chart.renderer,\n            e = b.graphic,\n            f = b.shapeType,\n            p = b.shapeArgs,\n            v = b.partShapeArgs,\n            E = b.clipRectArgs,\n            y = b.partialFill,\n            z = c.stacking && !c.borderRadius,\n            l = b.state,\n            x = c.states[l || \"normal\"] || {},\n            G = \"undefined\" === typeof l ? \"attr\" : d;\n        l = this.pointAttribs(b, l);\n        x = q(this.chart.options.chart.animation, x.animation);\n        if (b.isNull || !1 === b.visible) e && (b.graphic = e.destroy());else {\n          if (e) e.rect[d](p);else b.graphic = e = J.g(\"point\").addClass(b.getClassName()).add(b.group || this.group), e.rect = J[f](m(p)).addClass(b.getClassName()).addClass(\"highcharts-partfill-original\").add(e);\n          v && (e.partRect ? (e.partRect[d](m(v)), e.partialClipRect[d](m(E))) : (e.partialClipRect = J.clipRect(E.x, E.y, E.width, E.height), e.partRect = J[f](v).addClass(\"highcharts-partfill-overlay\").add(e).clip(e.partialClipRect)));\n          this.chart.styledMode || (e.rect[d](l, x).shadow(c.shadow, null, z), v && (g(y) || (y = {}), g(c.partialFill) && (y = m(c.partialFill, y)), b = y.fill || A(l.fill).brighten(-.3).get() || A(b.color || this.color).brighten(-.3).get(), l.fill = b, e.partRect[G](l, x).shadow(c.shadow, null, z)));\n        }\n      };\n\n      d.prototype.drawPoints = function () {\n        var b = this,\n            d = b.getAnimationVerb();\n        b.points.forEach(function (c) {\n          b.drawPoint(c, d);\n        });\n      };\n\n      d.prototype.getAnimationVerb = function () {\n        return this.chart.pointCount < (this.options.animationLimit || 250) ? \"animate\" : \"attr\";\n      };\n\n      d.prototype.isPointInside = function (b) {\n        var d = b.shapeArgs,\n            g = b.plotX,\n            q = b.plotY;\n        return d ? \"undefined\" !== typeof g && \"undefined\" !== typeof q && 0 <= q && q <= this.yAxis.len && 0 <= d.x + d.width && g <= this.xAxis.len : c.prototype.isPointInside.apply(this, arguments);\n      };\n\n      d.defaultOptions = m(D.defaultOptions, {\n        colorByPoint: !0,\n        dataLabels: {\n          formatter: function () {\n            var b = this.point.partialFill;\n            g(b) && (b = b.amount);\n            if (e(b) && 0 < b) return k(100 * b) + \"%\";\n          },\n          inside: !0,\n          verticalAlign: \"middle\"\n        },\n        tooltip: {\n          headerFormat: '<span style=\"font-size: 10px\">{point.x} - {point.x2}</span><br/>',\n          pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.yCategory}</b><br/>'\n        },\n        borderRadius: 3,\n        pointRange: 0\n      });\n      return d;\n    }(D);\n\n    u(r.prototype, {\n      type: \"xrange\",\n      parallelArrays: [\"x\", \"x2\", \"y\"],\n      requireSorting: !1,\n      animate: B.prototype.animate,\n      cropShoulder: 1,\n      getExtremesFromAll: !0,\n      autoIncrement: a.noop,\n      buildKDTree: a.noop,\n      pointClass: n\n    });\n    t.registerSeriesType(\"xrange\", r);\n    \"\";\n    return r;\n  });\n  F(a, \"Series/Gantt/GanttPoint.js\", [a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, u) {\n    var t = this && this.__extends || function () {\n      var a = function (h, n) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, h) {\n          a.__proto__ = h;\n        } || function (a, h) {\n          for (var p in h) h.hasOwnProperty(p) && (a[p] = h[p]);\n        };\n\n        return a(h, n);\n      };\n\n      return function (h, n) {\n        function r() {\n          this.constructor = h;\n        }\n\n        a(h, n);\n        h.prototype = null === n ? Object.create(n) : (r.prototype = n.prototype, new r());\n      };\n    }(),\n        r = u.pick;\n\n    return function (a) {\n      function h() {\n        var h = null !== a && a.apply(this, arguments) || this;\n        h.options = void 0;\n        h.series = void 0;\n        return h;\n      }\n\n      t(h, a);\n\n      h.setGanttPointAliases = function (a) {\n        function h(h, p) {\n          \"undefined\" !== typeof p && (a[h] = p);\n        }\n\n        h(\"x\", r(a.start, a.x));\n        h(\"x2\", r(a.end, a.x2));\n        h(\"partialFill\", r(a.completed, a.partialFill));\n      };\n\n      h.prototype.applyOptions = function (n, r) {\n        n = a.prototype.applyOptions.call(this, n, r);\n        h.setGanttPointAliases(n);\n        return n;\n      };\n\n      h.prototype.isValid = function () {\n        return (\"number\" === typeof this.start || \"number\" === typeof this.x) && (\"number\" === typeof this.end || \"number\" === typeof this.x2 || this.milestone);\n      };\n\n      return h;\n    }(a.seriesTypes.xrange.prototype.pointClass);\n  });\n  F(a, \"Gantt/Tree.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    var u = a.extend,\n        t = a.isNumber,\n        r = a.pick,\n        n = function (a, h) {\n      var n = a.reduce(function (p, a) {\n        var k = r(a.parent, \"\");\n        \"undefined\" === typeof p[k] && (p[k] = []);\n        p[k].push(a);\n        return p;\n      }, {});\n      Object.keys(n).forEach(function (p, a) {\n        var k = n[p];\n        \"\" !== p && -1 === h.indexOf(p) && (k.forEach(function (f) {\n          a[\"\"].push(f);\n        }), delete a[p]);\n      });\n      return n;\n    },\n        h = function (a, n, D, p, w, k) {\n      var f = 0,\n          v = 0,\n          e = k && k.after,\n          g = k && k.before;\n      n = {\n        data: p,\n        depth: D - 1,\n        id: a,\n        level: D,\n        parent: n\n      };\n      var m, q;\n      \"function\" === typeof g && g(n, k);\n      g = (w[a] || []).map(function (c) {\n        var d = h(c.id, a, D + 1, c, w, k),\n            b = c.start;\n        c = !0 === c.milestone ? b : c.end;\n        m = !t(m) || b < m ? b : m;\n        q = !t(q) || c > q ? c : q;\n        f = f + 1 + d.descendants;\n        v = Math.max(d.height + 1, v);\n        return d;\n      });\n      p && (p.start = r(p.start, m), p.end = r(p.end, q));\n      u(n, {\n        children: g,\n        descendants: f,\n        height: v\n      });\n      \"function\" === typeof e && e(n, k);\n      return n;\n    };\n\n    return {\n      getListOfParents: n,\n      getNode: h,\n      getTree: function (a, r) {\n        var D = a.map(function (a) {\n          return a.id;\n        });\n        a = n(a, D);\n        return h(\"\", null, 1, null, a, r);\n      }\n    };\n  });\n  F(a, \"Core/Axis/TreeGridTick.js\", [a[\"Core/Color/Palette.js\"], a[\"Core/Utilities.js\"]], function (a, u) {\n    var t = u.addEvent,\n        r = u.isObject,\n        n = u.isNumber,\n        h = u.pick,\n        A = u.wrap,\n        B;\n\n    (function (D) {\n      function p() {\n        this.treeGrid || (this.treeGrid = new e(this));\n      }\n\n      function w(g, e) {\n        g = g.treeGrid;\n        var q = !g.labelIcon,\n            c = e.renderer,\n            d = e.xy,\n            b = e.options,\n            J = b.width,\n            m = b.height,\n            f = d.x - J / 2 - b.padding;\n        d = d.y - m / 2;\n        var v = e.collapsed ? 90 : 180,\n            p = e.show && n(d),\n            k = g.labelIcon;\n        k || (g.labelIcon = k = c.path(c.symbols[b.type](b.x, b.y, J, m)).addClass(\"highcharts-label-icon\").add(e.group));\n        p || k.attr({\n          y: -9999\n        });\n        c.styledMode || k.attr({\n          \"stroke-width\": 1,\n          fill: h(e.color, a.neutralColor60)\n        }).css({\n          cursor: \"pointer\",\n          stroke: b.lineColor,\n          strokeWidth: b.lineWidth\n        });\n        k[q ? \"attr\" : \"animate\"]({\n          translateX: f,\n          translateY: d,\n          rotation: v\n        });\n      }\n\n      function k(g, e, q, c, d, b, J, f, a) {\n        var m = h(this.options && this.options.labels, b);\n        b = this.pos;\n        var I = this.axis,\n            v = \"treegrid\" === I.options.type;\n        g = g.apply(this, [e, q, c, d, m, J, f, a]);\n        v && (e = m && r(m.symbol, !0) ? m.symbol : {}, m = m && n(m.indentation) ? m.indentation : 0, b = (b = (I = I.treeGrid.mapOfPosToGridNode) && I[b]) && b.depth || 1, g.x += e.width + 2 * e.padding + (b - 1) * m);\n        return g;\n      }\n\n      function f(g) {\n        var e = this,\n            q = e.pos,\n            c = e.axis,\n            d = e.label,\n            b = c.treeGrid.mapOfPosToGridNode,\n            J = c.options,\n            f = h(e.options && e.options.labels, J && J.labels),\n            a = f && r(f.symbol, !0) ? f.symbol : {},\n            v = (b = b && b[q]) && b.depth;\n        J = \"treegrid\" === J.type;\n        var p = -1 < c.tickPositions.indexOf(q);\n        q = c.chart.styledMode;\n        J && b && d && d.element && d.addClass(\"highcharts-treegrid-node-level-\" + v);\n        g.apply(e, Array.prototype.slice.call(arguments, 1));\n        J && d && d.element && b && b.descendants && 0 < b.descendants && (c = c.treeGrid.isCollapsed(b), w(e, {\n          color: !q && d.styles && d.styles.color || \"\",\n          collapsed: c,\n          group: d.parentGroup,\n          options: a,\n          renderer: d.renderer,\n          show: p,\n          xy: d.xy\n        }), a = \"highcharts-treegrid-node-\" + (c ? \"expanded\" : \"collapsed\"), d.addClass(\"highcharts-treegrid-node-\" + (c ? \"collapsed\" : \"expanded\")).removeClass(a), q || d.css({\n          cursor: \"pointer\"\n        }), [d, e.treeGrid.labelIcon].forEach(function (b) {\n          b && !b.attachedTreeGridEvents && (t(b.element, \"mouseover\", function () {\n            d.addClass(\"highcharts-treegrid-node-active\");\n            d.renderer.styledMode || d.css({\n              textDecoration: \"underline\"\n            });\n          }), t(b.element, \"mouseout\", function () {\n            var b = r(f.style) ? f.style : {};\n            d.removeClass(\"highcharts-treegrid-node-active\");\n            d.renderer.styledMode || d.css({\n              textDecoration: b.textDecoration\n            });\n          }), t(b.element, \"click\", function () {\n            e.treeGrid.toggleCollapse();\n          }), b.attachedTreeGridEvents = !0);\n        }));\n      }\n\n      var v = !1;\n\n      D.compose = function (e) {\n        v || (t(e, \"init\", p), A(e.prototype, \"getLabelPosition\", k), A(e.prototype, \"renderLabel\", f), e.prototype.collapse = function (e) {\n          this.treeGrid.collapse(e);\n        }, e.prototype.expand = function (e) {\n          this.treeGrid.expand(e);\n        }, e.prototype.toggleCollapse = function (e) {\n          this.treeGrid.toggleCollapse(e);\n        }, v = !0);\n      };\n\n      var e = function () {\n        function e(e) {\n          this.tick = e;\n        }\n\n        e.prototype.collapse = function (e) {\n          var g = this.tick,\n              c = g.axis,\n              d = c.brokenAxis;\n          d && c.treeGrid.mapOfPosToGridNode && (g = c.treeGrid.collapse(c.treeGrid.mapOfPosToGridNode[g.pos]), d.setBreaks(g, h(e, !0)));\n        };\n\n        e.prototype.expand = function (e) {\n          var g = this.tick,\n              c = g.axis,\n              d = c.brokenAxis;\n          d && c.treeGrid.mapOfPosToGridNode && (g = c.treeGrid.expand(c.treeGrid.mapOfPosToGridNode[g.pos]), d.setBreaks(g, h(e, !0)));\n        };\n\n        e.prototype.toggleCollapse = function (e) {\n          var g = this.tick,\n              c = g.axis,\n              d = c.brokenAxis;\n          d && c.treeGrid.mapOfPosToGridNode && (g = c.treeGrid.toggleCollapse(c.treeGrid.mapOfPosToGridNode[g.pos]), d.setBreaks(g, h(e, !0)));\n        };\n\n        return e;\n      }();\n\n      D.Additions = e;\n    })(B || (B = {}));\n\n    return B;\n  });\n  F(a, \"Mixins/TreeSeries.js\", [a[\"Core/Color/Color.js\"], a[\"Core/Utilities.js\"]], function (a, u) {\n    var t = u.extend,\n        r = u.isArray,\n        n = u.isNumber,\n        h = u.isObject,\n        A = u.merge,\n        B = u.pick;\n    return {\n      getColor: function (h, p) {\n        var w = p.index,\n            k = p.mapOptionsToLevel,\n            f = p.parentColor,\n            v = p.parentColorIndex,\n            e = p.series,\n            g = p.colors,\n            m = p.siblings,\n            q = e.points,\n            c = e.chart.options.chart,\n            d;\n\n        if (h) {\n          q = q[h.i];\n          h = k[h.level] || {};\n\n          if (k = q && h.colorByPoint) {\n            var b = q.index % (g ? g.length : c.colorCount);\n            var J = g && g[b];\n          }\n\n          if (!e.chart.styledMode) {\n            g = q && q.options.color;\n            c = h && h.color;\n            if (d = f) d = (d = h && h.colorVariation) && \"brightness\" === d.key ? a.parse(f).brighten(w / m * d.to).get() : f;\n            d = B(g, c, J, d, e.color);\n          }\n\n          var I = B(q && q.options.colorIndex, h && h.colorIndex, b, v, p.colorIndex);\n        }\n\n        return {\n          color: d,\n          colorIndex: I\n        };\n      },\n      getLevelOptions: function (a) {\n        var p = null;\n\n        if (h(a)) {\n          p = {};\n          var w = n(a.from) ? a.from : 1;\n          var k = a.levels;\n          var f = {};\n          var v = h(a.defaults) ? a.defaults : {};\n          r(k) && (f = k.reduce(function (e, g) {\n            if (h(g) && n(g.level)) {\n              var a = A({}, g);\n              var q = \"boolean\" === typeof a.levelIsConstant ? a.levelIsConstant : v.levelIsConstant;\n              delete a.levelIsConstant;\n              delete a.level;\n              g = g.level + (q ? 0 : w - 1);\n              h(e[g]) ? t(e[g], a) : e[g] = a;\n            }\n\n            return e;\n          }, {}));\n          k = n(a.to) ? a.to : 1;\n\n          for (a = 0; a <= k; a++) p[a] = A({}, v, h(f[a]) ? f[a] : {});\n        }\n\n        return p;\n      },\n      setTreeValues: function k(a, w) {\n        var f = w.before,\n            v = w.idRoot,\n            e = w.mapIdToNode[v],\n            g = w.points[a.i],\n            m = g && g.options || {},\n            q = 0,\n            c = [];\n        t(a, {\n          levelDynamic: a.level - ((\"boolean\" === typeof w.levelIsConstant ? w.levelIsConstant : 1) ? 0 : e.level),\n          name: B(g && g.name, \"\"),\n          visible: v === a.id || (\"boolean\" === typeof w.visible ? w.visible : !1)\n        });\n        \"function\" === typeof f && (a = f(a, w));\n        a.children.forEach(function (d, b) {\n          var e = t({}, w);\n          t(e, {\n            index: b,\n            siblings: a.children.length,\n            visible: a.visible\n          });\n          d = k(d, e);\n          c.push(d);\n          d.visible && (q += d.val);\n        });\n        a.visible = 0 < q || a.visible;\n        f = B(m.value, q);\n        t(a, {\n          children: c,\n          childrenTotal: q,\n          isLeaf: a.visible && !q,\n          val: f\n        });\n        return a;\n      },\n      updateRootId: function (a) {\n        if (h(a)) {\n          var w = h(a.options) ? a.options : {};\n          w = B(a.rootNode, w.rootId, \"\");\n          h(a.userOptions) && (a.userOptions.rootId = w);\n          a.rootNode = w;\n        }\n\n        return w;\n      }\n    };\n  });\n  F(a, \"Core/Axis/GridAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/Tick.js\"], a[\"Core/Utilities.js\"]], function (a, u, t, r) {\n    var n = r.addEvent,\n        h = r.defined,\n        A = r.erase,\n        B = r.find,\n        D = r.isArray,\n        p = r.isNumber,\n        w = r.merge,\n        k = r.pick,\n        f = r.timeUnits,\n        v = r.wrap,\n        e = u.Chart,\n        g = function (c) {\n      var d = c.options;\n      d.labels || (d.labels = {});\n      d.labels.align = k(d.labels.align, \"center\");\n      c.categories || (d.showLastLabel = !1);\n      c.labelRotation = 0;\n      d.labels.rotation = 0;\n    };\n\n    \"\";\n\n    a.prototype.getMaxLabelDimensions = function (c, d) {\n      var b = {\n        width: 0,\n        height: 0\n      };\n      d.forEach(function (d) {\n        d = c[d];\n\n        if (r.isObject(d, !0)) {\n          var e = r.isObject(d.label, !0) ? d.label : {};\n          d = e.getBBox ? e.getBBox().height : 0;\n          e.textStr && !p(e.textPxLength) && (e.textPxLength = e.getBBox().width);\n          var a = p(e.textPxLength) ? Math.round(e.textPxLength) : 0;\n          e.textStr && (a = Math.round(e.getBBox().width));\n          b.height = Math.max(d, b.height);\n          b.width = Math.max(a, b.width);\n        }\n      });\n      return b;\n    };\n\n    u.dateFormats.W = function (c) {\n      c = new this.Date(c);\n      var d = (this.get(\"Day\", c) + 6) % 7,\n          b = new this.Date(c.valueOf());\n      this.set(\"Date\", b, this.get(\"Date\", c) - d + 3);\n      d = new this.Date(this.get(\"FullYear\", b), 0, 1);\n      4 !== this.get(\"Day\", d) && (this.set(\"Month\", c, 0), this.set(\"Date\", c, 1 + (11 - this.get(\"Day\", d)) % 7));\n      return (1 + Math.floor((b.valueOf() - d.valueOf()) / 6048E5)).toString();\n    };\n\n    u.dateFormats.E = function (c) {\n      return this.dateFormat(\"%a\", c, !0).charAt(0);\n    };\n\n    n(e, \"afterSetChartSize\", function () {\n      this.axes.forEach(function (c) {\n        (c.grid && c.grid.columns || []).forEach(function (d) {\n          d.setAxisSize();\n          d.setAxisTranslation();\n        });\n      });\n    });\n    n(t, \"afterGetLabelPosition\", function (c) {\n      var d = this.label,\n          b = this.axis,\n          e = b.reversed,\n          a = b.chart,\n          g = b.options.grid || {},\n          f = b.options.labels,\n          v = f.align,\n          m = q.Side[b.side],\n          k = c.tickmarkOffset,\n          E = b.tickPositions,\n          y = this.pos - k;\n      E = p(E[c.index + 1]) ? E[c.index + 1] - k : b.max + k;\n      var z = b.tickSize(\"tick\");\n      k = z ? z[0] : 0;\n      z = z ? z[1] / 2 : 0;\n\n      if (!0 === g.enabled) {\n        if (\"top\" === m) {\n          g = b.top + b.offset;\n          var l = g - k;\n        } else \"bottom\" === m ? (l = a.chartHeight - b.bottom + b.offset, g = l + k) : (g = b.top + b.len - b.translate(e ? E : y), l = b.top + b.len - b.translate(e ? y : E));\n\n        \"right\" === m ? (m = a.chartWidth - b.right + b.offset, e = m + k) : \"left\" === m ? (e = b.left + b.offset, m = e - k) : (m = Math.round(b.left + b.translate(e ? E : y)) - z, e = Math.round(b.left + b.translate(e ? y : E)) - z);\n        this.slotWidth = e - m;\n        c.pos.x = \"left\" === v ? m : \"right\" === v ? e : m + (e - m) / 2;\n        c.pos.y = l + (g - l) / 2;\n        a = a.renderer.fontMetrics(f.style.fontSize, d.element);\n        d = d.getBBox().height;\n        f.useHTML ? c.pos.y += a.b + -(d / 2) : (d = Math.round(d / a.h), c.pos.y += (a.b - (a.h - a.f)) / 2 + -((d - 1) * a.h / 2));\n        c.pos.x += b.horiz && f.x || 0;\n      }\n    });\n\n    var m = function () {\n      function c(d) {\n        this.axis = d;\n      }\n\n      c.prototype.isOuterAxis = function () {\n        var d = this.axis,\n            b = d.grid.columnIndex,\n            c = d.linkedParent && d.linkedParent.grid.columns || d.grid.columns,\n            e = b ? d.linkedParent : d,\n            a = -1,\n            g = 0;\n        d.chart[d.coll].forEach(function (b, c) {\n          b.side !== d.side || b.options.isInternal || (g = c, b === e && (a = c));\n        });\n        return g === a && (p(b) ? c.length === b : !0);\n      };\n\n      c.prototype.renderBorder = function (d) {\n        var b = this.axis,\n            c = b.chart.renderer,\n            e = b.options;\n        d = c.path(d).addClass(\"highcharts-axis-line\").add(b.axisBorder);\n        c.styledMode || d.attr({\n          stroke: e.lineColor,\n          \"stroke-width\": e.lineWidth,\n          zIndex: 7\n        });\n        return d;\n      };\n\n      return c;\n    }(),\n        q = function () {\n      function c() {}\n\n      c.compose = function (d) {\n        a.keepProps.push(\"grid\");\n        v(d.prototype, \"unsquish\", c.wrapUnsquish);\n        n(d, \"init\", c.onInit);\n        n(d, \"afterGetOffset\", c.onAfterGetOffset);\n        n(d, \"afterGetTitlePosition\", c.onAfterGetTitlePosition);\n        n(d, \"afterInit\", c.onAfterInit);\n        n(d, \"afterRender\", c.onAfterRender);\n        n(d, \"afterSetAxisTranslation\", c.onAfterSetAxisTranslation);\n        n(d, \"afterSetOptions\", c.onAfterSetOptions);\n        n(d, \"afterSetOptions\", c.onAfterSetOptions2);\n        n(d, \"afterSetScale\", c.onAfterSetScale);\n        n(d, \"afterTickSize\", c.onAfterTickSize);\n        n(d, \"trimTicks\", c.onTrimTicks);\n        n(d, \"destroy\", c.onDestroy);\n      };\n\n      c.onAfterGetOffset = function () {\n        var d = this.grid;\n        (d && d.columns || []).forEach(function (b) {\n          b.getOffset();\n        });\n      };\n\n      c.onAfterGetTitlePosition = function (d) {\n        if (!0 === (this.options.grid || {}).enabled) {\n          var b = this.axisTitle,\n              e = this.height,\n              a = this.horiz,\n              g = this.left,\n              f = this.offset,\n              q = this.opposite,\n              m = this.options.title,\n              v = void 0 === m ? {} : m;\n          m = this.top;\n          var E = this.width,\n              y = this.tickSize(),\n              z = b && b.getBBox().width,\n              l = v.x || 0,\n              x = v.y || 0,\n              G = k(v.margin, a ? 5 : 10);\n          b = this.chart.renderer.fontMetrics(v.style && v.style.fontSize, b).f;\n          y = (a ? m + e : g) + (a ? 1 : -1) * (q ? -1 : 1) * (y ? y[0] / 2 : 0) + (this.side === c.Side.bottom ? b : 0);\n          d.titlePosition.x = a ? g - z / 2 - G + l : y + (q ? E : 0) + f + l;\n          d.titlePosition.y = a ? y - (q ? e : 0) + (q ? b : -b) / 2 + f + x : m - G + x;\n        }\n      };\n\n      c.onAfterInit = function () {\n        var d = this.chart,\n            b = this.options.grid;\n        b = void 0 === b ? {} : b;\n        var c = this.userOptions;\n        b.enabled && (g(this), v(this, \"labelFormatter\", function (b) {\n          var d = this.axis,\n              c = this.value,\n              e = d.tickPositions,\n              y = (d.isLinked ? d.linkedParent : d).series[0],\n              z = c === e[0];\n          e = c === e[e.length - 1];\n          var l = y && B(y.options.data, function (l) {\n            return l[d.isXAxis ? \"x\" : \"y\"] === c;\n          });\n\n          if (l && y.is(\"gantt\")) {\n            var x = w(l);\n            u.seriesTypes.gantt.prototype.pointClass.setGanttPointAliases(x);\n          }\n\n          this.isFirst = z;\n          this.isLast = e;\n          this.point = x;\n          return b.call(this);\n        }));\n        if (b.columns) for (var e = this.grid.columns = [], q = this.grid.columnIndex = 0; ++q < b.columns.length;) {\n          var f = w(c, b.columns[b.columns.length - q - 1], {\n            linkedTo: 0,\n            type: \"category\",\n            scrollbar: {\n              enabled: !1\n            }\n          });\n          delete f.grid.columns;\n          f = new a(this.chart, f);\n          f.grid.isColumn = !0;\n          f.grid.columnIndex = q;\n          A(d.axes, f);\n          A(d[this.coll], f);\n          e.push(f);\n        }\n      };\n\n      c.onAfterRender = function () {\n        var d,\n            b = this.grid,\n            e = this.options;\n\n        if (!0 === (e.grid || {}).enabled) {\n          this.maxLabelDimensions = this.getMaxLabelDimensions(this.ticks, this.tickPositions);\n          this.rightWall && this.rightWall.destroy();\n\n          if (this.grid && this.grid.isOuterAxis() && this.axisLine && (e = e.lineWidth)) {\n            e = this.getLinePath(e);\n            var a = e[0],\n                g = e[1],\n                f = ((this.tickSize(\"tick\") || [1])[0] - 1) * (this.side === c.Side.top || this.side === c.Side.left ? -1 : 1);\n            \"M\" === a[0] && \"L\" === g[0] && (this.horiz ? (a[2] += f, g[2] += f) : (a[1] += f, g[1] += f));\n            !this.horiz && this.chart.marginRight && (a = [a, [\"L\", this.left, a[2]]], f = [\"L\", this.chart.chartWidth - this.chart.marginRight, this.toPixels(this.max + this.tickmarkOffset)], g = [[\"M\", g[1], this.toPixels(this.max + this.tickmarkOffset)], f], this.grid.upperBorder || 0 === this.min % 1 || (this.grid.upperBorder = this.grid.renderBorder(a)), this.grid.upperBorder && this.grid.upperBorder.animate({\n              d: a\n            }), this.grid.lowerBorder || 0 === this.max % 1 || (this.grid.lowerBorder = this.grid.renderBorder(g)), this.grid.lowerBorder && this.grid.lowerBorder.animate({\n              d: g\n            }));\n            this.grid.axisLineExtra ? this.grid.axisLineExtra.animate({\n              d: e\n            }) : this.grid.axisLineExtra = this.grid.renderBorder(e);\n            this.axisLine[this.showAxis ? \"show\" : \"hide\"](!0);\n          }\n\n          (b && b.columns || []).forEach(function (b) {\n            b.render();\n          });\n          !this.horiz && this.chart.hasRendered && (this.scrollbar || (null === (d = this.linkedParent) || void 0 === d ? 0 : d.scrollbar)) && (d = this.max, b = this.tickmarkOffset, e = this.tickPositions[this.tickPositions.length - 1], g = this.tickPositions[0], this.min - g > b ? this.ticks[g].label.hide() : this.ticks[g].label.show(), e - d > b ? this.ticks[e].label.hide() : this.ticks[e].label.show(), e - d < b && 0 < e - d && this.ticks[e].isLast ? this.ticks[e].mark.hide() : this.ticks[e - 1] && this.ticks[e - 1].mark.show());\n        }\n      };\n\n      c.onAfterSetAxisTranslation = function () {\n        var d,\n            b = this.tickPositions && this.tickPositions.info,\n            c = this.options,\n            e = this.userOptions.labels || {};\n        (c.grid || {}).enabled && (this.horiz ? (this.series.forEach(function (b) {\n          b.options.pointRange = 0;\n        }), b && c.dateTimeLabelFormats && c.labels && !h(e.align) && (!1 === c.dateTimeLabelFormats[b.unitName].range || 1 < b.count) && (c.labels.align = \"left\", h(e.x) || (c.labels.x = 3))) : \"treegrid\" !== this.options.type && (null === (d = this.grid) || void 0 === d ? 0 : d.columns) && (this.minPointOffset = this.tickInterval));\n      };\n\n      c.onAfterSetOptions = function (d) {\n        var b = this.options;\n        d = d.userOptions;\n        var c = b && r.isObject(b.grid, !0) ? b.grid : {};\n\n        if (!0 === c.enabled) {\n          var e = w(!0, {\n            className: \"highcharts-grid-axis \" + (d.className || \"\"),\n            dateTimeLabelFormats: {\n              hour: {\n                list: [\"%H:%M\", \"%H\"]\n              },\n              day: {\n                list: [\"%A, %e. %B\", \"%a, %e. %b\", \"%E\"]\n              },\n              week: {\n                list: [\"Week %W\", \"W%W\"]\n              },\n              month: {\n                list: [\"%B\", \"%b\", \"%o\"]\n              }\n            },\n            grid: {\n              borderWidth: 1\n            },\n            labels: {\n              padding: 2,\n              style: {\n                fontSize: \"13px\"\n              }\n            },\n            margin: 0,\n            title: {\n              text: null,\n              reserveSpace: !1,\n              rotation: 0\n            },\n            units: [[\"millisecond\", [1, 10, 100]], [\"second\", [1, 10]], [\"minute\", [1, 5, 15]], [\"hour\", [1, 6]], [\"day\", [1]], [\"week\", [1]], [\"month\", [1]], [\"year\", null]]\n          }, d);\n          \"xAxis\" === this.coll && (h(d.linkedTo) && !h(d.tickPixelInterval) && (e.tickPixelInterval = 350), h(d.tickPixelInterval) || !h(d.linkedTo) || h(d.tickPositioner) || h(d.tickInterval) || (e.tickPositioner = function (b, d) {\n            var c = this.linkedParent && this.linkedParent.tickPositions && this.linkedParent.tickPositions.info;\n\n            if (c) {\n              var a,\n                  g = e.units;\n\n              for (a = 0; a < g.length; a++) if (g[a][0] === c.unitName) {\n                var q = a;\n                break;\n              }\n\n              if (g[q + 1]) {\n                var y = g[q + 1][0];\n                var z = (g[q + 1][1] || [1])[0];\n              } else \"year\" === c.unitName && (y = \"year\", z = 10 * c.count);\n\n              c = f[y];\n              this.tickInterval = c * z;\n              return this.getTimeTicks({\n                unitRange: c,\n                count: z,\n                unitName: y\n              }, b, d, this.options.startOfWeek);\n            }\n          }));\n          w(!0, this.options, e);\n          this.horiz && (b.minPadding = k(d.minPadding, 0), b.maxPadding = k(d.maxPadding, 0));\n          p(b.grid.borderWidth) && (b.tickWidth = b.lineWidth = c.borderWidth);\n        }\n      };\n\n      c.onAfterSetOptions2 = function (d) {\n        d = (d = d.userOptions) && d.grid || {};\n        var b = d.columns;\n        d.enabled && b && w(!0, this.options, b[b.length - 1]);\n      };\n\n      c.onAfterSetScale = function () {\n        (this.grid.columns || []).forEach(function (d) {\n          d.setScale();\n        });\n      };\n\n      c.onAfterTickSize = function (d) {\n        var b = a.defaultLeftAxisOptions,\n            c = this.horiz,\n            e = this.maxLabelDimensions,\n            g = this.options.grid;\n        g = void 0 === g ? {} : g;\n        g.enabled && e && (b = 2 * Math.abs(b.labels.x), c = c ? g.cellHeight || b + e.height : b + e.width, D(d.tickSize) ? d.tickSize[0] = c : d.tickSize = [c, 0]);\n      };\n\n      c.onDestroy = function (d) {\n        var b = this.grid;\n        (b.columns || []).forEach(function (b) {\n          b.destroy(d.keepEvents);\n        });\n        b.columns = void 0;\n      };\n\n      c.onInit = function (d) {\n        d = d.userOptions || {};\n        var b = d.grid || {};\n        b.enabled && h(b.borderColor) && (d.tickColor = d.lineColor = b.borderColor);\n        this.grid || (this.grid = new m(this));\n      };\n\n      c.onTrimTicks = function () {\n        var d = this.options,\n            b = this.categories,\n            c = this.tickPositions,\n            e = c[0],\n            a = c[c.length - 1],\n            g = this.linkedParent && this.linkedParent.min || this.min,\n            f = this.linkedParent && this.linkedParent.max || this.max,\n            q = this.tickInterval;\n        !0 !== (d.grid || {}).enabled || b || !this.horiz && !this.isLinked || (e < g && e + q > g && !d.startOnTick && (c[0] = g), a > f && a - q < f && !d.endOnTick && (c[c.length - 1] = f));\n      };\n\n      c.wrapUnsquish = function (d) {\n        var b = this.options.grid;\n        return !0 === (void 0 === b ? {} : b).enabled && this.categories ? this.tickInterval : d.apply(this, Array.prototype.slice.call(arguments, 1));\n      };\n\n      return c;\n    }();\n\n    (function (c) {\n      c = c.Side || (c.Side = {});\n      c[c.top = 0] = \"top\";\n      c[c.right = 1] = \"right\";\n      c[c.bottom = 2] = \"bottom\";\n      c[c.left = 3] = \"left\";\n    })(q || (q = {}));\n\n    q.compose(a);\n    return q;\n  });\n  F(a, \"Core/Axis/BrokenAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Series/Series.js\"], a[\"Extensions/Stacking.js\"], a[\"Core/Utilities.js\"]], function (a, u, t, r) {\n    var n = r.addEvent,\n        h = r.find,\n        A = r.fireEvent,\n        B = r.isArray,\n        D = r.isNumber,\n        p = r.pick,\n        w = function () {\n      function k(a) {\n        this.hasBreaks = !1;\n        this.axis = a;\n      }\n\n      k.isInBreak = function (a, v) {\n        var e = a.repeat || Infinity,\n            g = a.from,\n            f = a.to - a.from;\n        v = v >= g ? (v - g) % e : e - (g - v) % e;\n        return a.inclusive ? v <= f : v < f && 0 !== v;\n      };\n\n      k.lin2Val = function (a) {\n        var f = this.brokenAxis;\n        f = f && f.breakArray;\n        if (!f) return a;\n        var e;\n\n        for (e = 0; e < f.length; e++) {\n          var g = f[e];\n          if (g.from >= a) break;else g.to < a ? a += g.len : k.isInBreak(g, a) && (a += g.len);\n        }\n\n        return a;\n      };\n\n      k.val2Lin = function (a) {\n        var f = this.brokenAxis;\n        f = f && f.breakArray;\n        if (!f) return a;\n        var e = a,\n            g;\n\n        for (g = 0; g < f.length; g++) {\n          var m = f[g];\n          if (m.to <= a) e -= m.len;else if (m.from >= a) break;else if (k.isInBreak(m, a)) {\n            e -= a - m.from;\n            break;\n          }\n        }\n\n        return e;\n      };\n\n      k.prototype.findBreakAt = function (a, k) {\n        return h(k, function (e) {\n          return e.from < a && a < e.to;\n        });\n      };\n\n      k.prototype.isInAnyBreak = function (a, v) {\n        var e = this.axis,\n            g = e.options.breaks,\n            f = g && g.length,\n            q;\n\n        if (f) {\n          for (; f--;) if (k.isInBreak(g[f], a)) {\n            var c = !0;\n            q || (q = p(g[f].showPoints, !e.isXAxis));\n          }\n\n          var d = c && v ? c && !q : c;\n        }\n\n        return d;\n      };\n\n      k.prototype.setBreaks = function (f, v) {\n        var e = this,\n            g = e.axis,\n            m = B(f) && !!f.length;\n        g.isDirty = e.hasBreaks !== m;\n        e.hasBreaks = m;\n        g.options.breaks = g.userOptions.breaks = f;\n        g.forceRedraw = !0;\n        g.series.forEach(function (e) {\n          e.isDirty = !0;\n        });\n        m || g.val2lin !== k.val2Lin || (delete g.val2lin, delete g.lin2val);\n        m && (g.userOptions.ordinal = !1, g.lin2val = k.lin2Val, g.val2lin = k.val2Lin, g.setExtremes = function (g, c, d, b, f) {\n          if (e.hasBreaks) {\n            for (var q, m = this.options.breaks; q = e.findBreakAt(g, m);) g = q.to;\n\n            for (; q = e.findBreakAt(c, m);) c = q.from;\n\n            c < g && (c = g);\n          }\n\n          a.prototype.setExtremes.call(this, g, c, d, b, f);\n        }, g.setAxisTranslation = function () {\n          a.prototype.setAxisTranslation.call(this);\n          e.unitLength = null;\n\n          if (e.hasBreaks) {\n            var f = g.options.breaks || [],\n                c = [],\n                d = [],\n                b = 0,\n                m,\n                v = g.userMin || g.min,\n                w = g.userMax || g.max,\n                h = p(g.pointRangePadding, 0),\n                n;\n            f.forEach(function (b) {\n              m = b.repeat || Infinity;\n              k.isInBreak(b, v) && (v += b.to % m - v % m);\n              k.isInBreak(b, w) && (w -= w % m - b.from % m);\n            });\n            f.forEach(function (b) {\n              t = b.from;\n\n              for (m = b.repeat || Infinity; t - m > v;) t -= m;\n\n              for (; t < v;) t += m;\n\n              for (n = t; n < w; n += m) c.push({\n                value: n,\n                move: \"in\"\n              }), c.push({\n                value: n + (b.to - b.from),\n                move: \"out\",\n                size: b.breakSize\n              });\n            });\n            c.sort(function (b, d) {\n              return b.value === d.value ? (\"in\" === b.move ? 0 : 1) - (\"in\" === d.move ? 0 : 1) : b.value - d.value;\n            });\n            var r = 0;\n            var t = v;\n            c.forEach(function (c) {\n              r += \"in\" === c.move ? 1 : -1;\n              1 === r && \"in\" === c.move && (t = c.value);\n              0 === r && (d.push({\n                from: t,\n                to: c.value,\n                len: c.value - t - (c.size || 0)\n              }), b += c.value - t - (c.size || 0));\n            });\n            g.breakArray = e.breakArray = d;\n            e.unitLength = w - v - b + h;\n            A(g, \"afterBreaks\");\n            g.staticScale ? g.transA = g.staticScale : e.unitLength && (g.transA *= (w - g.min + h) / e.unitLength);\n            h && (g.minPixelPadding = g.transA * g.minPointOffset);\n            g.min = v;\n            g.max = w;\n          }\n        });\n        p(v, !0) && g.chart.redraw();\n      };\n\n      return k;\n    }();\n\n    r = function () {\n      function a() {}\n\n      a.compose = function (a, v) {\n        a.keepProps.push(\"brokenAxis\");\n        var e = u.prototype;\n\n        e.drawBreaks = function (e, a) {\n          var g = this,\n              c = g.points,\n              d,\n              b,\n              f,\n              m;\n\n          if (e && e.brokenAxis && e.brokenAxis.hasBreaks) {\n            var v = e.brokenAxis;\n            a.forEach(function (a) {\n              d = v && v.breakArray || [];\n              b = e.isXAxis ? e.min : p(g.options.threshold, e.min);\n              c.forEach(function (c) {\n                m = p(c[\"stack\" + a.toUpperCase()], c[a]);\n                d.forEach(function (d) {\n                  if (D(b) && D(m)) {\n                    f = !1;\n                    if (b < d.from && m > d.to || b > d.from && m < d.from) f = \"pointBreak\";else if (b < d.from && m > d.from && m < d.to || b > d.from && m > d.to && m < d.from) f = \"pointInBreak\";\n                    f && A(e, f, {\n                      point: c,\n                      brk: d\n                    });\n                  }\n                });\n              });\n            });\n          }\n        };\n\n        e.gappedPath = function () {\n          var e = this.currentDataGrouping,\n              a = e && e.gapSize;\n          e = this.options.gapSize;\n          var f = this.points.slice(),\n              c = f.length - 1,\n              d = this.yAxis,\n              b;\n          if (e && 0 < c) for (\"value\" !== this.options.gapUnit && (e *= this.basePointRange), a && a > e && a >= this.basePointRange && (e = a), b = void 0; c--;) b && !1 !== b.visible || (b = f[c + 1]), a = f[c], !1 !== b.visible && !1 !== a.visible && (b.x - a.x > e && (b = (a.x + b.x) / 2, f.splice(c + 1, 0, {\n            isNull: !0,\n            x: b\n          }), d.stacking && this.options.stacking && (b = d.stacking.stacks[this.stackKey][b] = new t(d, d.options.stackLabels, !1, b, this.stack), b.total = 0)), b = a);\n          return this.getGraphPath(f);\n        };\n\n        n(a, \"init\", function () {\n          this.brokenAxis || (this.brokenAxis = new w(this));\n        });\n        n(a, \"afterInit\", function () {\n          \"undefined\" !== typeof this.brokenAxis && this.brokenAxis.setBreaks(this.options.breaks, !1);\n        });\n        n(a, \"afterSetTickPositions\", function () {\n          var e = this.brokenAxis;\n\n          if (e && e.hasBreaks) {\n            var a = this.tickPositions,\n                f = this.tickPositions.info,\n                c = [],\n                d;\n\n            for (d = 0; d < a.length; d++) e.isInAnyBreak(a[d]) || c.push(a[d]);\n\n            this.tickPositions = c;\n            this.tickPositions.info = f;\n          }\n        });\n        n(a, \"afterSetOptions\", function () {\n          this.brokenAxis && this.brokenAxis.hasBreaks && (this.options.ordinal = !1);\n        });\n        n(v, \"afterGeneratePoints\", function () {\n          var e = this.options.connectNulls,\n              a = this.points,\n              f = this.xAxis,\n              c = this.yAxis;\n          if (this.isDirty) for (var d = a.length; d--;) {\n            var b = a[d],\n                v = !(null === b.y && !1 === e) && (f && f.brokenAxis && f.brokenAxis.isInAnyBreak(b.x, !0) || c && c.brokenAxis && c.brokenAxis.isInAnyBreak(b.y, !0));\n            b.visible = v ? !1 : !1 !== b.options.visible;\n          }\n        });\n        n(v, \"afterRender\", function () {\n          this.drawBreaks(this.xAxis, [\"x\"]);\n          this.drawBreaks(this.yAxis, p(this.pointArrayMap, [\"y\"]));\n        });\n      };\n\n      return a;\n    }();\n\n    r.compose(a, u);\n    return r;\n  });\n  F(a, \"Core/Axis/TreeGridAxis.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Axis/Tick.js\"], a[\"Gantt/Tree.js\"], a[\"Core/Axis/TreeGridTick.js\"], a[\"Mixins/TreeSeries.js\"], a[\"Core/Utilities.js\"]], function (a, u, t, r, n, h) {\n    var A = n.getLevelOptions,\n        B = h.addEvent,\n        D = h.find,\n        p = h.fireEvent,\n        w = h.isArray,\n        k = h.isNumber,\n        f = h.isObject,\n        v = h.isString,\n        e = h.merge,\n        g = h.pick,\n        m = h.wrap,\n        q;\n\n    (function (c) {\n      function d(b, d) {\n        var c = b.collapseStart || 0;\n        b = b.collapseEnd || 0;\n        b >= d && (c -= .5);\n        return {\n          from: c,\n          to: b,\n          showPoints: !1\n        };\n      }\n\n      function b(b, d, c) {\n        var l = [],\n            x = [],\n            e = {},\n            a = {},\n            y = -1,\n            z = \"boolean\" === typeof d ? d : !1;\n        b = t.getTree(b, {\n          after: function (l) {\n            l = a[l.pos];\n            var b = 0,\n                d = 0;\n            l.children.forEach(function (l) {\n              d += (l.descendants || 0) + 1;\n              b = Math.max((l.height || 0) + 1, b);\n            });\n            l.descendants = d;\n            l.height = b;\n            l.collapsed && x.push(l);\n          },\n          before: function (b) {\n            var x = f(b.data, !0) ? b.data : {},\n                d = v(x.name) ? x.name : \"\",\n                c = e[b.parent];\n            c = f(c, !0) ? a[c.pos] : null;\n\n            var G = function (l) {\n              return l.name === d;\n            },\n                g;\n\n            z && f(c, !0) && (g = D(c.children, G)) ? (G = g.pos, g.nodes.push(b)) : G = y++;\n            a[G] || (a[G] = g = {\n              depth: c ? c.depth + 1 : 0,\n              name: d,\n              id: x.id,\n              nodes: [b],\n              children: [],\n              pos: G\n            }, -1 !== G && l.push(d), f(c, !0) && c.children.push(g));\n            v(b.id) && (e[b.id] = b);\n            g && !0 === x.collapsed && (g.collapsed = !0);\n            b.pos = G;\n          }\n        });\n\n        a = function (l, b) {\n          var x = function (l, d, c) {\n            var e = d + (-1 === d ? 0 : b - 1),\n                a = (e - d) / 2,\n                y = d + a;\n            l.nodes.forEach(function (l) {\n              var b = l.data;\n              f(b, !0) && (b.y = d + (b.seriesIndex || 0), delete b.seriesIndex);\n              l.pos = y;\n            });\n            c[y] = l;\n            l.pos = y;\n            l.tickmarkOffset = a + .5;\n            l.collapseStart = e + .5;\n            l.children.forEach(function (l) {\n              x(l, e + 1, c);\n              e = (l.collapseEnd || 0) - .5;\n            });\n            l.collapseEnd = e + .5;\n            return c;\n          };\n\n          return x(l[\"-1\"], -1, {});\n        }(a, c);\n\n        return {\n          categories: l,\n          mapOfIdToNode: e,\n          mapOfPosToGridNode: a,\n          collapsedNodes: x,\n          tree: b\n        };\n      }\n\n      function a(d) {\n        d.target.axes.filter(function (b) {\n          return \"treegrid\" === b.options.type;\n        }).forEach(function (c) {\n          var a = c.options || {},\n              l = a.labels,\n              x = a.uniqueNames,\n              y = 0;\n          a = a.max;\n\n          if (!c.treeGrid.mapOfPosToGridNode || c.series.some(function (l) {\n            return !l.hasRendered || l.isDirtyData || l.isDirty;\n          })) {\n            var g = c.series.reduce(function (l, b) {\n              b.visible && ((b.options.data || []).forEach(function (c) {\n                b.options.keys && b.options.keys.length && (c = b.pointClass.prototype.optionsToObject.call({\n                  series: b\n                }, c), b.pointClass.setGanttPointAliases(c));\n                f(c, !0) && (c.seriesIndex = y, l.push(c));\n              }), !0 === x && y++);\n              return l;\n            }, []);\n            if (a && g.length < a) for (var q = g.length; q <= a; q++) g.push({\n              name: q + \"\\u200b\"\n            });\n            a = b(g, x || !1, !0 === x ? y : 1);\n            c.categories = a.categories;\n            c.treeGrid.mapOfPosToGridNode = a.mapOfPosToGridNode;\n            c.hasNames = !0;\n            c.treeGrid.tree = a.tree;\n            c.series.forEach(function (l) {\n              var b = (l.options.data || []).map(function (b) {\n                w(b) && l.options.keys && l.options.keys.length && g.forEach(function (l) {\n                  0 <= b.indexOf(l.x) && 0 <= b.indexOf(l.x2) && (b = l);\n                });\n                return f(b, !0) ? e(b) : b;\n              });\n              l.visible && l.setData(b, !1);\n            });\n            c.treeGrid.mapOptionsToLevel = A({\n              defaults: l,\n              from: 1,\n              levels: l && l.levels,\n              to: c.treeGrid.tree && c.treeGrid.tree.height\n            });\n            \"beforeRender\" === d.type && (c.treeGrid.collapsedNodes = a.collapsedNodes);\n          }\n        });\n      }\n\n      function q(b, c) {\n        var d = this.treeGrid.mapOptionsToLevel || {},\n            l = this.ticks,\n            x = l[c],\n            a;\n\n        if (\"treegrid\" === this.options.type && this.treeGrid.mapOfPosToGridNode) {\n          var e = this.treeGrid.mapOfPosToGridNode[c];\n          (d = d[e.depth]) && (a = {\n            labels: d\n          });\n          x ? (x.parameters.category = e.name, x.options = a, x.addLabel()) : l[c] = new u(this, c, void 0, void 0, {\n            category: e.name,\n            tickmarkOffset: e.tickmarkOffset,\n            options: a\n          });\n        } else b.apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n\n      function h(b) {\n        var c = this.options;\n        c = (c = c && c.labels) && k(c.indentation) ? c.indentation : 0;\n        var d = b.apply(this, Array.prototype.slice.call(arguments, 1));\n\n        if (\"treegrid\" === this.options.type && this.treeGrid.mapOfPosToGridNode) {\n          var l = this.treeGrid.mapOfPosToGridNode[-1].height || 0;\n          d.width += c * (l - 1);\n        }\n\n        return d;\n      }\n\n      function n(c, d, z) {\n        var l = this,\n            x = \"treegrid\" === z.type;\n        l.treeGrid || (l.treeGrid = new M(l));\n        x && (B(d, \"beforeRender\", a), B(d, \"beforeRedraw\", a), B(d, \"addSeries\", function (c) {\n          c.options.data && (c = b(c.options.data, z.uniqueNames || !1, 1), l.treeGrid.collapsedNodes = (l.treeGrid.collapsedNodes || []).concat(c.collapsedNodes));\n        }), B(l, \"foundExtremes\", function () {\n          l.treeGrid.collapsedNodes && l.treeGrid.collapsedNodes.forEach(function (b) {\n            var c = l.treeGrid.collapse(b);\n            l.brokenAxis && (l.brokenAxis.setBreaks(c, !1), l.treeGrid.collapsedNodes && (l.treeGrid.collapsedNodes = l.treeGrid.collapsedNodes.filter(function (l) {\n              return b.collapseStart !== l.collapseStart || b.collapseEnd !== l.collapseEnd;\n            })));\n          });\n        }), B(l, \"afterBreaks\", function () {\n          var b;\n          \"yAxis\" === l.coll && !l.staticScale && (null === (b = l.chart.options.chart) || void 0 === b ? 0 : b.height) && (l.isDirty = !0);\n        }), z = e({\n          grid: {\n            enabled: !0\n          },\n          labels: {\n            align: \"left\",\n            levels: [{\n              level: void 0\n            }, {\n              level: 1,\n              style: {\n                fontWeight: \"bold\"\n              }\n            }],\n            symbol: {\n              type: \"triangle\",\n              x: -5,\n              y: -5,\n              height: 10,\n              width: 10,\n              padding: 5\n            }\n          },\n          uniqueNames: !1\n        }, z, {\n          reversed: !0,\n          grid: {\n            columns: void 0\n          }\n        }));\n        c.apply(l, [d, z]);\n        x && (l.hasNames = !0, l.options.showLastLabel = !0);\n      }\n\n      function H(b) {\n        var c = this.options;\n        \"treegrid\" === c.type ? (this.min = g(this.userMin, c.min, this.dataMin), this.max = g(this.userMax, c.max, this.dataMax), p(this, \"foundExtremes\"), this.setAxisTranslation(), this.tickmarkOffset = .5, this.tickInterval = 1, this.tickPositions = this.treeGrid.mapOfPosToGridNode ? this.treeGrid.getTickPositions() : []) : b.apply(this, Array.prototype.slice.call(arguments, 1));\n      }\n\n      var C = !1;\n\n      c.compose = function (b) {\n        C || (m(b.prototype, \"generateTick\", q), m(b.prototype, \"getMaxLabelDimensions\", h), m(b.prototype, \"init\", n), m(b.prototype, \"setTickInterval\", H), r.compose(u), C = !0);\n      };\n\n      var M = function () {\n        function b(b) {\n          this.axis = b;\n        }\n\n        b.prototype.setCollapsedStatus = function (b) {\n          var c = this.axis,\n              l = c.chart;\n          c.series.forEach(function (c) {\n            var d = c.options.data;\n\n            if (b.id && d) {\n              var x = l.get(b.id);\n              c = d[c.data.indexOf(x)];\n              x && c && (x.collapsed = b.collapsed, c.collapsed = b.collapsed);\n            }\n          });\n        };\n\n        b.prototype.collapse = function (b) {\n          var c = this.axis,\n              l = c.options.breaks || [],\n              x = d(b, c.max);\n          l.push(x);\n          b.collapsed = !0;\n          c.treeGrid.setCollapsedStatus(b);\n          return l;\n        };\n\n        b.prototype.expand = function (b) {\n          var c = this.axis,\n              l = c.options.breaks || [],\n              x = d(b, c.max);\n          b.collapsed = !1;\n          c.treeGrid.setCollapsedStatus(b);\n          return l.reduce(function (l, b) {\n            b.to === x.to && b.from === x.from || l.push(b);\n            return l;\n          }, []);\n        };\n\n        b.prototype.getTickPositions = function () {\n          var b = this.axis,\n              c = Math.floor(b.min / b.tickInterval) * b.tickInterval,\n              l = Math.ceil(b.max / b.tickInterval) * b.tickInterval;\n          return Object.keys(b.treeGrid.mapOfPosToGridNode || {}).reduce(function (d, a) {\n            a = +a;\n            !(a >= c && a <= l) || b.brokenAxis && b.brokenAxis.isInAnyBreak(a) || d.push(a);\n            return d;\n          }, []);\n        };\n\n        b.prototype.isCollapsed = function (b) {\n          var c = this.axis,\n              l = c.options.breaks || [],\n              x = d(b, c.max);\n          return l.some(function (b) {\n            return b.from === x.from && b.to === x.to;\n          });\n        };\n\n        b.prototype.toggleCollapse = function (b) {\n          return this.isCollapsed(b) ? this.expand(b) : this.collapse(b);\n        };\n\n        return b;\n      }();\n\n      c.Additions = M;\n    })(q || (q = {}));\n\n    a.prototype.utils = {\n      getNode: t.getNode\n    };\n    q.compose(a);\n    return q;\n  });\n  F(a, \"Extensions/CurrentDateIndication.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Color/Palette.js\"], a[\"Core/Utilities.js\"], a[\"Core/Axis/PlotLineOrBand.js\"]], function (a, u, t, r) {\n    var n = t.addEvent,\n        h = t.merge;\n    t = t.wrap;\n    var A = {\n      currentDateIndicator: !0,\n      color: u.highlightColor20,\n      width: 2,\n      label: {\n        format: \"%a, %b %d %Y, %H:%M\",\n        formatter: function (a, h) {\n          return this.axis.chart.time.dateFormat(h, a);\n        },\n        rotation: 0,\n        style: {\n          fontSize: \"10px\"\n        }\n      }\n    };\n    n(a, \"afterSetOptions\", function () {\n      var a = this.options,\n          n = a.currentDateIndicator;\n      n && (n = \"object\" === typeof n ? h(A, n) : h(A), n.value = new Date(), a.plotLines || (a.plotLines = []), a.plotLines.push(n));\n    });\n    n(r, \"render\", function () {\n      this.label && this.label.attr({\n        text: this.getLabelText(this.options.label)\n      });\n    });\n    t(r.prototype, \"getLabelText\", function (a, h) {\n      var p = this.options;\n      return p.currentDateIndicator && p.label && \"function\" === typeof p.label.formatter ? (p.value = new Date(), p.label.formatter.call(this, p.value, p.label.format)) : a.call(this, h);\n    });\n  });\n  F(a, \"Extensions/StaticScale.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Utilities.js\"]], function (a, u, t) {\n    var r = t.addEvent,\n        n = t.defined,\n        h = t.isNumber,\n        A = t.pick;\n    r(a, \"afterSetOptions\", function () {\n      var a = this.chart.options && this.chart.options.chart;\n      !this.horiz && h(this.options.staticScale) && (!a.height || a.scrollablePlotArea && a.scrollablePlotArea.minHeight) && (this.staticScale = this.options.staticScale);\n    });\n\n    u.prototype.adjustHeight = function () {\n      \"adjustHeight\" !== this.redrawTrigger && ((this.axes || []).forEach(function (a) {\n        var h = a.chart,\n            p = !!h.initiatedScale && h.options.animation,\n            w = a.options.staticScale;\n\n        if (a.staticScale && n(a.min)) {\n          var k = A(a.brokenAxis && a.brokenAxis.unitLength, a.max + a.tickInterval - a.min) * w;\n          k = Math.max(k, w);\n          w = k - h.plotHeight;\n          1 <= Math.abs(w) && (h.plotHeight = k, h.redrawTrigger = \"adjustHeight\", h.setSize(void 0, h.chartHeight + w, p));\n          a.series.forEach(function (a) {\n            (a = a.sharedClipKey && h[a.sharedClipKey]) && a.attr({\n              height: h.plotHeight\n            });\n          });\n        }\n      }), this.initiatedScale = !0);\n      this.redrawTrigger = null;\n    };\n\n    r(u, \"render\", u.prototype.adjustHeight);\n  });\n  F(a, \"Extensions/ArrowSymbols.js\", [a[\"Core/Renderer/SVG/SVGRenderer.js\"]], function (a) {\n    a.prototype.symbols.arrow = function (a, t, r, n) {\n      return [[\"M\", a, t + n / 2], [\"L\", a + r, t], [\"L\", a, t + n / 2], [\"L\", a + r, t + n]];\n    };\n\n    a.prototype.symbols[\"arrow-half\"] = function (u, t, r, n) {\n      return a.prototype.symbols.arrow(u, t, r / 2, n);\n    };\n\n    a.prototype.symbols[\"triangle-left\"] = function (a, t, r, n) {\n      return [[\"M\", a + r, t], [\"L\", a, t + n / 2], [\"L\", a + r, t + n], [\"Z\"]];\n    };\n\n    a.prototype.symbols[\"arrow-filled\"] = a.prototype.symbols[\"triangle-left\"];\n\n    a.prototype.symbols[\"triangle-left-half\"] = function (u, t, r, n) {\n      return a.prototype.symbols[\"triangle-left\"](u, t, r / 2, n);\n    };\n\n    a.prototype.symbols[\"arrow-filled-half\"] = a.prototype.symbols[\"triangle-left-half\"];\n  });\n  F(a, \"Gantt/Connection.js\", [a[\"Core/Globals.js\"], a[\"Core/Options.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"]], function (a, u, t, r) {\n    function n(a) {\n      var e = a.shapeArgs;\n      return e ? {\n        xMin: e.x,\n        xMax: e.x + e.width,\n        yMin: e.y,\n        yMax: e.y + e.height\n      } : (e = a.graphic && a.graphic.getBBox()) ? {\n        xMin: a.plotX - e.width / 2,\n        xMax: a.plotX + e.width / 2,\n        yMin: a.plotY - e.height / 2,\n        yMax: a.plotY + e.height / 2\n      } : null;\n    }\n\n    \"\";\n    var h = r.defined,\n        A = r.error,\n        B = r.extend,\n        D = r.merge,\n        p = r.objectEach,\n        w = a.deg2rad,\n        k = Math.max,\n        f = Math.min;\n    B(u.defaultOptions, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n\n    u = function () {\n      function a(a, g, f) {\n        this.toPoint = this.pathfinder = this.graphics = this.fromPoint = this.chart = void 0;\n        this.init(a, g, f);\n      }\n\n      a.prototype.init = function (a, g, f) {\n        this.fromPoint = a;\n        this.toPoint = g;\n        this.options = f;\n        this.chart = a.series.chart;\n        this.pathfinder = this.chart.pathfinder;\n      };\n\n      a.prototype.renderPath = function (a, g, f) {\n        var e = this.chart,\n            c = e.styledMode,\n            d = e.pathfinder,\n            b = !e.options.chart.forExport && !1 !== f,\n            m = this.graphics && this.graphics.path;\n        d.group || (d.group = e.renderer.g().addClass(\"highcharts-pathfinder-group\").attr({\n          zIndex: -1\n        }).add(e.seriesGroup));\n        d.group.translate(e.plotLeft, e.plotTop);\n        m && m.renderer || (m = e.renderer.path().add(d.group), c || m.attr({\n          opacity: 0\n        }));\n        m.attr(g);\n        a = {\n          d: a\n        };\n        c || (a.opacity = 1);\n        m[b ? \"animate\" : \"attr\"](a, f);\n        this.graphics = this.graphics || {};\n        this.graphics.path = m;\n      };\n\n      a.prototype.addMarker = function (a, g, f) {\n        var e = this.fromPoint.series.chart,\n            c = e.pathfinder;\n        e = e.renderer;\n        var d = \"start\" === a ? this.fromPoint : this.toPoint,\n            b = d.getPathfinderAnchorPoint(g);\n\n        if (g.enabled && ((f = \"start\" === a ? f[1] : f[f.length - 2]) && \"M\" === f[0] || \"L\" === f[0])) {\n          f = {\n            x: f[1],\n            y: f[2]\n          };\n          f = d.getRadiansToVector(f, b);\n          b = d.getMarkerVector(f, g.radius, b);\n          f = -f / w;\n\n          if (g.width && g.height) {\n            var k = g.width;\n            var m = g.height;\n          } else k = m = 2 * g.radius;\n\n          this.graphics = this.graphics || {};\n          b = {\n            x: b.x - k / 2,\n            y: b.y - m / 2,\n            width: k,\n            height: m,\n            rotation: f,\n            rotationOriginX: b.x,\n            rotationOriginY: b.y\n          };\n          this.graphics[a] ? this.graphics[a].animate(b) : (this.graphics[a] = e.symbol(g.symbol).addClass(\"highcharts-point-connecting-path-\" + a + \"-marker\").attr(b).add(c.group), e.styledMode || this.graphics[a].attr({\n            fill: g.color || this.fromPoint.color,\n            stroke: g.lineColor,\n            \"stroke-width\": g.lineWidth,\n            opacity: 0\n          }).animate({\n            opacity: 1\n          }, d.series.options.animation));\n        }\n      };\n\n      a.prototype.getPath = function (a) {\n        var e = this.pathfinder,\n            f = this.chart,\n            q = e.algorithms[a.type],\n            c = e.chartObstacles;\n        if (\"function\" !== typeof q) return A('\"' + a.type + '\" is not a Pathfinder algorithm.'), {\n          path: [],\n          obstacles: []\n        };\n        q.requiresObstacles && !c && (c = e.chartObstacles = e.getChartObstacles(a), f.options.connectors.algorithmMargin = a.algorithmMargin, e.chartObstacleMetrics = e.getObstacleMetrics(c));\n        return q(this.fromPoint.getPathfinderAnchorPoint(a.startMarker), this.toPoint.getPathfinderAnchorPoint(a.endMarker), D({\n          chartObstacles: c,\n          lineObstacles: e.lineObstacles || [],\n          obstacleMetrics: e.chartObstacleMetrics,\n          hardBounds: {\n            xMin: 0,\n            xMax: f.plotWidth,\n            yMin: 0,\n            yMax: f.plotHeight\n          },\n          obstacleOptions: {\n            margin: a.algorithmMargin\n          },\n          startDirectionX: e.getAlgorithmStartDirection(a.startMarker)\n        }, a));\n      };\n\n      a.prototype.render = function () {\n        var a = this.fromPoint,\n            g = a.series,\n            m = g.chart,\n            q = m.pathfinder,\n            c = D(m.options.connectors, g.options.connectors, a.options.connectors, this.options),\n            d = {};\n        m.styledMode || (d.stroke = c.lineColor || a.color, d[\"stroke-width\"] = c.lineWidth, c.dashStyle && (d.dashstyle = c.dashStyle));\n        d[\"class\"] = \"highcharts-point-connecting-path highcharts-color-\" + a.colorIndex;\n        c = D(d, c);\n        h(c.marker.radius) || (c.marker.radius = f(k(Math.ceil((c.algorithmMargin || 8) / 2) - 1, 1), 5));\n        a = this.getPath(c);\n        m = a.path;\n        a.obstacles && (q.lineObstacles = q.lineObstacles || [], q.lineObstacles = q.lineObstacles.concat(a.obstacles));\n        this.renderPath(m, d, g.options.animation);\n        this.addMarker(\"start\", D(c.marker, c.startMarker), m);\n        this.addMarker(\"end\", D(c.marker, c.endMarker), m);\n      };\n\n      a.prototype.destroy = function () {\n        this.graphics && (p(this.graphics, function (a) {\n          a.destroy();\n        }), delete this.graphics);\n      };\n\n      return a;\n    }();\n\n    a.Connection = u;\n    B(t.prototype, {\n      getPathfinderAnchorPoint: function (a) {\n        var e = n(this);\n\n        switch (a.align) {\n          case \"right\":\n            var g = \"xMax\";\n            break;\n\n          case \"left\":\n            g = \"xMin\";\n        }\n\n        switch (a.verticalAlign) {\n          case \"top\":\n            var f = \"yMin\";\n            break;\n\n          case \"bottom\":\n            f = \"yMax\";\n        }\n\n        return {\n          x: g ? e[g] : (e.xMin + e.xMax) / 2,\n          y: f ? e[f] : (e.yMin + e.yMax) / 2\n        };\n      },\n      getRadiansToVector: function (a, e) {\n        var g;\n        h(e) || (g = n(this)) && (e = {\n          x: (g.xMin + g.xMax) / 2,\n          y: (g.yMin + g.yMax) / 2\n        });\n        return Math.atan2(e.y - a.y, a.x - e.x);\n      },\n      getMarkerVector: function (a, e, g) {\n        var f = 2 * Math.PI,\n            q = n(this),\n            c = q.xMax - q.xMin,\n            d = q.yMax - q.yMin,\n            b = Math.atan2(d, c),\n            k = !1;\n        c /= 2;\n        var w = d / 2,\n            h = q.xMin + c;\n        q = q.yMin + w;\n\n        for (var p = h, v = q, r = 1, t = 1; a < -Math.PI;) a += f;\n\n        for (; a > Math.PI;) a -= f;\n\n        f = Math.tan(a);\n        a > -b && a <= b ? (t = -1, k = !0) : a > b && a <= Math.PI - b ? t = -1 : a > Math.PI - b || a <= -(Math.PI - b) ? (r = -1, k = !0) : r = -1;\n        k ? (p += r * c, v += t * c * f) : (p += d / (2 * f) * r, v += t * w);\n        g.x !== h && (p = g.x);\n        g.y !== q && (v = g.y);\n        return {\n          x: p + e * Math.cos(a),\n          y: v - e * Math.sin(a)\n        };\n      }\n    });\n    return u;\n  });\n  F(a, \"Gantt/PathfinderAlgorithms.js\", [a[\"Core/Utilities.js\"]], function (a) {\n    function u(a, k, f) {\n      f = f || 0;\n      var h = a.length - 1;\n      k -= 1e-7;\n\n      for (var e, g; f <= h;) if (e = h + f >> 1, g = k - a[e].xMin, 0 < g) f = e + 1;else if (0 > g) h = e - 1;else return e;\n\n      return 0 < f ? f - 1 : 0;\n    }\n\n    function t(a, k) {\n      for (var f = u(a, k.x + 1) + 1; f--;) {\n        var h;\n        if (h = a[f].xMax >= k.x) h = a[f], h = k.x <= h.xMax && k.x >= h.xMin && k.y <= h.yMax && k.y >= h.yMin;\n        if (h) return f;\n      }\n\n      return -1;\n    }\n\n    function r(a) {\n      var k = [];\n\n      if (a.length) {\n        k.push([\"M\", a[0].start.x, a[0].start.y]);\n\n        for (var f = 0; f < a.length; ++f) k.push([\"L\", a[f].end.x, a[f].end.y]);\n      }\n\n      return k;\n    }\n\n    function n(a, k) {\n      a.yMin = D(a.yMin, k.yMin);\n      a.yMax = B(a.yMax, k.yMax);\n      a.xMin = D(a.xMin, k.xMin);\n      a.xMax = B(a.xMax, k.xMax);\n    }\n\n    var h = a.extend,\n        A = a.pick,\n        B = Math.min,\n        D = Math.max,\n        p = Math.abs;\n    a = h(function (a, k, f) {\n      function h(a, b, c, d, e) {\n        a = {\n          x: a.x,\n          y: a.y\n        };\n        a[b] = c[d || b] + (e || 0);\n        return a;\n      }\n\n      function e(a, b, c) {\n        var d = p(b[c] - a[c + \"Min\"]) > p(b[c] - a[c + \"Max\"]);\n        return h(b, c, a, c + (d ? \"Max\" : \"Min\"), d ? 1 : -1);\n      }\n\n      var g = [],\n          m = A(f.startDirectionX, p(k.x - a.x) > p(k.y - a.y)) ? \"x\" : \"y\",\n          q = f.chartObstacles,\n          c = t(q, a);\n      f = t(q, k);\n\n      if (-1 < f) {\n        var d = q[f];\n        f = e(d, k, m);\n        d = {\n          start: f,\n          end: k\n        };\n        var b = f;\n      } else b = k;\n\n      -1 < c && (q = q[c], f = e(q, a, m), g.push({\n        start: a,\n        end: f\n      }), f[m] >= a[m] === f[m] >= b[m] && (m = \"y\" === m ? \"x\" : \"y\", k = a[m] < k[m], g.push({\n        start: f,\n        end: h(f, m, q, m + (k ? \"Max\" : \"Min\"), k ? 1 : -1)\n      }), m = \"y\" === m ? \"x\" : \"y\"));\n      a = g.length ? g[g.length - 1].end : a;\n      f = h(a, m, b);\n      g.push({\n        start: a,\n        end: f\n      });\n      m = h(f, \"y\" === m ? \"x\" : \"y\", b);\n      g.push({\n        start: f,\n        end: m\n      });\n      g.push(d);\n      return {\n        path: r(g),\n        obstacles: g\n      };\n    }, {\n      requiresObstacles: !0\n    });\n    return {\n      fastAvoid: h(function (a, k, f) {\n        function h(a, b, l) {\n          var c,\n              d = a.x < b.x ? 1 : -1;\n\n          if (a.x < b.x) {\n            var e = a;\n            var y = b;\n          } else e = b, y = a;\n\n          if (a.y < b.y) {\n            var f = a;\n            var g = b;\n          } else f = b, g = a;\n\n          for (c = 0 > d ? B(u(C, y.x), C.length - 1) : 0; C[c] && (0 < d && C[c].xMin <= y.x || 0 > d && C[c].xMax >= e.x);) {\n            if (C[c].xMin <= y.x && C[c].xMax >= e.x && C[c].yMin <= g.y && C[c].yMax >= f.y) return l ? {\n              y: a.y,\n              x: a.x < b.x ? C[c].xMin - 1 : C[c].xMax + 1,\n              obstacle: C[c]\n            } : {\n              x: a.x,\n              y: a.y < b.y ? C[c].yMin - 1 : C[c].yMax + 1,\n              obstacle: C[c]\n            };\n            c += d;\n          }\n\n          return b;\n        }\n\n        function e(a, b, l, c, d) {\n          var x = d.soft,\n              e = d.hard,\n              y = c ? \"x\" : \"y\",\n              f = {\n            x: b.x,\n            y: b.y\n          },\n              g = {\n            x: b.x,\n            y: b.y\n          };\n          d = a[y + \"Max\"] >= x[y + \"Max\"];\n          x = a[y + \"Min\"] <= x[y + \"Min\"];\n          var G = a[y + \"Max\"] >= e[y + \"Max\"];\n          e = a[y + \"Min\"] <= e[y + \"Min\"];\n          var z = p(a[y + \"Min\"] - b[y]),\n              k = p(a[y + \"Max\"] - b[y]);\n          l = 10 > p(z - k) ? b[y] < l[y] : k < z;\n          g[y] = a[y + \"Min\"];\n          f[y] = a[y + \"Max\"];\n          a = h(b, g, c)[y] !== g[y];\n          b = h(b, f, c)[y] !== f[y];\n          l = a ? b ? l : !0 : b ? !1 : l;\n          l = x ? d ? l : !0 : d ? !1 : l;\n          return e ? G ? l : !0 : G ? !1 : l;\n        }\n\n        function g(a, c, l) {\n          if (a.x === c.x && a.y === c.y) return [];\n          var d = l ? \"x\" : \"y\",\n              y = f.obstacleOptions.margin;\n          var z = {\n            soft: {\n              xMin: I,\n              xMax: K,\n              yMin: L,\n              yMax: H\n            },\n            hard: f.hardBounds\n          };\n          var k = t(C, a);\n\n          if (-1 < k) {\n            k = C[k];\n            z = e(k, a, c, l, z);\n            n(k, f.hardBounds);\n            var q = l ? {\n              y: a.y,\n              x: k[z ? \"xMax\" : \"xMin\"] + (z ? 1 : -1)\n            } : {\n              x: a.x,\n              y: k[z ? \"yMax\" : \"yMin\"] + (z ? 1 : -1)\n            };\n            var m = t(C, q);\n            -1 < m && (m = C[m], n(m, f.hardBounds), q[d] = z ? D(k[d + \"Max\"] - y + 1, (m[d + \"Min\"] + k[d + \"Max\"]) / 2) : B(k[d + \"Min\"] + y - 1, (m[d + \"Max\"] + k[d + \"Min\"]) / 2), a.x === q.x && a.y === q.y ? (b && (q[d] = z ? D(k[d + \"Max\"], m[d + \"Max\"]) + 1 : B(k[d + \"Min\"], m[d + \"Min\"]) - 1), b = !b) : b = !1);\n            a = [{\n              start: a,\n              end: q\n            }];\n          } else d = h(a, {\n            x: l ? c.x : a.x,\n            y: l ? a.y : c.y\n          }, l), a = [{\n            start: a,\n            end: {\n              x: d.x,\n              y: d.y\n            }\n          }], d[l ? \"x\" : \"y\"] !== c[l ? \"x\" : \"y\"] && (z = e(d.obstacle, d, c, !l, z), n(d.obstacle, f.hardBounds), z = {\n            x: l ? d.x : d.obstacle[z ? \"xMax\" : \"xMin\"] + (z ? 1 : -1),\n            y: l ? d.obstacle[z ? \"yMax\" : \"yMin\"] + (z ? 1 : -1) : d.y\n          }, l = !l, a = a.concat(g({\n            x: d.x,\n            y: d.y\n          }, z, l)));\n\n          return a = a.concat(g(a[a.length - 1].end, c, !l));\n        }\n\n        function m(a, b, l) {\n          var c = B(a.xMax - b.x, b.x - a.xMin) < B(a.yMax - b.y, b.y - a.yMin);\n          l = e(a, b, l, c, {\n            soft: f.hardBounds,\n            hard: f.hardBounds\n          });\n          return c ? {\n            y: b.y,\n            x: a[l ? \"xMax\" : \"xMin\"] + (l ? 1 : -1)\n          } : {\n            x: b.x,\n            y: a[l ? \"yMax\" : \"yMin\"] + (l ? 1 : -1)\n          };\n        }\n\n        var q = A(f.startDirectionX, p(k.x - a.x) > p(k.y - a.y)),\n            c = q ? \"x\" : \"y\",\n            d = [],\n            b = !1,\n            w = f.obstacleMetrics,\n            I = B(a.x, k.x) - w.maxWidth - 10,\n            K = D(a.x, k.x) + w.maxWidth + 10,\n            L = B(a.y, k.y) - w.maxHeight - 10,\n            H = D(a.y, k.y) + w.maxHeight + 10,\n            C = f.chartObstacles;\n        var M = u(C, I);\n        w = u(C, K);\n        C = C.slice(M, w + 1);\n\n        if (-1 < (w = t(C, k))) {\n          var E = m(C[w], k, a);\n          d.push({\n            end: k,\n            start: E\n          });\n          k = E;\n        }\n\n        for (; -1 < (w = t(C, k));) M = 0 > k[c] - a[c], E = {\n          x: k.x,\n          y: k.y\n        }, E[c] = C[w][M ? c + \"Max\" : c + \"Min\"] + (M ? 1 : -1), d.push({\n          end: k,\n          start: E\n        }), k = E;\n\n        a = g(a, k, q);\n        a = a.concat(d.reverse());\n        return {\n          path: r(a),\n          obstacles: a\n        };\n      }, {\n        requiresObstacles: !0\n      }),\n      straight: function (a, k) {\n        return {\n          path: [[\"M\", a.x, a.y], [\"L\", k.x, k.y]],\n          obstacles: [{\n            start: a,\n            end: k\n          }]\n        };\n      },\n      simpleConnect: a\n    };\n  });\n  F(a, \"Gantt/Pathfinder.js\", [a[\"Gantt/Connection.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Globals.js\"], a[\"Core/Options.js\"], a[\"Core/Series/Point.js\"], a[\"Core/Utilities.js\"], a[\"Gantt/PathfinderAlgorithms.js\"]], function (a, u, t, r, n, h, A) {\n    function B(a) {\n      var b = a.shapeArgs;\n      return b ? {\n        xMin: b.x,\n        xMax: b.x + b.width,\n        yMin: b.y,\n        yMax: b.y + b.height\n      } : (b = a.graphic && a.graphic.getBBox()) ? {\n        xMin: a.plotX - b.width / 2,\n        xMax: a.plotX + b.width / 2,\n        yMin: a.plotY - b.height / 2,\n        yMax: a.plotY + b.height / 2\n      } : null;\n    }\n\n    function D(a) {\n      for (var b = a.length, d = 0, e, f, k = [], h = function (a, b, d) {\n        d = g(d, 10);\n        var e = a.yMax + d > b.yMin - d && a.yMin - d < b.yMax + d,\n            l = a.xMax + d > b.xMin - d && a.xMin - d < b.xMax + d,\n            x = e ? a.xMin > b.xMax ? a.xMin - b.xMax : b.xMin - a.xMax : Infinity,\n            f = l ? a.yMin > b.yMax ? a.yMin - b.yMax : b.yMin - a.yMax : Infinity;\n        return l && e ? d ? h(a, b, Math.floor(d / 2)) : Infinity : c(x, f);\n      }; d < b; ++d) for (e = d + 1; e < b; ++e) f = h(a[d], a[e]), 80 > f && k.push(f);\n\n      k.push(80);\n      return q(Math.floor(k.sort(function (a, b) {\n        return a - b;\n      })[Math.floor(k.length / 10)] / 2 - 1), 1);\n    }\n\n    function p(a) {\n      if (a.options.pathfinder || a.series.reduce(function (a, b) {\n        b.options && e(!0, b.options.connectors = b.options.connectors || {}, b.options.pathfinder);\n        return a || b.options && b.options.pathfinder;\n      }, !1)) e(!0, a.options.connectors = a.options.connectors || {}, a.options.pathfinder), f('WARNING: Pathfinder options have been renamed. Use \"chart.connectors\" or \"series.connectors\" instead.');\n    }\n\n    \"\";\n    var w = h.addEvent,\n        k = h.defined,\n        f = h.error,\n        v = h.extend,\n        e = h.merge,\n        g = h.pick,\n        m = h.splat,\n        q = Math.max,\n        c = Math.min;\n    v(r.defaultOptions, {\n      connectors: {\n        type: \"straight\",\n        lineWidth: 1,\n        marker: {\n          enabled: !1,\n          align: \"center\",\n          verticalAlign: \"middle\",\n          inside: !1,\n          lineWidth: 1\n        },\n        startMarker: {\n          symbol: \"diamond\"\n        },\n        endMarker: {\n          symbol: \"arrow-filled\"\n        }\n      }\n    });\n\n    var d = function () {\n      function b(a) {\n        this.lineObstacles = this.group = this.connections = this.chartObstacleMetrics = this.chartObstacles = this.chart = void 0;\n        this.init(a);\n      }\n\n      b.prototype.init = function (a) {\n        this.chart = a;\n        this.connections = [];\n        w(a, \"redraw\", function () {\n          this.pathfinder.update();\n        });\n      };\n\n      b.prototype.update = function (b) {\n        var c = this.chart,\n            d = this,\n            e = d.connections;\n        d.connections = [];\n        c.series.forEach(function (b) {\n          b.visible && !b.options.isInternal && b.points.forEach(function (b) {\n            var l = b.options;\n            l && l.dependency && (l.connect = l.dependency);\n            var e;\n            l = b.options && b.options.connect && m(b.options.connect);\n            b.visible && !1 !== b.isInside && l && l.forEach(function (l) {\n              e = c.get(\"string\" === typeof l ? l : l.to);\n              e instanceof n && e.series.visible && e.visible && !1 !== e.isInside && d.connections.push(new a(b, e, \"string\" === typeof l ? {} : l));\n            });\n          });\n        });\n\n        for (var f = 0, g, k, q = e.length, y = d.connections.length; f < q; ++f) {\n          k = !1;\n\n          for (g = 0; g < y; ++g) if (e[f].fromPoint === d.connections[g].fromPoint && e[f].toPoint === d.connections[g].toPoint) {\n            d.connections[g].graphics = e[f].graphics;\n            k = !0;\n            break;\n          }\n\n          k || e[f].destroy();\n        }\n\n        delete this.chartObstacles;\n        delete this.lineObstacles;\n        d.renderConnections(b);\n      };\n\n      b.prototype.renderConnections = function (a) {\n        a ? this.chart.series.forEach(function (a) {\n          var b = function () {\n            var b = a.chart.pathfinder;\n            (b && b.connections || []).forEach(function (b) {\n              b.fromPoint && b.fromPoint.series === a && b.render();\n            });\n            a.pathfinderRemoveRenderEvent && (a.pathfinderRemoveRenderEvent(), delete a.pathfinderRemoveRenderEvent);\n          };\n\n          !1 === a.options.animation ? b() : a.pathfinderRemoveRenderEvent = w(a, \"afterAnimate\", b);\n        }) : this.connections.forEach(function (a) {\n          a.render();\n        });\n      };\n\n      b.prototype.getChartObstacles = function (a) {\n        for (var b = [], c = this.chart.series, d = g(a.algorithmMargin, 0), e, f = 0, q = c.length; f < q; ++f) if (c[f].visible && !c[f].options.isInternal) for (var h = 0, y = c[f].points.length, z; h < y; ++h) z = c[f].points[h], z.visible && (z = B(z)) && b.push({\n          xMin: z.xMin - d,\n          xMax: z.xMax + d,\n          yMin: z.yMin - d,\n          yMax: z.yMax + d\n        });\n\n        b = b.sort(function (a, b) {\n          return a.xMin - b.xMin;\n        });\n        k(a.algorithmMargin) || (e = a.algorithmMargin = D(b), b.forEach(function (a) {\n          a.xMin -= e;\n          a.xMax += e;\n          a.yMin -= e;\n          a.yMax += e;\n        }));\n        return b;\n      };\n\n      b.prototype.getObstacleMetrics = function (a) {\n        for (var b = 0, c = 0, d, e, f = a.length; f--;) d = a[f].xMax - a[f].xMin, e = a[f].yMax - a[f].yMin, b < d && (b = d), c < e && (c = e);\n\n        return {\n          maxHeight: c,\n          maxWidth: b\n        };\n      };\n\n      b.prototype.getAlgorithmStartDirection = function (a) {\n        var b = \"top\" !== a.verticalAlign && \"bottom\" !== a.verticalAlign;\n        return \"left\" !== a.align && \"right\" !== a.align ? b ? void 0 : !1 : b ? !0 : void 0;\n      };\n\n      return b;\n    }();\n\n    d.prototype.algorithms = A;\n    t.Pathfinder = d;\n    v(n.prototype, {\n      getPathfinderAnchorPoint: function (a) {\n        var b = B(this);\n\n        switch (a.align) {\n          case \"right\":\n            var c = \"xMax\";\n            break;\n\n          case \"left\":\n            c = \"xMin\";\n        }\n\n        switch (a.verticalAlign) {\n          case \"top\":\n            var d = \"yMin\";\n            break;\n\n          case \"bottom\":\n            d = \"yMax\";\n        }\n\n        return {\n          x: c ? b[c] : (b.xMin + b.xMax) / 2,\n          y: d ? b[d] : (b.yMin + b.yMax) / 2\n        };\n      },\n      getRadiansToVector: function (a, c) {\n        var b;\n        k(c) || (b = B(this)) && (c = {\n          x: (b.xMin + b.xMax) / 2,\n          y: (b.yMin + b.yMax) / 2\n        });\n        return Math.atan2(c.y - a.y, a.x - c.x);\n      },\n      getMarkerVector: function (a, c, d) {\n        var b = 2 * Math.PI,\n            e = B(this),\n            f = e.xMax - e.xMin,\n            g = e.yMax - e.yMin,\n            k = Math.atan2(g, f),\n            q = !1;\n        f /= 2;\n        var y = g / 2,\n            z = e.xMin + f;\n        e = e.yMin + y;\n\n        for (var l = z, x = e, G = 1, h = 1; a < -Math.PI;) a += b;\n\n        for (; a > Math.PI;) a -= b;\n\n        b = Math.tan(a);\n        a > -k && a <= k ? (h = -1, q = !0) : a > k && a <= Math.PI - k ? h = -1 : a > Math.PI - k || a <= -(Math.PI - k) ? (G = -1, q = !0) : G = -1;\n        q ? (l += G * f, x += h * f * b) : (l += g / (2 * b) * G, x += h * y);\n        d.x !== z && (l = d.x);\n        d.y !== e && (x = d.y);\n        return {\n          x: l + c * Math.cos(a),\n          y: x - c * Math.sin(a)\n        };\n      }\n    });\n    u.prototype.callbacks.push(function (a) {\n      !1 !== a.options.connectors.enabled && (p(a), this.pathfinder = new d(this), this.pathfinder.update(!0));\n    });\n    return d;\n  });\n  F(a, \"Series/Gantt/GanttSeries.js\", [a[\"Series/Gantt/GanttPoint.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, u, t) {\n    var r = this && this.__extends || function () {\n      var a = function (k, f) {\n        a = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, e) {\n          a.__proto__ = e;\n        } || function (a, e) {\n          for (var f in e) e.hasOwnProperty(f) && (a[f] = e[f]);\n        };\n\n        return a(k, f);\n      };\n\n      return function (k, f) {\n        function h() {\n          this.constructor = k;\n        }\n\n        a(k, f);\n        k.prototype = null === f ? Object.create(f) : (h.prototype = f.prototype, new h());\n      };\n    }(),\n        n = u.series,\n        h = u.seriesTypes.xrange,\n        A = t.extend,\n        B = t.isNumber,\n        D = t.merge,\n        p = t.splat;\n\n    t = function (a) {\n      function k() {\n        var f = null !== a && a.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      r(k, a);\n\n      k.prototype.drawPoint = function (a, k) {\n        var e = this.options,\n            f = this.chart.renderer,\n            m = a.shapeArgs,\n            q = a.plotY,\n            c = a.graphic,\n            d = a.selected && \"select\",\n            b = e.stacking && !e.borderRadius;\n        if (a.options.milestone) {\n          if (B(q) && null !== a.y && !1 !== a.visible) {\n            m = f.symbols.diamond(m.x, m.y, m.width, m.height);\n            if (c) c[k]({\n              d: m\n            });else a.graphic = f.path(m).addClass(a.getClassName(), !0).add(a.group || this.group);\n            this.chart.styledMode || a.graphic.attr(this.pointAttribs(a, d)).shadow(e.shadow, null, b);\n          } else c && (a.graphic = c.destroy());\n        } else h.prototype.drawPoint.call(this, a, k);\n      };\n\n      k.prototype.translatePoint = function (a) {\n        h.prototype.translatePoint.call(this, a);\n\n        if (a.options.milestone) {\n          var f = a.shapeArgs;\n          var e = f.height;\n          a.shapeArgs = {\n            x: f.x - e / 2,\n            y: f.y,\n            width: e,\n            height: e\n          };\n        }\n      };\n\n      k.defaultOptions = D(h.defaultOptions, {\n        grouping: !1,\n        dataLabels: {\n          enabled: !0\n        },\n        tooltip: {\n          headerFormat: '<span style=\"font-size: 10px\">{series.name}</span><br/>',\n          pointFormat: null,\n          pointFormatter: function () {\n            var a = this.series,\n                k = a.chart.tooltip,\n                e = a.xAxis,\n                g = a.tooltipOptions.dateTimeLabelFormats,\n                h = e.options.startOfWeek,\n                q = a.tooltipOptions,\n                c = q.xDateFormat,\n                d = this.options.milestone,\n                b = \"<b>\" + (this.name || this.yCategory) + \"</b>\";\n            if (q.pointFormat) return this.tooltipFormatter(q.pointFormat);\n            c || (c = p(k.getDateFormat(e.closestPointRange, this.start, h, g))[0]);\n            k = a.chart.time.dateFormat(c, this.start);\n            a = a.chart.time.dateFormat(c, this.end);\n            b += \"<br/>\";\n            return d ? b + (k + \"<br/>\") : b + (\"Start: \" + k + \"<br/>End: \") + (a + \"<br/>\");\n          }\n        },\n        connectors: {\n          type: \"simpleConnect\",\n          animation: {\n            reversed: !0\n          },\n          startMarker: {\n            enabled: !0,\n            symbol: \"arrow-filled\",\n            radius: 4,\n            fill: \"#fa0\",\n            align: \"left\"\n          },\n          endMarker: {\n            enabled: !1,\n            align: \"right\"\n          }\n        }\n      });\n      return k;\n    }(h);\n\n    A(t.prototype, {\n      keyboardMoveVertical: !1,\n      pointArrayMap: [\"start\", \"end\", \"y\"],\n      pointClass: a,\n      setData: n.prototype.setData\n    });\n    u.registerSeriesType(\"gantt\", t);\n    \"\";\n    return t;\n  });\n  F(a, \"Core/Chart/GanttChart.js\", [a[\"Core/Chart/Chart.js\"], a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, u, t) {\n    var r = t.getOptions,\n        n = t.isArray,\n        h = t.merge,\n        A = t.splat;\n\n    u.ganttChart = function (t, u, p) {\n      var w = \"string\" === typeof t || t.nodeName,\n          k = u.series,\n          f = r(),\n          v,\n          e = u;\n      u = arguments[w ? 1 : 0];\n      n(u.xAxis) || (u.xAxis = [u.xAxis || {}, {}]);\n      u.xAxis = u.xAxis.map(function (a, e) {\n        1 === e && (v = 0);\n        return h(f.xAxis, {\n          grid: {\n            enabled: !0\n          },\n          opposite: !0,\n          linkedTo: v\n        }, a, {\n          type: \"datetime\"\n        });\n      });\n      u.yAxis = A(u.yAxis || {}).map(function (a) {\n        return h(f.yAxis, {\n          grid: {\n            enabled: !0\n          },\n          staticScale: 50,\n          reversed: !0,\n          type: a.categories ? a.type : \"treegrid\"\n        }, a);\n      });\n      u.series = null;\n      u = h(!0, {\n        chart: {\n          type: \"gantt\"\n        },\n        title: {\n          text: null\n        },\n        legend: {\n          enabled: !1\n        },\n        navigator: {\n          series: {\n            type: \"gantt\"\n          },\n          yAxis: {\n            type: \"category\"\n          }\n        }\n      }, u, {\n        isGantt: !0\n      });\n      u.series = e.series = k;\n      return w ? new a(t, u, p) : new a(u, u);\n    };\n  });\n  F(a, \"Core/Axis/ScrollbarAxis.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, u) {\n    var t = u.addEvent,\n        r = u.defined,\n        n = u.pick;\n    return function () {\n      function h() {}\n\n      h.compose = function (h, u) {\n        var A = function (a) {\n          var h = n(a.options && a.options.min, a.min),\n              k = n(a.options && a.options.max, a.max);\n          return {\n            axisMin: h,\n            axisMax: k,\n            scrollMin: r(a.dataMin) ? Math.min(h, a.min, a.dataMin, n(a.threshold, Infinity)) : h,\n            scrollMax: r(a.dataMax) ? Math.max(k, a.max, a.dataMax, n(a.threshold, -Infinity)) : k\n          };\n        };\n\n        t(h, \"afterInit\", function () {\n          var h = this;\n          h.options && h.options.scrollbar && h.options.scrollbar.enabled && (h.options.scrollbar.vertical = !h.horiz, h.options.startOnTick = h.options.endOnTick = !1, h.scrollbar = new u(h.chart.renderer, h.options.scrollbar, h.chart), t(h.scrollbar, \"changed\", function (p) {\n            var k = A(h),\n                f = k.axisMax,\n                v = k.scrollMin,\n                e = k.scrollMax - v;\n            r(k.axisMin) && r(f) && (h.horiz && !h.reversed || !h.horiz && h.reversed ? (k = v + e * this.to, v += e * this.from) : (k = v + e * (1 - this.from), v += e * (1 - this.to)), n(this.options.liveRedraw, a.svg && !a.isTouchDevice && !this.chart.isBoosting) || \"mouseup\" === p.DOMType || \"touchend\" === p.DOMType || !r(p.DOMType) ? h.setExtremes(v, k, !0, \"mousemove\" !== p.DOMType && \"touchmove\" !== p.DOMType, p) : this.setRange(this.from, this.to));\n          }));\n        });\n        t(h, \"afterRender\", function () {\n          var a = A(this),\n              h = a.scrollMin,\n              k = a.scrollMax;\n          a = this.scrollbar;\n          var f = this.axisTitleMargin + (this.titleOffset || 0),\n              n = this.chart.scrollbarsOffsets,\n              e = this.options.margin || 0;\n          a && (this.horiz ? (this.opposite || (n[1] += f), a.position(this.left, this.top + this.height + 2 + n[1] - (this.opposite ? e : 0), this.width, this.height), this.opposite || (n[1] += e), f = 1) : (this.opposite && (n[0] += f), a.position(this.left + this.width + 2 + n[0] - (this.opposite ? 0 : e), this.top, this.width, this.height), this.opposite && (n[0] += e), f = 0), n[f] += a.size + a.options.margin, isNaN(h) || isNaN(k) || !r(this.min) || !r(this.max) || this.min === this.max ? a.setRange(0, 1) : (n = (this.min - h) / (k - h), h = (this.max - h) / (k - h), this.horiz && !this.reversed || !this.horiz && this.reversed ? a.setRange(n, h) : a.setRange(1 - h, 1 - n)));\n        });\n        t(h, \"afterGetOffset\", function () {\n          var a = this.horiz ? 2 : 1,\n              h = this.scrollbar;\n          h && (this.chart.scrollbarsOffsets = [0, 0], this.chart.axisOffset[a] += h.size + h.options.margin);\n        });\n      };\n\n      return h;\n    }();\n  });\n  F(a, \"Core/Scrollbar.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Globals.js\"], a[\"Core/Color/Palette.js\"], a[\"Core/Axis/ScrollbarAxis.js\"], a[\"Core/Utilities.js\"], a[\"Core/Options.js\"]], function (a, u, t, r, n, h) {\n    var A = n.addEvent,\n        B = n.correctFloat,\n        D = n.defined,\n        p = n.destroyObjectProperties,\n        w = n.fireEvent,\n        k = n.merge,\n        f = n.pick,\n        v = n.removeEvent;\n    n = h.defaultOptions;\n\n    var e = u.isTouchDevice,\n        g = u.swapXY = function (a, e) {\n      e && a.forEach(function (a) {\n        for (var c = a.length, b, e = 0; e < c; e += 2) b = a[e + 1], \"number\" === typeof b && (a[e + 1] = a[e + 2], a[e + 2] = b);\n      });\n      return a;\n    };\n\n    h = function () {\n      function a(a, c, d) {\n        this._events = [];\n        this.from = this.chartY = this.chartX = 0;\n        this.scrollbar = this.group = void 0;\n        this.scrollbarButtons = [];\n        this.scrollbarGroup = void 0;\n        this.scrollbarLeft = 0;\n        this.scrollbarRifles = void 0;\n        this.scrollbarStrokeWidth = 1;\n        this.to = this.size = this.scrollbarTop = 0;\n        this.track = void 0;\n        this.trackBorderWidth = 1;\n        this.userOptions = {};\n        this.y = this.x = 0;\n        this.chart = d;\n        this.options = c;\n        this.renderer = d.renderer;\n        this.init(a, c, d);\n      }\n\n      a.prototype.addEvents = function () {\n        var a = this.options.inverted ? [1, 0] : [0, 1],\n            c = this.scrollbarButtons,\n            d = this.scrollbarGroup.element,\n            b = this.track.element,\n            e = this.mouseDownHandler.bind(this),\n            f = this.mouseMoveHandler.bind(this),\n            g = this.mouseUpHandler.bind(this);\n        a = [[c[a[0]].element, \"click\", this.buttonToMinClick.bind(this)], [c[a[1]].element, \"click\", this.buttonToMaxClick.bind(this)], [b, \"click\", this.trackClick.bind(this)], [d, \"mousedown\", e], [d.ownerDocument, \"mousemove\", f], [d.ownerDocument, \"mouseup\", g]];\n        u.hasTouch && a.push([d, \"touchstart\", e], [d.ownerDocument, \"touchmove\", f], [d.ownerDocument, \"touchend\", g]);\n        a.forEach(function (a) {\n          A.apply(null, a);\n        });\n        this._events = a;\n      };\n\n      a.prototype.buttonToMaxClick = function (a) {\n        var c = (this.to - this.from) * f(this.options.step, .2);\n        this.updatePosition(this.from + c, this.to + c);\n        w(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.buttonToMinClick = function (a) {\n        var c = B(this.to - this.from) * f(this.options.step, .2);\n        this.updatePosition(B(this.from - c), B(this.to - c));\n        w(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.cursorToScrollbarPosition = function (a) {\n        var c = this.options;\n        c = c.minWidth > this.calculatedWidth ? c.minWidth : 0;\n        return {\n          chartX: (a.chartX - this.x - this.xOffset) / (this.barWidth - c),\n          chartY: (a.chartY - this.y - this.yOffset) / (this.barWidth - c)\n        };\n      };\n\n      a.prototype.destroy = function () {\n        var a = this.chart.scroller;\n        this.removeEvents();\n        [\"track\", \"scrollbarRifles\", \"scrollbar\", \"scrollbarGroup\", \"group\"].forEach(function (a) {\n          this[a] && this[a].destroy && (this[a] = this[a].destroy());\n        }, this);\n        a && this === a.scrollbar && (a.scrollbar = null, p(a.scrollbarButtons));\n      };\n\n      a.prototype.drawScrollbarButton = function (a) {\n        var c = this.renderer,\n            d = this.scrollbarButtons,\n            b = this.options,\n            e = this.size;\n        var f = c.g().add(this.group);\n        d.push(f);\n        f = c.rect().addClass(\"highcharts-scrollbar-button\").add(f);\n        this.chart.styledMode || f.attr({\n          stroke: b.buttonBorderColor,\n          \"stroke-width\": b.buttonBorderWidth,\n          fill: b.buttonBackgroundColor\n        });\n        f.attr(f.crisp({\n          x: -.5,\n          y: -.5,\n          width: e + 1,\n          height: e + 1,\n          r: b.buttonBorderRadius\n        }, f.strokeWidth()));\n        f = c.path(g([[\"M\", e / 2 + (a ? -1 : 1), e / 2 - 3], [\"L\", e / 2 + (a ? -1 : 1), e / 2 + 3], [\"L\", e / 2 + (a ? 2 : -2), e / 2]], b.vertical)).addClass(\"highcharts-scrollbar-arrow\").add(d[a]);\n        this.chart.styledMode || f.attr({\n          fill: b.buttonArrowColor\n        });\n      };\n\n      a.prototype.init = function (e, c, d) {\n        this.scrollbarButtons = [];\n        this.renderer = e;\n        this.userOptions = c;\n        this.options = k(a.defaultOptions, c);\n        this.chart = d;\n        this.size = f(this.options.size, this.options.height);\n        c.enabled && (this.render(), this.addEvents());\n      };\n\n      a.prototype.mouseDownHandler = function (a) {\n        a = this.chart.pointer.normalize(a);\n        a = this.cursorToScrollbarPosition(a);\n        this.chartX = a.chartX;\n        this.chartY = a.chartY;\n        this.initPositions = [this.from, this.to];\n        this.grabbedCenter = !0;\n      };\n\n      a.prototype.mouseMoveHandler = function (a) {\n        var c = this.chart.pointer.normalize(a),\n            d = this.options.vertical ? \"chartY\" : \"chartX\",\n            b = this.initPositions || [];\n        !this.grabbedCenter || a.touches && 0 === a.touches[0][d] || (c = this.cursorToScrollbarPosition(c)[d], d = this[d], d = c - d, this.hasDragged = !0, this.updatePosition(b[0] + d, b[1] + d), this.hasDragged && w(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        }));\n      };\n\n      a.prototype.mouseUpHandler = function (a) {\n        this.hasDragged && w(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMType: a.type,\n          DOMEvent: a\n        });\n        this.grabbedCenter = this.hasDragged = this.chartX = this.chartY = null;\n      };\n\n      a.prototype.position = function (a, c, d, b) {\n        var e = this.options.vertical,\n            f = 0,\n            g = this.rendered ? \"animate\" : \"attr\";\n        this.x = a;\n        this.y = c + this.trackBorderWidth;\n        this.width = d;\n        this.xOffset = this.height = b;\n        this.yOffset = f;\n        e ? (this.width = this.yOffset = d = f = this.size, this.xOffset = c = 0, this.barWidth = b - 2 * d, this.x = a += this.options.margin) : (this.height = this.xOffset = b = c = this.size, this.barWidth = d - 2 * b, this.y += this.options.margin);\n        this.group[g]({\n          translateX: a,\n          translateY: this.y\n        });\n        this.track[g]({\n          width: d,\n          height: b\n        });\n        this.scrollbarButtons[1][g]({\n          translateX: e ? 0 : d - c,\n          translateY: e ? b - f : 0\n        });\n      };\n\n      a.prototype.removeEvents = function () {\n        this._events.forEach(function (a) {\n          v.apply(null, a);\n        });\n\n        this._events.length = 0;\n      };\n\n      a.prototype.render = function () {\n        var a = this.renderer,\n            c = this.options,\n            d = this.size,\n            b = this.chart.styledMode,\n            e;\n        this.group = e = a.g(\"scrollbar\").attr({\n          zIndex: c.zIndex,\n          translateY: -99999\n        }).add();\n        this.track = a.rect().addClass(\"highcharts-scrollbar-track\").attr({\n          x: 0,\n          r: c.trackBorderRadius || 0,\n          height: d,\n          width: d\n        }).add(e);\n        b || this.track.attr({\n          fill: c.trackBackgroundColor,\n          stroke: c.trackBorderColor,\n          \"stroke-width\": c.trackBorderWidth\n        });\n        this.trackBorderWidth = this.track.strokeWidth();\n        this.track.attr({\n          y: -this.trackBorderWidth % 2 / 2\n        });\n        this.scrollbarGroup = a.g().add(e);\n        this.scrollbar = a.rect().addClass(\"highcharts-scrollbar-thumb\").attr({\n          height: d,\n          width: d,\n          r: c.barBorderRadius || 0\n        }).add(this.scrollbarGroup);\n        this.scrollbarRifles = a.path(g([[\"M\", -3, d / 4], [\"L\", -3, 2 * d / 3], [\"M\", 0, d / 4], [\"L\", 0, 2 * d / 3], [\"M\", 3, d / 4], [\"L\", 3, 2 * d / 3]], c.vertical)).addClass(\"highcharts-scrollbar-rifles\").add(this.scrollbarGroup);\n        b || (this.scrollbar.attr({\n          fill: c.barBackgroundColor,\n          stroke: c.barBorderColor,\n          \"stroke-width\": c.barBorderWidth\n        }), this.scrollbarRifles.attr({\n          stroke: c.rifleColor,\n          \"stroke-width\": 1\n        }));\n        this.scrollbarStrokeWidth = this.scrollbar.strokeWidth();\n        this.scrollbarGroup.translate(-this.scrollbarStrokeWidth % 2 / 2, -this.scrollbarStrokeWidth % 2 / 2);\n        this.drawScrollbarButton(0);\n        this.drawScrollbarButton(1);\n      };\n\n      a.prototype.setRange = function (a, c) {\n        var d = this.options,\n            b = d.vertical,\n            e = d.minWidth,\n            f = this.barWidth,\n            g,\n            h = !this.rendered || this.hasDragged || this.chart.navigator && this.chart.navigator.hasDragged ? \"attr\" : \"animate\";\n\n        if (D(f)) {\n          a = Math.max(a, 0);\n          var k = Math.ceil(f * a);\n          this.calculatedWidth = g = B(f * Math.min(c, 1) - k);\n          g < e && (k = (f - e + g) * a, g = e);\n          e = Math.floor(k + this.xOffset + this.yOffset);\n          f = g / 2 - .5;\n          this.from = a;\n          this.to = c;\n          b ? (this.scrollbarGroup[h]({\n            translateY: e\n          }), this.scrollbar[h]({\n            height: g\n          }), this.scrollbarRifles[h]({\n            translateY: f\n          }), this.scrollbarTop = e, this.scrollbarLeft = 0) : (this.scrollbarGroup[h]({\n            translateX: e\n          }), this.scrollbar[h]({\n            width: g\n          }), this.scrollbarRifles[h]({\n            translateX: f\n          }), this.scrollbarLeft = e, this.scrollbarTop = 0);\n          12 >= g ? this.scrollbarRifles.hide() : this.scrollbarRifles.show(!0);\n          !1 === d.showFull && (0 >= a && 1 <= c ? this.group.hide() : this.group.show());\n          this.rendered = !0;\n        }\n      };\n\n      a.prototype.trackClick = function (a) {\n        var c = this.chart.pointer.normalize(a),\n            d = this.to - this.from,\n            b = this.y + this.scrollbarTop,\n            e = this.x + this.scrollbarLeft;\n        this.options.vertical && c.chartY > b || !this.options.vertical && c.chartX > e ? this.updatePosition(this.from + d, this.to + d) : this.updatePosition(this.from - d, this.to - d);\n        w(this, \"changed\", {\n          from: this.from,\n          to: this.to,\n          trigger: \"scrollbar\",\n          DOMEvent: a\n        });\n      };\n\n      a.prototype.update = function (a) {\n        this.destroy();\n        this.init(this.chart.renderer, k(!0, this.options, a), this.chart);\n      };\n\n      a.prototype.updatePosition = function (a, c) {\n        1 < c && (a = B(1 - B(c - a)), c = 1);\n        0 > a && (c = B(c - a), a = 0);\n        this.from = a;\n        this.to = c;\n      };\n\n      a.defaultOptions = {\n        height: e ? 20 : 14,\n        barBorderRadius: 0,\n        buttonBorderRadius: 0,\n        liveRedraw: void 0,\n        margin: 10,\n        minWidth: 6,\n        step: .2,\n        zIndex: 3,\n        barBackgroundColor: t.neutralColor20,\n        barBorderWidth: 1,\n        barBorderColor: t.neutralColor20,\n        buttonArrowColor: t.neutralColor80,\n        buttonBackgroundColor: t.neutralColor10,\n        buttonBorderColor: t.neutralColor20,\n        buttonBorderWidth: 1,\n        rifleColor: t.neutralColor80,\n        trackBackgroundColor: t.neutralColor5,\n        trackBorderColor: t.neutralColor5,\n        trackBorderWidth: 1\n      };\n      return a;\n    }();\n\n    u.Scrollbar || (n.scrollbar = k(!0, h.defaultOptions, n.scrollbar), u.Scrollbar = h, r.compose(a, h));\n    return u.Scrollbar;\n  });\n  F(a, \"Extensions/RangeSelector.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Globals.js\"], a[\"Core/Options.js\"], a[\"Core/Color/Palette.js\"], a[\"Core/Renderer/SVG/SVGElement.js\"], a[\"Core/Utilities.js\"]], function (a, u, t, r, n, h, A) {\n    function B(a) {\n      if (-1 !== a.indexOf(\"%L\")) return \"text\";\n      var b = \"aAdewbBmoyY\".split(\"\").some(function (b) {\n        return -1 !== a.indexOf(\"%\" + b);\n      }),\n          c = \"HkIlMS\".split(\"\").some(function (b) {\n        return -1 !== a.indexOf(\"%\" + b);\n      });\n      return b && c ? \"datetime-local\" : b ? \"date\" : c ? \"time\" : \"text\";\n    }\n\n    var D = r.defaultOptions,\n        p = A.addEvent,\n        w = A.createElement,\n        k = A.css,\n        f = A.defined,\n        v = A.destroyObjectProperties,\n        e = A.discardElement,\n        g = A.extend,\n        m = A.find,\n        q = A.fireEvent,\n        c = A.isNumber,\n        d = A.merge,\n        b = A.objectEach,\n        F = A.pad,\n        I = A.pick,\n        K = A.pInt,\n        L = A.splat;\n    g(D, {\n      rangeSelector: {\n        allButtonsEnabled: !1,\n        buttons: void 0,\n        buttonSpacing: 5,\n        dropdown: \"responsive\",\n        enabled: void 0,\n        verticalAlign: \"top\",\n        buttonTheme: {\n          width: 28,\n          height: 18,\n          padding: 2,\n          zIndex: 7\n        },\n        floating: !1,\n        x: 0,\n        y: 0,\n        height: void 0,\n        inputBoxBorderColor: \"none\",\n        inputBoxHeight: 17,\n        inputBoxWidth: void 0,\n        inputDateFormat: \"%b %e, %Y\",\n        inputDateParser: void 0,\n        inputEditDateFormat: \"%Y-%m-%d\",\n        inputEnabled: !0,\n        inputPosition: {\n          align: \"right\",\n          x: 0,\n          y: 0\n        },\n        inputSpacing: 5,\n        selected: void 0,\n        buttonPosition: {\n          align: \"left\",\n          x: 0,\n          y: 0\n        },\n        inputStyle: {\n          color: n.highlightColor80,\n          cursor: \"pointer\"\n        },\n        labelStyle: {\n          color: n.neutralColor60\n        }\n      }\n    });\n    g(D.lang, {\n      rangeSelectorZoom: \"Zoom\",\n      rangeSelectorFrom: \"\",\n      rangeSelectorTo: \"\\u2192\"\n    });\n\n    var H = function () {\n      function m(a) {\n        this.buttons = void 0;\n        this.buttonOptions = m.prototype.defaultButtons;\n        this.initialButtonGroupWidth = 0;\n        this.options = void 0;\n        this.chart = a;\n        this.init(a);\n      }\n\n      m.prototype.clickButton = function (b, d) {\n        var l = this.chart,\n            e = this.buttonOptions[b],\n            g = l.xAxis[0],\n            h = l.scroller && l.scroller.getUnionExtremes() || g || {},\n            y = h.dataMin,\n            k = h.dataMax,\n            z = g && Math.round(Math.min(g.max, I(k, g.max))),\n            m = e.type;\n        h = e._range;\n        var n,\n            r = e.dataGrouping;\n\n        if (null !== y && null !== k) {\n          l.fixedRange = h;\n          r && (this.forcedDataGrouping = !0, a.prototype.setDataGrouping.call(g || {\n            chart: this.chart\n          }, r, !1), this.frozenStates = e.preserveDataGrouping);\n          if (\"month\" === m || \"year\" === m) {\n            if (g) {\n              m = {\n                range: e,\n                max: z,\n                chart: l,\n                dataMin: y,\n                dataMax: k\n              };\n              var t = g.minFromRange.call(m);\n              c(m.newMax) && (z = m.newMax);\n            } else h = e;\n          } else if (h) t = Math.max(z - h, y), z = Math.min(t + h, k);else if (\"ytd\" === m) {\n            if (g) \"undefined\" === typeof k && (y = Number.MAX_VALUE, k = Number.MIN_VALUE, l.series.forEach(function (a) {\n              a = a.xData;\n              y = Math.min(a[0], y);\n              k = Math.max(a[a.length - 1], k);\n            }), d = !1), z = this.getYTDExtremes(k, y, l.time.useUTC), t = n = z.min, z = z.max;else {\n              this.deferredYTDClick = b;\n              return;\n            }\n          } else \"all\" === m && g && (t = y, z = k);\n          f(t) && (t += e._offsetMin);\n          f(z) && (z += e._offsetMax);\n          this.setSelected(b);\n          this.dropdown && (this.dropdown.selectedIndex = b + 1);\n          if (g) g.setExtremes(t, z, I(d, !0), void 0, {\n            trigger: \"rangeSelectorButton\",\n            rangeSelectorButton: e\n          });else {\n            var v = L(l.options.xAxis)[0];\n            var u = v.range;\n            v.range = h;\n            var w = v.min;\n            v.min = n;\n            p(l, \"load\", function () {\n              v.range = u;\n              v.min = w;\n            });\n          }\n          q(this, \"afterBtnClick\");\n        }\n      };\n\n      m.prototype.setSelected = function (a) {\n        this.selected = this.options.selected = a;\n      };\n\n      m.prototype.init = function (a) {\n        var b = this,\n            c = a.options.rangeSelector,\n            d = c.buttons || b.defaultButtons.slice(),\n            e = c.selected,\n            f = function () {\n          var a = b.minInput,\n              c = b.maxInput;\n          a && a.blur && q(a, \"blur\");\n          c && c.blur && q(c, \"blur\");\n        };\n\n        b.chart = a;\n        b.options = c;\n        b.buttons = [];\n        b.buttonOptions = d;\n        this.eventsToUnbind = [];\n        this.eventsToUnbind.push(p(a.container, \"mousedown\", f));\n        this.eventsToUnbind.push(p(a, \"resize\", f));\n        d.forEach(b.computeButtonRange);\n        \"undefined\" !== typeof e && d[e] && this.clickButton(e, !1);\n        this.eventsToUnbind.push(p(a, \"load\", function () {\n          a.xAxis && a.xAxis[0] && p(a.xAxis[0], \"setExtremes\", function (c) {\n            this.max - this.min !== a.fixedRange && \"rangeSelectorButton\" !== c.trigger && \"updatedData\" !== c.trigger && b.forcedDataGrouping && !b.frozenStates && this.setDataGrouping(!1, !1);\n          });\n        }));\n      };\n\n      m.prototype.updateButtonStates = function () {\n        var a = this,\n            b = this.chart,\n            d = this.dropdown,\n            e = b.xAxis[0],\n            f = Math.round(e.max - e.min),\n            g = !e.hasVisibleSeries,\n            h = b.scroller && b.scroller.getUnionExtremes() || e,\n            k = h.dataMin,\n            m = h.dataMax;\n        b = a.getYTDExtremes(m, k, b.time.useUTC);\n        var n = b.min,\n            q = b.max,\n            t = a.selected,\n            p = c(t),\n            r = a.options.allButtonsEnabled,\n            v = a.buttons;\n        a.buttonOptions.forEach(function (b, c) {\n          var l = b._range,\n              x = b.type,\n              h = b.count || 1,\n              y = v[c],\n              z = 0,\n              G = b._offsetMax - b._offsetMin;\n          b = c === t;\n          var O = l > m - k,\n              P = l < e.minRange,\n              N = !1,\n              u = !1;\n          l = l === f;\n          (\"month\" === x || \"year\" === x) && f + 36E5 >= 864E5 * {\n            month: 28,\n            year: 365\n          }[x] * h - G && f - 36E5 <= 864E5 * {\n            month: 31,\n            year: 366\n          }[x] * h + G ? l = !0 : \"ytd\" === x ? (l = q - n + G === f, N = !b) : \"all\" === x && (l = e.max - e.min >= m - k, u = !b && p && l);\n          x = !r && (O || P || u || g);\n          h = b && l || l && !p && !N || b && a.frozenStates;\n          x ? z = 3 : h && (p = !0, z = 2);\n          y.state !== z && (y.setState(z), d && (d.options[c + 1].disabled = x, 2 === z && (d.selectedIndex = c + 1)), 0 === z && t === c && a.setSelected());\n        });\n      };\n\n      m.prototype.computeButtonRange = function (a) {\n        var b = a.type,\n            c = a.count || 1,\n            d = {\n          millisecond: 1,\n          second: 1E3,\n          minute: 6E4,\n          hour: 36E5,\n          day: 864E5,\n          week: 6048E5\n        };\n        if (d[b]) a._range = d[b] * c;else if (\"month\" === b || \"year\" === b) a._range = 864E5 * {\n          month: 30,\n          year: 365\n        }[b] * c;\n        a._offsetMin = I(a.offsetMin, 0);\n        a._offsetMax = I(a.offsetMax, 0);\n        a._range += a._offsetMax - a._offsetMin;\n      };\n\n      m.prototype.getInputValue = function (a) {\n        a = \"min\" === a ? this.minInput : this.maxInput;\n        var b = this.chart.options.rangeSelector,\n            c = this.chart.time;\n        return a ? (\"text\" === a.type && b.inputDateParser || this.defaultInputDateParser)(a.value, c.useUTC, c) : 0;\n      };\n\n      m.prototype.setInputValue = function (a, b) {\n        var c = this.options,\n            d = this.chart.time,\n            e = \"min\" === a ? this.minInput : this.maxInput;\n        a = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if (e) {\n          var g = e.getAttribute(\"data-hc-time\");\n          g = f(g) ? Number(g) : void 0;\n          f(b) && (f(g) && e.setAttribute(\"data-hc-time-previous\", g), e.setAttribute(\"data-hc-time\", b), g = b);\n          e.value = d.dateFormat(this.inputTypeFormats[e.type] || c.inputEditDateFormat, g);\n          a && a.attr({\n            text: d.dateFormat(c.inputDateFormat, g)\n          });\n        }\n      };\n\n      m.prototype.setInputExtremes = function (a, b, c) {\n        if (a = \"min\" === a ? this.minInput : this.maxInput) {\n          var d = this.inputTypeFormats[a.type],\n              l = this.chart.time;\n          d && (b = l.dateFormat(d, b), a.min !== b && (a.min = b), c = l.dateFormat(d, c), a.max !== c && (a.max = c));\n        }\n      };\n\n      m.prototype.showInput = function (a) {\n        var b = \"min\" === a ? this.minDateBox : this.maxDateBox;\n\n        if ((a = \"min\" === a ? this.minInput : this.maxInput) && b && this.inputGroup) {\n          var c = \"text\" === a.type,\n              d = this.inputGroup,\n              e = d.translateX;\n          d = d.translateY;\n          k(a, {\n            width: c ? b.width - 2 + \"px\" : \"auto\",\n            height: c ? b.height - 2 + \"px\" : \"auto\",\n            border: \"2px solid silver\"\n          });\n          c ? k(a, {\n            left: e + b.x + \"px\",\n            top: d + \"px\"\n          }) : k(a, {\n            left: Math.min(Math.round(b.x + e - (a.offsetWidth - b.width) / 2), this.chart.chartWidth - a.offsetWidth) + \"px\",\n            top: d - (a.offsetHeight - b.height) / 2 + \"px\"\n          });\n        }\n      };\n\n      m.prototype.hideInput = function (a) {\n        (a = \"min\" === a ? this.minInput : this.maxInput) && k(a, {\n          top: \"-9999em\",\n          border: 0,\n          width: \"1px\",\n          height: \"1px\"\n        });\n      };\n\n      m.prototype.defaultInputDateParser = function (a, b, d) {\n        var e = a.split(\"/\").join(\"-\").split(\" \").join(\"T\");\n        -1 === e.indexOf(\"T\") && (e += \"T00:00\");\n        if (b) e += \"Z\";else {\n          var l;\n          if (l = t.isSafari) l = e, l = !(6 < l.length && (l.lastIndexOf(\"-\") === l.length - 6 || l.lastIndexOf(\"+\") === l.length - 6));\n          l && (l = new Date(e).getTimezoneOffset() / 60, e += 0 >= l ? \"+\" + F(-l) + \":00\" : \"-\" + F(l) + \":00\");\n        }\n        e = Date.parse(e);\n        c(e) || (a = a.split(\"-\"), e = Date.UTC(K(a[0]), K(a[1]) - 1, K(a[2])));\n        d && b && (e += d.getTimezoneOffset(e));\n        return e;\n      };\n\n      m.prototype.drawInput = function (a) {\n        function b() {\n          var b = m.getInputValue(a),\n              d = e.xAxis[0],\n              l = e.scroller && e.scroller.xAxis ? e.scroller.xAxis : d,\n              f = l.dataMin;\n          l = l.dataMax;\n          var g = m.maxInput,\n              x = m.minInput;\n          b !== Number(u.getAttribute(\"data-hc-time-previous\")) && c(b) && (u.setAttribute(\"data-hc-time-previous\", b), r && g && c(f) ? b > Number(g.getAttribute(\"data-hc-time\")) ? b = void 0 : b < f && (b = f) : x && c(l) && (b < Number(x.getAttribute(\"data-hc-time\")) ? b = void 0 : b > l && (b = l)), \"undefined\" !== typeof b && d.setExtremes(r ? b : d.min, r ? d.max : b, void 0, void 0, {\n            trigger: \"rangeSelectorInput\"\n          }));\n        }\n\n        var e = this.chart,\n            f = this.div,\n            h = this.inputGroup,\n            m = this,\n            y = e.renderer.style || {},\n            q = e.renderer,\n            p = e.options.rangeSelector,\n            r = \"min\" === a,\n            v = D.lang[r ? \"rangeSelectorFrom\" : \"rangeSelectorTo\"];\n        v = q.label(v, 0).addClass(\"highcharts-range-label\").attr({\n          padding: v ? 2 : 0\n        }).add(h);\n        q = q.label(\"\", 0).addClass(\"highcharts-range-input\").attr({\n          padding: 2,\n          width: p.inputBoxWidth,\n          height: p.inputBoxHeight,\n          \"text-align\": \"center\"\n        }).on(\"click\", function () {\n          m.showInput(a);\n          m[a + \"Input\"].focus();\n        });\n        e.styledMode || q.attr({\n          stroke: p.inputBoxBorderColor,\n          \"stroke-width\": 1\n        });\n        q.add(h);\n        var u = w(\"input\", {\n          name: a,\n          className: \"highcharts-range-selector\"\n        }, void 0, f);\n        u.setAttribute(\"type\", B(p.inputDateFormat || \"%b %e, %Y\"));\n        e.styledMode || (v.css(d(y, p.labelStyle)), q.css(d({\n          color: n.neutralColor80\n        }, y, p.inputStyle)), k(u, g({\n          position: \"absolute\",\n          border: 0,\n          boxShadow: \"0 0 15px rgba(0,0,0,0.3)\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          textAlign: \"center\",\n          fontSize: y.fontSize,\n          fontFamily: y.fontFamily,\n          top: \"-9999em\"\n        }, p.inputStyle)));\n\n        u.onfocus = function () {\n          m.showInput(a);\n        };\n\n        u.onblur = function () {\n          u === t.doc.activeElement && b();\n          m.hideInput(a);\n          m.setInputValue(a);\n          u.blur();\n        };\n\n        var E = !1;\n\n        u.onchange = function () {\n          b();\n          E || (m.hideInput(a), u.blur());\n        };\n\n        u.onkeypress = function (a) {\n          13 === a.keyCode && b();\n        };\n\n        u.onkeydown = function () {\n          E = !0;\n        };\n\n        u.onkeyup = function () {\n          E = !1;\n        };\n\n        return {\n          dateBox: q,\n          input: u,\n          label: v\n        };\n      };\n\n      m.prototype.getPosition = function () {\n        var a = this.chart,\n            b = a.options.rangeSelector;\n        a = \"top\" === b.verticalAlign ? a.plotTop - a.axisOffset[0] : 0;\n        return {\n          buttonTop: a + b.buttonPosition.y,\n          inputTop: a + b.inputPosition.y - 10\n        };\n      };\n\n      m.prototype.getYTDExtremes = function (a, b, c) {\n        var d = this.chart.time,\n            e = new d.Date(a),\n            l = d.get(\"FullYear\", e);\n        c = c ? d.Date.UTC(l, 0, 1) : +new d.Date(l, 0, 1);\n        b = Math.max(b, c);\n        e = e.getTime();\n        return {\n          max: Math.min(a || e, e),\n          min: b\n        };\n      };\n\n      m.prototype.render = function (a, b) {\n        var c = this.chart,\n            d = c.renderer,\n            e = c.container,\n            g = c.options,\n            h = g.rangeSelector,\n            k = I(g.chart.style && g.chart.style.zIndex, 0) + 1;\n        g = h.inputEnabled;\n\n        if (!1 !== h.enabled) {\n          this.rendered || (this.group = d.g(\"range-selector-group\").attr({\n            zIndex: 7\n          }).add(), this.div = w(\"div\", void 0, {\n            position: \"relative\",\n            height: 0,\n            zIndex: k\n          }), this.buttonOptions.length && this.renderButtons(), e.parentNode && e.parentNode.insertBefore(this.div, e), g && (this.inputGroup = d.g(\"input-group\").add(this.group), d = this.drawInput(\"min\"), this.minDateBox = d.dateBox, this.minLabel = d.label, this.minInput = d.input, d = this.drawInput(\"max\"), this.maxDateBox = d.dateBox, this.maxLabel = d.label, this.maxInput = d.input));\n\n          if (g && (this.setInputValue(\"min\", a), this.setInputValue(\"max\", b), a = c.scroller && c.scroller.getUnionExtremes() || c.xAxis[0] || {}, f(a.dataMin) && f(a.dataMax) && (c = c.xAxis[0].minRange || 0, this.setInputExtremes(\"min\", a.dataMin, Math.min(a.dataMax, this.getInputValue(\"max\")) - c), this.setInputExtremes(\"max\", Math.max(a.dataMin, this.getInputValue(\"min\")) + c, a.dataMax)), this.inputGroup)) {\n            var m = 0;\n            [this.minLabel, this.minDateBox, this.maxLabel, this.maxDateBox].forEach(function (a) {\n              a && a.width && (a.attr({\n                x: m\n              }), m += a.width + h.inputSpacing);\n            });\n          }\n\n          this.alignElements();\n          this.rendered = !0;\n        }\n      };\n\n      m.prototype.renderButtons = function () {\n        var a = this,\n            b = this.buttons,\n            c = this.options,\n            e = D.lang,\n            f = this.chart.renderer,\n            g = d(c.buttonTheme),\n            h = g && g.states,\n            k = g.width || 28;\n        delete g.width;\n        this.buttonGroup = f.g(\"range-selector-buttons\").add(this.group);\n        var m = this.dropdown = w(\"select\", void 0, {\n          position: \"absolute\",\n          width: \"1px\",\n          height: \"1px\",\n          padding: 0,\n          border: 0,\n          top: \"-9999em\",\n          cursor: \"pointer\",\n          opacity: .0001\n        }, this.div);\n        p(m, \"touchstart\", function () {\n          m.style.fontSize = \"16px\";\n        });\n        [[t.isMS ? \"mouseover\" : \"mouseenter\"], [t.isMS ? \"mouseout\" : \"mouseleave\"], [\"change\", \"click\"]].forEach(function (c) {\n          var d = c[0],\n              e = c[1];\n          p(m, d, function () {\n            var c = b[a.currentButtonIndex()];\n            c && q(c.element, e || d);\n          });\n        });\n        this.zoomText = f.text(e.rangeSelectorZoom, 0, 15).add(this.buttonGroup);\n        this.chart.styledMode || (this.zoomText.css(c.labelStyle), g[\"stroke-width\"] = I(g[\"stroke-width\"], 0));\n        w(\"option\", {\n          textContent: this.zoomText.textStr,\n          disabled: !0\n        }, void 0, m);\n        this.buttonOptions.forEach(function (c, d) {\n          w(\"option\", {\n            textContent: c.title || c.text\n          }, void 0, m);\n          b[d] = f.button(c.text, 0, 0, function (b) {\n            var e = c.events && c.events.click,\n                l;\n            e && (l = e.call(c, b));\n            !1 !== l && a.clickButton(d);\n            a.isActive = !0;\n          }, g, h && h.hover, h && h.select, h && h.disabled).attr({\n            \"text-align\": \"center\",\n            width: k\n          }).add(a.buttonGroup);\n          c.title && b[d].attr(\"title\", c.title);\n        });\n      };\n\n      m.prototype.alignElements = function () {\n        var a = this,\n            b = this.buttonGroup,\n            c = this.buttons,\n            d = this.chart,\n            e = this.group,\n            f = this.inputGroup,\n            g = this.options,\n            h = this.zoomText,\n            k = d.options,\n            m = k.exporting && !1 !== k.exporting.enabled && k.navigation && k.navigation.buttonOptions;\n        k = g.buttonPosition;\n\n        var n = g.inputPosition,\n            q = g.verticalAlign,\n            p = function (b, c) {\n          return m && a.titleCollision(d) && \"top\" === q && \"right\" === c.align && c.y - b.getBBox().height - 12 < (m.y || 0) + (m.height || 0) + d.spacing[0] ? -40 : 0;\n        },\n            t = d.plotLeft;\n\n        if (e && k && n) {\n          var r = k.x - d.spacing[3];\n\n          if (b) {\n            this.positionButtons();\n\n            if (!this.initialButtonGroupWidth) {\n              var u = 0;\n              h && (u += h.getBBox().width + 5);\n              c.forEach(function (a, b) {\n                u += a.width;\n                b !== c.length - 1 && (u += g.buttonSpacing);\n              });\n              this.initialButtonGroupWidth = u;\n            }\n\n            t -= d.spacing[3];\n            this.updateButtonStates();\n            h = p(b, k);\n            this.alignButtonGroup(h);\n            e.placed = b.placed = d.hasLoaded;\n          }\n\n          b = 0;\n          f && (b = p(f, n), \"left\" === n.align ? r = t : \"right\" === n.align && (r = -Math.max(d.axisOffset[1], -b)), f.align({\n            y: n.y,\n            width: f.getBBox().width,\n            align: n.align,\n            x: n.x + r - 2\n          }, !0, d.spacingBox), f.placed = d.hasLoaded);\n          this.handleCollision(b);\n          e.align({\n            verticalAlign: q\n          }, !0, d.spacingBox);\n          f = e.alignAttr.translateY;\n          b = e.getBBox().height + 20;\n          p = 0;\n          \"bottom\" === q && (p = (p = d.legend && d.legend.options) && \"bottom\" === p.verticalAlign && p.enabled && !p.floating ? d.legend.legendHeight + I(p.margin, 10) : 0, b = b + p - 20, p = f - b - (g.floating ? 0 : g.y) - (d.titleOffset ? d.titleOffset[2] : 0) - 10);\n          if (\"top\" === q) g.floating && (p = 0), d.titleOffset && d.titleOffset[0] && (p = d.titleOffset[0]), p += d.margin[0] - d.spacing[0] || 0;else if (\"middle\" === q) if (n.y === k.y) p = f;else if (n.y || k.y) p = 0 > n.y || 0 > k.y ? p - Math.min(n.y, k.y) : f - b;\n          e.translate(g.x, g.y + Math.floor(p));\n          k = this.minInput;\n          n = this.maxInput;\n          f = this.dropdown;\n          g.inputEnabled && k && n && (k.style.marginTop = e.translateY + \"px\", n.style.marginTop = e.translateY + \"px\");\n          f && (f.style.marginTop = e.translateY + \"px\");\n        }\n      };\n\n      m.prototype.alignButtonGroup = function (a, b) {\n        var c = this.chart,\n            d = this.buttonGroup,\n            e = this.options.buttonPosition,\n            f = c.plotLeft - c.spacing[3],\n            g = e.x - c.spacing[3];\n        \"right\" === e.align ? g += a - f : \"center\" === e.align && (g -= f / 2);\n        d && d.align({\n          y: e.y,\n          width: I(b, this.initialButtonGroupWidth),\n          align: e.align,\n          x: g\n        }, !0, c.spacingBox);\n      };\n\n      m.prototype.positionButtons = function () {\n        var a = this.buttons,\n            b = this.chart,\n            c = this.options,\n            d = this.zoomText,\n            e = b.hasLoaded ? \"animate\" : \"attr\",\n            f = c.buttonPosition,\n            g = b.plotLeft,\n            h = g;\n        d && \"hidden\" !== d.visibility && (d[e]({\n          x: I(g + f.x, g)\n        }), h += f.x + d.getBBox().width + 5);\n        this.buttonOptions.forEach(function (b, d) {\n          if (\"hidden\" !== a[d].visibility) a[d][e]({\n            x: h\n          }), h += a[d].width + c.buttonSpacing;else a[d][e]({\n            x: g\n          });\n        });\n      };\n\n      m.prototype.handleCollision = function (a) {\n        var b = this,\n            c = this.chart,\n            d = this.buttonGroup,\n            e = this.inputGroup,\n            f = this.options,\n            g = f.buttonPosition,\n            h = f.dropdown,\n            k = f.inputPosition;\n\n        f = function () {\n          var a = 0;\n          b.buttons.forEach(function (b) {\n            b = b.getBBox();\n            b.width > a && (a = b.width);\n          });\n          return a;\n        };\n\n        var m = function (b) {\n          if (e && d) {\n            var c = e.alignAttr.translateX + e.alignOptions.x - a + e.getBBox().x + 2,\n                l = e.alignOptions.width,\n                f = d.alignAttr.translateX + d.getBBox().x;\n            return f + b > c && c + l > f && g.y < k.y + e.getBBox().height;\n          }\n\n          return !1;\n        },\n            n = function () {\n          e && d && e.attr({\n            translateX: e.alignAttr.translateX + (c.axisOffset[1] >= -a ? 0 : -a),\n            translateY: e.alignAttr.translateY + d.getBBox().height + 10\n          });\n        };\n\n        if (d) {\n          if (\"always\" === h) {\n            this.collapseButtons(a);\n            m(f()) && n();\n            return;\n          }\n\n          \"never\" === h && this.expandButtons();\n        }\n\n        e && d ? k.align === g.align || m(this.initialButtonGroupWidth + 20) ? \"responsive\" === h ? (this.collapseButtons(a), m(f()) && n()) : n() : \"responsive\" === h && this.expandButtons() : d && \"responsive\" === h && (this.initialButtonGroupWidth > c.plotWidth ? this.collapseButtons(a) : this.expandButtons());\n      };\n\n      m.prototype.collapseButtons = function (a) {\n        var b,\n            c = this.buttons,\n            d = this.buttonOptions,\n            e = this.dropdown,\n            f = this.options,\n            g = this.zoomText,\n            h = function (a) {\n          return {\n            text: a ? a + \" \\u25be\" : \"\\u25be\",\n            width: \"auto\",\n            paddingLeft: 8,\n            paddingRight: 8\n          };\n        };\n\n        g && g.hide();\n        var k = !1;\n        d.forEach(function (a, b) {\n          b = c[b];\n          2 !== b.state ? b.hide() : (b.show(), b.attr(h(a.text)), k = !0);\n        });\n        k || (e && (e.selectedIndex = 0), c[0].show(), c[0].attr(h(null === (b = this.zoomText) || void 0 === b ? void 0 : b.textStr)));\n        b = f.buttonPosition.align;\n        this.positionButtons();\n        \"right\" !== b && \"center\" !== b || this.alignButtonGroup(a, c[this.currentButtonIndex()].getBBox().width);\n        this.showDropdown();\n      };\n\n      m.prototype.expandButtons = function () {\n        var a = this.buttons,\n            b = this.buttonOptions,\n            c = this.options,\n            d = this.zoomText;\n        this.hideDropdown();\n        d && d.show();\n        b.forEach(function (b, d) {\n          d = a[d];\n          d.show();\n          d.attr({\n            text: b.text,\n            width: c.buttonTheme.width || 28,\n            paddingLeft: \"unset\",\n            paddingRight: \"unset\"\n          });\n          2 > d.state && d.setState(0);\n        });\n        this.positionButtons();\n      };\n\n      m.prototype.currentButtonIndex = function () {\n        var a = this.dropdown;\n        return a && 0 < a.selectedIndex ? a.selectedIndex - 1 : 0;\n      };\n\n      m.prototype.showDropdown = function () {\n        var a = this.buttonGroup,\n            b = this.buttons,\n            d = this.chart,\n            c = this.dropdown;\n\n        if (a && c) {\n          var e = a.translateX;\n          a = a.translateY;\n          b = b[this.currentButtonIndex()].getBBox();\n          k(c, {\n            left: d.plotLeft + e + \"px\",\n            top: a + .5 + \"px\",\n            width: b.width + \"px\",\n            height: b.height + \"px\"\n          });\n          this.hasVisibleDropdown = !0;\n        }\n      };\n\n      m.prototype.hideDropdown = function () {\n        var a = this.dropdown;\n        a && (k(a, {\n          top: \"-9999em\",\n          width: \"1px\",\n          height: \"1px\"\n        }), this.hasVisibleDropdown = !1);\n      };\n\n      m.prototype.getHeight = function () {\n        var a = this.options,\n            b = this.group,\n            d = a.y,\n            c = a.buttonPosition.y,\n            e = a.inputPosition.y;\n        if (a.height) return a.height;\n        this.alignElements();\n        a = b ? b.getBBox(!0).height + 13 + d : 0;\n        b = Math.min(e, c);\n        if (0 > e && 0 > c || 0 < e && 0 < c) a += Math.abs(b);\n        return a;\n      };\n\n      m.prototype.titleCollision = function (a) {\n        return !(a.options.title.text || a.options.subtitle.text);\n      };\n\n      m.prototype.update = function (a) {\n        var b = this.chart;\n        d(!0, b.options.rangeSelector, a);\n        this.destroy();\n        this.init(b);\n        this.render();\n      };\n\n      m.prototype.destroy = function () {\n        var a = this,\n            c = a.minInput,\n            d = a.maxInput;\n        a.eventsToUnbind && (a.eventsToUnbind.forEach(function (a) {\n          return a();\n        }), a.eventsToUnbind = void 0);\n        v(a.buttons);\n        c && (c.onfocus = c.onblur = c.onchange = null);\n        d && (d.onfocus = d.onblur = d.onchange = null);\n        b(a, function (b, c) {\n          b && \"chart\" !== c && (b instanceof h ? b.destroy() : b instanceof window.HTMLElement && e(b));\n          b !== m.prototype[c] && (a[c] = null);\n        }, this);\n      };\n\n      return m;\n    }();\n\n    H.prototype.defaultButtons = [{\n      type: \"month\",\n      count: 1,\n      text: \"1m\",\n      title: \"View 1 month\"\n    }, {\n      type: \"month\",\n      count: 3,\n      text: \"3m\",\n      title: \"View 3 months\"\n    }, {\n      type: \"month\",\n      count: 6,\n      text: \"6m\",\n      title: \"View 6 months\"\n    }, {\n      type: \"ytd\",\n      text: \"YTD\",\n      title: \"View year to date\"\n    }, {\n      type: \"year\",\n      count: 1,\n      text: \"1y\",\n      title: \"View 1 year\"\n    }, {\n      type: \"all\",\n      text: \"All\",\n      title: \"View all\"\n    }];\n    H.prototype.inputTypeFormats = {\n      \"datetime-local\": \"%Y-%m-%dT%H:%M:%S\",\n      date: \"%Y-%m-%d\",\n      time: \"%H:%M:%S\"\n    };\n\n    a.prototype.minFromRange = function () {\n      var a = this.range,\n          b = a.type,\n          d = this.max,\n          e = this.chart.time,\n          f = function (a, d) {\n        var c = \"year\" === b ? \"FullYear\" : \"Month\",\n            l = new e.Date(a),\n            f = e.get(c, l);\n        e.set(c, l, f + d);\n        f === e.get(c, l) && e.set(\"Date\", l, 0);\n        return l.getTime() - a;\n      };\n\n      if (c(a)) {\n        var g = d - a;\n        var h = a;\n      } else g = d + f(d, -a.count), this.chart && (this.chart.fixedRange = d - g);\n\n      var k = I(this.dataMin, Number.MIN_VALUE);\n      c(g) || (g = k);\n      g <= k && (g = k, \"undefined\" === typeof h && (h = f(g, a.count)), this.newMax = Math.min(g + h, this.dataMax));\n      c(d) || (g = void 0);\n      return g;\n    };\n\n    if (!t.RangeSelector) {\n      var C = [],\n          M = function (a) {\n        function b() {\n          l && (e = a.xAxis[0].getExtremes(), f = a.legend, h = null === l || void 0 === l ? void 0 : l.options.verticalAlign, c(e.min) && l.render(e.min, e.max), f.display && \"top\" === h && h === f.options.verticalAlign && (g = d(a.spacingBox), g.y = \"vertical\" === f.options.layout ? a.plotTop : g.y + l.getHeight(), f.group.placed = !1, f.align(g)));\n        }\n\n        var e,\n            l = a.rangeSelector,\n            f,\n            g,\n            h;\n        l && (m(C, function (b) {\n          return b[0] === a;\n        }) || C.push([a, [p(a.xAxis[0], \"afterSetExtremes\", function (a) {\n          l && l.render(a.min, a.max);\n        }), p(a, \"redraw\", b)]]), b());\n      };\n\n      p(u, \"afterGetContainer\", function () {\n        var a;\n        if (null === (a = this.options.rangeSelector) || void 0 === a ? 0 : a.enabled) this.rangeSelector = new H(this);\n      });\n      p(u, \"beforeRender\", function () {\n        var a = this.axes,\n            b = this.rangeSelector;\n        b && (c(b.deferredYTDClick) && (b.clickButton(b.deferredYTDClick), delete b.deferredYTDClick), a.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        }), this.getAxisMargins(), b.render(), a = b.options.verticalAlign, b.options.floating || (\"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0)));\n      });\n      p(u, \"update\", function (a) {\n        var b = a.options.rangeSelector;\n        a = this.rangeSelector;\n        var c = this.extraBottomMargin,\n            d = this.extraTopMargin;\n        b && b.enabled && !f(a) && this.options.rangeSelector && (this.options.rangeSelector.enabled = !0, this.rangeSelector = a = new H(this));\n        this.extraTopMargin = this.extraBottomMargin = !1;\n        a && (M(this), b = b && b.verticalAlign || a.options && a.options.verticalAlign, a.options.floating || (\"bottom\" === b ? this.extraBottomMargin = !0 : \"middle\" !== b && (this.extraTopMargin = !0)), this.extraBottomMargin !== c || this.extraTopMargin !== d) && (this.isDirtyBox = !0);\n      });\n      p(u, \"render\", function () {\n        var a = this.rangeSelector;\n        a && !a.options.floating && (a.render(), a = a.options.verticalAlign, \"bottom\" === a ? this.extraBottomMargin = !0 : \"middle\" !== a && (this.extraTopMargin = !0));\n      });\n      p(u, \"getMargins\", function () {\n        var a = this.rangeSelector;\n        a && (a = a.getHeight(), this.extraTopMargin && (this.plotTop += a), this.extraBottomMargin && (this.marginBottom += a));\n      });\n      u.prototype.callbacks.push(M);\n      p(u, \"destroy\", function () {\n        for (var a = 0; a < C.length; a++) {\n          var b = C[a];\n\n          if (b[0] === this) {\n            b[1].forEach(function (a) {\n              return a();\n            });\n            C.splice(a, 1);\n            break;\n          }\n        }\n      });\n      t.RangeSelector = H;\n    }\n\n    return t.RangeSelector;\n  });\n  F(a, \"Core/Axis/NavigatorAxis.js\", [a[\"Core/Globals.js\"], a[\"Core/Utilities.js\"]], function (a, u) {\n    var t = a.isTouchDevice,\n        r = u.addEvent,\n        n = u.correctFloat,\n        h = u.defined,\n        A = u.isNumber,\n        B = u.pick,\n        D = function () {\n      function a(a) {\n        this.axis = a;\n      }\n\n      a.prototype.destroy = function () {\n        this.axis = void 0;\n      };\n\n      a.prototype.toFixedRange = function (a, k, f, p) {\n        var e = this.axis,\n            g = e.chart;\n        g = g && g.fixedRange;\n        var m = (e.pointRange || 0) / 2;\n        a = B(f, e.translate(a, !0, !e.horiz));\n        k = B(p, e.translate(k, !0, !e.horiz));\n        e = g && (k - a) / g;\n        h(f) || (a = n(a + m));\n        h(p) || (k = n(k - m));\n        .7 < e && 1.3 > e && (p ? a = k - g : k = a + g);\n        A(a) && A(k) || (a = k = void 0);\n        return {\n          min: a,\n          max: k\n        };\n      };\n\n      return a;\n    }();\n\n    return function () {\n      function a() {}\n\n      a.compose = function (a) {\n        a.keepProps.push(\"navigatorAxis\");\n        r(a, \"init\", function () {\n          this.navigatorAxis || (this.navigatorAxis = new D(this));\n        });\n        r(a, \"zoom\", function (a) {\n          var f = this.chart.options,\n              k = f.navigator,\n              e = this.navigatorAxis,\n              g = f.chart.pinchType,\n              m = f.rangeSelector;\n          f = f.chart.zoomType;\n          this.isXAxis && (k && k.enabled || m && m.enabled) && (\"y\" === f ? a.zoomed = !1 : (!t && \"xy\" === f || t && \"xy\" === g) && this.options.range && (k = e.previousZoom, h(a.newMin) ? e.previousZoom = [this.min, this.max] : k && (a.newMin = k[0], a.newMax = k[1], e.previousZoom = void 0)));\n          \"undefined\" !== typeof a.zoomed && a.preventDefault();\n        });\n      };\n\n      a.AdditionsClass = D;\n      return a;\n    }();\n  });\n  F(a, \"Core/Navigator.js\", [a[\"Core/Axis/Axis.js\"], a[\"Core/Chart/Chart.js\"], a[\"Core/Color/Color.js\"], a[\"Core/Globals.js\"], a[\"Core/Axis/NavigatorAxis.js\"], a[\"Core/Options.js\"], a[\"Core/Color/Palette.js\"], a[\"Core/Scrollbar.js\"], a[\"Core/Series/Series.js\"], a[\"Core/Series/SeriesRegistry.js\"], a[\"Core/Utilities.js\"]], function (a, u, t, r, n, h, A, B, D, p, w) {\n    t = t.parse;\n\n    var k = r.hasTouch,\n        f = r.isTouchDevice,\n        v = h.defaultOptions,\n        e = w.addEvent,\n        g = w.clamp,\n        m = w.correctFloat,\n        q = w.defined,\n        c = w.destroyObjectProperties,\n        d = w.erase,\n        b = w.extend,\n        F = w.find,\n        I = w.isArray,\n        K = w.isNumber,\n        L = w.merge,\n        H = w.pick,\n        C = w.removeEvent,\n        M = w.splat,\n        E = function (a) {\n      for (var b = [], c = 1; c < arguments.length; c++) b[c - 1] = arguments[c];\n\n      b = [].filter.call(b, K);\n      if (b.length) return Math[a].apply(0, b);\n    };\n\n    h = \"undefined\" === typeof p.seriesTypes.areaspline ? \"line\" : \"areaspline\";\n    b(v, {\n      navigator: {\n        height: 40,\n        margin: 25,\n        maskInside: !0,\n        handles: {\n          width: 7,\n          height: 15,\n          symbols: [\"navigator-handle\", \"navigator-handle\"],\n          enabled: !0,\n          lineWidth: 1,\n          backgroundColor: A.neutralColor5,\n          borderColor: A.neutralColor40\n        },\n        maskFill: t(A.highlightColor60).setOpacity(.3).get(),\n        outlineColor: A.neutralColor20,\n        outlineWidth: 1,\n        series: {\n          type: h,\n          fillOpacity: .05,\n          lineWidth: 1,\n          compare: null,\n          dataGrouping: {\n            approximation: \"average\",\n            enabled: !0,\n            groupPixelWidth: 2,\n            smoothed: !0,\n            units: [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2, 3, 4]], [\"week\", [1, 2, 3]], [\"month\", [1, 3, 6]], [\"year\", null]]\n          },\n          dataLabels: {\n            enabled: !1,\n            zIndex: 2\n          },\n          id: \"highcharts-navigator-series\",\n          className: \"highcharts-navigator-series\",\n          lineColor: null,\n          marker: {\n            enabled: !1\n          },\n          threshold: null\n        },\n        xAxis: {\n          overscroll: 0,\n          className: \"highcharts-navigator-xaxis\",\n          tickLength: 0,\n          lineWidth: 0,\n          gridLineColor: A.neutralColor10,\n          gridLineWidth: 1,\n          tickPixelInterval: 200,\n          labels: {\n            align: \"left\",\n            style: {\n              color: A.neutralColor40\n            },\n            x: 3,\n            y: -4\n          },\n          crosshair: !1\n        },\n        yAxis: {\n          className: \"highcharts-navigator-yaxis\",\n          gridLineWidth: 0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: .1,\n          maxPadding: .1,\n          labels: {\n            enabled: !1\n          },\n          crosshair: !1,\n          title: {\n            text: null\n          },\n          tickLength: 0,\n          tickWidth: 0\n        }\n      }\n    });\n\n    r.Renderer.prototype.symbols[\"navigator-handle\"] = function (a, b, c, d, e) {\n      a = (e && e.width || 0) / 2;\n      b = Math.round(a / 3) + .5;\n      e = e && e.height || 0;\n      return [[\"M\", -a - 1, .5], [\"L\", a, .5], [\"L\", a, e + .5], [\"L\", -a - 1, e + .5], [\"L\", -a - 1, .5], [\"M\", -b, 4], [\"L\", -b, e - 3], [\"M\", b - 1, 4], [\"L\", b - 1, e - 3]];\n    };\n\n    var y = function () {\n      function h(a) {\n        this.zoomedMin = this.zoomedMax = this.yAxis = this.xAxis = this.top = this.size = this.shades = this.rendered = this.range = this.outlineHeight = this.outline = this.opposite = this.navigatorSize = this.navigatorSeries = this.navigatorOptions = this.navigatorGroup = this.navigatorEnabled = this.left = this.height = this.handles = this.chart = this.baseSeries = void 0;\n        this.init(a);\n      }\n\n      h.prototype.drawHandle = function (a, b, c, d) {\n        var e = this.navigatorOptions.handles.height;\n        this.handles[b][d](c ? {\n          translateX: Math.round(this.left + this.height / 2),\n          translateY: Math.round(this.top + parseInt(a, 10) + .5 - e)\n        } : {\n          translateX: Math.round(this.left + parseInt(a, 10)),\n          translateY: Math.round(this.top + this.height / 2 - e / 2 - 1)\n        });\n      };\n\n      h.prototype.drawOutline = function (a, b, c, d) {\n        var e = this.navigatorOptions.maskInside,\n            l = this.outline.strokeWidth(),\n            f = l / 2,\n            g = l % 2 / 2;\n        l = this.outlineHeight;\n        var h = this.scrollbarHeight || 0,\n            k = this.size,\n            m = this.left - h,\n            x = this.top;\n        c ? (m -= f, c = x + b + g, b = x + a + g, g = [[\"M\", m + l, x - h - g], [\"L\", m + l, c], [\"L\", m, c], [\"L\", m, b], [\"L\", m + l, b], [\"L\", m + l, x + k + h]], e && g.push([\"M\", m + l, c - f], [\"L\", m + l, b + f])) : (a += m + h - g, b += m + h - g, x += f, g = [[\"M\", m, x], [\"L\", a, x], [\"L\", a, x + l], [\"L\", b, x + l], [\"L\", b, x], [\"L\", m + k + 2 * h, x]], e && g.push([\"M\", a - f, x], [\"L\", b + f, x]));\n        this.outline[d]({\n          d: g\n        });\n      };\n\n      h.prototype.drawMasks = function (a, b, c, d) {\n        var e = this.left,\n            l = this.top,\n            f = this.height;\n\n        if (c) {\n          var g = [e, e, e];\n          var h = [l, l + a, l + b];\n          var k = [f, f, f];\n          var m = [a, b - a, this.size - b];\n        } else g = [e, e + a, e + b], h = [l, l, l], k = [a, b - a, this.size - b], m = [f, f, f];\n\n        this.shades.forEach(function (a, b) {\n          a[d]({\n            x: g[b],\n            y: h[b],\n            width: k[b],\n            height: m[b]\n          });\n        });\n      };\n\n      h.prototype.renderElements = function () {\n        var a = this,\n            b = a.navigatorOptions,\n            c = b.maskInside,\n            d = a.chart,\n            e = d.renderer,\n            f,\n            g = {\n          cursor: d.inverted ? \"ns-resize\" : \"ew-resize\"\n        };\n        a.navigatorGroup = f = e.g(\"navigator\").attr({\n          zIndex: 8,\n          visibility: \"hidden\"\n        }).add();\n        [!c, c, !c].forEach(function (c, l) {\n          a.shades[l] = e.rect().addClass(\"highcharts-navigator-mask\" + (1 === l ? \"-inside\" : \"-outside\")).add(f);\n          d.styledMode || a.shades[l].attr({\n            fill: c ? b.maskFill : \"rgba(0,0,0,0)\"\n          }).css(1 === l && g);\n        });\n        a.outline = e.path().addClass(\"highcharts-navigator-outline\").add(f);\n        d.styledMode || a.outline.attr({\n          \"stroke-width\": b.outlineWidth,\n          stroke: b.outlineColor\n        });\n        b.handles.enabled && [0, 1].forEach(function (c) {\n          b.handles.inverted = d.inverted;\n          a.handles[c] = e.symbol(b.handles.symbols[c], -b.handles.width / 2 - 1, 0, b.handles.width, b.handles.height, b.handles);\n          a.handles[c].attr({\n            zIndex: 7 - c\n          }).addClass(\"highcharts-navigator-handle highcharts-navigator-handle-\" + [\"left\", \"right\"][c]).add(f);\n\n          if (!d.styledMode) {\n            var l = b.handles;\n            a.handles[c].attr({\n              fill: l.backgroundColor,\n              stroke: l.borderColor,\n              \"stroke-width\": l.lineWidth\n            }).css(g);\n          }\n        });\n      };\n\n      h.prototype.update = function (a) {\n        (this.series || []).forEach(function (a) {\n          a.baseSeries && delete a.baseSeries.navigatorSeries;\n        });\n        this.destroy();\n        L(!0, this.chart.options.navigator, this.options, a);\n        this.init(this.chart);\n      };\n\n      h.prototype.render = function (a, b, c, d) {\n        var e = this.chart,\n            l = this.scrollbarHeight,\n            f,\n            h = this.xAxis,\n            k = h.pointRange || 0;\n        var x = h.navigatorAxis.fake ? e.xAxis[0] : h;\n        var n = this.navigatorEnabled,\n            p,\n            t = this.rendered;\n        var r = e.inverted;\n        var u = e.xAxis[0].minRange,\n            v = e.xAxis[0].options.maxRange;\n\n        if (!this.hasDragged || q(c)) {\n          a = m(a - k / 2);\n          b = m(b + k / 2);\n          if (!K(a) || !K(b)) if (t) c = 0, d = H(h.width, x.width);else return;\n          this.left = H(h.left, e.plotLeft + l + (r ? e.plotWidth : 0));\n          this.size = p = f = H(h.len, (r ? e.plotHeight : e.plotWidth) - 2 * l);\n          e = r ? l : f + 2 * l;\n          c = H(c, h.toPixels(a, !0));\n          d = H(d, h.toPixels(b, !0));\n          K(c) && Infinity !== Math.abs(c) || (c = 0, d = e);\n          a = h.toValue(c, !0);\n          b = h.toValue(d, !0);\n          var G = Math.abs(m(b - a));\n          G < u ? this.grabbedLeft ? c = h.toPixels(b - u - k, !0) : this.grabbedRight && (d = h.toPixels(a + u + k, !0)) : q(v) && m(G - k) > v && (this.grabbedLeft ? c = h.toPixels(b - v - k, !0) : this.grabbedRight && (d = h.toPixels(a + v + k, !0)));\n          this.zoomedMax = g(Math.max(c, d), 0, p);\n          this.zoomedMin = g(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Math.min(c, d), 0, p);\n          this.range = this.zoomedMax - this.zoomedMin;\n          p = Math.round(this.zoomedMax);\n          c = Math.round(this.zoomedMin);\n          n && (this.navigatorGroup.attr({\n            visibility: \"visible\"\n          }), t = t && !this.hasDragged ? \"animate\" : \"attr\", this.drawMasks(c, p, r, t), this.drawOutline(c, p, r, t), this.navigatorOptions.handles.enabled && (this.drawHandle(c, 0, r, t), this.drawHandle(p, 1, r, t)));\n          this.scrollbar && (r ? (r = this.top - l, x = this.left - l + (n || !x.opposite ? 0 : (x.titleOffset || 0) + x.axisTitleMargin), l = f + 2 * l) : (r = this.top + (n ? this.height : -l), x = this.left - l), this.scrollbar.position(x, r, e, l), this.scrollbar.setRange(this.zoomedMin / (f || 1), this.zoomedMax / (f || 1)));\n          this.rendered = !0;\n        }\n      };\n\n      h.prototype.addMouseEvents = function () {\n        var a = this,\n            b = a.chart,\n            c = b.container,\n            d = [],\n            f,\n            g;\n\n        a.mouseMoveHandler = f = function (b) {\n          a.onMouseMove(b);\n        };\n\n        a.mouseUpHandler = g = function (b) {\n          a.onMouseUp(b);\n        };\n\n        d = a.getPartsEvents(\"mousedown\");\n        d.push(e(b.renderTo, \"mousemove\", f), e(c.ownerDocument, \"mouseup\", g));\n        k && (d.push(e(b.renderTo, \"touchmove\", f), e(c.ownerDocument, \"touchend\", g)), d.concat(a.getPartsEvents(\"touchstart\")));\n        a.eventsToUnbind = d;\n        a.series && a.series[0] && d.push(e(a.series[0].xAxis, \"foundExtremes\", function () {\n          b.navigator.modifyNavigatorAxisExtremes();\n        }));\n      };\n\n      h.prototype.getPartsEvents = function (a) {\n        var b = this,\n            c = [];\n        [\"shades\", \"handles\"].forEach(function (d) {\n          b[d].forEach(function (l, f) {\n            c.push(e(l.element, a, function (a) {\n              b[d + \"Mousedown\"](a, f);\n            }));\n          });\n        });\n        return c;\n      };\n\n      h.prototype.shadesMousedown = function (a, b) {\n        a = this.chart.pointer.normalize(a);\n        var c = this.chart,\n            d = this.xAxis,\n            e = this.zoomedMin,\n            l = this.left,\n            f = this.size,\n            g = this.range,\n            h = a.chartX;\n        c.inverted && (h = a.chartY, l = this.top);\n        if (1 === b) this.grabbedCenter = h, this.fixedWidth = g, this.dragOffset = h - e;else {\n          a = h - l - g / 2;\n          if (0 === b) a = Math.max(0, a);else if (2 === b && a + g >= f) if (a = f - g, this.reversedExtremes) {\n            a -= g;\n            var k = this.getUnionExtremes().dataMin;\n          } else var m = this.getUnionExtremes().dataMax;\n          a !== e && (this.fixedWidth = g, b = d.navigatorAxis.toFixedRange(a, a + g, k, m), q(b.min) && c.xAxis[0].setExtremes(Math.min(b.min, b.max), Math.max(b.min, b.max), !0, null, {\n            trigger: \"navigator\"\n          }));\n        }\n      };\n\n      h.prototype.handlesMousedown = function (a, b) {\n        this.chart.pointer.normalize(a);\n        a = this.chart;\n        var c = a.xAxis[0],\n            d = this.reversedExtremes;\n        0 === b ? (this.grabbedLeft = !0, this.otherHandlePos = this.zoomedMax, this.fixedExtreme = d ? c.min : c.max) : (this.grabbedRight = !0, this.otherHandlePos = this.zoomedMin, this.fixedExtreme = d ? c.max : c.min);\n        a.fixedRange = null;\n      };\n\n      h.prototype.onMouseMove = function (a) {\n        var b = this,\n            c = b.chart,\n            d = b.left,\n            e = b.navigatorSize,\n            l = b.range,\n            g = b.dragOffset,\n            h = c.inverted;\n        a.touches && 0 === a.touches[0].pageX || (a = c.pointer.normalize(a), c = a.chartX, h && (d = b.top, c = a.chartY), b.grabbedLeft ? (b.hasDragged = !0, b.render(0, 0, c - d, b.otherHandlePos)) : b.grabbedRight ? (b.hasDragged = !0, b.render(0, 0, b.otherHandlePos, c - d)) : b.grabbedCenter && (b.hasDragged = !0, c < g ? c = g : c > e + g - l && (c = e + g - l), b.render(0, 0, c - g, c - g + l)), b.hasDragged && b.scrollbar && H(b.scrollbar.options.liveRedraw, r.svg && !f && !this.chart.isBoosting) && (a.DOMType = a.type, setTimeout(function () {\n          b.onMouseUp(a);\n        }, 0)));\n      };\n\n      h.prototype.onMouseUp = function (a) {\n        var b = this.chart,\n            c = this.xAxis,\n            d = this.scrollbar,\n            e = a.DOMEvent || a,\n            f = b.inverted,\n            g = this.rendered && !this.hasDragged ? \"animate\" : \"attr\";\n\n        if (this.hasDragged && (!d || !d.hasDragged) || \"scrollbar\" === a.trigger) {\n          d = this.getUnionExtremes();\n          if (this.zoomedMin === this.otherHandlePos) var l = this.fixedExtreme;else if (this.zoomedMax === this.otherHandlePos) var h = this.fixedExtreme;\n          this.zoomedMax === this.size && (h = this.reversedExtremes ? d.dataMin : d.dataMax);\n          0 === this.zoomedMin && (l = this.reversedExtremes ? d.dataMax : d.dataMin);\n          c = c.navigatorAxis.toFixedRange(this.zoomedMin, this.zoomedMax, l, h);\n          q(c.min) && b.xAxis[0].setExtremes(Math.min(c.min, c.max), Math.max(c.min, c.max), !0, this.hasDragged ? !1 : null, {\n            trigger: \"navigator\",\n            triggerOp: \"navigator-drag\",\n            DOMEvent: e\n          });\n        }\n\n        \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType && (this.grabbedLeft = this.grabbedRight = this.grabbedCenter = this.fixedWidth = this.fixedExtreme = this.otherHandlePos = this.hasDragged = this.dragOffset = null);\n        this.navigatorEnabled && K(this.zoomedMin) && K(this.zoomedMax) && (b = Math.round(this.zoomedMin), a = Math.round(this.zoomedMax), this.shades && this.drawMasks(b, a, f, g), this.outline && this.drawOutline(b, a, f, g), this.navigatorOptions.handles.enabled && Object.keys(this.handles).length === this.handles.length && (this.drawHandle(b, 0, f, g), this.drawHandle(a, 1, f, g)));\n      };\n\n      h.prototype.removeEvents = function () {\n        this.eventsToUnbind && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind = void 0);\n        this.removeBaseSeriesEvents();\n      };\n\n      h.prototype.removeBaseSeriesEvents = function () {\n        var a = this.baseSeries || [];\n        this.navigatorEnabled && a[0] && (!1 !== this.navigatorOptions.adaptToUpdatedData && a.forEach(function (a) {\n          C(a, \"updatedData\", this.updatedDataHandler);\n        }, this), a[0].xAxis && C(a[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes));\n      };\n\n      h.prototype.init = function (b) {\n        var c = b.options,\n            d = c.navigator,\n            f = d.enabled,\n            g = c.scrollbar,\n            h = g.enabled;\n        c = f ? d.height : 0;\n        var l = h ? g.height : 0;\n        this.handles = [];\n        this.shades = [];\n        this.chart = b;\n        this.setBaseSeries();\n        this.height = c;\n        this.scrollbarHeight = l;\n        this.scrollbarEnabled = h;\n        this.navigatorEnabled = f;\n        this.navigatorOptions = d;\n        this.scrollbarOptions = g;\n        this.outlineHeight = c + l;\n        this.opposite = H(d.opposite, !(f || !b.inverted));\n        var k = this;\n        f = k.baseSeries;\n        g = b.xAxis.length;\n        h = b.yAxis.length;\n        var m = f && f[0] && f[0].xAxis || b.xAxis[0] || {\n          options: {}\n        };\n        b.isDirtyBox = !0;\n        k.navigatorEnabled ? (k.xAxis = new a(b, L({\n          breaks: m.options.breaks,\n          ordinal: m.options.ordinal\n        }, d.xAxis, {\n          id: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          isX: !0,\n          type: \"datetime\",\n          index: g,\n          isInternal: !0,\n          offset: 0,\n          keepOrdinalPadding: !0,\n          startOnTick: !1,\n          endOnTick: !1,\n          minPadding: 0,\n          maxPadding: 0,\n          zoomEnabled: !1\n        }, b.inverted ? {\n          offsets: [l, 0, -l, 0],\n          width: c\n        } : {\n          offsets: [0, -l, 0, l],\n          height: c\n        })), k.yAxis = new a(b, L(d.yAxis, {\n          id: \"navigator-y-axis\",\n          alignTicks: !1,\n          offset: 0,\n          index: h,\n          isInternal: !0,\n          reversed: H(d.yAxis && d.yAxis.reversed, b.yAxis[0] && b.yAxis[0].reversed, !1),\n          zoomEnabled: !1\n        }, b.inverted ? {\n          width: c\n        } : {\n          height: c\n        })), f || d.series.data ? k.updateNavigatorSeries(!1) : 0 === b.series.length && (k.unbindRedraw = e(b, \"beforeRedraw\", function () {\n          0 < b.series.length && !k.series && (k.setBaseSeries(), k.unbindRedraw());\n        })), k.reversedExtremes = b.inverted && !k.xAxis.reversed || !b.inverted && k.xAxis.reversed, k.renderElements(), k.addMouseEvents()) : (k.xAxis = {\n          chart: b,\n          navigatorAxis: {\n            fake: !0\n          },\n          translate: function (a, c) {\n            var d = b.xAxis[0],\n                e = d.getExtremes(),\n                f = d.len - 2 * l,\n                g = E(\"min\", d.options.min, e.dataMin);\n            d = E(\"max\", d.options.max, e.dataMax) - g;\n            return c ? a * d / f + g : f * (a - g) / d;\n          },\n          toPixels: function (a) {\n            return this.translate(a);\n          },\n          toValue: function (a) {\n            return this.translate(a, !0);\n          }\n        }, k.xAxis.navigatorAxis.axis = k.xAxis, k.xAxis.navigatorAxis.toFixedRange = n.AdditionsClass.prototype.toFixedRange.bind(k.xAxis.navigatorAxis));\n        b.options.scrollbar.enabled && (b.scrollbar = k.scrollbar = new B(b.renderer, L(b.options.scrollbar, {\n          margin: k.navigatorEnabled ? 0 : 10,\n          vertical: b.inverted\n        }), b), e(k.scrollbar, \"changed\", function (a) {\n          var c = k.size,\n              d = c * this.to;\n          c *= this.from;\n          k.hasDragged = k.scrollbar.hasDragged;\n          k.render(0, 0, c, d);\n          (b.options.scrollbar.liveRedraw || \"mousemove\" !== a.DOMType && \"touchmove\" !== a.DOMType) && setTimeout(function () {\n            k.onMouseUp(a);\n          });\n        }));\n        k.addBaseSeriesEvents();\n        k.addChartEvents();\n      };\n\n      h.prototype.getUnionExtremes = function (a) {\n        var b = this.chart.xAxis[0],\n            c = this.xAxis,\n            d = c.options,\n            e = b.options,\n            f;\n        a && null === b.dataMin || (f = {\n          dataMin: H(d && d.min, E(\"min\", e.min, b.dataMin, c.dataMin, c.min)),\n          dataMax: H(d && d.max, E(\"max\", e.max, b.dataMax, c.dataMax, c.max))\n        });\n        return f;\n      };\n\n      h.prototype.setBaseSeries = function (a, b) {\n        var c = this.chart,\n            d = this.baseSeries = [];\n        a = a || c.options && c.options.navigator.baseSeries || (c.series.length ? F(c.series, function (a) {\n          return !a.options.isInternal;\n        }).index : 0);\n        (c.series || []).forEach(function (b, c) {\n          b.options.isInternal || !b.options.showInNavigator && (c !== a && b.options.id !== a || !1 === b.options.showInNavigator) || d.push(b);\n        });\n        this.xAxis && !this.xAxis.navigatorAxis.fake && this.updateNavigatorSeries(!0, b);\n      };\n\n      h.prototype.updateNavigatorSeries = function (a, c) {\n        var d = this,\n            e = d.chart,\n            f = d.baseSeries,\n            g,\n            h,\n            l = d.navigatorOptions.series,\n            k,\n            m = {\n          enableMouseTracking: !1,\n          index: null,\n          linkedTo: null,\n          group: \"nav\",\n          padXAxis: !1,\n          xAxis: \"navigator-x-axis\",\n          yAxis: \"navigator-y-axis\",\n          showInLegend: !1,\n          stacking: void 0,\n          isInternal: !0,\n          states: {\n            inactive: {\n              opacity: 1\n            }\n          }\n        },\n            n = d.series = (d.series || []).filter(function (a) {\n          var b = a.baseSeries;\n          return 0 > f.indexOf(b) ? (b && (C(b, \"updatedData\", d.updatedDataHandler), delete b.navigatorSeries), a.chart && a.destroy(), !1) : !0;\n        });\n        f && f.length && f.forEach(function (a) {\n          var p = a.navigatorSeries,\n              q = b({\n            color: a.color,\n            visible: a.visible\n          }, I(l) ? v.navigator.series : l);\n          p && !1 === d.navigatorOptions.adaptToUpdatedData || (m.name = \"Navigator \" + f.length, g = a.options || {}, k = g.navigatorOptions || {}, h = L(g, m, q, k), h.pointRange = H(q.pointRange, k.pointRange, v.plotOptions[h.type || \"line\"].pointRange), q = k.data || q.data, d.hasNavigatorData = d.hasNavigatorData || !!q, h.data = q || g.data && g.data.slice(0), p && p.options ? p.update(h, c) : (a.navigatorSeries = e.initSeries(h), a.navigatorSeries.baseSeries = a, n.push(a.navigatorSeries)));\n        });\n        if (l.data && (!f || !f.length) || I(l)) d.hasNavigatorData = !1, l = M(l), l.forEach(function (a, b) {\n          m.name = \"Navigator \" + (n.length + 1);\n          h = L(v.navigator.series, {\n            color: e.series[b] && !e.series[b].options.isInternal && e.series[b].color || e.options.colors[b] || e.options.colors[0]\n          }, m, a);\n          h.data = a.data;\n          h.data && (d.hasNavigatorData = !0, n.push(e.initSeries(h)));\n        });\n        a && this.addBaseSeriesEvents();\n      };\n\n      h.prototype.addBaseSeriesEvents = function () {\n        var a = this,\n            b = a.baseSeries || [];\n        b[0] && b[0].xAxis && e(b[0].xAxis, \"foundExtremes\", this.modifyBaseAxisExtremes);\n        b.forEach(function (b) {\n          e(b, \"show\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!0, !1);\n          });\n          e(b, \"hide\", function () {\n            this.navigatorSeries && this.navigatorSeries.setVisible(!1, !1);\n          });\n          !1 !== this.navigatorOptions.adaptToUpdatedData && b.xAxis && e(b, \"updatedData\", this.updatedDataHandler);\n          e(b, \"remove\", function () {\n            this.navigatorSeries && (d(a.series, this.navigatorSeries), q(this.navigatorSeries.options) && this.navigatorSeries.remove(!1), delete this.navigatorSeries);\n          });\n        }, this);\n      };\n\n      h.prototype.getBaseSeriesMin = function (a) {\n        return this.baseSeries.reduce(function (a, b) {\n          return Math.min(a, b.xData ? b.xData[0] : a);\n        }, a);\n      };\n\n      h.prototype.modifyNavigatorAxisExtremes = function () {\n        var a = this.xAxis,\n            b;\n        \"undefined\" !== typeof a.getExtremes && (!(b = this.getUnionExtremes(!0)) || b.dataMin === a.min && b.dataMax === a.max || (a.min = b.dataMin, a.max = b.dataMax));\n      };\n\n      h.prototype.modifyBaseAxisExtremes = function () {\n        var a = this.chart.navigator,\n            b = this.getExtremes(),\n            c = b.dataMin,\n            d = b.dataMax;\n        b = b.max - b.min;\n        var e = a.stickToMin,\n            f = a.stickToMax,\n            g = H(this.options.overscroll, 0),\n            h = a.series && a.series[0],\n            k = !!this.setExtremes;\n\n        if (!this.eventArgs || \"rangeSelectorButton\" !== this.eventArgs.trigger) {\n          if (e) {\n            var m = c;\n            var n = m + b;\n          }\n\n          f && (n = d + g, e || (m = Math.max(c, n - b, a.getBaseSeriesMin(h && h.xData ? h.xData[0] : -Number.MAX_VALUE))));\n          k && (e || f) && K(m) && (this.min = this.userMin = m, this.max = this.userMax = n);\n        }\n\n        a.stickToMin = a.stickToMax = null;\n      };\n\n      h.prototype.updatedDataHandler = function () {\n        var a = this.chart.navigator,\n            b = this.navigatorSeries,\n            c = a.getBaseSeriesMin(this.xData[0]);\n        a.stickToMax = a.reversedExtremes ? 0 === Math.round(a.zoomedMin) : Math.round(a.zoomedMax) >= Math.round(a.size);\n        a.stickToMin = K(this.xAxis.min) && this.xAxis.min <= c && (!this.chart.fixedRange || !a.stickToMax);\n        b && !a.hasNavigatorData && (b.options.pointStart = this.xData[0], b.setData(this.options.data, !1, null, !1));\n      };\n\n      h.prototype.addChartEvents = function () {\n        this.eventsToUnbind || (this.eventsToUnbind = []);\n        this.eventsToUnbind.push(e(this.chart, \"redraw\", function () {\n          var a = this.navigator,\n              b = a && (a.baseSeries && a.baseSeries[0] && a.baseSeries[0].xAxis || this.xAxis[0]);\n          b && a.render(b.min, b.max);\n        }), e(this.chart, \"getMargins\", function () {\n          var a = this.navigator,\n              b = a.opposite ? \"plotTop\" : \"marginBottom\";\n          this.inverted && (b = a.opposite ? \"marginRight\" : \"plotLeft\");\n          this[b] = (this[b] || 0) + (a.navigatorEnabled || !this.inverted ? a.outlineHeight : 0) + a.navigatorOptions.margin;\n        }));\n      };\n\n      h.prototype.destroy = function () {\n        this.removeEvents();\n        this.xAxis && (d(this.chart.xAxis, this.xAxis), d(this.chart.axes, this.xAxis));\n        this.yAxis && (d(this.chart.yAxis, this.yAxis), d(this.chart.axes, this.yAxis));\n        (this.series || []).forEach(function (a) {\n          a.destroy && a.destroy();\n        });\n        \"series xAxis yAxis shades outline scrollbarTrack scrollbarRifles scrollbarGroup scrollbar navigatorGroup rendered\".split(\" \").forEach(function (a) {\n          this[a] && this[a].destroy && this[a].destroy();\n          this[a] = null;\n        }, this);\n        [this.handles].forEach(function (a) {\n          c(a);\n        }, this);\n      };\n\n      return h;\n    }();\n\n    r.Navigator || (r.Navigator = y, n.compose(a), e(u, \"beforeShowResetZoom\", function () {\n      var a = this.options,\n          b = a.navigator,\n          c = a.rangeSelector;\n      if ((b && b.enabled || c && c.enabled) && (!f && \"x\" === a.chart.zoomType || f && \"x\" === a.chart.pinchType)) return !1;\n    }), e(u, \"beforeRender\", function () {\n      var a = this.options;\n      if (a.navigator.enabled || a.scrollbar.enabled) this.scroller = this.navigator = new y(this);\n    }), e(u, \"afterSetChartSize\", function () {\n      var a = this.legend,\n          b = this.navigator;\n\n      if (b) {\n        var c = a && a.options;\n        var d = b.xAxis;\n        var e = b.yAxis;\n        var f = b.scrollbarHeight;\n        this.inverted ? (b.left = b.opposite ? this.chartWidth - f - b.height : this.spacing[3] + f, b.top = this.plotTop + f) : (b.left = this.plotLeft + f, b.top = b.navigatorOptions.top || this.chartHeight - b.height - f - this.spacing[2] - (this.rangeSelector && this.extraBottomMargin ? this.rangeSelector.getHeight() : 0) - (c && \"bottom\" === c.verticalAlign && \"proximate\" !== c.layout && c.enabled && !c.floating ? a.legendHeight + H(c.margin, 10) : 0) - (this.titleOffset ? this.titleOffset[2] : 0));\n        d && e && (this.inverted ? d.options.left = e.options.left = b.left : d.options.top = e.options.top = b.top, d.setAxisSize(), e.setAxisSize());\n      }\n    }), e(u, \"update\", function (a) {\n      var b = a.options.navigator || {},\n          c = a.options.scrollbar || {};\n      this.navigator || this.scroller || !b.enabled && !c.enabled || (L(!0, this.options.navigator, b), L(!0, this.options.scrollbar, c), delete a.options.navigator, delete a.options.scrollbar);\n    }), e(u, \"afterUpdate\", function (a) {\n      this.navigator || this.scroller || !this.options.navigator.enabled && !this.options.scrollbar.enabled || (this.scroller = this.navigator = new y(this), H(a.redraw, !0) && this.redraw(a.animation));\n    }), e(u, \"afterAddSeries\", function () {\n      this.navigator && this.navigator.setBaseSeries(null, !1);\n    }), e(D, \"afterUpdate\", function () {\n      this.chart.navigator && !this.options.isInternal && this.chart.navigator.setBaseSeries(null, !1);\n    }), u.prototype.callbacks.push(function (a) {\n      var b = a.navigator;\n      b && a.xAxis[0] && (a = a.xAxis[0].getExtremes(), b.render(a.min, a.max));\n    }));\n    r.Navigator = y;\n    return r.Navigator;\n  });\n  F(a, \"masters/modules/gantt.src.js\", [], function () {});\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZ2FudHQuc3JjLmpzPzEwZjQiXSwibmFtZXMiOlsibW9kdWxlIiwiZmFjdG9yeSIsImRlZmluZSIsIkhpZ2hjaGFydHMiLCJfcmVnaXN0ZXJNb2R1bGUiLCJvYmoiLCJmbiIsIl9tb2R1bGVzIiwiX19leHRlbmRzIiwiZXh0ZW5kU3RhdGljcyIsIk9iamVjdCIsIl9fcHJvdG9fXyIsImQiLCJwIiwiYiIsIl9fIiwiWFJhbmdlUG9pbnQiLCJfdGhpcyIsIl9zdXBlciIsIlhSYW5nZVBvaW50LmdldENvbG9yQnlDYXRlZ29yeSIsImNvbG9ycyIsInNlcmllcyIsImNvbG9ySW5kZXgiLCJwb2ludCIsImNvbG9yIiwiWFJhbmdlUG9pbnQucHJvdG90eXBlLnJlc29sdmVDb2xvciIsImNvbG9yQnlQb2ludCIsIlhSYW5nZVBvaW50LnByb3RvdHlwZS5pbml0IiwiUG9pbnQiLCJYUmFuZ2VQb2ludC5wcm90b3R5cGUuc2V0U3RhdGUiLCJYUmFuZ2VQb2ludC5wcm90b3R5cGUuZ2V0TGFiZWxDb25maWciLCJjZmciLCJ5Q2F0cyIsIngyIiwiWFJhbmdlUG9pbnQucHJvdG90eXBlLmlzVmFsaWQiLCJTZXJpZXNSZWdpc3RyeSIsInByb3RvdHlwZSIsImFkZEV2ZW50IiwiVSIsInBpY2siLCJheGlzU2VyaWVzIiwiYXhpcyIsIm1vZE1heCIsIk51bWJlciIsInZhbCIsImRhdGFNYXgiLCJDb2xvciIsIlNlcmllcyIsIkNvbHVtblNlcmllcyIsImNvbHVtblByb3RvIiwiY2xhbXAiLCJjb3JyZWN0RmxvYXQiLCJkZWZpbmVkIiwiZXh0ZW5kIiwiZmluZCIsImlzTnVtYmVyIiwiaXNPYmplY3QiLCJtZXJnZSIsIlhSYW5nZVNlcmllcyIsIlhSYW5nZVNlcmllcy5wcm90b3R5cGUuaW5pdCIsIlhSYW5nZVNlcmllcy5wcm90b3R5cGUuZ2V0Q29sdW1uTWV0cmljcyIsInN3YXBBeGVzIiwiY2hhcnQiLCJ4QXhpcyIsInMiLCJYUmFuZ2VTZXJpZXMucHJvdG90eXBlLmNyb3BEYXRhIiwiY3JvcCIsInhEYXRhIiwiWFJhbmdlU2VyaWVzLnByb3RvdHlwZS5maW5kUG9pbnRJbmRleCIsImNyb3BwZWQiLCJfYSIsImNyb3BTdGFydCIsInBvaW50cyIsImlkIiwib3B0aW9ucyIsInBvaW50SW5kZXgiLCJYUmFuZ2VTZXJpZXMucHJvdG90eXBlLnRyYW5zbGF0ZVBvaW50IiwieUF4aXMiLCJtZXRyaWNzIiwibWluUG9pbnRMZW5ndGgiLCJvbGRDb2xXaWR0aCIsInNlcmllc1hPZmZzZXQiLCJwbG90WCIsInBvc1giLCJwbG90WDIiLCJsZW5ndGgiLCJNYXRoIiwiaW52ZXJ0ZWQiLCJjcmlzcGVyIiwieU9mZnNldCIsInBvaW50SGVpZ2h0Iiwid2lkdGhEaWZmZXJlbmNlIiwic2hhcGVBcmdzIiwieCIsInkiLCJ3aWR0aCIsImhlaWdodCIsInIiLCJfYiIsImRsTGVmdCIsImRsUmlnaHQiLCJkbFdpZHRoIiwiY2VudGVyWCIsInRvb2x0aXBQb3MiLCJ4SW5kZXgiLCJ5SW5kZXgiLCJ0b29sdGlwWU9mZnNldCIsImNvbHVtbk1ldHJpY3MiLCJwYXJ0aWFsRmlsbCIsImNsaXBSZWN0V2lkdGgiLCJYUmFuZ2VTZXJpZXMucHJvdG90eXBlLnRyYW5zbGF0ZSIsIlhSYW5nZVNlcmllcy5wcm90b3R5cGUuZHJhd1BvaW50Iiwic2VyaWVzT3B0cyIsInJlbmRlcmVyIiwiZ3JhcGhpYyIsInR5cGUiLCJwYXJ0U2hhcGVBcmdzIiwiY2xpcFJlY3RBcmdzIiwicGZPcHRpb25zIiwiY3V0T2ZmIiwicG9pbnRTdGF0ZSIsInN0YXRlT3B0cyIsInBvaW50U3RhdGVWZXJiIiwidmVyYiIsInBvaW50QXR0ciIsInBvaW50QXR0cmlicyIsImFuaW1hdGlvbiIsImZpbGwiLCJYUmFuZ2VTZXJpZXMucHJvdG90eXBlLmRyYXdQb2ludHMiLCJYUmFuZ2VTZXJpZXMucHJvdG90eXBlLmdldEFuaW1hdGlvblZlcmIiLCJYUmFuZ2VTZXJpZXMucHJvdG90eXBlLmlzUG9pbnRJbnNpZGUiLCJwbG90WSIsImRhdGFMYWJlbHMiLCJmb3JtYXR0ZXIiLCJhbW91bnQiLCJpbnNpZGUiLCJ2ZXJ0aWNhbEFsaWduIiwidG9vbHRpcCIsImhlYWRlckZvcm1hdCIsInBvaW50Rm9ybWF0IiwiYm9yZGVyUmFkaXVzIiwicG9pbnRSYW5nZSIsInBhcmFsbGVsQXJyYXlzIiwicmVxdWlyZVNvcnRpbmciLCJhbmltYXRlIiwiY3JvcFNob3VsZGVyIiwiZ2V0RXh0cmVtZXNGcm9tQWxsIiwiYXV0b0luY3JlbWVudCIsIkgiLCJidWlsZEtEVHJlZSIsInBvaW50Q2xhc3MiLCJHYW50dFBvaW50IiwiR2FudHRQb2ludC5zZXRHYW50dFBvaW50QWxpYXNlcyIsImFkZElmRXhpc3RzIiwiR2FudHRQb2ludC5wcm90b3R5cGUuYXBwbHlPcHRpb25zIiwiZ2FudHRQb2ludCIsIkdhbnR0UG9pbnQucHJvdG90eXBlLmlzVmFsaWQiLCJnZXRMaXN0T2ZQYXJlbnRzIiwibGlzdE9mUGFyZW50cyIsImRhdGEiLCJwYXJlbnQiLCJjdXJyIiwicHJldiIsImNoaWxkcmVuIiwiaWRzIiwibGlzdCIsImdldE5vZGUiLCJkZXNjZW5kYW50cyIsImFmdGVyIiwiYmVmb3JlIiwibm9kZSIsImRlcHRoIiwibGV2ZWwiLCJlbmQiLCJtYXAiLCJtYXBPZklkVG9DaGlsZHJlbiIsImNoaWxkIiwiY2hpbGRTdGFydCIsImNoaWxkRW5kIiwic3RhcnQiLCJUcmVlIiwiZ2V0VHJlZSIsIndyYXAiLCJUcmVlR3JpZFRpY2siLCJvbkluaXQiLCJ0aWNrIiwicmVuZGVyTGFiZWxJY29uIiwidHJlZUdyaWQiLCJpc05ldyIsInBhcmFtcyIsImxhYmVsQm94Iiwicm90YXRpb24iLCJzaG91bGRSZW5kZXIiLCJpY29uIiwicGFsZXR0ZSIsImN1cnNvciIsInN0cm9rZSIsInN0cm9rZVdpZHRoIiwidHJhbnNsYXRlWCIsInRyYW5zbGF0ZVkiLCJ3cmFwR2V0TGFiZWxQb3NpdGlvbiIsImxiT3B0aW9ucyIsInBvcyIsImlzVHJlZUdyaWQiLCJyZXN1bHQiLCJzeW1ib2xPcHRpb25zIiwiaW5kZW50YXRpb24iLCJtYXBPZlBvc1RvR3JpZE5vZGUiLCJ3cmFwUmVuZGVyTGFiZWwiLCJsYWJlbCIsImxhYmVsT3B0aW9ucyIsInN0eWxlZE1vZGUiLCJwcm9jZWVkIiwiQXJyYXkiLCJjb2xsYXBzZWQiLCJncm91cCIsInNob3ciLCJ4eSIsInJlbW92ZUNsYXNzTmFtZSIsInByZWZpeENsYXNzTmFtZSIsIm9iamVjdCIsImFkZENsYXNzIiwiY3NzIiwidGV4dERlY29yYXRpb24iLCJzdHlsZSIsInJlbW92ZUNsYXNzIiwiYXBwbGllZCIsImNvbXBvc2UiLCJUaWNrQ2xhc3MiLCJUaWNrQ2xhc3MucHJvdG90eXBlLmNvbGxhcHNlIiwiVGlja0NsYXNzLnByb3RvdHlwZS5leHBhbmQiLCJUaWNrQ2xhc3MucHJvdG90eXBlLnRvZ2dsZUNvbGxhcHNlIiwiQWRkaXRpb25zIiwiQWRkaXRpb25zLnByb3RvdHlwZS5jb2xsYXBzZSIsImJyb2tlbkF4aXMiLCJicmVha3MiLCJBZGRpdGlvbnMucHJvdG90eXBlLmV4cGFuZCIsIkFkZGl0aW9ucy5wcm90b3R5cGUudG9nZ2xlQ29sbGFwc2UiLCJpc0FycmF5IiwiZ2V0Q29sb3IiLCJpbmRleCIsIm1hcE9wdGlvbnNUb0xldmVsIiwicGFyZW50Q29sb3IiLCJwYXJlbnRDb2xvckluZGV4Iiwic2libGluZ3MiLCJjaGFydE9wdGlvbnNDaGFydCIsImdldENvbG9yQnlQb2ludCIsImNvbG9yVmFyaWF0aW9uIiwiZ2V0TGV2ZWxPcHRpb25zIiwiY29udmVydGVkIiwibGV2ZWxzIiwiaXRlbSIsImRlZmF1bHRzIiwibGV2ZWxJc0NvbnN0YW50IiwiZnJvbSIsInRvIiwiaSIsInNldFRyZWVWYWx1ZXMiLCJpZFJvb3QiLCJub2RlUm9vdCIsInRyZWUiLCJvcHRpb25zUG9pbnQiLCJjaGlsZHJlblRvdGFsIiwibGV2ZWxEeW5hbWljIiwibmFtZSIsInZpc2libGUiLCJuZXdPcHRpb25zIiwidmFsdWUiLCJpc0xlYWYiLCJ1cGRhdGVSb290SWQiLCJyb290SWQiLCJlcmFzZSIsInRpbWVVbml0cyIsIkNoYXJ0IiwiYXBwbHlHcmlkT3B0aW9ucyIsIkF4aXMiLCJBeGlzLnByb3RvdHlwZS5nZXRNYXhMYWJlbERpbWVuc2lvbnMiLCJkaW1lbnNpb25zIiwidGlja3MiLCJsYWJlbEhlaWdodCIsImxhYmVsV2lkdGgiLCJILmRhdGVGb3JtYXRzLlciLCJmaXJzdERheSIsInRodXJzZGF5IiwiZmlyc3RUaHVyc2RheSIsInRvU3RyaW5nIiwiSC5kYXRlRm9ybWF0cy5FIiwiZm9yRWFjaCIsImNvbHVtbiIsInJldmVyc2VkIiwiZ3JpZE9wdGlvbnMiLCJsYWJlbE9wdHMiLCJhbGlnbiIsInNpZGUiLCJHcmlkQXhpcyIsInRpY2ttYXJrT2Zmc2V0IiwiZSIsInRpY2tQb3NpdGlvbnMiLCJ0aWNrUG9zIiwibmV4dFRpY2tQb3MiLCJ0aWNrU2l6ZSIsInRpY2tXaWR0aCIsImNyaXNwQ29yciIsImJvdHRvbSIsInRvcCIsImxlZnQiLCJyaWdodCIsInNsb3RXaWR0aCIsImxibE1ldHJpY3MiLCJsaW5lcyIsIkdyaWRBeGlzQWRkaXRpb25zIiwiR3JpZEF4aXNBZGRpdGlvbnMucHJvdG90eXBlLmlzT3V0ZXJBeGlzIiwiY29sdW1uSW5kZXgiLCJjb2x1bW5zIiwicGFyZW50QXhpcyIsInRoaXNJbmRleCIsImxhc3RJbmRleCIsIm90aGVyQXhpcyIsIkdyaWRBeGlzQWRkaXRpb25zLnByb3RvdHlwZS5yZW5kZXJCb3JkZXIiLCJleHRyYUJvcmRlckxpbmUiLCJ6SW5kZXgiLCJHcmlkQXhpcy5jb21wb3NlIiwiQXhpc0NsYXNzIiwiR3JpZEF4aXMub25BZnRlckdldE9mZnNldCIsImdyaWQiLCJHcmlkQXhpcy5vbkFmdGVyR2V0VGl0bGVQb3NpdGlvbiIsImVuYWJsZWQiLCJ0aXRsZSIsImF4aXNIZWlnaHQiLCJob3JpeiIsImF4aXNMZWZ0Iiwib2Zmc2V0Iiwib3Bwb3NpdGUiLCJheGlzVGl0bGVPcHRpb25zIiwiYXhpc1RvcCIsImF4aXNXaWR0aCIsInRpdGxlV2lkdGgiLCJ4T3B0aW9uIiwieU9wdGlvbiIsInRpdGxlTWFyZ2luIiwidGl0bGVGb250U2l6ZSIsIm9mZkF4aXMiLCJHcmlkQXhpcy5vbkFmdGVySW5pdCIsInVzZXJPcHRpb25zIiwiaXNGaXJzdCIsImlzTGFzdCIsInBvaW50Q29weSIsImNvbHVtbk9wdGlvbnMiLCJsaW5rZWRUbyIsInNjcm9sbGJhciIsIkdyaWRBeGlzLm9uQWZ0ZXJSZW5kZXIiLCJtYXhMYWJlbERpbWVuc2lvbnMiLCJnZXRNYXhMYWJlbERpbWVuc2lvbnMiLCJyaWdodFdhbGwiLCJsaW5lV2lkdGgiLCJsaW5lUGF0aCIsImdldExpbmVQYXRoIiwic3RhcnRQb2ludCIsImVuZFBvaW50IiwiZGlzdGFuY2UiLCJ0aWNrTGVuZ3RoIiwidXBwZXJCb3JkZXJQYXRoIiwidXBwZXJCb3JkZXJFbmRQb2ludCIsImxvd2VyQm9yZGVyRW5kUG9pbnQiLCJ0b1BpeGVscyIsImxvd2VyQm9yZGVyUGF0aCIsImxvd2VyQm9yZGVyU3RhcnRQb2ludCIsIm1pbiIsIm1heCIsImF4aXNMaW5lIiwic2hvd0F4aXMiLCJsYXN0VGljayIsImZpcnN0VGljayIsIkdyaWRBeGlzLm9uQWZ0ZXJTZXRBeGlzVHJhbnNsYXRpb24iLCJ0aWNrSW5mbyIsInVzZXJMYWJlbHMiLCJHcmlkQXhpcy5vbkFmdGVyU2V0T3B0aW9ucyIsImNsYXNzTmFtZSIsImRhdGVUaW1lTGFiZWxGb3JtYXRzIiwiaG91ciIsImRheSIsIndlZWsiLCJtb250aCIsImJvcmRlcldpZHRoIiwibGFiZWxzIiwicGFkZGluZyIsImZvbnRTaXplIiwibWFyZ2luIiwidGV4dCIsInJlc2VydmVTcGFjZSIsInVuaXRzIiwiZ3JpZEF4aXNPcHRpb25zIiwiZ3JpZEF4aXNPcHRpb25zLnRpY2tQb3NpdGlvbmVyIiwicGFyZW50SW5mbyIsInVuaXRJZHgiLCJ1bml0TmFtZSIsInVuaXRSYW5nZSIsImNvdW50IiwiR3JpZEF4aXMub25BZnRlclNldE9wdGlvbnMyIiwiR3JpZEF4aXMub25BZnRlclNldFNjYWxlIiwiR3JpZEF4aXMub25BZnRlclRpY2tTaXplIiwiZGVmYXVsdExlZnRBeGlzT3B0aW9ucyIsImxhYmVsUGFkZGluZyIsIkdyaWRBeGlzLm9uRGVzdHJveSIsIkdyaWRBeGlzLm9uSW5pdCIsIm9uVHJpbVRpY2tzIiwiR3JpZEF4aXMub25UcmltVGlja3MiLCJjYXRlZ29yeUF4aXMiLCJmaXJzdFBvcyIsImxhc3RQb3MiLCJsaW5rZWRQYXJlbnQiLCJ0aWNrSW50ZXJ2YWwiLCJpc0xpbmtlZCIsIkdyaWRBeGlzLndyYXBVbnNxdWlzaCIsIlNpZGUiLCJmaXJlRXZlbnQiLCJCcm9rZW5BeGlzQWRkaXRpb25zIiwiQnJva2VuQXhpc0FkZGl0aW9ucy5pc0luQnJlYWsiLCJyZXBlYXQiLCJicmsiLCJ0ZXN0IiwicmV0IiwiQnJva2VuQXhpc0FkZGl0aW9ucy5saW4yVmFsIiwiYnJlYWtBcnJheSIsIm52YWwiLCJCcm9rZW5BeGlzQWRkaXRpb25zLnZhbDJMaW4iLCJCcm9rZW5BeGlzQWRkaXRpb25zLnByb3RvdHlwZS5maW5kQnJlYWtBdCIsIkJyb2tlbkF4aXNBZGRpdGlvbnMucHJvdG90eXBlLmlzSW5BbnlCcmVhayIsImtlZXAiLCJpbmJyayIsIkJyb2tlbkF4aXNBZGRpdGlvbnMucHJvdG90eXBlLnNldEJyZWFrcyIsImhhc0JyZWFrcyIsImF4aXMuc2V0RXh0cmVtZXMiLCJheGlzQnJlYWsiLCJuZXdNaW4iLCJuZXdNYXgiLCJheGlzLnNldEF4aXNUcmFuc2xhdGlvbiIsImJyZWFrQXJyYXlUIiwicG9pbnRSYW5nZVBhZGRpbmciLCJJbmZpbml0eSIsIm1vdmUiLCJzaXplIiwiYSIsImluQnJrIiwibGVuIiwiQnJva2VuQXhpcyIsIkJyb2tlbkF4aXMuY29tcG9zZSIsInNlcmllc1Byb3RvIiwiZHJhd0JyZWFrcyIsInNlcmllc1Byb3RvLmRyYXdCcmVha3MiLCJicm9rZW5BeGlzXzEiLCJrZXlzIiwidGhyZXNob2xkIiwia2V5IiwiZXZlbnROYW1lIiwic2VyaWVzUHJvdG8uZ2FwcGVkUGF0aCIsImN1cnJlbnREYXRhR3JvdXBpbmciLCJncm91cGluZ1NpemUiLCJnYXBTaXplIiwic3RhY2siLCJuZXh0IiwiY3VycmVudCIsInhSYW5nZSIsImlzTnVsbCIsImluZm8iLCJuZXdQb3NpdGlvbnMiLCJjb25uZWN0TnVsbHMiLCJpc0RpcnR5IiwiaXNQb2ludEluQnJlYWsiLCJkcmF3UG9pbnRzV3JhcHBlZCIsIm1peGluVHJlZVNlcmllcyIsImlzU3RyaW5nIiwiVHJlZUdyaWRBeGlzIiwiZ2V0QnJlYWtGcm9tTm9kZSIsInNob3dQb2ludHMiLCJnZXRUcmVlR3JpZEZyb21EYXRhIiwiY2F0ZWdvcmllcyIsImNvbGxhcHNlZE5vZGVzIiwibWFwT2ZJZFRvTm9kZSIsInBvc0l0ZXJhdG9yIiwidW5pcXVlTmFtZXNFbmFibGVkIiwidHJlZVBhcmFtcyIsImdyaWROb2RlIiwicGFyZW50Tm9kZSIsInBhcmVudEdyaWROb2RlIiwiaGFzU2FtZU5hbWUiLCJub2RlcyIsInVwZGF0ZVlWYWx1ZXNBbmRUaWNrUG9zIiwic2V0VmFsdWVzIiwibnVtYmVyT2ZTZXJpZXMiLCJkaWZmIiwib25CZWZvcmVSZW5kZXIiLCJheGVzIiwiZmlsdGVyIiwidW5pcXVlTmFtZXMiLCJheGlzRGF0YSIsIndyYXBHZW5lcmF0ZVRpY2siLCJsZXZlbE9wdGlvbnMiLCJjYXRlZ29yeSIsIndyYXBHZXRNYXhMYWJlbERpbWVuc2lvbnMiLCJyZXRWYWwiLCJ0cmVlRGVwdGgiLCJ3cmFwSW5pdCIsImNvbmNhdCIsIm4iLCJmb250V2VpZ2h0Iiwic3ltYm9sIiwiYXBwbHkiLCJ3cmFwU2V0VGlja0ludGVydmFsIiwic2V0QXhpc1RyYW5zbGF0aW9uIiwiQWRkaXRpb25zLnByb3RvdHlwZS5zZXRDb2xsYXBzZWRTdGF0dXMiLCJkYXRhUG9pbnQiLCJhcnIiLCJBZGRpdGlvbnMucHJvdG90eXBlLmdldFRpY2tQb3NpdGlvbnMiLCJyb3VuZGVkTWluIiwicm91bmRlZE1heCIsIkFkZGl0aW9ucy5wcm90b3R5cGUuaXNDb2xsYXBzZWQiLCJkZWZhdWx0Q29uZmlnIiwiY3VycmVudERhdGVJbmRpY2F0b3IiLCJmb3JtYXQiLCJjZGlPcHRpb25zIiwiRGF0ZSIsIlBsb3RMaW5lT3JCYW5kIiwiZGVmYXVsdE1ldGhvZCIsImNoYXJ0T3B0aW9ucyIsIkNoYXJ0LnByb3RvdHlwZS5hZGp1c3RIZWlnaHQiLCJzdGF0aWNTY2FsZSIsImNsaXBSZWN0IiwiU1ZHUmVuZGVyZXIiLCJTVkdSZW5kZXJlci5wcm90b3R5cGUuc3ltYm9scy5hcnJvdyIsImgiLCJ3IiwiZ2V0UG9pbnRCQiIsInhNaW4iLCJ4TWF4IiwieU1pbiIsInlNYXgiLCJiYiIsImVycm9yIiwib2JqZWN0RWFjaCIsImRlZzJyYWQiLCJPIiwiY29ubmVjdG9ycyIsIm1hcmtlciIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwiQ29ubmVjdGlvbiIsIkNvbm5lY3Rpb24ucHJvdG90eXBlLmluaXQiLCJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW5kZXJQYXRoIiwicGF0aGZpbmRlciIsInBhdGhHcmFwaGljIiwiY29ubmVjdGlvbiIsImdyYXBoaWNzIiwib3BhY2l0eSIsImFuaW0iLCJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRNYXJrZXIiLCJmcm9tUG9pbnQiLCJhbmNob3IiLCJzZWdtZW50IiwicGF0aCIsInBhdGhWZWN0b3IiLCJyYWRpYW5zIiwibWFya2VyVmVjdG9yIiwiYm94Iiwicm90YXRpb25PcmlnaW5YIiwicm90YXRpb25PcmlnaW5ZIiwiQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UGF0aCIsImFsZ29yaXRobSIsImNoYXJ0T2JzdGFjbGVzIiwib2JzdGFjbGVzIiwibGluZU9ic3RhY2xlcyIsIm9ic3RhY2xlTWV0cmljcyIsImhhcmRCb3VuZHMiLCJvYnN0YWNsZU9wdGlvbnMiLCJzdGFydERpcmVjdGlvblgiLCJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW5kZXIiLCJhdHRyaWJzIiwicGF0aFJlc3VsdCIsImdldFBhdGgiLCJyZW5kZXJQYXRoIiwiYWRkTWFya2VyIiwiQ29ubmVjdGlvbi5wcm90b3R5cGUuZGVzdHJveSIsImdldFBhdGhmaW5kZXJBbmNob3JQb2ludCIsIm1hcmtlck9wdGlvbnMiLCJnZXRSYWRpYW5zVG9WZWN0b3IiLCJ2MiIsInYxIiwiZ2V0TWFya2VyVmVjdG9yIiwidHdvUEkiLCJyZWN0V2lkdGgiLCJyZWN0SGVpZ2h0IiwickF0YW4iLCJsZWZ0T3JSaWdodFJlZ2lvbiIsInJlY3RIYWxmV2lkdGgiLCJyZWN0SGFsZkhlaWdodCIsInJlY3RIb3Jpem9udGFsQ2VudGVyIiwicmVjdFZlcnRpY2FsQ2VudGVyIiwieEZhY3RvciIsInlGYWN0b3IiLCJ0aGV0YSIsInRhblRoZXRhIiwibWFya2VyUmFkaXVzIiwiZmluZExhc3RPYnN0YWNsZUJlZm9yZSIsInN0YXJ0SXgiLCJjbXAiLCJmaW5kT2JzdGFjbGVGcm9tUG9pbnQiLCJvYnN0YWNsZSIsInBhdGhGcm9tU2VnbWVudHMiLCJzZWdtZW50cyIsImxpbWl0T2JzdGFjbGVUb0JvdW5kcyIsImJvdW5kcyIsImFicyIsInNpbXBsZUNvbm5lY3QiLCJjb3B5RnJvbVBvaW50IiwidG9LZXkiLCJnZXRNZU91dCIsInVzZU1heCIsImRpcmVjdGlvbiIsImRpciIsInN0YXJ0T2JzdGFjbGVJeCIsImVuZE9ic3RhY2xlSXgiLCJ3YXlwb2ludCIsImVuZFNlZ21lbnQiLCJzdGFydE9ic3RhY2xlIiwicHJldldheXBvaW50Iiwid2F5cG9pbnQyIiwicmVxdWlyZXNPYnN0YWNsZXMiLCJhbGdvcml0aG1zIiwiZmFzdEF2b2lkIiwicGl2b3RQb2ludCIsInNlYXJjaERpcmVjdGlvbiIsInRvUG9pbnQiLCJmaXJzdFBvaW50IiwibG93ZXN0UG9pbnQiLCJsYXN0UG9pbnQiLCJoaWdoZXN0UG9pbnQiLCJkaXJlY3Rpb25Jc1giLCJnZXREb2RnZURpcmVjdGlvbiIsInNvZnRCb3VuZHMiLCJkaXJJc1giLCJ0b1BvaW50TWF4IiwidG9Qb2ludE1pbiIsIm1heE91dE9mU29mdEJvdW5kcyIsIm1pbk91dE9mU29mdEJvdW5kcyIsIm1heE91dE9mSGFyZEJvdW5kcyIsIm1pbk91dE9mSGFyZEJvdW5kcyIsIm1pbkRpc3RhbmNlIiwibWF4RGlzdGFuY2UiLCJtaW5QaXZvdCIsIm1heFBpdm90IiwiY2xlYXJQYXRoVG8iLCJvYnN0YWNsZU1hcmdpbiIsInNvZnQiLCJoYXJkIiwiZW52ZWxvcGluZ09ic3RhY2xlIiwid2F5cG9pbnRVc2VNYXgiLCJzZWNvbmRFbnZlbG9waW5nT2JzdGFjbGUiLCJlbnZlbG9wV2F5cG9pbnQiLCJmb3JjZU9ic3RhY2xlQnJlYWsiLCJwaXZvdCIsImV4dHJhY3RGcm9tT2JzdGFjbGUiLCJlbmRTZWdtZW50cyIsInNvZnRNaW5YIiwic29mdE1heFgiLCJzb2Z0TWluWSIsInNvZnRNYXhZIiwiZXh0cmFjdGVkRW5kUG9pbnQiLCJzdHJhaWdodCIsImNhbGN1bGF0ZU9ic3RhY2xlTWFyZ2luIiwiZGlzdGFuY2VzIiwieU92ZXJsYXAiLCJ4T3ZlcmxhcCIsInhEaXN0YW5jZSIsInlEaXN0YW5jZSIsImoiLCJvYnN0YWNsZURpc3RhbmNlIiwid2FybkxlZ2FjeSIsImFjYyIsInNwbGF0IiwiUGF0aGZpbmRlciIsIlBhdGhmaW5kZXIucHJvdG90eXBlLmluaXQiLCJQYXRoZmluZGVyLnByb3RvdHlwZS51cGRhdGUiLCJvbGRDb25uZWN0aW9ucyIsImdhbnR0UG9pbnRPcHRpb25zIiwiY29ubmVjdHMiLCJjb25uZWN0IiwibGVuT2xkIiwibGVuTmV3IiwiZm91bmQiLCJrIiwiUGF0aGZpbmRlci5wcm90b3R5cGUucmVuZGVyQ29ubmVjdGlvbnMiLCJkZWZlclJlbmRlciIsInJlbmRlciIsIlBhdGhmaW5kZXIucHJvdG90eXBlLmdldENoYXJ0T2JzdGFjbGVzIiwic0xlbiIsInBMZW4iLCJjYWxjdWxhdGVkTWFyZ2luIiwiUGF0aGZpbmRlci5wcm90b3R5cGUuZ2V0T2JzdGFjbGVNZXRyaWNzIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJQYXRoZmluZGVyLnByb3RvdHlwZS5nZXRBbGdvcml0aG1TdGFydERpcmVjdGlvbiIsInlDZW50ZXIiLCJ1bmRlZiIsInBhdGhmaW5kZXJBbGdvcml0aG1zIiwiR2FudHRTZXJpZXMiLCJHYW50dFNlcmllcy5wcm90b3R5cGUuZHJhd1BvaW50Iiwic3RhdGUiLCJkaWFtb25kU2hhcGUiLCJHYW50dFNlcmllcy5wcm90b3R5cGUudHJhbnNsYXRlUG9pbnQiLCJkZWZhdWx0T3B0aW9ucyIsImdyb3VwaW5nIiwicG9pbnRGb3JtYXR0ZXIiLCJmb3JtYXRzIiwic3RhcnRPZldlZWsiLCJ0dE9wdGlvbnMiLCJtaWxlc3RvbmUiLCJ0b29sdGlwRm9ybWF0dGVyIiwicmFkaXVzIiwia2V5Ym9hcmRNb3ZlVmVydGljYWwiLCJwb2ludEFycmF5TWFwIiwic2V0RGF0YSIsImdldE9wdGlvbnMiLCJILmdhbnR0Q2hhcnQiLCJoYXNSZW5kZXJUb0FyZyIsInJlbmRlclRvIiwic2VyaWVzT3B0aW9ucyIsImFyZ3VtZW50cyIsImRlZmF1bHRMaW5rZWRUbyIsInlBeGlzT3B0aW9ucyIsImxlZ2VuZCIsIm5hdmlnYXRvciIsImlzR2FudHQiLCJTY3JvbGxiYXJBeGlzIiwiU2Nyb2xsYmFyQXhpcy5jb21wb3NlIiwiZ2V0RXh0cmVtZXMiLCJheGlzTWluIiwiYXhpc01heCIsInNjcm9sbE1pbiIsInNjcm9sbE1heCIsInVuaXRlZE1pbiIsInJhbmdlIiwic2Nyb2xsYmFyc09mZnNldHMiLCJheGlzTWFyZ2luIiwiaXNOYU4iLCJkZXN0cm95T2JqZWN0UHJvcGVydGllcyIsInJlbW92ZUV2ZW50IiwiaXNUb3VjaERldmljZSIsInN3YXBYWSIsIkguc3dhcFhZIiwidmVydGljYWwiLCJzZWciLCJ0ZW1wIiwiU2Nyb2xsYmFyIiwiU2Nyb2xsYmFyLnByb3RvdHlwZS5hZGRFdmVudHMiLCJidXR0b25zT3JkZXIiLCJidXR0b25zIiwiYmFyIiwidHJhY2siLCJtb3VzZURvd25IYW5kbGVyIiwibW91c2VNb3ZlSGFuZGxlciIsIm1vdXNlVXBIYW5kbGVyIiwiX2V2ZW50cyIsIlNjcm9sbGJhci5wcm90b3R5cGUuYnV0dG9uVG9NYXhDbGljayIsInNjcm9sbGVyIiwidXBkYXRlUG9zaXRpb24iLCJ0cmlnZ2VyIiwiRE9NRXZlbnQiLCJTY3JvbGxiYXIucHJvdG90eXBlLmJ1dHRvblRvTWluQ2xpY2siLCJTY3JvbGxiYXIucHJvdG90eXBlLmN1cnNvclRvU2Nyb2xsYmFyUG9zaXRpb24iLCJtaW5XaWR0aERpZmZlcmVuY2UiLCJjaGFydFgiLCJub3JtYWxpemVkRXZlbnQiLCJjaGFydFkiLCJTY3JvbGxiYXIucHJvdG90eXBlLmRlc3Ryb3kiLCJTY3JvbGxiYXIucHJvdG90eXBlLmRyYXdTY3JvbGxiYXJCdXR0b24iLCJzY3JvbGxiYXJCdXR0b25zIiwicHVzaCIsInRlbXBFbGVtIiwiU2Nyb2xsYmFyLnByb3RvdHlwZS5pbml0IiwiU2Nyb2xsYmFyLnByb3RvdHlwZS5tb3VzZURvd25IYW5kbGVyIiwibW91c2VQb3NpdGlvbiIsImN1cnNvclRvU2Nyb2xsYmFyUG9zaXRpb24iLCJpbml0UG9zaXRpb25zIiwiZ3JhYmJlZENlbnRlciIsIlNjcm9sbGJhci5wcm90b3R5cGUubW91c2VNb3ZlSGFuZGxlciIsImNoYXJ0UG9zaXRpb24iLCJzY3JvbGxQb3NpdGlvbiIsImNoYW5nZSIsImhhc0RyYWdnZWQiLCJET01UeXBlIiwiU2Nyb2xsYmFyLnByb3RvdHlwZS5tb3VzZVVwSGFuZGxlciIsIlNjcm9sbGJhci5wcm90b3R5cGUucG9zaXRpb24iLCJtZXRob2QiLCJyZW5kZXJlZCIsInhPZmZzZXQiLCJiYXJXaWR0aCIsIlNjcm9sbGJhci5wcm90b3R5cGUucmVtb3ZlRXZlbnRzIiwiU2Nyb2xsYmFyLnByb3RvdHlwZS5yZW5kZXIiLCJzY3JvbGxiYXJHcm91cCIsInNjcm9sbGJhclJpZmxlcyIsInNjcm9sbGJhclN0cm9rZVdpZHRoIiwiZHJhd1Njcm9sbGJhckJ1dHRvbiIsIlNjcm9sbGJhci5wcm90b3R5cGUuc2V0UmFuZ2UiLCJtaW5XaWR0aCIsImZ1bGxXaWR0aCIsImNhbGN1bGF0ZWRXaWR0aCIsIm5ld1NpemUiLCJmcm9tUFgiLCJuZXdQb3MiLCJuZXdSaWZsZXNQb3MiLCJzY3JvbGxiYXJUb3AiLCJzY3JvbGxiYXJMZWZ0IiwiU2Nyb2xsYmFyLnByb3RvdHlwZS50cmFja0NsaWNrIiwiU2Nyb2xsYmFyLnByb3RvdHlwZS51cGRhdGUiLCJTY3JvbGxiYXIucHJvdG90eXBlLnVwZGF0ZVBvc2l0aW9uIiwiYmFyQm9yZGVyUmFkaXVzIiwiYnV0dG9uQm9yZGVyUmFkaXVzIiwibGl2ZVJlZHJhdyIsInN0ZXAiLCJiYXJCYWNrZ3JvdW5kQ29sb3IiLCJiYXJCb3JkZXJXaWR0aCIsImJhckJvcmRlckNvbG9yIiwiYnV0dG9uQXJyb3dDb2xvciIsImJ1dHRvbkJhY2tncm91bmRDb2xvciIsImJ1dHRvbkJvcmRlckNvbG9yIiwiYnV0dG9uQm9yZGVyV2lkdGgiLCJyaWZsZUNvbG9yIiwidHJhY2tCYWNrZ3JvdW5kQ29sb3IiLCJ0cmFja0JvcmRlckNvbG9yIiwidHJhY2tCb3JkZXJXaWR0aCIsInByZWZlcnJlZElucHV0VHlwZSIsImRhdGUiLCJ0aW1lIiwiY3JlYXRlRWxlbWVudCIsImRpc2NhcmRFbGVtZW50IiwicGFkIiwicEludCIsInJhbmdlU2VsZWN0b3IiLCJhbGxCdXR0b25zRW5hYmxlZCIsImJ1dHRvblNwYWNpbmciLCJkcm9wZG93biIsImJ1dHRvblRoZW1lIiwiZmxvYXRpbmciLCJpbnB1dEJveEJvcmRlckNvbG9yIiwiaW5wdXRCb3hIZWlnaHQiLCJpbnB1dEJveFdpZHRoIiwiaW5wdXREYXRlRm9ybWF0IiwiaW5wdXREYXRlUGFyc2VyIiwiaW5wdXRFZGl0RGF0ZUZvcm1hdCIsImlucHV0RW5hYmxlZCIsImlucHV0UG9zaXRpb24iLCJpbnB1dFNwYWNpbmciLCJzZWxlY3RlZCIsImJ1dHRvblBvc2l0aW9uIiwiaW5wdXRTdHlsZSIsImxhYmVsU3R5bGUiLCJyYW5nZVNlbGVjdG9yWm9vbSIsInJhbmdlU2VsZWN0b3JGcm9tIiwicmFuZ2VTZWxlY3RvclRvIiwiUmFuZ2VTZWxlY3RvciIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNsaWNrQnV0dG9uIiwicmFuZ2VPcHRpb25zIiwiYnV0dG9uT3B0aW9ucyIsImJhc2VBeGlzIiwidW5pb25FeHRyZW1lcyIsImRhdGFNaW4iLCJkYXRhR3JvdXBpbmciLCJjdHgiLCJ5dGRFeHRyZW1lcyIsImdldFlUREV4dHJlbWVzIiwicmFuZ2VNaW4iLCJkZWZlcnJlZFlURENsaWNrIiwic2V0U2VsZWN0ZWQiLCJyYW5nZVNlbGVjdG9yQnV0dG9uIiwicmFuZ2VTZXR0aW5nIiwiYmFzZVhBeGlzT3B0aW9ucyIsInJlc2V0TWluQW5kUmFuZ2UiLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5zZXRTZWxlY3RlZCIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmluaXQiLCJzZWxlY3RlZE9wdGlvbiIsImJsdXJJbnB1dHMiLCJtaW5JbnB1dCIsIm1heElucHV0IiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUudXBkYXRlQnV0dG9uU3RhdGVzIiwiYWN0dWFsUmFuZ2UiLCJoYXNOb0RhdGEiLCJ5dGRNaW4iLCJ5dGRNYXgiLCJzZWxlY3RlZEV4aXN0cyIsImJ1dHRvbiIsIm9mZnNldFJhbmdlIiwiaXNTZWxlY3RlZCIsImlzVG9vR3JlYXRSYW5nZSIsImlzVG9vU21hbGxSYW5nZSIsImlzWVREQnV0Tm90U2VsZWN0ZWQiLCJpc0FsbEJ1dEFscmVhZHlTaG93aW5nQWxsIiwiaXNTYW1lUmFuZ2UiLCJ5ZWFyIiwiZGlzYWJsZSIsInNlbGVjdCIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNvbXB1dGVCdXR0b25SYW5nZSIsImZpeGVkVGltZXMiLCJtaWxsaXNlY29uZCIsInNlY29uZCIsIm1pbnV0ZSIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldElucHV0VmFsdWUiLCJpbnB1dCIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnNldElucHV0VmFsdWUiLCJkYXRlQm94IiwiaGNUaW1lQXR0ciIsInVwZGF0ZWRUaW1lIiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuc2V0SW5wdXRFeHRyZW1lcyIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnNob3dJbnB1dCIsImlzVGV4dElucHV0IiwiYm9yZGVyIiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuaGlkZUlucHV0IiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZGVmYXVsdElucHV0RGF0ZVBhcnNlciIsImlucHV0RGF0ZSIsInN0ciIsImdldFRpbWV6b25lT2Zmc2V0IiwicGFydHMiLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5kcmF3SW5wdXQiLCJ1cGRhdGVFeHRyZW1lcyIsImNoYXJ0QXhpcyIsImRhdGFBeGlzIiwiaXNNaW4iLCJkaXYiLCJpbnB1dEdyb3VwIiwiY2hhcnRTdHlsZSIsInBvc2l0aW9uIiwiYm94U2hhZG93IiwidGV4dEFsaWduIiwiZm9udEZhbWlseSIsImlucHV0Lm9uZm9jdXMiLCJpbnB1dC5vbmJsdXIiLCJrZXlEb3duIiwiaW5wdXQub25jaGFuZ2UiLCJpbnB1dC5vbmtleXByZXNzIiwiZXZlbnQiLCJpbnB1dC5vbmtleWRvd24iLCJpbnB1dC5vbmtleXVwIiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZ2V0UG9zaXRpb24iLCJidXR0b25Ub3AiLCJpbnB1dFRvcCIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmdldFlUREV4dHJlbWVzIiwibm93Iiwic3RhcnRPZlllYXIiLCJ1c2VVVEMiLCJ0cyIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlciIsImNvbnRhaW5lciIsImlucHV0c1pJbmRleCIsIm1pbkVsZW1zIiwibWF4RWxlbXMiLCJtaW5SYW5nZSIsInhfMSIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnJlbmRlckJ1dHRvbnMiLCJsYW5nIiwic3RhdGVzIiwidGV4dENvbnRlbnQiLCJkaXNhYmxlZCIsImJ1dHRvbkV2ZW50cyIsImNhbGxEZWZhdWx0RXZlbnQiLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5hbGlnbkVsZW1lbnRzIiwiYnV0dG9uR3JvdXAiLCJ6b29tVGV4dCIsIm5hdkJ1dHRvbk9wdGlvbnMiLCJnZXRYT2Zmc2V0Rm9yRXhwb3J0QnV0dG9uIiwicGxvdExlZnQiLCJ3aWR0aF8xIiwieE9mZnNldEZvckV4cG9ydEJ1dHRvbl8xIiwieE9mZnNldEZvckV4cG9ydEJ1dHRvbiIsImFsaWduVHJhbnNsYXRlWSIsImdyb3VwSGVpZ2h0IiwibGVnZW5kSGVpZ2h0IiwibGVnZW5kT3B0aW9ucyIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmFsaWduQnV0dG9uR3JvdXAiLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5wb3NpdGlvbkJ1dHRvbnMiLCJidXR0b25MZWZ0IiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuaGFuZGxlQ29sbGlzaW9uIiwibWF4QnV0dG9uV2lkdGgiLCJidXR0b25XaWR0aCIsImJCb3giLCJncm91cHNPdmVybGFwIiwiaW5wdXRHcm91cFgiLCJpbnB1dEdyb3VwV2lkdGgiLCJidXR0b25Hcm91cFgiLCJtb3ZlSW5wdXRzRG93biIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmNvbGxhcHNlQnV0dG9ucyIsImdldEF0dHJpYnMiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImhhc0FjdGl2ZUJ1dHRvbiIsInBvc2l0aW9uQnV0dG9ucyIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLmV4cGFuZEJ1dHRvbnMiLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5jdXJyZW50QnV0dG9uSW5kZXgiLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5zaG93RHJvcGRvd24iLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5oaWRlRHJvcGRvd24iLCJSYW5nZVNlbGVjdG9yLnByb3RvdHlwZS5nZXRIZWlnaHQiLCJyYW5nZVNlbGVjdG9yR3JvdXAiLCJ5UG9zaXRpb24iLCJidXR0b25Qb3NpdGlvblkiLCJpbnB1dFBvc2l0aW9uWSIsInJhbmdlU2VsZWN0b3JIZWlnaHQiLCJtaW5Qb3NpdGlvbiIsIlJhbmdlU2VsZWN0b3IucHJvdG90eXBlLnRpdGxlQ29sbGlzaW9uIiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUudXBkYXRlIiwiUmFuZ2VTZWxlY3Rvci5wcm90b3R5cGUuZGVzdHJveSIsInJTZWxlY3RvciIsInVuYmluZCIsIndpbmRvdyIsIkF4aXMucHJvdG90eXBlLm1pbkZyb21SYW5nZSIsImdldFRydWVSYW5nZSIsInRpbWVOYW1lIiwiYmFzZVBlcmlvZCIsImNoYXJ0RGVzdHJveUV2ZW50c18xIiwiaW5pdFJhbmdlU2VsZWN0b3JfMSIsImV4dHJlbWVzIiwiYWxpZ25UbyIsImdldEF4aXNNYXJnaW5zIiwib3B0aW9uc1JhbmdlU2VsZWN0b3IiLCJleHRyYUJvdHRvbU1hcmdpbldhcyIsImV4dHJhVG9wTWFyZ2luV2FzIiwiZGVzdHJveUV2ZW50cyIsImV2ZW50cyIsIk5hdmlnYXRvckF4aXNBZGRpdGlvbnMiLCJOYXZpZ2F0b3JBeGlzQWRkaXRpb25zLnByb3RvdHlwZS5kZXN0cm95IiwiTmF2aWdhdG9yQXhpc0FkZGl0aW9ucy5wcm90b3R5cGUudG9GaXhlZFJhbmdlIiwiZml4ZWRSYW5nZSIsImhhbGZQb2ludFJhbmdlIiwiY2hhbmdlUmF0aW8iLCJmaXhlZE1heCIsIk5hdmlnYXRvckF4aXMiLCJOYXZpZ2F0b3JBeGlzLmNvbXBvc2UiLCJuYXZpZ2F0b3JBeGlzIiwicGluY2hUeXBlIiwiem9vbVR5cGUiLCJwcmV2aW91c1pvb20iLCJBZGRpdGlvbnNDbGFzcyIsImhhc1RvdWNoIiwibnVtRXh0IiwiYXJncyIsIl9pIiwibnVtYmVycyIsImRlZmF1bHRTZXJpZXNUeXBlIiwibWFza0luc2lkZSIsImhhbmRsZXMiLCJzeW1ib2xzIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyQ29sb3IiLCJtYXNrRmlsbCIsIm91dGxpbmVDb2xvciIsIm91dGxpbmVXaWR0aCIsImZpbGxPcGFjaXR5IiwiY29tcGFyZSIsImFwcHJveGltYXRpb24iLCJncm91cFBpeGVsV2lkdGgiLCJzbW9vdGhlZCIsImxpbmVDb2xvciIsIm92ZXJzY3JvbGwiLCJncmlkTGluZUNvbG9yIiwiZ3JpZExpbmVXaWR0aCIsInRpY2tQaXhlbEludGVydmFsIiwiY3Jvc3NoYWlyIiwic3RhcnRPblRpY2siLCJlbmRPblRpY2siLCJtaW5QYWRkaW5nIiwibWF4UGFkZGluZyIsImhhbGZXaWR0aCIsIm1hcmtlclBvc2l0aW9uIiwiTmF2aWdhdG9yIiwiTmF2aWdhdG9yLnByb3RvdHlwZS5kcmF3SGFuZGxlIiwibmF2aWdhdG9yT3B0aW9ucyIsInBhcnNlSW50IiwiTmF2aWdhdG9yLnByb3RvdHlwZS5kcmF3T3V0bGluZSIsIm91dGxpbmUiLCJoYWxmT3V0bGluZSIsIm91dGxpbmVDb3JyZWN0aW9uIiwib3V0bGluZUhlaWdodCIsInNjcm9sbGJhckhlaWdodCIsIm5hdmlnYXRvclNpemUiLCJuYXZpZ2F0b3JUb3AiLCJ2ZXJ0aWNhbE1pbiIsInpvb21lZE1heCIsInpvb21lZE1pbiIsIk5hdmlnYXRvci5wcm90b3R5cGUuZHJhd01hc2tzIiwibmF2aWdhdG9ySGVpZ2h0Iiwic2hhZGVzIiwic2hhZGUiLCJOYXZpZ2F0b3IucHJvdG90eXBlLnJlbmRlckVsZW1lbnRzIiwibW91c2VDdXJzb3IiLCJuYXZpZ2F0b3JHcm91cCIsInZpc2liaWxpdHkiLCJoYXNNYXNrIiwiaGFuZGxlc09wdGlvbnMiLCJOYXZpZ2F0b3IucHJvdG90eXBlLnVwZGF0ZSIsIk5hdmlnYXRvci5wcm90b3R5cGUucmVuZGVyIiwic2Nyb2xsYmFyWEF4aXMiLCJuYXZpZ2F0b3JFbmFibGVkIiwibWF4UmFuZ2UiLCJweE1pbiIsIm5hdmlnYXRvcldpZHRoIiwicHhNYXgiLCJjdXJyZW50UmFuZ2UiLCJmaXhlZFdpZHRoIiwiZHJhd01hc2tzIiwiZHJhd091dGxpbmUiLCJkcmF3SGFuZGxlIiwiTmF2aWdhdG9yLnByb3RvdHlwZS5hZGRNb3VzZUV2ZW50cyIsImV2ZW50c1RvVW5iaW5kIiwiTmF2aWdhdG9yLnByb3RvdHlwZS5nZXRQYXJ0c0V2ZW50cyIsIm5hdmlnYXRvckl0ZW0iLCJOYXZpZ2F0b3IucHJvdG90eXBlLnNoYWRlc01vdXNlZG93biIsIm5hdmlnYXRvclBvc2l0aW9uIiwicmV2ZXJzZWRFeHRyZW1lcyIsImdldFVuaW9uRXh0cmVtZXMiLCJleHQiLCJOYXZpZ2F0b3IucHJvdG90eXBlLmhhbmRsZXNNb3VzZWRvd24iLCJiYXNlWEF4aXMiLCJyZXZlcnNlIiwiZ3JhYmJlZExlZnQiLCJvdGhlckhhbmRsZVBvcyIsImZpeGVkRXh0cmVtZSIsImdyYWJiZWRSaWdodCIsIk5hdmlnYXRvci5wcm90b3R5cGUub25Nb3VzZU1vdmUiLCJkcmFnT2Zmc2V0IiwiTmF2aWdhdG9yLnByb3RvdHlwZS5vbk1vdXNlVXAiLCJmaXhlZE1pbiIsInRyaWdnZXJPcCIsIk5hdmlnYXRvci5wcm90b3R5cGUucmVtb3ZlRXZlbnRzIiwiTmF2aWdhdG9yLnByb3RvdHlwZS5yZW1vdmVCYXNlU2VyaWVzRXZlbnRzIiwiYmFzZVNlcmllcyIsIk5hdmlnYXRvci5wcm90b3R5cGUuaW5pdCIsInNjcm9sbGJhck9wdGlvbnMiLCJzY3JvbGxiYXJFbmFibGVkIiwieEF4aXNJbmRleCIsInlBeGlzSW5kZXgiLCJiYXNlWGF4aXMiLCJvcmRpbmFsIiwiaXNYIiwiaXNJbnRlcm5hbCIsImtlZXBPcmRpbmFsUGFkZGluZyIsInpvb21FbmFibGVkIiwib2Zmc2V0cyIsImFsaWduVGlja3MiLCJmYWtlIiwidHJhbnNsYXRlIiwic2Nyb2xsVHJhY2tXaWR0aCIsInZhbHVlUmFuZ2UiLCJ0b1ZhbHVlIiwic2V0VGltZW91dCIsIk5hdmlnYXRvci5wcm90b3R5cGUuZ2V0VW5pb25FeHRyZW1lcyIsIm5hdkF4aXMiLCJuYXZBeGlzT3B0aW9ucyIsImJhc2VBeGlzT3B0aW9ucyIsInJldHVybkZhbHNlT25Ob0Jhc2VTZXJpZXMiLCJOYXZpZ2F0b3IucHJvdG90eXBlLnNldEJhc2VTZXJpZXMiLCJiYXNlU2VyaWVzT3B0aW9ucyIsInNob3dJbk5hdmlnYXRvciIsIk5hdmlnYXRvci5wcm90b3R5cGUudXBkYXRlTmF2aWdhdG9yU2VyaWVzIiwiY2hhcnROYXZpZ2F0b3JTZXJpZXNPcHRpb25zIiwibmF2U2VyaWVzTWl4aW4iLCJlbmFibGVNb3VzZVRyYWNraW5nIiwicGFkWEF4aXMiLCJzaG93SW5MZWdlbmQiLCJzdGFja2luZyIsImluYWN0aXZlIiwibmF2aWdhdG9yU2VyaWVzIiwiYmFzZSIsIm5hdlNlcmllcyIsImVhY2hCYXNlU2VyaWVzIiwibGlua2VkTmF2U2VyaWVzIiwidXNlck5hdk9wdGlvbnMiLCJiYXNlT3B0aW9ucyIsImJhc2VOYXZpZ2F0b3JPcHRpb25zIiwibWVyZ2VkTmF2U2VyaWVzT3B0aW9ucyIsIm5hdmlnYXRvclNlcmllc0RhdGEiLCJ1c2VyU2VyaWVzT3B0aW9ucyIsImFkZEV2ZW50cyIsIk5hdmlnYXRvci5wcm90b3R5cGUuYWRkQmFzZVNlcmllc0V2ZW50cyIsIk5hdmlnYXRvci5wcm90b3R5cGUuZ2V0QmFzZVNlcmllc01pbiIsIk5hdmlnYXRvci5wcm90b3R5cGUubW9kaWZ5TmF2aWdhdG9yQXhpc0V4dHJlbWVzIiwiTmF2aWdhdG9yLnByb3RvdHlwZS5tb2RpZnlCYXNlQXhpc0V4dHJlbWVzIiwiYmFzZUV4dHJlbWVzIiwiYmFzZURhdGFNaW4iLCJiYXNlRGF0YU1heCIsInN0aWNrVG9NaW4iLCJzdGlja1RvTWF4IiwiaGFzU2V0RXh0cmVtZXMiLCJzZXRFeHRyZW1lcyIsImV2ZW50QXJncyIsInVzZXJNaW4iLCJOYXZpZ2F0b3IucHJvdG90eXBlLnVwZGF0ZWREYXRhSGFuZGxlciIsInhEYXRhTWluIiwiTmF2aWdhdG9yLnByb3RvdHlwZS5hZGRDaGFydEV2ZW50cyIsIm1hcmdpbk5hbWUiLCJOYXZpZ2F0b3IucHJvdG90eXBlLmRlc3Ryb3kiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQVVDLFdBQVMsQ0FBVCxFQUFtQjtBQUNoQixXQUFrQ0EsT0FBbEMsV0FDSUMsZUFBcUJBLENBQXJCQSxFQUNBLGlCQUZKLEtBR08sUUFDSEMsaUNBQW1DLENBQW5DQSx3QkFBbUMsQ0FBbkNBLG1DQUFt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QUFrQyxZQUFZO0FBQ3RDLFdBQUosU0FBSSxJQUVBLG1DQUFtQyxDQUhHLENBR3RDLENBRkE7QUFEUkEsTUF4R0ErRyxFQStHQS9HLG9CQUFnQyxZQUFZO0FBQ3BDLGlCQUFKLFNBQUksSUFBd0IsQ0FBQyxhQUE3QixVQUFJLElBQ0EseUNBQXlDLENBRkwsQ0FFcEMsQ0FEQTtBQURSQSxNQS9HQStHLEVBb0hBLDJCQUErQixVQUFTLENBQVQsRUFBaUI7QUFDNUMsVUFDSXNrQixJQUFZNXBCLFdBRGhCO0FBR0k0cEIsT0FBSixJQUFpQjVwQixRQUFqQixDQUFpQkEsQ0FBYjRwQixLQUNBK1IsQ0FDQSxHQURXMzdCLHdCQUFYMjdCLEVBQ0EsU0FBaUJBLEVBQWpCLEtBQStCQSxFQU5TLEdBTXhDLENBRkEvUjtBQXpIWixLQXFISSxDQXJIQ3RrQjtBQStITEEsa0JBQWMwNUIsQ0FBZDE1QjtBQUVBLFdBQU9BLEVBbmhFMGYsU0FtaEVqZ0I7QUFuaEVKaEo7QUFxaEVBLDJDQUE4RCxZQUFZLENBdjJadEQsQ0F1MlpwQjtBQXAzWkgiLCJmaWxlIjoiNTY0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiBIaWdoY2hhcnRzIEdhbnR0IEpTIHY5LjAuMSAoMjAyMS0wMi0xNSlcblxuIEdhbnR0IHNlcmllc1xuXG4gKGMpIDIwMTYtMjAyMSBMYXJzIEEuIFYuIENhYnJlcmFcblxuIExpY2Vuc2U6IHd3dy5oaWdoY2hhcnRzLmNvbS9saWNlbnNlXG4qL1xuKGZ1bmN0aW9uKGEpe1wib2JqZWN0XCI9PT10eXBlb2YgbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz8oYVtcImRlZmF1bHRcIl09YSxtb2R1bGUuZXhwb3J0cz1hKTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShcImhpZ2hjaGFydHMvbW9kdWxlcy9nYW50dFwiLFtcImhpZ2hjaGFydHNcIl0sZnVuY3Rpb24oRil7YShGKTthLkhpZ2hjaGFydHM9RjtyZXR1cm4gYX0pOmEoXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBIaWdoY2hhcnRzP0hpZ2hjaGFydHM6dm9pZCAwKX0pKGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIEYoYSx1LHQscil7YS5oYXNPd25Qcm9wZXJ0eSh1KXx8KGFbdV09ci5hcHBseShudWxsLHQpKX1hPWE/YS5fbW9kdWxlczp7fTtGKGEsXCJTZXJpZXMvWFJhbmdlL1hSYW5nZVBvaW50LmpzXCIsW2FbXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiXSxhW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl1dLGZ1bmN0aW9uKGEsdSl7dmFyIHQ9dGhpcyYmdGhpcy5fX2V4dGVuZHN8fFxuZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbihuLGgpe2E9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGgsYSl7aC5fX3Byb3RvX189YX18fGZ1bmN0aW9uKGgsYSl7Zm9yKHZhciBEIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShEKSYmKGhbRF09YVtEXSl9O3JldHVybiBhKG4saCl9O3JldHVybiBmdW5jdGlvbihuLGgpe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPW59YShuLGgpO24ucHJvdG90eXBlPW51bGw9PT1oP09iamVjdC5jcmVhdGUoaCk6KHIucHJvdG90eXBlPWgucHJvdG90eXBlLG5ldyByKX19KCk7cmV0dXJuIGZ1bmN0aW9uKHIpe2Z1bmN0aW9uIG4oKXt2YXIgaD1udWxsIT09ciYmci5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7aC5vcHRpb25zPXZvaWQgMDtoLnNlcmllcz12b2lkIDA7aC50b29sdGlwRGF0ZUtleXM9W1wieFwiLFwieDJcIl07cmV0dXJuIGh9dChuLHIpO24uZ2V0Q29sb3JCeUNhdGVnb3J5PVxuZnVuY3Rpb24oaCxhKXt2YXIgbj1oLm9wdGlvbnMuY29sb3JzfHxoLmNoYXJ0Lm9wdGlvbnMuY29sb3JzO2g9YS55JShuP24ubGVuZ3RoOmguY2hhcnQub3B0aW9ucy5jaGFydC5jb2xvckNvdW50KTtyZXR1cm57Y29sb3JJbmRleDpoLGNvbG9yOm4mJm5baF19fTtuLnByb3RvdHlwZS5yZXNvbHZlQ29sb3I9ZnVuY3Rpb24oKXt2YXIgaD10aGlzLnNlcmllcztpZihoLm9wdGlvbnMuY29sb3JCeVBvaW50JiYhdGhpcy5vcHRpb25zLmNvbG9yKXt2YXIgYT1uLmdldENvbG9yQnlDYXRlZ29yeShoLHRoaXMpO2guY2hhcnQuc3R5bGVkTW9kZXx8KHRoaXMuY29sb3I9YS5jb2xvcik7dGhpcy5vcHRpb25zLmNvbG9ySW5kZXh8fCh0aGlzLmNvbG9ySW5kZXg9YS5jb2xvckluZGV4KX1lbHNlIHRoaXMuY29sb3J8fCh0aGlzLmNvbG9yPWguY29sb3IpfTtuLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKCl7YS5wcm90b3R5cGUuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhpcy55fHwodGhpcy55PVxuMCk7cmV0dXJuIHRoaXN9O24ucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKCl7YS5wcm90b3R5cGUuc2V0U3RhdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMuc2VyaWVzLmRyYXdQb2ludCh0aGlzLHRoaXMuc2VyaWVzLmdldEFuaW1hdGlvblZlcmIoKSl9O24ucHJvdG90eXBlLmdldExhYmVsQ29uZmlnPWZ1bmN0aW9uKCl7dmFyIGg9YS5wcm90b3R5cGUuZ2V0TGFiZWxDb25maWcuY2FsbCh0aGlzKSxuPXRoaXMuc2VyaWVzLnlBeGlzLmNhdGVnb3JpZXM7aC54Mj10aGlzLngyO2gueUNhdGVnb3J5PXRoaXMueUNhdGVnb3J5PW4mJm5bdGhpcy55XTtyZXR1cm4gaH07bi5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVyblwibnVtYmVyXCI9PT10eXBlb2YgdGhpcy54JiZcIm51bWJlclwiPT09dHlwZW9mIHRoaXMueDJ9O3JldHVybiBufSh1LnNlcmllc1R5cGVzLmNvbHVtbi5wcm90b3R5cGUucG9pbnRDbGFzcyl9KTtGKGEsXCJTZXJpZXMvWFJhbmdlL1hSYW5nZUNvbXBvc2l0aW9uLmpzXCIsXG5bYVtcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLGFbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oYSx1KXt2YXIgdD11LmFkZEV2ZW50LHI9dS5waWNrO3QoYSxcImFmdGVyR2V0U2VyaWVzRXh0cmVtZXNcIixmdW5jdGlvbigpe3ZhciBhPXRoaXMuc2VyaWVzLGg7aWYodGhpcy5pc1hBeGlzKXt2YXIgdD1yKHRoaXMuZGF0YU1heCwtTnVtYmVyLk1BWF9WQUxVRSk7YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EueDJEYXRhJiZhLngyRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2E+dCYmKHQ9YSxoPSEwKX0pfSk7aCYmKHRoaXMuZGF0YU1heD10KX19KX0pO0YoYSxcIlNlcmllcy9YUmFuZ2UvWFJhbmdlU2VyaWVzLmpzXCIsW2FbXCJDb3JlL0dsb2JhbHMuanNcIl0sYVtcIkNvcmUvQ29sb3IvQ29sb3IuanNcIl0sYVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGFbXCJDb3JlL1V0aWxpdGllcy5qc1wiXSxhW1wiU2VyaWVzL1hSYW5nZS9YUmFuZ2VQb2ludC5qc1wiXV0sZnVuY3Rpb24oYSx1LHQsXG5yLG4pe3ZhciBoPXRoaXMmJnRoaXMuX19leHRlbmRzfHxmdW5jdGlvbigpe3ZhciBjPWZ1bmN0aW9uKGQsYil7Yz1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fHtfX3Byb3RvX186W119aW5zdGFuY2VvZiBBcnJheSYmZnVuY3Rpb24oYixkKXtiLl9fcHJvdG9fXz1kfXx8ZnVuY3Rpb24oYixkKXtmb3IodmFyIGMgaW4gZClkLmhhc093blByb3BlcnR5KGMpJiYoYltjXT1kW2NdKX07cmV0dXJuIGMoZCxiKX07cmV0dXJuIGZ1bmN0aW9uKGQsYil7ZnVuY3Rpb24gSigpe3RoaXMuY29uc3RydWN0b3I9ZH1jKGQsYik7ZC5wcm90b3R5cGU9bnVsbD09PWI/T2JqZWN0LmNyZWF0ZShiKTooSi5wcm90b3R5cGU9Yi5wcm90b3R5cGUsbmV3IEopfX0oKSxBPXUucGFyc2UsQj10LnNlcmllcyxEPXQuc2VyaWVzVHlwZXMuY29sdW1uLHA9RC5wcm90b3R5cGUsdz1yLmNsYW1wLGs9ci5jb3JyZWN0RmxvYXQsZj1yLmRlZmluZWQ7dT1yLmV4dGVuZDt2YXIgdj1yLmZpbmQsZT1yLmlzTnVtYmVyLGc9ci5pc09iamVjdCxcbm09ci5tZXJnZSxxPXIucGljaztyPWZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoKXt2YXIgYj1udWxsIT09YyYmYy5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7Yi5kYXRhPXZvaWQgMDtiLm9wdGlvbnM9dm9pZCAwO2IucG9pbnRzPXZvaWQgMDtyZXR1cm4gYn1oKGQsYyk7ZC5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbigpe0QucHJvdG90eXBlLmluaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3RoaXMub3B0aW9ucy5zdGFja2luZz12b2lkIDB9O2QucHJvdG90eXBlLmdldENvbHVtbk1ldHJpY3M9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7ZC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihiKXt2YXIgZD1iLnhBeGlzO2IueEF4aXM9Yi55QXhpcztiLnlBeGlzPWR9KX12YXIgZD10aGlzLmNoYXJ0O2IoKTt2YXIgYz1wLmdldENvbHVtbk1ldHJpY3MuY2FsbCh0aGlzKTtiKCk7cmV0dXJuIGN9O2QucHJvdG90eXBlLmNyb3BEYXRhPWZ1bmN0aW9uKGIsZCxjLGcpe2Q9Qi5wcm90b3R5cGUuY3JvcERhdGEuY2FsbCh0aGlzLFxudGhpcy54MkRhdGEsZCxjLGcpO2QueERhdGE9Yi5zbGljZShkLnN0YXJ0LGQuZW5kKTtyZXR1cm4gZH07ZC5wcm90b3R5cGUuZmluZFBvaW50SW5kZXg9ZnVuY3Rpb24oYil7dmFyIGQ9dGhpcy5jcm9wcGVkLGM9dGhpcy5jcm9wU3RhcnQsZz10aGlzLnBvaW50cyxxPWIuaWQ7aWYocSl2YXIgbT0obT12KGcsZnVuY3Rpb24oYil7cmV0dXJuIGIuaWQ9PT1xfSkpP20uaW5kZXg6dm9pZCAwO1widW5kZWZpbmVkXCI9PT10eXBlb2YgbSYmKG09KG09dihnLGZ1bmN0aW9uKGQpe3JldHVybiBkLng9PT1iLngmJmQueDI9PT1iLngyJiYhZC50b3VjaGVkfSkpP20uaW5kZXg6dm9pZCAwKTtkJiZlKG0pJiZlKGMpJiZtPj1jJiYobS09Yyk7cmV0dXJuIG19O2QucHJvdG90eXBlLnRyYW5zbGF0ZVBvaW50PWZ1bmN0aW9uKGIpe3ZhciBkLGMscD10aGlzLnhBeGlzLHY9dGhpcy55QXhpcyxrPXRoaXMuY29sdW1uTWV0cmljcyxDPXRoaXMub3B0aW9ucyxhPUMubWluUG9pbnRMZW5ndGh8fDAsRT0obnVsbD09PVxuKGQ9Yi5zaGFwZUFyZ3MpfHx2b2lkIDA9PT1kP05hTjpkLndpZHRoKS8yLHk9dGhpcy5wb2ludFhPZmZzZXQ9ay5vZmZzZXQ7ZD1iLnBsb3RYO3ZhciB6PXEoYi54MixiLngrKGIubGVufHwwKSksbD1wLnRyYW5zbGF0ZSh6LDAsMCwwLDEpO3o9TWF0aC5hYnMobC1kKTt2YXIgeD10aGlzLmNoYXJ0LmludmVydGVkLEc9cShDLmJvcmRlcldpZHRoLDEpJTIvMixPPWsub2Zmc2V0LE49TWF0aC5yb3VuZChrLndpZHRoKTthJiYoYS09eiwwPmEmJihhPTApLGQtPWEvMixsKz1hLzIpO2Q9TWF0aC5tYXgoZCwtMTApO2w9dyhsLC0xMCxwLmxlbisxMCk7ZihiLm9wdGlvbnMucG9pbnRXaWR0aCkmJihPLT0oTWF0aC5jZWlsKGIub3B0aW9ucy5wb2ludFdpZHRoKS1OKS8yLE49TWF0aC5jZWlsKGIub3B0aW9ucy5wb2ludFdpZHRoKSk7Qy5wb2ludFBsYWNlbWVudCYmZShiLnBsb3RZKSYmdi5jYXRlZ29yaWVzJiYoYi5wbG90WT12LnRyYW5zbGF0ZShiLnksMCwxLDAsMSxDLnBvaW50UGxhY2VtZW50KSk7XG5iLnNoYXBlQXJncz17eDpNYXRoLmZsb29yKE1hdGgubWluKGQsbCkpK0cseTpNYXRoLmZsb29yKGIucGxvdFkrTykrRyx3aWR0aDpNYXRoLnJvdW5kKE1hdGguYWJzKGwtZCkpLGhlaWdodDpOLHI6dGhpcy5vcHRpb25zLmJvcmRlclJhZGl1c307eD9iLnRvb2x0aXBQb3NbMV0rPXkrRTpiLnRvb2x0aXBQb3NbMF0tPUUreS0obnVsbD09PShjPWIuc2hhcGVBcmdzKXx8dm9pZCAwPT09Yz9OYU46Yy53aWR0aCkvMjtjPWIuc2hhcGVBcmdzLng7Qz1jK2Iuc2hhcGVBcmdzLndpZHRoOzA+Y3x8Qz5wLmxlbj8oYz13KGMsMCxwLmxlbiksQz13KEMsMCxwLmxlbiksRT1DLWMsYi5kbEJveD1tKGIuc2hhcGVBcmdzLHt4OmMsd2lkdGg6Qy1jLGNlbnRlclg6RT9FLzI6bnVsbH0pKTpiLmRsQm94PW51bGw7Yz1iLnRvb2x0aXBQb3M7Qz14PzE6MDtFPXg/MDoxO2s9dGhpcy5jb2x1bW5NZXRyaWNzP3RoaXMuY29sdW1uTWV0cmljcy5vZmZzZXQ6LWsud2lkdGgvMjtjW0NdPXg/Y1tDXStiLnNoYXBlQXJncy53aWR0aC9cbjI6Y1tDXSsocC5yZXZlcnNlZD8tMTowKSpiLnNoYXBlQXJncy53aWR0aDtjW0VdPXcoY1tFXSsoeD8tMToxKSprLDAsdi5sZW4tMSk7aWYoaz1iLnBhcnRpYWxGaWxsKWcoaykmJihrPWsuYW1vdW50KSxlKGspfHwoaz0wKSx2PWIuc2hhcGVBcmdzLGIucGFydFNoYXBlQXJncz17eDp2LngseTp2Lnksd2lkdGg6di53aWR0aCxoZWlnaHQ6di5oZWlnaHQscjp0aGlzLm9wdGlvbnMuYm9yZGVyUmFkaXVzfSxkPU1hdGgubWF4KE1hdGgucm91bmQoeiprK2IucGxvdFgtZCksMCksYi5jbGlwUmVjdEFyZ3M9e3g6cC5yZXZlcnNlZD92Lngrei1kOnYueCx5OnYueSx3aWR0aDpkLGhlaWdodDp2LmhlaWdodH19O2QucHJvdG90eXBlLnRyYW5zbGF0ZT1mdW5jdGlvbigpe3AudHJhbnNsYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aGlzLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGIpe3RoaXMudHJhbnNsYXRlUG9pbnQoYil9LHRoaXMpfTtkLnByb3RvdHlwZS5kcmF3UG9pbnQ9ZnVuY3Rpb24oYixcbmQpe3ZhciBjPXRoaXMub3B0aW9ucyxKPXRoaXMuY2hhcnQucmVuZGVyZXIsZT1iLmdyYXBoaWMsZj1iLnNoYXBlVHlwZSxwPWIuc2hhcGVBcmdzLHY9Yi5wYXJ0U2hhcGVBcmdzLEU9Yi5jbGlwUmVjdEFyZ3MseT1iLnBhcnRpYWxGaWxsLHo9Yy5zdGFja2luZyYmIWMuYm9yZGVyUmFkaXVzLGw9Yi5zdGF0ZSx4PWMuc3RhdGVzW2x8fFwibm9ybWFsXCJdfHx7fSxHPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgbD9cImF0dHJcIjpkO2w9dGhpcy5wb2ludEF0dHJpYnMoYixsKTt4PXEodGhpcy5jaGFydC5vcHRpb25zLmNoYXJ0LmFuaW1hdGlvbix4LmFuaW1hdGlvbik7aWYoYi5pc051bGx8fCExPT09Yi52aXNpYmxlKWUmJihiLmdyYXBoaWM9ZS5kZXN0cm95KCkpO2Vsc2V7aWYoZSllLnJlY3RbZF0ocCk7ZWxzZSBiLmdyYXBoaWM9ZT1KLmcoXCJwb2ludFwiKS5hZGRDbGFzcyhiLmdldENsYXNzTmFtZSgpKS5hZGQoYi5ncm91cHx8dGhpcy5ncm91cCksZS5yZWN0PUpbZl0obShwKSkuYWRkQ2xhc3MoYi5nZXRDbGFzc05hbWUoKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBhcnRmaWxsLW9yaWdpbmFsXCIpLmFkZChlKTtcbnYmJihlLnBhcnRSZWN0PyhlLnBhcnRSZWN0W2RdKG0odikpLGUucGFydGlhbENsaXBSZWN0W2RdKG0oRSkpKTooZS5wYXJ0aWFsQ2xpcFJlY3Q9Si5jbGlwUmVjdChFLngsRS55LEUud2lkdGgsRS5oZWlnaHQpLGUucGFydFJlY3Q9SltmXSh2KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtcGFydGZpbGwtb3ZlcmxheVwiKS5hZGQoZSkuY2xpcChlLnBhcnRpYWxDbGlwUmVjdCkpKTt0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fChlLnJlY3RbZF0obCx4KS5zaGFkb3coYy5zaGFkb3csbnVsbCx6KSx2JiYoZyh5KXx8KHk9e30pLGcoYy5wYXJ0aWFsRmlsbCkmJih5PW0oYy5wYXJ0aWFsRmlsbCx5KSksYj15LmZpbGx8fEEobC5maWxsKS5icmlnaHRlbigtLjMpLmdldCgpfHxBKGIuY29sb3J8fHRoaXMuY29sb3IpLmJyaWdodGVuKC0uMykuZ2V0KCksbC5maWxsPWIsZS5wYXJ0UmVjdFtHXShsLHgpLnNoYWRvdyhjLnNoYWRvdyxudWxsLHopKSl9fTtkLnByb3RvdHlwZS5kcmF3UG9pbnRzPWZ1bmN0aW9uKCl7dmFyIGI9XG50aGlzLGQ9Yi5nZXRBbmltYXRpb25WZXJiKCk7Yi5wb2ludHMuZm9yRWFjaChmdW5jdGlvbihjKXtiLmRyYXdQb2ludChjLGQpfSl9O2QucHJvdG90eXBlLmdldEFuaW1hdGlvblZlcmI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGFydC5wb2ludENvdW50PCh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uTGltaXR8fDI1MCk/XCJhbmltYXRlXCI6XCJhdHRyXCJ9O2QucHJvdG90eXBlLmlzUG9pbnRJbnNpZGU9ZnVuY3Rpb24oYil7dmFyIGQ9Yi5zaGFwZUFyZ3MsZz1iLnBsb3RYLHE9Yi5wbG90WTtyZXR1cm4gZD9cInVuZGVmaW5lZFwiIT09dHlwZW9mIGcmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgcSYmMDw9cSYmcTw9dGhpcy55QXhpcy5sZW4mJjA8PWQueCtkLndpZHRoJiZnPD10aGlzLnhBeGlzLmxlbjpjLnByb3RvdHlwZS5pc1BvaW50SW5zaWRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07ZC5kZWZhdWx0T3B0aW9ucz1tKEQuZGVmYXVsdE9wdGlvbnMse2NvbG9yQnlQb2ludDohMCxkYXRhTGFiZWxzOntmb3JtYXR0ZXI6ZnVuY3Rpb24oKXt2YXIgYj1cbnRoaXMucG9pbnQucGFydGlhbEZpbGw7ZyhiKSYmKGI9Yi5hbW91bnQpO2lmKGUoYikmJjA8YilyZXR1cm4gaygxMDAqYikrXCIlXCJ9LGluc2lkZTohMCx2ZXJ0aWNhbEFsaWduOlwibWlkZGxlXCJ9LHRvb2x0aXA6e2hlYWRlckZvcm1hdDonPHNwYW4gc3R5bGU9XCJmb250LXNpemU6IDEwcHhcIj57cG9pbnQueH0gLSB7cG9pbnQueDJ9PC9zcGFuPjxici8+Jyxwb2ludEZvcm1hdDonPHNwYW4gc3R5bGU9XCJjb2xvcjp7cG9pbnQuY29sb3J9XCI+XFx1MjVjZjwvc3Bhbj4ge3Nlcmllcy5uYW1lfTogPGI+e3BvaW50LnlDYXRlZ29yeX08L2I+PGJyLz4nfSxib3JkZXJSYWRpdXM6Myxwb2ludFJhbmdlOjB9KTtyZXR1cm4gZH0oRCk7dShyLnByb3RvdHlwZSx7dHlwZTpcInhyYW5nZVwiLHBhcmFsbGVsQXJyYXlzOltcInhcIixcIngyXCIsXCJ5XCJdLHJlcXVpcmVTb3J0aW5nOiExLGFuaW1hdGU6Qi5wcm90b3R5cGUuYW5pbWF0ZSxjcm9wU2hvdWxkZXI6MSxnZXRFeHRyZW1lc0Zyb21BbGw6ITAsYXV0b0luY3JlbWVudDphLm5vb3AsXG5idWlsZEtEVHJlZTphLm5vb3AscG9pbnRDbGFzczpufSk7dC5yZWdpc3RlclNlcmllc1R5cGUoXCJ4cmFuZ2VcIixyKTtcIlwiO3JldHVybiByfSk7RihhLFwiU2VyaWVzL0dhbnR0L0dhbnR0UG9pbnQuanNcIixbYVtcIkNvcmUvU2VyaWVzL1Nlcmllc1JlZ2lzdHJ5LmpzXCJdLGFbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oYSx1KXt2YXIgdD10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbihoLG4pe2E9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGEsaCl7YS5fX3Byb3RvX189aH18fGZ1bmN0aW9uKGEsaCl7Zm9yKHZhciBwIGluIGgpaC5oYXNPd25Qcm9wZXJ0eShwKSYmKGFbcF09aFtwXSl9O3JldHVybiBhKGgsbil9O3JldHVybiBmdW5jdGlvbihoLG4pe2Z1bmN0aW9uIHIoKXt0aGlzLmNvbnN0cnVjdG9yPWh9YShoLG4pO2gucHJvdG90eXBlPW51bGw9PT1uP09iamVjdC5jcmVhdGUobik6XG4oci5wcm90b3R5cGU9bi5wcm90b3R5cGUsbmV3IHIpfX0oKSxyPXUucGljaztyZXR1cm4gZnVuY3Rpb24oYSl7ZnVuY3Rpb24gaCgpe3ZhciBoPW51bGwhPT1hJiZhLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8dGhpcztoLm9wdGlvbnM9dm9pZCAwO2guc2VyaWVzPXZvaWQgMDtyZXR1cm4gaH10KGgsYSk7aC5zZXRHYW50dFBvaW50QWxpYXNlcz1mdW5jdGlvbihhKXtmdW5jdGlvbiBoKGgscCl7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBwJiYoYVtoXT1wKX1oKFwieFwiLHIoYS5zdGFydCxhLngpKTtoKFwieDJcIixyKGEuZW5kLGEueDIpKTtoKFwicGFydGlhbEZpbGxcIixyKGEuY29tcGxldGVkLGEucGFydGlhbEZpbGwpKX07aC5wcm90b3R5cGUuYXBwbHlPcHRpb25zPWZ1bmN0aW9uKG4scil7bj1hLnByb3RvdHlwZS5hcHBseU9wdGlvbnMuY2FsbCh0aGlzLG4scik7aC5zZXRHYW50dFBvaW50QWxpYXNlcyhuKTtyZXR1cm4gbn07aC5wcm90b3R5cGUuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybihcIm51bWJlclwiPT09XG50eXBlb2YgdGhpcy5zdGFydHx8XCJudW1iZXJcIj09PXR5cGVvZiB0aGlzLngpJiYoXCJudW1iZXJcIj09PXR5cGVvZiB0aGlzLmVuZHx8XCJudW1iZXJcIj09PXR5cGVvZiB0aGlzLngyfHx0aGlzLm1pbGVzdG9uZSl9O3JldHVybiBofShhLnNlcmllc1R5cGVzLnhyYW5nZS5wcm90b3R5cGUucG9pbnRDbGFzcyl9KTtGKGEsXCJHYW50dC9UcmVlLmpzXCIsW2FbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oYSl7dmFyIHU9YS5leHRlbmQsdD1hLmlzTnVtYmVyLHI9YS5waWNrLG49ZnVuY3Rpb24oYSxoKXt2YXIgbj1hLnJlZHVjZShmdW5jdGlvbihwLGEpe3ZhciBrPXIoYS5wYXJlbnQsXCJcIik7XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBwW2tdJiYocFtrXT1bXSk7cFtrXS5wdXNoKGEpO3JldHVybiBwfSx7fSk7T2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbihwLGEpe3ZhciBrPW5bcF07XCJcIiE9PXAmJi0xPT09aC5pbmRleE9mKHApJiYoay5mb3JFYWNoKGZ1bmN0aW9uKGYpe2FbXCJcIl0ucHVzaChmKX0pLFxuZGVsZXRlIGFbcF0pfSk7cmV0dXJuIG59LGg9ZnVuY3Rpb24oYSxuLEQscCx3LGspe3ZhciBmPTAsdj0wLGU9ayYmay5hZnRlcixnPWsmJmsuYmVmb3JlO249e2RhdGE6cCxkZXB0aDpELTEsaWQ6YSxsZXZlbDpELHBhcmVudDpufTt2YXIgbSxxO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBnJiZnKG4sayk7Zz0od1thXXx8W10pLm1hcChmdW5jdGlvbihjKXt2YXIgZD1oKGMuaWQsYSxEKzEsYyx3LGspLGI9Yy5zdGFydDtjPSEwPT09Yy5taWxlc3RvbmU/YjpjLmVuZDttPSF0KG0pfHxiPG0/YjptO3E9IXQocSl8fGM+cT9jOnE7Zj1mKzErZC5kZXNjZW5kYW50czt2PU1hdGgubWF4KGQuaGVpZ2h0KzEsdik7cmV0dXJuIGR9KTtwJiYocC5zdGFydD1yKHAuc3RhcnQsbSkscC5lbmQ9cihwLmVuZCxxKSk7dShuLHtjaGlsZHJlbjpnLGRlc2NlbmRhbnRzOmYsaGVpZ2h0OnZ9KTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZSYmZShuLGspO3JldHVybiBufTtyZXR1cm57Z2V0TGlzdE9mUGFyZW50czpuLFxuZ2V0Tm9kZTpoLGdldFRyZWU6ZnVuY3Rpb24oYSxyKXt2YXIgRD1hLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYS5pZH0pO2E9bihhLEQpO3JldHVybiBoKFwiXCIsbnVsbCwxLG51bGwsYSxyKX19fSk7RihhLFwiQ29yZS9BeGlzL1RyZWVHcmlkVGljay5qc1wiLFthW1wiQ29yZS9Db2xvci9QYWxldHRlLmpzXCJdLGFbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oYSx1KXt2YXIgdD11LmFkZEV2ZW50LHI9dS5pc09iamVjdCxuPXUuaXNOdW1iZXIsaD11LnBpY2ssQT11LndyYXAsQjsoZnVuY3Rpb24oRCl7ZnVuY3Rpb24gcCgpe3RoaXMudHJlZUdyaWR8fCh0aGlzLnRyZWVHcmlkPW5ldyBlKHRoaXMpKX1mdW5jdGlvbiB3KGcsZSl7Zz1nLnRyZWVHcmlkO3ZhciBxPSFnLmxhYmVsSWNvbixjPWUucmVuZGVyZXIsZD1lLnh5LGI9ZS5vcHRpb25zLEo9Yi53aWR0aCxtPWIuaGVpZ2h0LGY9ZC54LUovMi1iLnBhZGRpbmc7ZD1kLnktbS8yO3ZhciB2PWUuY29sbGFwc2VkPzkwOjE4MCxwPWUuc2hvdyYmXG5uKGQpLGs9Zy5sYWJlbEljb247a3x8KGcubGFiZWxJY29uPWs9Yy5wYXRoKGMuc3ltYm9sc1tiLnR5cGVdKGIueCxiLnksSixtKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWxhYmVsLWljb25cIikuYWRkKGUuZ3JvdXApKTtwfHxrLmF0dHIoe3k6LTk5OTl9KTtjLnN0eWxlZE1vZGV8fGsuYXR0cih7XCJzdHJva2Utd2lkdGhcIjoxLGZpbGw6aChlLmNvbG9yLGEubmV1dHJhbENvbG9yNjApfSkuY3NzKHtjdXJzb3I6XCJwb2ludGVyXCIsc3Ryb2tlOmIubGluZUNvbG9yLHN0cm9rZVdpZHRoOmIubGluZVdpZHRofSk7a1txP1wiYXR0clwiOlwiYW5pbWF0ZVwiXSh7dHJhbnNsYXRlWDpmLHRyYW5zbGF0ZVk6ZCxyb3RhdGlvbjp2fSl9ZnVuY3Rpb24gayhnLGUscSxjLGQsYixKLGYsYSl7dmFyIG09aCh0aGlzLm9wdGlvbnMmJnRoaXMub3B0aW9ucy5sYWJlbHMsYik7Yj10aGlzLnBvczt2YXIgST10aGlzLmF4aXMsdj1cInRyZWVncmlkXCI9PT1JLm9wdGlvbnMudHlwZTtnPWcuYXBwbHkodGhpcyxbZSxxLGMsXG5kLG0sSixmLGFdKTt2JiYoZT1tJiZyKG0uc3ltYm9sLCEwKT9tLnN5bWJvbDp7fSxtPW0mJm4obS5pbmRlbnRhdGlvbik/bS5pbmRlbnRhdGlvbjowLGI9KGI9KEk9SS50cmVlR3JpZC5tYXBPZlBvc1RvR3JpZE5vZGUpJiZJW2JdKSYmYi5kZXB0aHx8MSxnLngrPWUud2lkdGgrMiplLnBhZGRpbmcrKGItMSkqbSk7cmV0dXJuIGd9ZnVuY3Rpb24gZihnKXt2YXIgZT10aGlzLHE9ZS5wb3MsYz1lLmF4aXMsZD1lLmxhYmVsLGI9Yy50cmVlR3JpZC5tYXBPZlBvc1RvR3JpZE5vZGUsSj1jLm9wdGlvbnMsZj1oKGUub3B0aW9ucyYmZS5vcHRpb25zLmxhYmVscyxKJiZKLmxhYmVscyksYT1mJiZyKGYuc3ltYm9sLCEwKT9mLnN5bWJvbDp7fSx2PShiPWImJmJbcV0pJiZiLmRlcHRoO0o9XCJ0cmVlZ3JpZFwiPT09Si50eXBlO3ZhciBwPS0xPGMudGlja1Bvc2l0aW9ucy5pbmRleE9mKHEpO3E9Yy5jaGFydC5zdHlsZWRNb2RlO0omJmImJmQmJmQuZWxlbWVudCYmZC5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJlZWdyaWQtbm9kZS1sZXZlbC1cIitcbnYpO2cuYXBwbHkoZSxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpO0omJmQmJmQuZWxlbWVudCYmYiYmYi5kZXNjZW5kYW50cyYmMDxiLmRlc2NlbmRhbnRzJiYoYz1jLnRyZWVHcmlkLmlzQ29sbGFwc2VkKGIpLHcoZSx7Y29sb3I6IXEmJmQuc3R5bGVzJiZkLnN0eWxlcy5jb2xvcnx8XCJcIixjb2xsYXBzZWQ6Yyxncm91cDpkLnBhcmVudEdyb3VwLG9wdGlvbnM6YSxyZW5kZXJlcjpkLnJlbmRlcmVyLHNob3c6cCx4eTpkLnh5fSksYT1cImhpZ2hjaGFydHMtdHJlZWdyaWQtbm9kZS1cIisoYz9cImV4cGFuZGVkXCI6XCJjb2xsYXBzZWRcIiksZC5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJlZWdyaWQtbm9kZS1cIisoYz9cImNvbGxhcHNlZFwiOlwiZXhwYW5kZWRcIikpLnJlbW92ZUNsYXNzKGEpLHF8fGQuY3NzKHtjdXJzb3I6XCJwb2ludGVyXCJ9KSxbZCxlLnRyZWVHcmlkLmxhYmVsSWNvbl0uZm9yRWFjaChmdW5jdGlvbihiKXtiJiYhYi5hdHRhY2hlZFRyZWVHcmlkRXZlbnRzJiZcbih0KGIuZWxlbWVudCxcIm1vdXNlb3ZlclwiLGZ1bmN0aW9uKCl7ZC5hZGRDbGFzcyhcImhpZ2hjaGFydHMtdHJlZWdyaWQtbm9kZS1hY3RpdmVcIik7ZC5yZW5kZXJlci5zdHlsZWRNb2RlfHxkLmNzcyh7dGV4dERlY29yYXRpb246XCJ1bmRlcmxpbmVcIn0pfSksdChiLmVsZW1lbnQsXCJtb3VzZW91dFwiLGZ1bmN0aW9uKCl7dmFyIGI9cihmLnN0eWxlKT9mLnN0eWxlOnt9O2QucmVtb3ZlQ2xhc3MoXCJoaWdoY2hhcnRzLXRyZWVncmlkLW5vZGUtYWN0aXZlXCIpO2QucmVuZGVyZXIuc3R5bGVkTW9kZXx8ZC5jc3Moe3RleHREZWNvcmF0aW9uOmIudGV4dERlY29yYXRpb259KX0pLHQoYi5lbGVtZW50LFwiY2xpY2tcIixmdW5jdGlvbigpe2UudHJlZUdyaWQudG9nZ2xlQ29sbGFwc2UoKX0pLGIuYXR0YWNoZWRUcmVlR3JpZEV2ZW50cz0hMCl9KSl9dmFyIHY9ITE7RC5jb21wb3NlPWZ1bmN0aW9uKGUpe3Z8fCh0KGUsXCJpbml0XCIscCksQShlLnByb3RvdHlwZSxcImdldExhYmVsUG9zaXRpb25cIixrKSxBKGUucHJvdG90eXBlLFxuXCJyZW5kZXJMYWJlbFwiLGYpLGUucHJvdG90eXBlLmNvbGxhcHNlPWZ1bmN0aW9uKGUpe3RoaXMudHJlZUdyaWQuY29sbGFwc2UoZSl9LGUucHJvdG90eXBlLmV4cGFuZD1mdW5jdGlvbihlKXt0aGlzLnRyZWVHcmlkLmV4cGFuZChlKX0sZS5wcm90b3R5cGUudG9nZ2xlQ29sbGFwc2U9ZnVuY3Rpb24oZSl7dGhpcy50cmVlR3JpZC50b2dnbGVDb2xsYXBzZShlKX0sdj0hMCl9O3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZShlKXt0aGlzLnRpY2s9ZX1lLnByb3RvdHlwZS5jb2xsYXBzZT1mdW5jdGlvbihlKXt2YXIgZz10aGlzLnRpY2ssYz1nLmF4aXMsZD1jLmJyb2tlbkF4aXM7ZCYmYy50cmVlR3JpZC5tYXBPZlBvc1RvR3JpZE5vZGUmJihnPWMudHJlZUdyaWQuY29sbGFwc2UoYy50cmVlR3JpZC5tYXBPZlBvc1RvR3JpZE5vZGVbZy5wb3NdKSxkLnNldEJyZWFrcyhnLGgoZSwhMCkpKX07ZS5wcm90b3R5cGUuZXhwYW5kPWZ1bmN0aW9uKGUpe3ZhciBnPXRoaXMudGljayxjPWcuYXhpcyxcbmQ9Yy5icm9rZW5BeGlzO2QmJmMudHJlZUdyaWQubWFwT2ZQb3NUb0dyaWROb2RlJiYoZz1jLnRyZWVHcmlkLmV4cGFuZChjLnRyZWVHcmlkLm1hcE9mUG9zVG9HcmlkTm9kZVtnLnBvc10pLGQuc2V0QnJlYWtzKGcsaChlLCEwKSkpfTtlLnByb3RvdHlwZS50b2dnbGVDb2xsYXBzZT1mdW5jdGlvbihlKXt2YXIgZz10aGlzLnRpY2ssYz1nLmF4aXMsZD1jLmJyb2tlbkF4aXM7ZCYmYy50cmVlR3JpZC5tYXBPZlBvc1RvR3JpZE5vZGUmJihnPWMudHJlZUdyaWQudG9nZ2xlQ29sbGFwc2UoYy50cmVlR3JpZC5tYXBPZlBvc1RvR3JpZE5vZGVbZy5wb3NdKSxkLnNldEJyZWFrcyhnLGgoZSwhMCkpKX07cmV0dXJuIGV9KCk7RC5BZGRpdGlvbnM9ZX0pKEJ8fChCPXt9KSk7cmV0dXJuIEJ9KTtGKGEsXCJNaXhpbnMvVHJlZVNlcmllcy5qc1wiLFthW1wiQ29yZS9Db2xvci9Db2xvci5qc1wiXSxhW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGEsdSl7dmFyIHQ9dS5leHRlbmQscj11LmlzQXJyYXksXG5uPXUuaXNOdW1iZXIsaD11LmlzT2JqZWN0LEE9dS5tZXJnZSxCPXUucGljaztyZXR1cm57Z2V0Q29sb3I6ZnVuY3Rpb24oaCxwKXt2YXIgdz1wLmluZGV4LGs9cC5tYXBPcHRpb25zVG9MZXZlbCxmPXAucGFyZW50Q29sb3Isdj1wLnBhcmVudENvbG9ySW5kZXgsZT1wLnNlcmllcyxnPXAuY29sb3JzLG09cC5zaWJsaW5ncyxxPWUucG9pbnRzLGM9ZS5jaGFydC5vcHRpb25zLmNoYXJ0LGQ7aWYoaCl7cT1xW2guaV07aD1rW2gubGV2ZWxdfHx7fTtpZihrPXEmJmguY29sb3JCeVBvaW50KXt2YXIgYj1xLmluZGV4JShnP2cubGVuZ3RoOmMuY29sb3JDb3VudCk7dmFyIEo9ZyYmZ1tiXX1pZighZS5jaGFydC5zdHlsZWRNb2RlKXtnPXEmJnEub3B0aW9ucy5jb2xvcjtjPWgmJmguY29sb3I7aWYoZD1mKWQ9KGQ9aCYmaC5jb2xvclZhcmlhdGlvbikmJlwiYnJpZ2h0bmVzc1wiPT09ZC5rZXk/YS5wYXJzZShmKS5icmlnaHRlbih3L20qZC50bykuZ2V0KCk6ZjtkPUIoZyxjLEosZCxlLmNvbG9yKX12YXIgST1cbkIocSYmcS5vcHRpb25zLmNvbG9ySW5kZXgsaCYmaC5jb2xvckluZGV4LGIsdixwLmNvbG9ySW5kZXgpfXJldHVybntjb2xvcjpkLGNvbG9ySW5kZXg6SX19LGdldExldmVsT3B0aW9uczpmdW5jdGlvbihhKXt2YXIgcD1udWxsO2lmKGgoYSkpe3A9e307dmFyIHc9bihhLmZyb20pP2EuZnJvbToxO3ZhciBrPWEubGV2ZWxzO3ZhciBmPXt9O3ZhciB2PWgoYS5kZWZhdWx0cyk/YS5kZWZhdWx0czp7fTtyKGspJiYoZj1rLnJlZHVjZShmdW5jdGlvbihlLGcpe2lmKGgoZykmJm4oZy5sZXZlbCkpe3ZhciBhPUEoe30sZyk7dmFyIHE9XCJib29sZWFuXCI9PT10eXBlb2YgYS5sZXZlbElzQ29uc3RhbnQ/YS5sZXZlbElzQ29uc3RhbnQ6di5sZXZlbElzQ29uc3RhbnQ7ZGVsZXRlIGEubGV2ZWxJc0NvbnN0YW50O2RlbGV0ZSBhLmxldmVsO2c9Zy5sZXZlbCsocT8wOnctMSk7aChlW2ddKT90KGVbZ10sYSk6ZVtnXT1hfXJldHVybiBlfSx7fSkpO2s9bihhLnRvKT9hLnRvOjE7Zm9yKGE9MDthPD1rO2ErKylwW2FdPVxuQSh7fSx2LGgoZlthXSk/ZlthXTp7fSl9cmV0dXJuIHB9LHNldFRyZWVWYWx1ZXM6ZnVuY3Rpb24gayhhLHcpe3ZhciBmPXcuYmVmb3JlLHY9dy5pZFJvb3QsZT13Lm1hcElkVG9Ob2RlW3ZdLGc9dy5wb2ludHNbYS5pXSxtPWcmJmcub3B0aW9uc3x8e30scT0wLGM9W107dChhLHtsZXZlbER5bmFtaWM6YS5sZXZlbC0oKFwiYm9vbGVhblwiPT09dHlwZW9mIHcubGV2ZWxJc0NvbnN0YW50P3cubGV2ZWxJc0NvbnN0YW50OjEpPzA6ZS5sZXZlbCksbmFtZTpCKGcmJmcubmFtZSxcIlwiKSx2aXNpYmxlOnY9PT1hLmlkfHwoXCJib29sZWFuXCI9PT10eXBlb2Ygdy52aXNpYmxlP3cudmlzaWJsZTohMSl9KTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZiYmKGE9ZihhLHcpKTthLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oZCxiKXt2YXIgZT10KHt9LHcpO3QoZSx7aW5kZXg6YixzaWJsaW5nczphLmNoaWxkcmVuLmxlbmd0aCx2aXNpYmxlOmEudmlzaWJsZX0pO2Q9ayhkLGUpO2MucHVzaChkKTtkLnZpc2libGUmJlxuKHErPWQudmFsKX0pO2EudmlzaWJsZT0wPHF8fGEudmlzaWJsZTtmPUIobS52YWx1ZSxxKTt0KGEse2NoaWxkcmVuOmMsY2hpbGRyZW5Ub3RhbDpxLGlzTGVhZjphLnZpc2libGUmJiFxLHZhbDpmfSk7cmV0dXJuIGF9LHVwZGF0ZVJvb3RJZDpmdW5jdGlvbihhKXtpZihoKGEpKXt2YXIgdz1oKGEub3B0aW9ucyk/YS5vcHRpb25zOnt9O3c9QihhLnJvb3ROb2RlLHcucm9vdElkLFwiXCIpO2goYS51c2VyT3B0aW9ucykmJihhLnVzZXJPcHRpb25zLnJvb3RJZD13KTthLnJvb3ROb2RlPXd9cmV0dXJuIHd9fX0pO0YoYSxcIkNvcmUvQXhpcy9HcmlkQXhpcy5qc1wiLFthW1wiQ29yZS9BeGlzL0F4aXMuanNcIl0sYVtcIkNvcmUvR2xvYmFscy5qc1wiXSxhW1wiQ29yZS9BeGlzL1RpY2suanNcIl0sYVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihhLHUsdCxyKXt2YXIgbj1yLmFkZEV2ZW50LGg9ci5kZWZpbmVkLEE9ci5lcmFzZSxCPXIuZmluZCxEPXIuaXNBcnJheSxwPXIuaXNOdW1iZXIsdz1yLm1lcmdlLFxuaz1yLnBpY2ssZj1yLnRpbWVVbml0cyx2PXIud3JhcCxlPXUuQ2hhcnQsZz1mdW5jdGlvbihjKXt2YXIgZD1jLm9wdGlvbnM7ZC5sYWJlbHN8fChkLmxhYmVscz17fSk7ZC5sYWJlbHMuYWxpZ249ayhkLmxhYmVscy5hbGlnbixcImNlbnRlclwiKTtjLmNhdGVnb3JpZXN8fChkLnNob3dMYXN0TGFiZWw9ITEpO2MubGFiZWxSb3RhdGlvbj0wO2QubGFiZWxzLnJvdGF0aW9uPTB9O1wiXCI7YS5wcm90b3R5cGUuZ2V0TWF4TGFiZWxEaW1lbnNpb25zPWZ1bmN0aW9uKGMsZCl7dmFyIGI9e3dpZHRoOjAsaGVpZ2h0OjB9O2QuZm9yRWFjaChmdW5jdGlvbihkKXtkPWNbZF07aWYoci5pc09iamVjdChkLCEwKSl7dmFyIGU9ci5pc09iamVjdChkLmxhYmVsLCEwKT9kLmxhYmVsOnt9O2Q9ZS5nZXRCQm94P2UuZ2V0QkJveCgpLmhlaWdodDowO2UudGV4dFN0ciYmIXAoZS50ZXh0UHhMZW5ndGgpJiYoZS50ZXh0UHhMZW5ndGg9ZS5nZXRCQm94KCkud2lkdGgpO3ZhciBhPXAoZS50ZXh0UHhMZW5ndGgpP1xuTWF0aC5yb3VuZChlLnRleHRQeExlbmd0aCk6MDtlLnRleHRTdHImJihhPU1hdGgucm91bmQoZS5nZXRCQm94KCkud2lkdGgpKTtiLmhlaWdodD1NYXRoLm1heChkLGIuaGVpZ2h0KTtiLndpZHRoPU1hdGgubWF4KGEsYi53aWR0aCl9fSk7cmV0dXJuIGJ9O3UuZGF0ZUZvcm1hdHMuVz1mdW5jdGlvbihjKXtjPW5ldyB0aGlzLkRhdGUoYyk7dmFyIGQ9KHRoaXMuZ2V0KFwiRGF5XCIsYykrNiklNyxiPW5ldyB0aGlzLkRhdGUoYy52YWx1ZU9mKCkpO3RoaXMuc2V0KFwiRGF0ZVwiLGIsdGhpcy5nZXQoXCJEYXRlXCIsYyktZCszKTtkPW5ldyB0aGlzLkRhdGUodGhpcy5nZXQoXCJGdWxsWWVhclwiLGIpLDAsMSk7NCE9PXRoaXMuZ2V0KFwiRGF5XCIsZCkmJih0aGlzLnNldChcIk1vbnRoXCIsYywwKSx0aGlzLnNldChcIkRhdGVcIixjLDErKDExLXRoaXMuZ2V0KFwiRGF5XCIsZCkpJTcpKTtyZXR1cm4oMStNYXRoLmZsb29yKChiLnZhbHVlT2YoKS1kLnZhbHVlT2YoKSkvNjA0OEU1KSkudG9TdHJpbmcoKX07dS5kYXRlRm9ybWF0cy5FPVxuZnVuY3Rpb24oYyl7cmV0dXJuIHRoaXMuZGF0ZUZvcm1hdChcIiVhXCIsYywhMCkuY2hhckF0KDApfTtuKGUsXCJhZnRlclNldENoYXJ0U2l6ZVwiLGZ1bmN0aW9uKCl7dGhpcy5heGVzLmZvckVhY2goZnVuY3Rpb24oYyl7KGMuZ3JpZCYmYy5ncmlkLmNvbHVtbnN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGQpe2Quc2V0QXhpc1NpemUoKTtkLnNldEF4aXNUcmFuc2xhdGlvbigpfSl9KX0pO24odCxcImFmdGVyR2V0TGFiZWxQb3NpdGlvblwiLGZ1bmN0aW9uKGMpe3ZhciBkPXRoaXMubGFiZWwsYj10aGlzLmF4aXMsZT1iLnJldmVyc2VkLGE9Yi5jaGFydCxnPWIub3B0aW9ucy5ncmlkfHx7fSxmPWIub3B0aW9ucy5sYWJlbHMsdj1mLmFsaWduLG09cS5TaWRlW2Iuc2lkZV0saz1jLnRpY2ttYXJrT2Zmc2V0LEU9Yi50aWNrUG9zaXRpb25zLHk9dGhpcy5wb3MtaztFPXAoRVtjLmluZGV4KzFdKT9FW2MuaW5kZXgrMV0tazpiLm1heCtrO3ZhciB6PWIudGlja1NpemUoXCJ0aWNrXCIpO2s9ej96WzBdOjA7XG56PXo/elsxXS8yOjA7aWYoITA9PT1nLmVuYWJsZWQpe2lmKFwidG9wXCI9PT1tKXtnPWIudG9wK2Iub2Zmc2V0O3ZhciBsPWcta31lbHNlXCJib3R0b21cIj09PW0/KGw9YS5jaGFydEhlaWdodC1iLmJvdHRvbStiLm9mZnNldCxnPWwrayk6KGc9Yi50b3ArYi5sZW4tYi50cmFuc2xhdGUoZT9FOnkpLGw9Yi50b3ArYi5sZW4tYi50cmFuc2xhdGUoZT95OkUpKTtcInJpZ2h0XCI9PT1tPyhtPWEuY2hhcnRXaWR0aC1iLnJpZ2h0K2Iub2Zmc2V0LGU9bStrKTpcImxlZnRcIj09PW0/KGU9Yi5sZWZ0K2Iub2Zmc2V0LG09ZS1rKToobT1NYXRoLnJvdW5kKGIubGVmdCtiLnRyYW5zbGF0ZShlP0U6eSkpLXosZT1NYXRoLnJvdW5kKGIubGVmdCtiLnRyYW5zbGF0ZShlP3k6RSkpLXopO3RoaXMuc2xvdFdpZHRoPWUtbTtjLnBvcy54PVwibGVmdFwiPT09dj9tOlwicmlnaHRcIj09PXY/ZTptKyhlLW0pLzI7Yy5wb3MueT1sKyhnLWwpLzI7YT1hLnJlbmRlcmVyLmZvbnRNZXRyaWNzKGYuc3R5bGUuZm9udFNpemUsZC5lbGVtZW50KTtcbmQ9ZC5nZXRCQm94KCkuaGVpZ2h0O2YudXNlSFRNTD9jLnBvcy55Kz1hLmIrLShkLzIpOihkPU1hdGgucm91bmQoZC9hLmgpLGMucG9zLnkrPShhLmItKGEuaC1hLmYpKS8yKy0oKGQtMSkqYS5oLzIpKTtjLnBvcy54Kz1iLmhvcml6JiZmLnh8fDB9fSk7dmFyIG09ZnVuY3Rpb24oKXtmdW5jdGlvbiBjKGQpe3RoaXMuYXhpcz1kfWMucHJvdG90eXBlLmlzT3V0ZXJBeGlzPWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5heGlzLGI9ZC5ncmlkLmNvbHVtbkluZGV4LGM9ZC5saW5rZWRQYXJlbnQmJmQubGlua2VkUGFyZW50LmdyaWQuY29sdW1uc3x8ZC5ncmlkLmNvbHVtbnMsZT1iP2QubGlua2VkUGFyZW50OmQsYT0tMSxnPTA7ZC5jaGFydFtkLmNvbGxdLmZvckVhY2goZnVuY3Rpb24oYixjKXtiLnNpZGUhPT1kLnNpZGV8fGIub3B0aW9ucy5pc0ludGVybmFsfHwoZz1jLGI9PT1lJiYoYT1jKSl9KTtyZXR1cm4gZz09PWEmJihwKGIpP2MubGVuZ3RoPT09YjohMCl9O2MucHJvdG90eXBlLnJlbmRlckJvcmRlcj1cbmZ1bmN0aW9uKGQpe3ZhciBiPXRoaXMuYXhpcyxjPWIuY2hhcnQucmVuZGVyZXIsZT1iLm9wdGlvbnM7ZD1jLnBhdGgoZCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLWF4aXMtbGluZVwiKS5hZGQoYi5heGlzQm9yZGVyKTtjLnN0eWxlZE1vZGV8fGQuYXR0cih7c3Ryb2tlOmUubGluZUNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6ZS5saW5lV2lkdGgsekluZGV4Ojd9KTtyZXR1cm4gZH07cmV0dXJuIGN9KCkscT1mdW5jdGlvbigpe2Z1bmN0aW9uIGMoKXt9Yy5jb21wb3NlPWZ1bmN0aW9uKGQpe2Eua2VlcFByb3BzLnB1c2goXCJncmlkXCIpO3YoZC5wcm90b3R5cGUsXCJ1bnNxdWlzaFwiLGMud3JhcFVuc3F1aXNoKTtuKGQsXCJpbml0XCIsYy5vbkluaXQpO24oZCxcImFmdGVyR2V0T2Zmc2V0XCIsYy5vbkFmdGVyR2V0T2Zmc2V0KTtuKGQsXCJhZnRlckdldFRpdGxlUG9zaXRpb25cIixjLm9uQWZ0ZXJHZXRUaXRsZVBvc2l0aW9uKTtuKGQsXCJhZnRlckluaXRcIixjLm9uQWZ0ZXJJbml0KTtuKGQsXCJhZnRlclJlbmRlclwiLFxuYy5vbkFmdGVyUmVuZGVyKTtuKGQsXCJhZnRlclNldEF4aXNUcmFuc2xhdGlvblwiLGMub25BZnRlclNldEF4aXNUcmFuc2xhdGlvbik7bihkLFwiYWZ0ZXJTZXRPcHRpb25zXCIsYy5vbkFmdGVyU2V0T3B0aW9ucyk7bihkLFwiYWZ0ZXJTZXRPcHRpb25zXCIsYy5vbkFmdGVyU2V0T3B0aW9uczIpO24oZCxcImFmdGVyU2V0U2NhbGVcIixjLm9uQWZ0ZXJTZXRTY2FsZSk7bihkLFwiYWZ0ZXJUaWNrU2l6ZVwiLGMub25BZnRlclRpY2tTaXplKTtuKGQsXCJ0cmltVGlja3NcIixjLm9uVHJpbVRpY2tzKTtuKGQsXCJkZXN0cm95XCIsYy5vbkRlc3Ryb3kpfTtjLm9uQWZ0ZXJHZXRPZmZzZXQ9ZnVuY3Rpb24oKXt2YXIgZD10aGlzLmdyaWQ7KGQmJmQuY29sdW1uc3x8W10pLmZvckVhY2goZnVuY3Rpb24oYil7Yi5nZXRPZmZzZXQoKX0pfTtjLm9uQWZ0ZXJHZXRUaXRsZVBvc2l0aW9uPWZ1bmN0aW9uKGQpe2lmKCEwPT09KHRoaXMub3B0aW9ucy5ncmlkfHx7fSkuZW5hYmxlZCl7dmFyIGI9dGhpcy5heGlzVGl0bGUsXG5lPXRoaXMuaGVpZ2h0LGE9dGhpcy5ob3JpeixnPXRoaXMubGVmdCxmPXRoaXMub2Zmc2V0LHE9dGhpcy5vcHBvc2l0ZSxtPXRoaXMub3B0aW9ucy50aXRsZSx2PXZvaWQgMD09PW0/e306bTttPXRoaXMudG9wO3ZhciBFPXRoaXMud2lkdGgseT10aGlzLnRpY2tTaXplKCksej1iJiZiLmdldEJCb3goKS53aWR0aCxsPXYueHx8MCx4PXYueXx8MCxHPWsodi5tYXJnaW4sYT81OjEwKTtiPXRoaXMuY2hhcnQucmVuZGVyZXIuZm9udE1ldHJpY3Modi5zdHlsZSYmdi5zdHlsZS5mb250U2l6ZSxiKS5mO3k9KGE/bStlOmcpKyhhPzE6LTEpKihxPy0xOjEpKih5P3lbMF0vMjowKSsodGhpcy5zaWRlPT09Yy5TaWRlLmJvdHRvbT9iOjApO2QudGl0bGVQb3NpdGlvbi54PWE/Zy16LzItRytsOnkrKHE/RTowKStmK2w7ZC50aXRsZVBvc2l0aW9uLnk9YT95LShxP2U6MCkrKHE/YjotYikvMitmK3g6bS1HK3h9fTtjLm9uQWZ0ZXJJbml0PWZ1bmN0aW9uKCl7dmFyIGQ9dGhpcy5jaGFydCxiPXRoaXMub3B0aW9ucy5ncmlkO1xuYj12b2lkIDA9PT1iP3t9OmI7dmFyIGM9dGhpcy51c2VyT3B0aW9ucztiLmVuYWJsZWQmJihnKHRoaXMpLHYodGhpcyxcImxhYmVsRm9ybWF0dGVyXCIsZnVuY3Rpb24oYil7dmFyIGQ9dGhpcy5heGlzLGM9dGhpcy52YWx1ZSxlPWQudGlja1Bvc2l0aW9ucyx5PShkLmlzTGlua2VkP2QubGlua2VkUGFyZW50OmQpLnNlcmllc1swXSx6PWM9PT1lWzBdO2U9Yz09PWVbZS5sZW5ndGgtMV07dmFyIGw9eSYmQih5Lm9wdGlvbnMuZGF0YSxmdW5jdGlvbihsKXtyZXR1cm4gbFtkLmlzWEF4aXM/XCJ4XCI6XCJ5XCJdPT09Y30pO2lmKGwmJnkuaXMoXCJnYW50dFwiKSl7dmFyIHg9dyhsKTt1LnNlcmllc1R5cGVzLmdhbnR0LnByb3RvdHlwZS5wb2ludENsYXNzLnNldEdhbnR0UG9pbnRBbGlhc2VzKHgpfXRoaXMuaXNGaXJzdD16O3RoaXMuaXNMYXN0PWU7dGhpcy5wb2ludD14O3JldHVybiBiLmNhbGwodGhpcyl9KSk7aWYoYi5jb2x1bW5zKWZvcih2YXIgZT10aGlzLmdyaWQuY29sdW1ucz1bXSxxPXRoaXMuZ3JpZC5jb2x1bW5JbmRleD1cbjA7KytxPGIuY29sdW1ucy5sZW5ndGg7KXt2YXIgZj13KGMsYi5jb2x1bW5zW2IuY29sdW1ucy5sZW5ndGgtcS0xXSx7bGlua2VkVG86MCx0eXBlOlwiY2F0ZWdvcnlcIixzY3JvbGxiYXI6e2VuYWJsZWQ6ITF9fSk7ZGVsZXRlIGYuZ3JpZC5jb2x1bW5zO2Y9bmV3IGEodGhpcy5jaGFydCxmKTtmLmdyaWQuaXNDb2x1bW49ITA7Zi5ncmlkLmNvbHVtbkluZGV4PXE7QShkLmF4ZXMsZik7QShkW3RoaXMuY29sbF0sZik7ZS5wdXNoKGYpfX07Yy5vbkFmdGVyUmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGQsYj10aGlzLmdyaWQsZT10aGlzLm9wdGlvbnM7aWYoITA9PT0oZS5ncmlkfHx7fSkuZW5hYmxlZCl7dGhpcy5tYXhMYWJlbERpbWVuc2lvbnM9dGhpcy5nZXRNYXhMYWJlbERpbWVuc2lvbnModGhpcy50aWNrcyx0aGlzLnRpY2tQb3NpdGlvbnMpO3RoaXMucmlnaHRXYWxsJiZ0aGlzLnJpZ2h0V2FsbC5kZXN0cm95KCk7aWYodGhpcy5ncmlkJiZ0aGlzLmdyaWQuaXNPdXRlckF4aXMoKSYmdGhpcy5heGlzTGluZSYmXG4oZT1lLmxpbmVXaWR0aCkpe2U9dGhpcy5nZXRMaW5lUGF0aChlKTt2YXIgYT1lWzBdLGc9ZVsxXSxmPSgodGhpcy50aWNrU2l6ZShcInRpY2tcIil8fFsxXSlbMF0tMSkqKHRoaXMuc2lkZT09PWMuU2lkZS50b3B8fHRoaXMuc2lkZT09PWMuU2lkZS5sZWZ0Py0xOjEpO1wiTVwiPT09YVswXSYmXCJMXCI9PT1nWzBdJiYodGhpcy5ob3Jpej8oYVsyXSs9ZixnWzJdKz1mKTooYVsxXSs9ZixnWzFdKz1mKSk7IXRoaXMuaG9yaXomJnRoaXMuY2hhcnQubWFyZ2luUmlnaHQmJihhPVthLFtcIkxcIix0aGlzLmxlZnQsYVsyXV1dLGY9W1wiTFwiLHRoaXMuY2hhcnQuY2hhcnRXaWR0aC10aGlzLmNoYXJ0Lm1hcmdpblJpZ2h0LHRoaXMudG9QaXhlbHModGhpcy5tYXgrdGhpcy50aWNrbWFya09mZnNldCldLGc9W1tcIk1cIixnWzFdLHRoaXMudG9QaXhlbHModGhpcy5tYXgrdGhpcy50aWNrbWFya09mZnNldCldLGZdLHRoaXMuZ3JpZC51cHBlckJvcmRlcnx8MD09PXRoaXMubWluJTF8fCh0aGlzLmdyaWQudXBwZXJCb3JkZXI9XG50aGlzLmdyaWQucmVuZGVyQm9yZGVyKGEpKSx0aGlzLmdyaWQudXBwZXJCb3JkZXImJnRoaXMuZ3JpZC51cHBlckJvcmRlci5hbmltYXRlKHtkOmF9KSx0aGlzLmdyaWQubG93ZXJCb3JkZXJ8fDA9PT10aGlzLm1heCUxfHwodGhpcy5ncmlkLmxvd2VyQm9yZGVyPXRoaXMuZ3JpZC5yZW5kZXJCb3JkZXIoZykpLHRoaXMuZ3JpZC5sb3dlckJvcmRlciYmdGhpcy5ncmlkLmxvd2VyQm9yZGVyLmFuaW1hdGUoe2Q6Z30pKTt0aGlzLmdyaWQuYXhpc0xpbmVFeHRyYT90aGlzLmdyaWQuYXhpc0xpbmVFeHRyYS5hbmltYXRlKHtkOmV9KTp0aGlzLmdyaWQuYXhpc0xpbmVFeHRyYT10aGlzLmdyaWQucmVuZGVyQm9yZGVyKGUpO3RoaXMuYXhpc0xpbmVbdGhpcy5zaG93QXhpcz9cInNob3dcIjpcImhpZGVcIl0oITApfShiJiZiLmNvbHVtbnN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IucmVuZGVyKCl9KTshdGhpcy5ob3JpeiYmdGhpcy5jaGFydC5oYXNSZW5kZXJlZCYmKHRoaXMuc2Nyb2xsYmFyfHxcbihudWxsPT09KGQ9dGhpcy5saW5rZWRQYXJlbnQpfHx2b2lkIDA9PT1kPzA6ZC5zY3JvbGxiYXIpKSYmKGQ9dGhpcy5tYXgsYj10aGlzLnRpY2ttYXJrT2Zmc2V0LGU9dGhpcy50aWNrUG9zaXRpb25zW3RoaXMudGlja1Bvc2l0aW9ucy5sZW5ndGgtMV0sZz10aGlzLnRpY2tQb3NpdGlvbnNbMF0sdGhpcy5taW4tZz5iP3RoaXMudGlja3NbZ10ubGFiZWwuaGlkZSgpOnRoaXMudGlja3NbZ10ubGFiZWwuc2hvdygpLGUtZD5iP3RoaXMudGlja3NbZV0ubGFiZWwuaGlkZSgpOnRoaXMudGlja3NbZV0ubGFiZWwuc2hvdygpLGUtZDxiJiYwPGUtZCYmdGhpcy50aWNrc1tlXS5pc0xhc3Q/dGhpcy50aWNrc1tlXS5tYXJrLmhpZGUoKTp0aGlzLnRpY2tzW2UtMV0mJnRoaXMudGlja3NbZS0xXS5tYXJrLnNob3coKSl9fTtjLm9uQWZ0ZXJTZXRBeGlzVHJhbnNsYXRpb249ZnVuY3Rpb24oKXt2YXIgZCxiPXRoaXMudGlja1Bvc2l0aW9ucyYmdGhpcy50aWNrUG9zaXRpb25zLmluZm8sYz10aGlzLm9wdGlvbnMsXG5lPXRoaXMudXNlck9wdGlvbnMubGFiZWxzfHx7fTsoYy5ncmlkfHx7fSkuZW5hYmxlZCYmKHRoaXMuaG9yaXo/KHRoaXMuc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYil7Yi5vcHRpb25zLnBvaW50UmFuZ2U9MH0pLGImJmMuZGF0ZVRpbWVMYWJlbEZvcm1hdHMmJmMubGFiZWxzJiYhaChlLmFsaWduKSYmKCExPT09Yy5kYXRlVGltZUxhYmVsRm9ybWF0c1tiLnVuaXROYW1lXS5yYW5nZXx8MTxiLmNvdW50KSYmKGMubGFiZWxzLmFsaWduPVwibGVmdFwiLGgoZS54KXx8KGMubGFiZWxzLng9MykpKTpcInRyZWVncmlkXCIhPT10aGlzLm9wdGlvbnMudHlwZSYmKG51bGw9PT0oZD10aGlzLmdyaWQpfHx2b2lkIDA9PT1kPzA6ZC5jb2x1bW5zKSYmKHRoaXMubWluUG9pbnRPZmZzZXQ9dGhpcy50aWNrSW50ZXJ2YWwpKX07Yy5vbkFmdGVyU2V0T3B0aW9ucz1mdW5jdGlvbihkKXt2YXIgYj10aGlzLm9wdGlvbnM7ZD1kLnVzZXJPcHRpb25zO3ZhciBjPWImJnIuaXNPYmplY3QoYi5ncmlkLCEwKT9iLmdyaWQ6XG57fTtpZighMD09PWMuZW5hYmxlZCl7dmFyIGU9dyghMCx7Y2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1ncmlkLWF4aXMgXCIrKGQuY2xhc3NOYW1lfHxcIlwiKSxkYXRlVGltZUxhYmVsRm9ybWF0czp7aG91cjp7bGlzdDpbXCIlSDolTVwiLFwiJUhcIl19LGRheTp7bGlzdDpbXCIlQSwgJWUuICVCXCIsXCIlYSwgJWUuICViXCIsXCIlRVwiXX0sd2Vlazp7bGlzdDpbXCJXZWVrICVXXCIsXCJXJVdcIl19LG1vbnRoOntsaXN0OltcIiVCXCIsXCIlYlwiLFwiJW9cIl19fSxncmlkOntib3JkZXJXaWR0aDoxfSxsYWJlbHM6e3BhZGRpbmc6MixzdHlsZTp7Zm9udFNpemU6XCIxM3B4XCJ9fSxtYXJnaW46MCx0aXRsZTp7dGV4dDpudWxsLHJlc2VydmVTcGFjZTohMSxyb3RhdGlvbjowfSx1bml0czpbW1wibWlsbGlzZWNvbmRcIixbMSwxMCwxMDBdXSxbXCJzZWNvbmRcIixbMSwxMF1dLFtcIm1pbnV0ZVwiLFsxLDUsMTVdXSxbXCJob3VyXCIsWzEsNl1dLFtcImRheVwiLFsxXV0sW1wid2Vla1wiLFsxXV0sW1wibW9udGhcIixbMV1dLFtcInllYXJcIixudWxsXV19LGQpO1xuXCJ4QXhpc1wiPT09dGhpcy5jb2xsJiYoaChkLmxpbmtlZFRvKSYmIWgoZC50aWNrUGl4ZWxJbnRlcnZhbCkmJihlLnRpY2tQaXhlbEludGVydmFsPTM1MCksaChkLnRpY2tQaXhlbEludGVydmFsKXx8IWgoZC5saW5rZWRUbyl8fGgoZC50aWNrUG9zaXRpb25lcil8fGgoZC50aWNrSW50ZXJ2YWwpfHwoZS50aWNrUG9zaXRpb25lcj1mdW5jdGlvbihiLGQpe3ZhciBjPXRoaXMubGlua2VkUGFyZW50JiZ0aGlzLmxpbmtlZFBhcmVudC50aWNrUG9zaXRpb25zJiZ0aGlzLmxpbmtlZFBhcmVudC50aWNrUG9zaXRpb25zLmluZm87aWYoYyl7dmFyIGEsZz1lLnVuaXRzO2ZvcihhPTA7YTxnLmxlbmd0aDthKyspaWYoZ1thXVswXT09PWMudW5pdE5hbWUpe3ZhciBxPWE7YnJlYWt9aWYoZ1txKzFdKXt2YXIgeT1nW3ErMV1bMF07dmFyIHo9KGdbcSsxXVsxXXx8WzFdKVswXX1lbHNlXCJ5ZWFyXCI9PT1jLnVuaXROYW1lJiYoeT1cInllYXJcIix6PTEwKmMuY291bnQpO2M9Zlt5XTt0aGlzLnRpY2tJbnRlcnZhbD1cbmMqejtyZXR1cm4gdGhpcy5nZXRUaW1lVGlja3Moe3VuaXRSYW5nZTpjLGNvdW50OnosdW5pdE5hbWU6eX0sYixkLHRoaXMub3B0aW9ucy5zdGFydE9mV2Vlayl9fSkpO3coITAsdGhpcy5vcHRpb25zLGUpO3RoaXMuaG9yaXomJihiLm1pblBhZGRpbmc9ayhkLm1pblBhZGRpbmcsMCksYi5tYXhQYWRkaW5nPWsoZC5tYXhQYWRkaW5nLDApKTtwKGIuZ3JpZC5ib3JkZXJXaWR0aCkmJihiLnRpY2tXaWR0aD1iLmxpbmVXaWR0aD1jLmJvcmRlcldpZHRoKX19O2Mub25BZnRlclNldE9wdGlvbnMyPWZ1bmN0aW9uKGQpe2Q9KGQ9ZC51c2VyT3B0aW9ucykmJmQuZ3JpZHx8e307dmFyIGI9ZC5jb2x1bW5zO2QuZW5hYmxlZCYmYiYmdyghMCx0aGlzLm9wdGlvbnMsYltiLmxlbmd0aC0xXSl9O2Mub25BZnRlclNldFNjYWxlPWZ1bmN0aW9uKCl7KHRoaXMuZ3JpZC5jb2x1bW5zfHxbXSkuZm9yRWFjaChmdW5jdGlvbihkKXtkLnNldFNjYWxlKCl9KX07Yy5vbkFmdGVyVGlja1NpemU9ZnVuY3Rpb24oZCl7dmFyIGI9XG5hLmRlZmF1bHRMZWZ0QXhpc09wdGlvbnMsYz10aGlzLmhvcml6LGU9dGhpcy5tYXhMYWJlbERpbWVuc2lvbnMsZz10aGlzLm9wdGlvbnMuZ3JpZDtnPXZvaWQgMD09PWc/e306ZztnLmVuYWJsZWQmJmUmJihiPTIqTWF0aC5hYnMoYi5sYWJlbHMueCksYz1jP2cuY2VsbEhlaWdodHx8YitlLmhlaWdodDpiK2Uud2lkdGgsRChkLnRpY2tTaXplKT9kLnRpY2tTaXplWzBdPWM6ZC50aWNrU2l6ZT1bYywwXSl9O2Mub25EZXN0cm95PWZ1bmN0aW9uKGQpe3ZhciBiPXRoaXMuZ3JpZDsoYi5jb2x1bW5zfHxbXSkuZm9yRWFjaChmdW5jdGlvbihiKXtiLmRlc3Ryb3koZC5rZWVwRXZlbnRzKX0pO2IuY29sdW1ucz12b2lkIDB9O2Mub25Jbml0PWZ1bmN0aW9uKGQpe2Q9ZC51c2VyT3B0aW9uc3x8e307dmFyIGI9ZC5ncmlkfHx7fTtiLmVuYWJsZWQmJmgoYi5ib3JkZXJDb2xvcikmJihkLnRpY2tDb2xvcj1kLmxpbmVDb2xvcj1iLmJvcmRlckNvbG9yKTt0aGlzLmdyaWR8fCh0aGlzLmdyaWQ9bmV3IG0odGhpcykpfTtcbmMub25UcmltVGlja3M9ZnVuY3Rpb24oKXt2YXIgZD10aGlzLm9wdGlvbnMsYj10aGlzLmNhdGVnb3JpZXMsYz10aGlzLnRpY2tQb3NpdGlvbnMsZT1jWzBdLGE9Y1tjLmxlbmd0aC0xXSxnPXRoaXMubGlua2VkUGFyZW50JiZ0aGlzLmxpbmtlZFBhcmVudC5taW58fHRoaXMubWluLGY9dGhpcy5saW5rZWRQYXJlbnQmJnRoaXMubGlua2VkUGFyZW50Lm1heHx8dGhpcy5tYXgscT10aGlzLnRpY2tJbnRlcnZhbDshMCE9PShkLmdyaWR8fHt9KS5lbmFibGVkfHxifHwhdGhpcy5ob3JpeiYmIXRoaXMuaXNMaW5rZWR8fChlPGcmJmUrcT5nJiYhZC5zdGFydE9uVGljayYmKGNbMF09ZyksYT5mJiZhLXE8ZiYmIWQuZW5kT25UaWNrJiYoY1tjLmxlbmd0aC0xXT1mKSl9O2Mud3JhcFVuc3F1aXNoPWZ1bmN0aW9uKGQpe3ZhciBiPXRoaXMub3B0aW9ucy5ncmlkO3JldHVybiEwPT09KHZvaWQgMD09PWI/e306YikuZW5hYmxlZCYmdGhpcy5jYXRlZ29yaWVzP3RoaXMudGlja0ludGVydmFsOmQuYXBwbHkodGhpcyxcbkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSl9O3JldHVybiBjfSgpOyhmdW5jdGlvbihjKXtjPWMuU2lkZXx8KGMuU2lkZT17fSk7Y1tjLnRvcD0wXT1cInRvcFwiO2NbYy5yaWdodD0xXT1cInJpZ2h0XCI7Y1tjLmJvdHRvbT0yXT1cImJvdHRvbVwiO2NbYy5sZWZ0PTNdPVwibGVmdFwifSkocXx8KHE9e30pKTtxLmNvbXBvc2UoYSk7cmV0dXJuIHF9KTtGKGEsXCJDb3JlL0F4aXMvQnJva2VuQXhpcy5qc1wiLFthW1wiQ29yZS9BeGlzL0F4aXMuanNcIl0sYVtcIkNvcmUvU2VyaWVzL1Nlcmllcy5qc1wiXSxhW1wiRXh0ZW5zaW9ucy9TdGFja2luZy5qc1wiXSxhW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGEsdSx0LHIpe3ZhciBuPXIuYWRkRXZlbnQsaD1yLmZpbmQsQT1yLmZpcmVFdmVudCxCPXIuaXNBcnJheSxEPXIuaXNOdW1iZXIscD1yLnBpY2ssdz1mdW5jdGlvbigpe2Z1bmN0aW9uIGsoYSl7dGhpcy5oYXNCcmVha3M9ITE7dGhpcy5heGlzPWF9ay5pc0luQnJlYWs9ZnVuY3Rpb24oYSxcbnYpe3ZhciBlPWEucmVwZWF0fHxJbmZpbml0eSxnPWEuZnJvbSxmPWEudG8tYS5mcm9tO3Y9dj49Zz8odi1nKSVlOmUtKGctdiklZTtyZXR1cm4gYS5pbmNsdXNpdmU/djw9Zjp2PGYmJjAhPT12fTtrLmxpbjJWYWw9ZnVuY3Rpb24oYSl7dmFyIGY9dGhpcy5icm9rZW5BeGlzO2Y9ZiYmZi5icmVha0FycmF5O2lmKCFmKXJldHVybiBhO3ZhciBlO2ZvcihlPTA7ZTxmLmxlbmd0aDtlKyspe3ZhciBnPWZbZV07aWYoZy5mcm9tPj1hKWJyZWFrO2Vsc2UgZy50bzxhP2ErPWcubGVuOmsuaXNJbkJyZWFrKGcsYSkmJihhKz1nLmxlbil9cmV0dXJuIGF9O2sudmFsMkxpbj1mdW5jdGlvbihhKXt2YXIgZj10aGlzLmJyb2tlbkF4aXM7Zj1mJiZmLmJyZWFrQXJyYXk7aWYoIWYpcmV0dXJuIGE7dmFyIGU9YSxnO2ZvcihnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBtPWZbZ107aWYobS50bzw9YSllLT1tLmxlbjtlbHNlIGlmKG0uZnJvbT49YSlicmVhaztlbHNlIGlmKGsuaXNJbkJyZWFrKG0sYSkpe2UtPVxuYS1tLmZyb207YnJlYWt9fXJldHVybiBlfTtrLnByb3RvdHlwZS5maW5kQnJlYWtBdD1mdW5jdGlvbihhLGspe3JldHVybiBoKGssZnVuY3Rpb24oZSl7cmV0dXJuIGUuZnJvbTxhJiZhPGUudG99KX07ay5wcm90b3R5cGUuaXNJbkFueUJyZWFrPWZ1bmN0aW9uKGEsdil7dmFyIGU9dGhpcy5heGlzLGc9ZS5vcHRpb25zLmJyZWFrcyxmPWcmJmcubGVuZ3RoLHE7aWYoZil7Zm9yKDtmLS07KWlmKGsuaXNJbkJyZWFrKGdbZl0sYSkpe3ZhciBjPSEwO3F8fChxPXAoZ1tmXS5zaG93UG9pbnRzLCFlLmlzWEF4aXMpKX12YXIgZD1jJiZ2P2MmJiFxOmN9cmV0dXJuIGR9O2sucHJvdG90eXBlLnNldEJyZWFrcz1mdW5jdGlvbihmLHYpe3ZhciBlPXRoaXMsZz1lLmF4aXMsbT1CKGYpJiYhIWYubGVuZ3RoO2cuaXNEaXJ0eT1lLmhhc0JyZWFrcyE9PW07ZS5oYXNCcmVha3M9bTtnLm9wdGlvbnMuYnJlYWtzPWcudXNlck9wdGlvbnMuYnJlYWtzPWY7Zy5mb3JjZVJlZHJhdz0hMDtnLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UuaXNEaXJ0eT1cbiEwfSk7bXx8Zy52YWwybGluIT09ay52YWwyTGlufHwoZGVsZXRlIGcudmFsMmxpbixkZWxldGUgZy5saW4ydmFsKTttJiYoZy51c2VyT3B0aW9ucy5vcmRpbmFsPSExLGcubGluMnZhbD1rLmxpbjJWYWwsZy52YWwybGluPWsudmFsMkxpbixnLnNldEV4dHJlbWVzPWZ1bmN0aW9uKGcsYyxkLGIsZil7aWYoZS5oYXNCcmVha3Mpe2Zvcih2YXIgcSxtPXRoaXMub3B0aW9ucy5icmVha3M7cT1lLmZpbmRCcmVha0F0KGcsbSk7KWc9cS50bztmb3IoO3E9ZS5maW5kQnJlYWtBdChjLG0pOyljPXEuZnJvbTtjPGcmJihjPWcpfWEucHJvdG90eXBlLnNldEV4dHJlbWVzLmNhbGwodGhpcyxnLGMsZCxiLGYpfSxnLnNldEF4aXNUcmFuc2xhdGlvbj1mdW5jdGlvbigpe2EucHJvdG90eXBlLnNldEF4aXNUcmFuc2xhdGlvbi5jYWxsKHRoaXMpO2UudW5pdExlbmd0aD1udWxsO2lmKGUuaGFzQnJlYWtzKXt2YXIgZj1nLm9wdGlvbnMuYnJlYWtzfHxbXSxjPVtdLGQ9W10sYj0wLG0sdj1nLnVzZXJNaW58fFxuZy5taW4sdz1nLnVzZXJNYXh8fGcubWF4LGg9cChnLnBvaW50UmFuZ2VQYWRkaW5nLDApLG47Zi5mb3JFYWNoKGZ1bmN0aW9uKGIpe209Yi5yZXBlYXR8fEluZmluaXR5O2suaXNJbkJyZWFrKGIsdikmJih2Kz1iLnRvJW0tdiVtKTtrLmlzSW5CcmVhayhiLHcpJiYody09dyVtLWIuZnJvbSVtKX0pO2YuZm9yRWFjaChmdW5jdGlvbihiKXt0PWIuZnJvbTtmb3IobT1iLnJlcGVhdHx8SW5maW5pdHk7dC1tPnY7KXQtPW07Zm9yKDt0PHY7KXQrPW07Zm9yKG49dDtuPHc7bis9bSljLnB1c2goe3ZhbHVlOm4sbW92ZTpcImluXCJ9KSxjLnB1c2goe3ZhbHVlOm4rKGIudG8tYi5mcm9tKSxtb3ZlOlwib3V0XCIsc2l6ZTpiLmJyZWFrU2l6ZX0pfSk7Yy5zb3J0KGZ1bmN0aW9uKGIsZCl7cmV0dXJuIGIudmFsdWU9PT1kLnZhbHVlPyhcImluXCI9PT1iLm1vdmU/MDoxKS0oXCJpblwiPT09ZC5tb3ZlPzA6MSk6Yi52YWx1ZS1kLnZhbHVlfSk7dmFyIHI9MDt2YXIgdD12O2MuZm9yRWFjaChmdW5jdGlvbihjKXtyKz1cblwiaW5cIj09PWMubW92ZT8xOi0xOzE9PT1yJiZcImluXCI9PT1jLm1vdmUmJih0PWMudmFsdWUpOzA9PT1yJiYoZC5wdXNoKHtmcm9tOnQsdG86Yy52YWx1ZSxsZW46Yy52YWx1ZS10LShjLnNpemV8fDApfSksYis9Yy52YWx1ZS10LShjLnNpemV8fDApKX0pO2cuYnJlYWtBcnJheT1lLmJyZWFrQXJyYXk9ZDtlLnVuaXRMZW5ndGg9dy12LWIraDtBKGcsXCJhZnRlckJyZWFrc1wiKTtnLnN0YXRpY1NjYWxlP2cudHJhbnNBPWcuc3RhdGljU2NhbGU6ZS51bml0TGVuZ3RoJiYoZy50cmFuc0EqPSh3LWcubWluK2gpL2UudW5pdExlbmd0aCk7aCYmKGcubWluUGl4ZWxQYWRkaW5nPWcudHJhbnNBKmcubWluUG9pbnRPZmZzZXQpO2cubWluPXY7Zy5tYXg9d319KTtwKHYsITApJiZnLmNoYXJ0LnJlZHJhdygpfTtyZXR1cm4ga30oKTtyPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe31hLmNvbXBvc2U9ZnVuY3Rpb24oYSx2KXthLmtlZXBQcm9wcy5wdXNoKFwiYnJva2VuQXhpc1wiKTt2YXIgZT11LnByb3RvdHlwZTtcbmUuZHJhd0JyZWFrcz1mdW5jdGlvbihlLGEpe3ZhciBnPXRoaXMsYz1nLnBvaW50cyxkLGIsZixtO2lmKGUmJmUuYnJva2VuQXhpcyYmZS5icm9rZW5BeGlzLmhhc0JyZWFrcyl7dmFyIHY9ZS5icm9rZW5BeGlzO2EuZm9yRWFjaChmdW5jdGlvbihhKXtkPXYmJnYuYnJlYWtBcnJheXx8W107Yj1lLmlzWEF4aXM/ZS5taW46cChnLm9wdGlvbnMudGhyZXNob2xkLGUubWluKTtjLmZvckVhY2goZnVuY3Rpb24oYyl7bT1wKGNbXCJzdGFja1wiK2EudG9VcHBlckNhc2UoKV0sY1thXSk7ZC5mb3JFYWNoKGZ1bmN0aW9uKGQpe2lmKEQoYikmJkQobSkpe2Y9ITE7aWYoYjxkLmZyb20mJm0+ZC50b3x8Yj5kLmZyb20mJm08ZC5mcm9tKWY9XCJwb2ludEJyZWFrXCI7ZWxzZSBpZihiPGQuZnJvbSYmbT5kLmZyb20mJm08ZC50b3x8Yj5kLmZyb20mJm0+ZC50byYmbTxkLmZyb20pZj1cInBvaW50SW5CcmVha1wiO2YmJkEoZSxmLHtwb2ludDpjLGJyazpkfSl9fSl9KX0pfX07ZS5nYXBwZWRQYXRoPWZ1bmN0aW9uKCl7dmFyIGU9XG50aGlzLmN1cnJlbnREYXRhR3JvdXBpbmcsYT1lJiZlLmdhcFNpemU7ZT10aGlzLm9wdGlvbnMuZ2FwU2l6ZTt2YXIgZj10aGlzLnBvaW50cy5zbGljZSgpLGM9Zi5sZW5ndGgtMSxkPXRoaXMueUF4aXMsYjtpZihlJiYwPGMpZm9yKFwidmFsdWVcIiE9PXRoaXMub3B0aW9ucy5nYXBVbml0JiYoZSo9dGhpcy5iYXNlUG9pbnRSYW5nZSksYSYmYT5lJiZhPj10aGlzLmJhc2VQb2ludFJhbmdlJiYoZT1hKSxiPXZvaWQgMDtjLS07KWImJiExIT09Yi52aXNpYmxlfHwoYj1mW2MrMV0pLGE9ZltjXSwhMSE9PWIudmlzaWJsZSYmITEhPT1hLnZpc2libGUmJihiLngtYS54PmUmJihiPShhLngrYi54KS8yLGYuc3BsaWNlKGMrMSwwLHtpc051bGw6ITAseDpifSksZC5zdGFja2luZyYmdGhpcy5vcHRpb25zLnN0YWNraW5nJiYoYj1kLnN0YWNraW5nLnN0YWNrc1t0aGlzLnN0YWNrS2V5XVtiXT1uZXcgdChkLGQub3B0aW9ucy5zdGFja0xhYmVscywhMSxiLHRoaXMuc3RhY2spLGIudG90YWw9MCkpLFxuYj1hKTtyZXR1cm4gdGhpcy5nZXRHcmFwaFBhdGgoZil9O24oYSxcImluaXRcIixmdW5jdGlvbigpe3RoaXMuYnJva2VuQXhpc3x8KHRoaXMuYnJva2VuQXhpcz1uZXcgdyh0aGlzKSl9KTtuKGEsXCJhZnRlckluaXRcIixmdW5jdGlvbigpe1widW5kZWZpbmVkXCIhPT10eXBlb2YgdGhpcy5icm9rZW5BeGlzJiZ0aGlzLmJyb2tlbkF4aXMuc2V0QnJlYWtzKHRoaXMub3B0aW9ucy5icmVha3MsITEpfSk7bihhLFwiYWZ0ZXJTZXRUaWNrUG9zaXRpb25zXCIsZnVuY3Rpb24oKXt2YXIgZT10aGlzLmJyb2tlbkF4aXM7aWYoZSYmZS5oYXNCcmVha3Mpe3ZhciBhPXRoaXMudGlja1Bvc2l0aW9ucyxmPXRoaXMudGlja1Bvc2l0aW9ucy5pbmZvLGM9W10sZDtmb3IoZD0wO2Q8YS5sZW5ndGg7ZCsrKWUuaXNJbkFueUJyZWFrKGFbZF0pfHxjLnB1c2goYVtkXSk7dGhpcy50aWNrUG9zaXRpb25zPWM7dGhpcy50aWNrUG9zaXRpb25zLmluZm89Zn19KTtuKGEsXCJhZnRlclNldE9wdGlvbnNcIixmdW5jdGlvbigpe3RoaXMuYnJva2VuQXhpcyYmXG50aGlzLmJyb2tlbkF4aXMuaGFzQnJlYWtzJiYodGhpcy5vcHRpb25zLm9yZGluYWw9ITEpfSk7bih2LFwiYWZ0ZXJHZW5lcmF0ZVBvaW50c1wiLGZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5vcHRpb25zLmNvbm5lY3ROdWxscyxhPXRoaXMucG9pbnRzLGY9dGhpcy54QXhpcyxjPXRoaXMueUF4aXM7aWYodGhpcy5pc0RpcnR5KWZvcih2YXIgZD1hLmxlbmd0aDtkLS07KXt2YXIgYj1hW2RdLHY9IShudWxsPT09Yi55JiYhMT09PWUpJiYoZiYmZi5icm9rZW5BeGlzJiZmLmJyb2tlbkF4aXMuaXNJbkFueUJyZWFrKGIueCwhMCl8fGMmJmMuYnJva2VuQXhpcyYmYy5icm9rZW5BeGlzLmlzSW5BbnlCcmVhayhiLnksITApKTtiLnZpc2libGU9dj8hMTohMSE9PWIub3B0aW9ucy52aXNpYmxlfX0pO24odixcImFmdGVyUmVuZGVyXCIsZnVuY3Rpb24oKXt0aGlzLmRyYXdCcmVha3ModGhpcy54QXhpcyxbXCJ4XCJdKTt0aGlzLmRyYXdCcmVha3ModGhpcy55QXhpcyxwKHRoaXMucG9pbnRBcnJheU1hcCxbXCJ5XCJdKSl9KX07XG5yZXR1cm4gYX0oKTtyLmNvbXBvc2UoYSx1KTtyZXR1cm4gcn0pO0YoYSxcIkNvcmUvQXhpcy9UcmVlR3JpZEF4aXMuanNcIixbYVtcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLGFbXCJDb3JlL0F4aXMvVGljay5qc1wiXSxhW1wiR2FudHQvVHJlZS5qc1wiXSxhW1wiQ29yZS9BeGlzL1RyZWVHcmlkVGljay5qc1wiXSxhW1wiTWl4aW5zL1RyZWVTZXJpZXMuanNcIl0sYVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihhLHUsdCxyLG4saCl7dmFyIEE9bi5nZXRMZXZlbE9wdGlvbnMsQj1oLmFkZEV2ZW50LEQ9aC5maW5kLHA9aC5maXJlRXZlbnQsdz1oLmlzQXJyYXksaz1oLmlzTnVtYmVyLGY9aC5pc09iamVjdCx2PWguaXNTdHJpbmcsZT1oLm1lcmdlLGc9aC5waWNrLG09aC53cmFwLHE7KGZ1bmN0aW9uKGMpe2Z1bmN0aW9uIGQoYixkKXt2YXIgYz1iLmNvbGxhcHNlU3RhcnR8fDA7Yj1iLmNvbGxhcHNlRW5kfHwwO2I+PWQmJihjLT0uNSk7cmV0dXJue2Zyb206Yyx0bzpiLHNob3dQb2ludHM6ITF9fVxuZnVuY3Rpb24gYihiLGQsYyl7dmFyIGw9W10seD1bXSxlPXt9LGE9e30seT0tMSx6PVwiYm9vbGVhblwiPT09dHlwZW9mIGQ/ZDohMTtiPXQuZ2V0VHJlZShiLHthZnRlcjpmdW5jdGlvbihsKXtsPWFbbC5wb3NdO3ZhciBiPTAsZD0wO2wuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihsKXtkKz0obC5kZXNjZW5kYW50c3x8MCkrMTtiPU1hdGgubWF4KChsLmhlaWdodHx8MCkrMSxiKX0pO2wuZGVzY2VuZGFudHM9ZDtsLmhlaWdodD1iO2wuY29sbGFwc2VkJiZ4LnB1c2gobCl9LGJlZm9yZTpmdW5jdGlvbihiKXt2YXIgeD1mKGIuZGF0YSwhMCk/Yi5kYXRhOnt9LGQ9dih4Lm5hbWUpP3gubmFtZTpcIlwiLGM9ZVtiLnBhcmVudF07Yz1mKGMsITApP2FbYy5wb3NdOm51bGw7dmFyIEc9ZnVuY3Rpb24obCl7cmV0dXJuIGwubmFtZT09PWR9LGc7eiYmZihjLCEwKSYmKGc9RChjLmNoaWxkcmVuLEcpKT8oRz1nLnBvcyxnLm5vZGVzLnB1c2goYikpOkc9eSsrO2FbR118fChhW0ddPWc9e2RlcHRoOmM/XG5jLmRlcHRoKzE6MCxuYW1lOmQsaWQ6eC5pZCxub2RlczpbYl0sY2hpbGRyZW46W10scG9zOkd9LC0xIT09RyYmbC5wdXNoKGQpLGYoYywhMCkmJmMuY2hpbGRyZW4ucHVzaChnKSk7dihiLmlkKSYmKGVbYi5pZF09Yik7ZyYmITA9PT14LmNvbGxhcHNlZCYmKGcuY29sbGFwc2VkPSEwKTtiLnBvcz1HfX0pO2E9ZnVuY3Rpb24obCxiKXt2YXIgeD1mdW5jdGlvbihsLGQsYyl7dmFyIGU9ZCsoLTE9PT1kPzA6Yi0xKSxhPShlLWQpLzIseT1kK2E7bC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGwpe3ZhciBiPWwuZGF0YTtmKGIsITApJiYoYi55PWQrKGIuc2VyaWVzSW5kZXh8fDApLGRlbGV0ZSBiLnNlcmllc0luZGV4KTtsLnBvcz15fSk7Y1t5XT1sO2wucG9zPXk7bC50aWNrbWFya09mZnNldD1hKy41O2wuY29sbGFwc2VTdGFydD1lKy41O2wuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihsKXt4KGwsZSsxLGMpO2U9KGwuY29sbGFwc2VFbmR8fDApLS41fSk7bC5jb2xsYXBzZUVuZD1lKy41O1xucmV0dXJuIGN9O3JldHVybiB4KGxbXCItMVwiXSwtMSx7fSl9KGEsYyk7cmV0dXJue2NhdGVnb3JpZXM6bCxtYXBPZklkVG9Ob2RlOmUsbWFwT2ZQb3NUb0dyaWROb2RlOmEsY29sbGFwc2VkTm9kZXM6eCx0cmVlOmJ9fWZ1bmN0aW9uIGEoZCl7ZC50YXJnZXQuYXhlcy5maWx0ZXIoZnVuY3Rpb24oYil7cmV0dXJuXCJ0cmVlZ3JpZFwiPT09Yi5vcHRpb25zLnR5cGV9KS5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBhPWMub3B0aW9uc3x8e30sbD1hLmxhYmVscyx4PWEudW5pcXVlTmFtZXMseT0wO2E9YS5tYXg7aWYoIWMudHJlZUdyaWQubWFwT2ZQb3NUb0dyaWROb2RlfHxjLnNlcmllcy5zb21lKGZ1bmN0aW9uKGwpe3JldHVybiFsLmhhc1JlbmRlcmVkfHxsLmlzRGlydHlEYXRhfHxsLmlzRGlydHl9KSl7dmFyIGc9Yy5zZXJpZXMucmVkdWNlKGZ1bmN0aW9uKGwsYil7Yi52aXNpYmxlJiYoKGIub3B0aW9ucy5kYXRhfHxbXSkuZm9yRWFjaChmdW5jdGlvbihjKXtiLm9wdGlvbnMua2V5cyYmYi5vcHRpb25zLmtleXMubGVuZ3RoJiZcbihjPWIucG9pbnRDbGFzcy5wcm90b3R5cGUub3B0aW9uc1RvT2JqZWN0LmNhbGwoe3NlcmllczpifSxjKSxiLnBvaW50Q2xhc3Muc2V0R2FudHRQb2ludEFsaWFzZXMoYykpO2YoYywhMCkmJihjLnNlcmllc0luZGV4PXksbC5wdXNoKGMpKX0pLCEwPT09eCYmeSsrKTtyZXR1cm4gbH0sW10pO2lmKGEmJmcubGVuZ3RoPGEpZm9yKHZhciBxPWcubGVuZ3RoO3E8PWE7cSsrKWcucHVzaCh7bmFtZTpxK1wiXFx1MjAwYlwifSk7YT1iKGcseHx8ITEsITA9PT14P3k6MSk7Yy5jYXRlZ29yaWVzPWEuY2F0ZWdvcmllcztjLnRyZWVHcmlkLm1hcE9mUG9zVG9HcmlkTm9kZT1hLm1hcE9mUG9zVG9HcmlkTm9kZTtjLmhhc05hbWVzPSEwO2MudHJlZUdyaWQudHJlZT1hLnRyZWU7Yy5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihsKXt2YXIgYj0obC5vcHRpb25zLmRhdGF8fFtdKS5tYXAoZnVuY3Rpb24oYil7dyhiKSYmbC5vcHRpb25zLmtleXMmJmwub3B0aW9ucy5rZXlzLmxlbmd0aCYmZy5mb3JFYWNoKGZ1bmN0aW9uKGwpezA8PVxuYi5pbmRleE9mKGwueCkmJjA8PWIuaW5kZXhPZihsLngyKSYmKGI9bCl9KTtyZXR1cm4gZihiLCEwKT9lKGIpOmJ9KTtsLnZpc2libGUmJmwuc2V0RGF0YShiLCExKX0pO2MudHJlZUdyaWQubWFwT3B0aW9uc1RvTGV2ZWw9QSh7ZGVmYXVsdHM6bCxmcm9tOjEsbGV2ZWxzOmwmJmwubGV2ZWxzLHRvOmMudHJlZUdyaWQudHJlZSYmYy50cmVlR3JpZC50cmVlLmhlaWdodH0pO1wiYmVmb3JlUmVuZGVyXCI9PT1kLnR5cGUmJihjLnRyZWVHcmlkLmNvbGxhcHNlZE5vZGVzPWEuY29sbGFwc2VkTm9kZXMpfX0pfWZ1bmN0aW9uIHEoYixjKXt2YXIgZD10aGlzLnRyZWVHcmlkLm1hcE9wdGlvbnNUb0xldmVsfHx7fSxsPXRoaXMudGlja3MseD1sW2NdLGE7aWYoXCJ0cmVlZ3JpZFwiPT09dGhpcy5vcHRpb25zLnR5cGUmJnRoaXMudHJlZUdyaWQubWFwT2ZQb3NUb0dyaWROb2RlKXt2YXIgZT10aGlzLnRyZWVHcmlkLm1hcE9mUG9zVG9HcmlkTm9kZVtjXTsoZD1kW2UuZGVwdGhdKSYmKGE9e2xhYmVsczpkfSk7XG54Pyh4LnBhcmFtZXRlcnMuY2F0ZWdvcnk9ZS5uYW1lLHgub3B0aW9ucz1hLHguYWRkTGFiZWwoKSk6bFtjXT1uZXcgdSh0aGlzLGMsdm9pZCAwLHZvaWQgMCx7Y2F0ZWdvcnk6ZS5uYW1lLHRpY2ttYXJrT2Zmc2V0OmUudGlja21hcmtPZmZzZXQsb3B0aW9uczphfSl9ZWxzZSBiLmFwcGx5KHRoaXMsQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpKX1mdW5jdGlvbiBoKGIpe3ZhciBjPXRoaXMub3B0aW9ucztjPShjPWMmJmMubGFiZWxzKSYmayhjLmluZGVudGF0aW9uKT9jLmluZGVudGF0aW9uOjA7dmFyIGQ9Yi5hcHBseSh0aGlzLEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSk7aWYoXCJ0cmVlZ3JpZFwiPT09dGhpcy5vcHRpb25zLnR5cGUmJnRoaXMudHJlZUdyaWQubWFwT2ZQb3NUb0dyaWROb2RlKXt2YXIgbD10aGlzLnRyZWVHcmlkLm1hcE9mUG9zVG9HcmlkTm9kZVstMV0uaGVpZ2h0fHwwO2Qud2lkdGgrPWMqKGwtMSl9cmV0dXJuIGR9XG5mdW5jdGlvbiBuKGMsZCx6KXt2YXIgbD10aGlzLHg9XCJ0cmVlZ3JpZFwiPT09ei50eXBlO2wudHJlZUdyaWR8fChsLnRyZWVHcmlkPW5ldyBNKGwpKTt4JiYoQihkLFwiYmVmb3JlUmVuZGVyXCIsYSksQihkLFwiYmVmb3JlUmVkcmF3XCIsYSksQihkLFwiYWRkU2VyaWVzXCIsZnVuY3Rpb24oYyl7Yy5vcHRpb25zLmRhdGEmJihjPWIoYy5vcHRpb25zLmRhdGEsei51bmlxdWVOYW1lc3x8ITEsMSksbC50cmVlR3JpZC5jb2xsYXBzZWROb2Rlcz0obC50cmVlR3JpZC5jb2xsYXBzZWROb2Rlc3x8W10pLmNvbmNhdChjLmNvbGxhcHNlZE5vZGVzKSl9KSxCKGwsXCJmb3VuZEV4dHJlbWVzXCIsZnVuY3Rpb24oKXtsLnRyZWVHcmlkLmNvbGxhcHNlZE5vZGVzJiZsLnRyZWVHcmlkLmNvbGxhcHNlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24oYil7dmFyIGM9bC50cmVlR3JpZC5jb2xsYXBzZShiKTtsLmJyb2tlbkF4aXMmJihsLmJyb2tlbkF4aXMuc2V0QnJlYWtzKGMsITEpLGwudHJlZUdyaWQuY29sbGFwc2VkTm9kZXMmJlxuKGwudHJlZUdyaWQuY29sbGFwc2VkTm9kZXM9bC50cmVlR3JpZC5jb2xsYXBzZWROb2Rlcy5maWx0ZXIoZnVuY3Rpb24obCl7cmV0dXJuIGIuY29sbGFwc2VTdGFydCE9PWwuY29sbGFwc2VTdGFydHx8Yi5jb2xsYXBzZUVuZCE9PWwuY29sbGFwc2VFbmR9KSkpfSl9KSxCKGwsXCJhZnRlckJyZWFrc1wiLGZ1bmN0aW9uKCl7dmFyIGI7XCJ5QXhpc1wiPT09bC5jb2xsJiYhbC5zdGF0aWNTY2FsZSYmKG51bGw9PT0oYj1sLmNoYXJ0Lm9wdGlvbnMuY2hhcnQpfHx2b2lkIDA9PT1iPzA6Yi5oZWlnaHQpJiYobC5pc0RpcnR5PSEwKX0pLHo9ZSh7Z3JpZDp7ZW5hYmxlZDohMH0sbGFiZWxzOnthbGlnbjpcImxlZnRcIixsZXZlbHM6W3tsZXZlbDp2b2lkIDB9LHtsZXZlbDoxLHN0eWxlOntmb250V2VpZ2h0OlwiYm9sZFwifX1dLHN5bWJvbDp7dHlwZTpcInRyaWFuZ2xlXCIseDotNSx5Oi01LGhlaWdodDoxMCx3aWR0aDoxMCxwYWRkaW5nOjV9fSx1bmlxdWVOYW1lczohMX0seix7cmV2ZXJzZWQ6ITAsZ3JpZDp7Y29sdW1uczp2b2lkIDB9fSkpO1xuYy5hcHBseShsLFtkLHpdKTt4JiYobC5oYXNOYW1lcz0hMCxsLm9wdGlvbnMuc2hvd0xhc3RMYWJlbD0hMCl9ZnVuY3Rpb24gSChiKXt2YXIgYz10aGlzLm9wdGlvbnM7XCJ0cmVlZ3JpZFwiPT09Yy50eXBlPyh0aGlzLm1pbj1nKHRoaXMudXNlck1pbixjLm1pbix0aGlzLmRhdGFNaW4pLHRoaXMubWF4PWcodGhpcy51c2VyTWF4LGMubWF4LHRoaXMuZGF0YU1heCkscCh0aGlzLFwiZm91bmRFeHRyZW1lc1wiKSx0aGlzLnNldEF4aXNUcmFuc2xhdGlvbigpLHRoaXMudGlja21hcmtPZmZzZXQ9LjUsdGhpcy50aWNrSW50ZXJ2YWw9MSx0aGlzLnRpY2tQb3NpdGlvbnM9dGhpcy50cmVlR3JpZC5tYXBPZlBvc1RvR3JpZE5vZGU/dGhpcy50cmVlR3JpZC5nZXRUaWNrUG9zaXRpb25zKCk6W10pOmIuYXBwbHkodGhpcyxBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSkpfXZhciBDPSExO2MuY29tcG9zZT1mdW5jdGlvbihiKXtDfHwobShiLnByb3RvdHlwZSxcImdlbmVyYXRlVGlja1wiLFxucSksbShiLnByb3RvdHlwZSxcImdldE1heExhYmVsRGltZW5zaW9uc1wiLGgpLG0oYi5wcm90b3R5cGUsXCJpbml0XCIsbiksbShiLnByb3RvdHlwZSxcInNldFRpY2tJbnRlcnZhbFwiLEgpLHIuY29tcG9zZSh1KSxDPSEwKX07dmFyIE09ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKGIpe3RoaXMuYXhpcz1ifWIucHJvdG90eXBlLnNldENvbGxhcHNlZFN0YXR1cz1mdW5jdGlvbihiKXt2YXIgYz10aGlzLmF4aXMsbD1jLmNoYXJ0O2Muc2VyaWVzLmZvckVhY2goZnVuY3Rpb24oYyl7dmFyIGQ9Yy5vcHRpb25zLmRhdGE7aWYoYi5pZCYmZCl7dmFyIHg9bC5nZXQoYi5pZCk7Yz1kW2MuZGF0YS5pbmRleE9mKHgpXTt4JiZjJiYoeC5jb2xsYXBzZWQ9Yi5jb2xsYXBzZWQsYy5jb2xsYXBzZWQ9Yi5jb2xsYXBzZWQpfX0pfTtiLnByb3RvdHlwZS5jb2xsYXBzZT1mdW5jdGlvbihiKXt2YXIgYz10aGlzLmF4aXMsbD1jLm9wdGlvbnMuYnJlYWtzfHxbXSx4PWQoYixjLm1heCk7bC5wdXNoKHgpO2IuY29sbGFwc2VkPVxuITA7Yy50cmVlR3JpZC5zZXRDb2xsYXBzZWRTdGF0dXMoYik7cmV0dXJuIGx9O2IucHJvdG90eXBlLmV4cGFuZD1mdW5jdGlvbihiKXt2YXIgYz10aGlzLmF4aXMsbD1jLm9wdGlvbnMuYnJlYWtzfHxbXSx4PWQoYixjLm1heCk7Yi5jb2xsYXBzZWQ9ITE7Yy50cmVlR3JpZC5zZXRDb2xsYXBzZWRTdGF0dXMoYik7cmV0dXJuIGwucmVkdWNlKGZ1bmN0aW9uKGwsYil7Yi50bz09PXgudG8mJmIuZnJvbT09PXguZnJvbXx8bC5wdXNoKGIpO3JldHVybiBsfSxbXSl9O2IucHJvdG90eXBlLmdldFRpY2tQb3NpdGlvbnM9ZnVuY3Rpb24oKXt2YXIgYj10aGlzLmF4aXMsYz1NYXRoLmZsb29yKGIubWluL2IudGlja0ludGVydmFsKSpiLnRpY2tJbnRlcnZhbCxsPU1hdGguY2VpbChiLm1heC9iLnRpY2tJbnRlcnZhbCkqYi50aWNrSW50ZXJ2YWw7cmV0dXJuIE9iamVjdC5rZXlzKGIudHJlZUdyaWQubWFwT2ZQb3NUb0dyaWROb2RlfHx7fSkucmVkdWNlKGZ1bmN0aW9uKGQsYSl7YT0rYTshKGE+PVxuYyYmYTw9bCl8fGIuYnJva2VuQXhpcyYmYi5icm9rZW5BeGlzLmlzSW5BbnlCcmVhayhhKXx8ZC5wdXNoKGEpO3JldHVybiBkfSxbXSl9O2IucHJvdG90eXBlLmlzQ29sbGFwc2VkPWZ1bmN0aW9uKGIpe3ZhciBjPXRoaXMuYXhpcyxsPWMub3B0aW9ucy5icmVha3N8fFtdLHg9ZChiLGMubWF4KTtyZXR1cm4gbC5zb21lKGZ1bmN0aW9uKGIpe3JldHVybiBiLmZyb209PT14LmZyb20mJmIudG89PT14LnRvfSl9O2IucHJvdG90eXBlLnRvZ2dsZUNvbGxhcHNlPWZ1bmN0aW9uKGIpe3JldHVybiB0aGlzLmlzQ29sbGFwc2VkKGIpP3RoaXMuZXhwYW5kKGIpOnRoaXMuY29sbGFwc2UoYil9O3JldHVybiBifSgpO2MuQWRkaXRpb25zPU19KShxfHwocT17fSkpO2EucHJvdG90eXBlLnV0aWxzPXtnZXROb2RlOnQuZ2V0Tm9kZX07cS5jb21wb3NlKGEpO3JldHVybiBxfSk7RihhLFwiRXh0ZW5zaW9ucy9DdXJyZW50RGF0ZUluZGljYXRpb24uanNcIixbYVtcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLGFbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sXG5hW1wiQ29yZS9VdGlsaXRpZXMuanNcIl0sYVtcIkNvcmUvQXhpcy9QbG90TGluZU9yQmFuZC5qc1wiXV0sZnVuY3Rpb24oYSx1LHQscil7dmFyIG49dC5hZGRFdmVudCxoPXQubWVyZ2U7dD10LndyYXA7dmFyIEE9e2N1cnJlbnREYXRlSW5kaWNhdG9yOiEwLGNvbG9yOnUuaGlnaGxpZ2h0Q29sb3IyMCx3aWR0aDoyLGxhYmVsOntmb3JtYXQ6XCIlYSwgJWIgJWQgJVksICVIOiVNXCIsZm9ybWF0dGVyOmZ1bmN0aW9uKGEsaCl7cmV0dXJuIHRoaXMuYXhpcy5jaGFydC50aW1lLmRhdGVGb3JtYXQoaCxhKX0scm90YXRpb246MCxzdHlsZTp7Zm9udFNpemU6XCIxMHB4XCJ9fX07bihhLFwiYWZ0ZXJTZXRPcHRpb25zXCIsZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsbj1hLmN1cnJlbnREYXRlSW5kaWNhdG9yO24mJihuPVwib2JqZWN0XCI9PT10eXBlb2Ygbj9oKEEsbik6aChBKSxuLnZhbHVlPW5ldyBEYXRlLGEucGxvdExpbmVzfHwoYS5wbG90TGluZXM9W10pLGEucGxvdExpbmVzLnB1c2gobikpfSk7XG5uKHIsXCJyZW5kZXJcIixmdW5jdGlvbigpe3RoaXMubGFiZWwmJnRoaXMubGFiZWwuYXR0cih7dGV4dDp0aGlzLmdldExhYmVsVGV4dCh0aGlzLm9wdGlvbnMubGFiZWwpfSl9KTt0KHIucHJvdG90eXBlLFwiZ2V0TGFiZWxUZXh0XCIsZnVuY3Rpb24oYSxoKXt2YXIgcD10aGlzLm9wdGlvbnM7cmV0dXJuIHAuY3VycmVudERhdGVJbmRpY2F0b3ImJnAubGFiZWwmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBwLmxhYmVsLmZvcm1hdHRlcj8ocC52YWx1ZT1uZXcgRGF0ZSxwLmxhYmVsLmZvcm1hdHRlci5jYWxsKHRoaXMscC52YWx1ZSxwLmxhYmVsLmZvcm1hdCkpOmEuY2FsbCh0aGlzLGgpfSl9KTtGKGEsXCJFeHRlbnNpb25zL1N0YXRpY1NjYWxlLmpzXCIsW2FbXCJDb3JlL0F4aXMvQXhpcy5qc1wiXSxhW1wiQ29yZS9DaGFydC9DaGFydC5qc1wiXSxhW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGEsdSx0KXt2YXIgcj10LmFkZEV2ZW50LG49dC5kZWZpbmVkLGg9dC5pc051bWJlcixBPXQucGljaztcbnIoYSxcImFmdGVyU2V0T3B0aW9uc1wiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydC5vcHRpb25zJiZ0aGlzLmNoYXJ0Lm9wdGlvbnMuY2hhcnQ7IXRoaXMuaG9yaXomJmgodGhpcy5vcHRpb25zLnN0YXRpY1NjYWxlKSYmKCFhLmhlaWdodHx8YS5zY3JvbGxhYmxlUGxvdEFyZWEmJmEuc2Nyb2xsYWJsZVBsb3RBcmVhLm1pbkhlaWdodCkmJih0aGlzLnN0YXRpY1NjYWxlPXRoaXMub3B0aW9ucy5zdGF0aWNTY2FsZSl9KTt1LnByb3RvdHlwZS5hZGp1c3RIZWlnaHQ9ZnVuY3Rpb24oKXtcImFkanVzdEhlaWdodFwiIT09dGhpcy5yZWRyYXdUcmlnZ2VyJiYoKHRoaXMuYXhlc3x8W10pLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGg9YS5jaGFydCxwPSEhaC5pbml0aWF0ZWRTY2FsZSYmaC5vcHRpb25zLmFuaW1hdGlvbix3PWEub3B0aW9ucy5zdGF0aWNTY2FsZTtpZihhLnN0YXRpY1NjYWxlJiZuKGEubWluKSl7dmFyIGs9QShhLmJyb2tlbkF4aXMmJmEuYnJva2VuQXhpcy51bml0TGVuZ3RoLFxuYS5tYXgrYS50aWNrSW50ZXJ2YWwtYS5taW4pKnc7az1NYXRoLm1heChrLHcpO3c9ay1oLnBsb3RIZWlnaHQ7MTw9TWF0aC5hYnModykmJihoLnBsb3RIZWlnaHQ9ayxoLnJlZHJhd1RyaWdnZXI9XCJhZGp1c3RIZWlnaHRcIixoLnNldFNpemUodm9pZCAwLGguY2hhcnRIZWlnaHQrdyxwKSk7YS5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihhKXsoYT1hLnNoYXJlZENsaXBLZXkmJmhbYS5zaGFyZWRDbGlwS2V5XSkmJmEuYXR0cih7aGVpZ2h0OmgucGxvdEhlaWdodH0pfSl9fSksdGhpcy5pbml0aWF0ZWRTY2FsZT0hMCk7dGhpcy5yZWRyYXdUcmlnZ2VyPW51bGx9O3IodSxcInJlbmRlclwiLHUucHJvdG90eXBlLmFkanVzdEhlaWdodCl9KTtGKGEsXCJFeHRlbnNpb25zL0Fycm93U3ltYm9scy5qc1wiLFthW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHUmVuZGVyZXIuanNcIl1dLGZ1bmN0aW9uKGEpe2EucHJvdG90eXBlLnN5bWJvbHMuYXJyb3c9ZnVuY3Rpb24oYSx0LHIsbil7cmV0dXJuW1tcIk1cIixhLFxudCtuLzJdLFtcIkxcIixhK3IsdF0sW1wiTFwiLGEsdCtuLzJdLFtcIkxcIixhK3IsdCtuXV19O2EucHJvdG90eXBlLnN5bWJvbHNbXCJhcnJvdy1oYWxmXCJdPWZ1bmN0aW9uKHUsdCxyLG4pe3JldHVybiBhLnByb3RvdHlwZS5zeW1ib2xzLmFycm93KHUsdCxyLzIsbil9O2EucHJvdG90eXBlLnN5bWJvbHNbXCJ0cmlhbmdsZS1sZWZ0XCJdPWZ1bmN0aW9uKGEsdCxyLG4pe3JldHVybltbXCJNXCIsYStyLHRdLFtcIkxcIixhLHQrbi8yXSxbXCJMXCIsYStyLHQrbl0sW1wiWlwiXV19O2EucHJvdG90eXBlLnN5bWJvbHNbXCJhcnJvdy1maWxsZWRcIl09YS5wcm90b3R5cGUuc3ltYm9sc1tcInRyaWFuZ2xlLWxlZnRcIl07YS5wcm90b3R5cGUuc3ltYm9sc1tcInRyaWFuZ2xlLWxlZnQtaGFsZlwiXT1mdW5jdGlvbih1LHQscixuKXtyZXR1cm4gYS5wcm90b3R5cGUuc3ltYm9sc1tcInRyaWFuZ2xlLWxlZnRcIl0odSx0LHIvMixuKX07YS5wcm90b3R5cGUuc3ltYm9sc1tcImFycm93LWZpbGxlZC1oYWxmXCJdPWEucHJvdG90eXBlLnN5bWJvbHNbXCJ0cmlhbmdsZS1sZWZ0LWhhbGZcIl19KTtcbkYoYSxcIkdhbnR0L0Nvbm5lY3Rpb24uanNcIixbYVtcIkNvcmUvR2xvYmFscy5qc1wiXSxhW1wiQ29yZS9PcHRpb25zLmpzXCJdLGFbXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiXSxhW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGEsdSx0LHIpe2Z1bmN0aW9uIG4oYSl7dmFyIGU9YS5zaGFwZUFyZ3M7cmV0dXJuIGU/e3hNaW46ZS54LHhNYXg6ZS54K2Uud2lkdGgseU1pbjplLnkseU1heDplLnkrZS5oZWlnaHR9OihlPWEuZ3JhcGhpYyYmYS5ncmFwaGljLmdldEJCb3goKSk/e3hNaW46YS5wbG90WC1lLndpZHRoLzIseE1heDphLnBsb3RYK2Uud2lkdGgvMix5TWluOmEucGxvdFktZS5oZWlnaHQvMix5TWF4OmEucGxvdFkrZS5oZWlnaHQvMn06bnVsbH1cIlwiO3ZhciBoPXIuZGVmaW5lZCxBPXIuZXJyb3IsQj1yLmV4dGVuZCxEPXIubWVyZ2UscD1yLm9iamVjdEVhY2gsdz1hLmRlZzJyYWQsaz1NYXRoLm1heCxmPU1hdGgubWluO0IodS5kZWZhdWx0T3B0aW9ucyx7Y29ubmVjdG9yczp7dHlwZTpcInN0cmFpZ2h0XCIsXG5saW5lV2lkdGg6MSxtYXJrZXI6e2VuYWJsZWQ6ITEsYWxpZ246XCJjZW50ZXJcIix2ZXJ0aWNhbEFsaWduOlwibWlkZGxlXCIsaW5zaWRlOiExLGxpbmVXaWR0aDoxfSxzdGFydE1hcmtlcjp7c3ltYm9sOlwiZGlhbW9uZFwifSxlbmRNYXJrZXI6e3N5bWJvbDpcImFycm93LWZpbGxlZFwifX19KTt1PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGcsZil7dGhpcy50b1BvaW50PXRoaXMucGF0aGZpbmRlcj10aGlzLmdyYXBoaWNzPXRoaXMuZnJvbVBvaW50PXRoaXMuY2hhcnQ9dm9pZCAwO3RoaXMuaW5pdChhLGcsZil9YS5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhLGcsZil7dGhpcy5mcm9tUG9pbnQ9YTt0aGlzLnRvUG9pbnQ9Zzt0aGlzLm9wdGlvbnM9Zjt0aGlzLmNoYXJ0PWEuc2VyaWVzLmNoYXJ0O3RoaXMucGF0aGZpbmRlcj10aGlzLmNoYXJ0LnBhdGhmaW5kZXJ9O2EucHJvdG90eXBlLnJlbmRlclBhdGg9ZnVuY3Rpb24oYSxnLGYpe3ZhciBlPXRoaXMuY2hhcnQsYz1lLnN0eWxlZE1vZGUsZD1cbmUucGF0aGZpbmRlcixiPSFlLm9wdGlvbnMuY2hhcnQuZm9yRXhwb3J0JiYhMSE9PWYsbT10aGlzLmdyYXBoaWNzJiZ0aGlzLmdyYXBoaWNzLnBhdGg7ZC5ncm91cHx8KGQuZ3JvdXA9ZS5yZW5kZXJlci5nKCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXBhdGhmaW5kZXItZ3JvdXBcIikuYXR0cih7ekluZGV4Oi0xfSkuYWRkKGUuc2VyaWVzR3JvdXApKTtkLmdyb3VwLnRyYW5zbGF0ZShlLnBsb3RMZWZ0LGUucGxvdFRvcCk7bSYmbS5yZW5kZXJlcnx8KG09ZS5yZW5kZXJlci5wYXRoKCkuYWRkKGQuZ3JvdXApLGN8fG0uYXR0cih7b3BhY2l0eTowfSkpO20uYXR0cihnKTthPXtkOmF9O2N8fChhLm9wYWNpdHk9MSk7bVtiP1wiYW5pbWF0ZVwiOlwiYXR0clwiXShhLGYpO3RoaXMuZ3JhcGhpY3M9dGhpcy5ncmFwaGljc3x8e307dGhpcy5ncmFwaGljcy5wYXRoPW19O2EucHJvdG90eXBlLmFkZE1hcmtlcj1mdW5jdGlvbihhLGcsZil7dmFyIGU9dGhpcy5mcm9tUG9pbnQuc2VyaWVzLmNoYXJ0LGM9ZS5wYXRoZmluZGVyO1xuZT1lLnJlbmRlcmVyO3ZhciBkPVwic3RhcnRcIj09PWE/dGhpcy5mcm9tUG9pbnQ6dGhpcy50b1BvaW50LGI9ZC5nZXRQYXRoZmluZGVyQW5jaG9yUG9pbnQoZyk7aWYoZy5lbmFibGVkJiYoKGY9XCJzdGFydFwiPT09YT9mWzFdOmZbZi5sZW5ndGgtMl0pJiZcIk1cIj09PWZbMF18fFwiTFwiPT09ZlswXSkpe2Y9e3g6ZlsxXSx5OmZbMl19O2Y9ZC5nZXRSYWRpYW5zVG9WZWN0b3IoZixiKTtiPWQuZ2V0TWFya2VyVmVjdG9yKGYsZy5yYWRpdXMsYik7Zj0tZi93O2lmKGcud2lkdGgmJmcuaGVpZ2h0KXt2YXIgaz1nLndpZHRoO3ZhciBtPWcuaGVpZ2h0fWVsc2Ugaz1tPTIqZy5yYWRpdXM7dGhpcy5ncmFwaGljcz10aGlzLmdyYXBoaWNzfHx7fTtiPXt4OmIueC1rLzIseTpiLnktbS8yLHdpZHRoOmssaGVpZ2h0Om0scm90YXRpb246Zixyb3RhdGlvbk9yaWdpblg6Yi54LHJvdGF0aW9uT3JpZ2luWTpiLnl9O3RoaXMuZ3JhcGhpY3NbYV0/dGhpcy5ncmFwaGljc1thXS5hbmltYXRlKGIpOih0aGlzLmdyYXBoaWNzW2FdPVxuZS5zeW1ib2woZy5zeW1ib2wpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1wb2ludC1jb25uZWN0aW5nLXBhdGgtXCIrYStcIi1tYXJrZXJcIikuYXR0cihiKS5hZGQoYy5ncm91cCksZS5zdHlsZWRNb2RlfHx0aGlzLmdyYXBoaWNzW2FdLmF0dHIoe2ZpbGw6Zy5jb2xvcnx8dGhpcy5mcm9tUG9pbnQuY29sb3Isc3Ryb2tlOmcubGluZUNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6Zy5saW5lV2lkdGgsb3BhY2l0eTowfSkuYW5pbWF0ZSh7b3BhY2l0eToxfSxkLnNlcmllcy5vcHRpb25zLmFuaW1hdGlvbikpfX07YS5wcm90b3R5cGUuZ2V0UGF0aD1mdW5jdGlvbihhKXt2YXIgZT10aGlzLnBhdGhmaW5kZXIsZj10aGlzLmNoYXJ0LHE9ZS5hbGdvcml0aG1zW2EudHlwZV0sYz1lLmNoYXJ0T2JzdGFjbGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBxKXJldHVybiBBKCdcIicrYS50eXBlKydcIiBpcyBub3QgYSBQYXRoZmluZGVyIGFsZ29yaXRobS4nKSx7cGF0aDpbXSxvYnN0YWNsZXM6W119O3EucmVxdWlyZXNPYnN0YWNsZXMmJlxuIWMmJihjPWUuY2hhcnRPYnN0YWNsZXM9ZS5nZXRDaGFydE9ic3RhY2xlcyhhKSxmLm9wdGlvbnMuY29ubmVjdG9ycy5hbGdvcml0aG1NYXJnaW49YS5hbGdvcml0aG1NYXJnaW4sZS5jaGFydE9ic3RhY2xlTWV0cmljcz1lLmdldE9ic3RhY2xlTWV0cmljcyhjKSk7cmV0dXJuIHEodGhpcy5mcm9tUG9pbnQuZ2V0UGF0aGZpbmRlckFuY2hvclBvaW50KGEuc3RhcnRNYXJrZXIpLHRoaXMudG9Qb2ludC5nZXRQYXRoZmluZGVyQW5jaG9yUG9pbnQoYS5lbmRNYXJrZXIpLEQoe2NoYXJ0T2JzdGFjbGVzOmMsbGluZU9ic3RhY2xlczplLmxpbmVPYnN0YWNsZXN8fFtdLG9ic3RhY2xlTWV0cmljczplLmNoYXJ0T2JzdGFjbGVNZXRyaWNzLGhhcmRCb3VuZHM6e3hNaW46MCx4TWF4OmYucGxvdFdpZHRoLHlNaW46MCx5TWF4OmYucGxvdEhlaWdodH0sb2JzdGFjbGVPcHRpb25zOnttYXJnaW46YS5hbGdvcml0aG1NYXJnaW59LHN0YXJ0RGlyZWN0aW9uWDplLmdldEFsZ29yaXRobVN0YXJ0RGlyZWN0aW9uKGEuc3RhcnRNYXJrZXIpfSxcbmEpKX07YS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5mcm9tUG9pbnQsZz1hLnNlcmllcyxtPWcuY2hhcnQscT1tLnBhdGhmaW5kZXIsYz1EKG0ub3B0aW9ucy5jb25uZWN0b3JzLGcub3B0aW9ucy5jb25uZWN0b3JzLGEub3B0aW9ucy5jb25uZWN0b3JzLHRoaXMub3B0aW9ucyksZD17fTttLnN0eWxlZE1vZGV8fChkLnN0cm9rZT1jLmxpbmVDb2xvcnx8YS5jb2xvcixkW1wic3Ryb2tlLXdpZHRoXCJdPWMubGluZVdpZHRoLGMuZGFzaFN0eWxlJiYoZC5kYXNoc3R5bGU9Yy5kYXNoU3R5bGUpKTtkW1wiY2xhc3NcIl09XCJoaWdoY2hhcnRzLXBvaW50LWNvbm5lY3RpbmctcGF0aCBoaWdoY2hhcnRzLWNvbG9yLVwiK2EuY29sb3JJbmRleDtjPUQoZCxjKTtoKGMubWFya2VyLnJhZGl1cyl8fChjLm1hcmtlci5yYWRpdXM9ZihrKE1hdGguY2VpbCgoYy5hbGdvcml0aG1NYXJnaW58fDgpLzIpLTEsMSksNSkpO2E9dGhpcy5nZXRQYXRoKGMpO209YS5wYXRoO2Eub2JzdGFjbGVzJiZcbihxLmxpbmVPYnN0YWNsZXM9cS5saW5lT2JzdGFjbGVzfHxbXSxxLmxpbmVPYnN0YWNsZXM9cS5saW5lT2JzdGFjbGVzLmNvbmNhdChhLm9ic3RhY2xlcykpO3RoaXMucmVuZGVyUGF0aChtLGQsZy5vcHRpb25zLmFuaW1hdGlvbik7dGhpcy5hZGRNYXJrZXIoXCJzdGFydFwiLEQoYy5tYXJrZXIsYy5zdGFydE1hcmtlciksbSk7dGhpcy5hZGRNYXJrZXIoXCJlbmRcIixEKGMubWFya2VyLGMuZW5kTWFya2VyKSxtKX07YS5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMuZ3JhcGhpY3MmJihwKHRoaXMuZ3JhcGhpY3MsZnVuY3Rpb24oYSl7YS5kZXN0cm95KCl9KSxkZWxldGUgdGhpcy5ncmFwaGljcyl9O3JldHVybiBhfSgpO2EuQ29ubmVjdGlvbj11O0IodC5wcm90b3R5cGUse2dldFBhdGhmaW5kZXJBbmNob3JQb2ludDpmdW5jdGlvbihhKXt2YXIgZT1uKHRoaXMpO3N3aXRjaChhLmFsaWduKXtjYXNlIFwicmlnaHRcIjp2YXIgZz1cInhNYXhcIjticmVhaztjYXNlIFwibGVmdFwiOmc9XCJ4TWluXCJ9c3dpdGNoKGEudmVydGljYWxBbGlnbil7Y2FzZSBcInRvcFwiOnZhciBmPVxuXCJ5TWluXCI7YnJlYWs7Y2FzZSBcImJvdHRvbVwiOmY9XCJ5TWF4XCJ9cmV0dXJue3g6Zz9lW2ddOihlLnhNaW4rZS54TWF4KS8yLHk6Zj9lW2ZdOihlLnlNaW4rZS55TWF4KS8yfX0sZ2V0UmFkaWFuc1RvVmVjdG9yOmZ1bmN0aW9uKGEsZSl7dmFyIGc7aChlKXx8KGc9bih0aGlzKSkmJihlPXt4OihnLnhNaW4rZy54TWF4KS8yLHk6KGcueU1pbitnLnlNYXgpLzJ9KTtyZXR1cm4gTWF0aC5hdGFuMihlLnktYS55LGEueC1lLngpfSxnZXRNYXJrZXJWZWN0b3I6ZnVuY3Rpb24oYSxlLGcpe3ZhciBmPTIqTWF0aC5QSSxxPW4odGhpcyksYz1xLnhNYXgtcS54TWluLGQ9cS55TWF4LXEueU1pbixiPU1hdGguYXRhbjIoZCxjKSxrPSExO2MvPTI7dmFyIHc9ZC8yLGg9cS54TWluK2M7cT1xLnlNaW4rdztmb3IodmFyIHA9aCx2PXEscj0xLHQ9MTthPC1NYXRoLlBJOylhKz1mO2Zvcig7YT5NYXRoLlBJOylhLT1mO2Y9TWF0aC50YW4oYSk7YT4tYiYmYTw9Yj8odD0tMSxrPSEwKTphPmImJmE8PU1hdGguUEktXG5iP3Q9LTE6YT5NYXRoLlBJLWJ8fGE8PS0oTWF0aC5QSS1iKT8ocj0tMSxrPSEwKTpyPS0xO2s/KHArPXIqYyx2Kz10KmMqZik6KHArPWQvKDIqZikqcix2Kz10KncpO2cueCE9PWgmJihwPWcueCk7Zy55IT09cSYmKHY9Zy55KTtyZXR1cm57eDpwK2UqTWF0aC5jb3MoYSkseTp2LWUqTWF0aC5zaW4oYSl9fX0pO3JldHVybiB1fSk7RihhLFwiR2FudHQvUGF0aGZpbmRlckFsZ29yaXRobXMuanNcIixbYVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihhKXtmdW5jdGlvbiB1KGEsayxmKXtmPWZ8fDA7dmFyIGg9YS5sZW5ndGgtMTtrLT0xZS03O2Zvcih2YXIgZSxnO2Y8PWg7KWlmKGU9aCtmPj4xLGc9ay1hW2VdLnhNaW4sMDxnKWY9ZSsxO2Vsc2UgaWYoMD5nKWg9ZS0xO2Vsc2UgcmV0dXJuIGU7cmV0dXJuIDA8Zj9mLTE6MH1mdW5jdGlvbiB0KGEsayl7Zm9yKHZhciBmPXUoYSxrLngrMSkrMTtmLS07KXt2YXIgaDtpZihoPWFbZl0ueE1heD49ay54KWg9YVtmXSxoPWsueDw9aC54TWF4JiZcbmsueD49aC54TWluJiZrLnk8PWgueU1heCYmay55Pj1oLnlNaW47aWYoaClyZXR1cm4gZn1yZXR1cm4tMX1mdW5jdGlvbiByKGEpe3ZhciBrPVtdO2lmKGEubGVuZ3RoKXtrLnB1c2goW1wiTVwiLGFbMF0uc3RhcnQueCxhWzBdLnN0YXJ0LnldKTtmb3IodmFyIGY9MDtmPGEubGVuZ3RoOysrZilrLnB1c2goW1wiTFwiLGFbZl0uZW5kLngsYVtmXS5lbmQueV0pfXJldHVybiBrfWZ1bmN0aW9uIG4oYSxrKXthLnlNaW49RChhLnlNaW4say55TWluKTthLnlNYXg9QihhLnlNYXgsay55TWF4KTthLnhNaW49RChhLnhNaW4say54TWluKTthLnhNYXg9QihhLnhNYXgsay54TWF4KX12YXIgaD1hLmV4dGVuZCxBPWEucGljayxCPU1hdGgubWluLEQ9TWF0aC5tYXgscD1NYXRoLmFiczthPWgoZnVuY3Rpb24oYSxrLGYpe2Z1bmN0aW9uIGgoYSxiLGMsZCxlKXthPXt4OmEueCx5OmEueX07YVtiXT1jW2R8fGJdKyhlfHwwKTtyZXR1cm4gYX1mdW5jdGlvbiBlKGEsYixjKXt2YXIgZD1wKGJbY10tYVtjK1wiTWluXCJdKT5cbnAoYltjXS1hW2MrXCJNYXhcIl0pO3JldHVybiBoKGIsYyxhLGMrKGQ/XCJNYXhcIjpcIk1pblwiKSxkPzE6LTEpfXZhciBnPVtdLG09QShmLnN0YXJ0RGlyZWN0aW9uWCxwKGsueC1hLngpPnAoay55LWEueSkpP1wieFwiOlwieVwiLHE9Zi5jaGFydE9ic3RhY2xlcyxjPXQocSxhKTtmPXQocSxrKTtpZigtMTxmKXt2YXIgZD1xW2ZdO2Y9ZShkLGssbSk7ZD17c3RhcnQ6ZixlbmQ6a307dmFyIGI9Zn1lbHNlIGI9azstMTxjJiYocT1xW2NdLGY9ZShxLGEsbSksZy5wdXNoKHtzdGFydDphLGVuZDpmfSksZlttXT49YVttXT09PWZbbV0+PWJbbV0mJihtPVwieVwiPT09bT9cInhcIjpcInlcIixrPWFbbV08a1ttXSxnLnB1c2goe3N0YXJ0OmYsZW5kOmgoZixtLHEsbSsoaz9cIk1heFwiOlwiTWluXCIpLGs/MTotMSl9KSxtPVwieVwiPT09bT9cInhcIjpcInlcIikpO2E9Zy5sZW5ndGg/Z1tnLmxlbmd0aC0xXS5lbmQ6YTtmPWgoYSxtLGIpO2cucHVzaCh7c3RhcnQ6YSxlbmQ6Zn0pO209aChmLFwieVwiPT09bT9cInhcIjpcInlcIixiKTtnLnB1c2goe3N0YXJ0OmYsXG5lbmQ6bX0pO2cucHVzaChkKTtyZXR1cm57cGF0aDpyKGcpLG9ic3RhY2xlczpnfX0se3JlcXVpcmVzT2JzdGFjbGVzOiEwfSk7cmV0dXJue2Zhc3RBdm9pZDpoKGZ1bmN0aW9uKGEsayxmKXtmdW5jdGlvbiBoKGEsYixsKXt2YXIgYyxkPWEueDxiLng/MTotMTtpZihhLng8Yi54KXt2YXIgZT1hO3ZhciB5PWJ9ZWxzZSBlPWIseT1hO2lmKGEueTxiLnkpe3ZhciBmPWE7dmFyIGc9Yn1lbHNlIGY9YixnPWE7Zm9yKGM9MD5kP0IodShDLHkueCksQy5sZW5ndGgtMSk6MDtDW2NdJiYoMDxkJiZDW2NdLnhNaW48PXkueHx8MD5kJiZDW2NdLnhNYXg+PWUueCk7KXtpZihDW2NdLnhNaW48PXkueCYmQ1tjXS54TWF4Pj1lLngmJkNbY10ueU1pbjw9Zy55JiZDW2NdLnlNYXg+PWYueSlyZXR1cm4gbD97eTphLnkseDphLng8Yi54P0NbY10ueE1pbi0xOkNbY10ueE1heCsxLG9ic3RhY2xlOkNbY119Ont4OmEueCx5OmEueTxiLnk/Q1tjXS55TWluLTE6Q1tjXS55TWF4KzEsb2JzdGFjbGU6Q1tjXX07XG5jKz1kfXJldHVybiBifWZ1bmN0aW9uIGUoYSxiLGwsYyxkKXt2YXIgeD1kLnNvZnQsZT1kLmhhcmQseT1jP1wieFwiOlwieVwiLGY9e3g6Yi54LHk6Yi55fSxnPXt4OmIueCx5OmIueX07ZD1hW3krXCJNYXhcIl0+PXhbeStcIk1heFwiXTt4PWFbeStcIk1pblwiXTw9eFt5K1wiTWluXCJdO3ZhciBHPWFbeStcIk1heFwiXT49ZVt5K1wiTWF4XCJdO2U9YVt5K1wiTWluXCJdPD1lW3krXCJNaW5cIl07dmFyIHo9cChhW3krXCJNaW5cIl0tYlt5XSksaz1wKGFbeStcIk1heFwiXS1iW3ldKTtsPTEwPnAoei1rKT9iW3ldPGxbeV06azx6O2dbeV09YVt5K1wiTWluXCJdO2ZbeV09YVt5K1wiTWF4XCJdO2E9aChiLGcsYylbeV0hPT1nW3ldO2I9aChiLGYsYylbeV0hPT1mW3ldO2w9YT9iP2w6ITA6Yj8hMTpsO2w9eD9kP2w6ITA6ZD8hMTpsO3JldHVybiBlP0c/bDohMDpHPyExOmx9ZnVuY3Rpb24gZyhhLGMsbCl7aWYoYS54PT09Yy54JiZhLnk9PT1jLnkpcmV0dXJuW107dmFyIGQ9bD9cInhcIjpcInlcIix5PWYub2JzdGFjbGVPcHRpb25zLm1hcmdpbjtcbnZhciB6PXtzb2Z0Ont4TWluOkkseE1heDpLLHlNaW46TCx5TWF4Okh9LGhhcmQ6Zi5oYXJkQm91bmRzfTt2YXIgaz10KEMsYSk7aWYoLTE8ayl7az1DW2tdO3o9ZShrLGEsYyxsLHopO24oayxmLmhhcmRCb3VuZHMpO3ZhciBxPWw/e3k6YS55LHg6a1t6P1wieE1heFwiOlwieE1pblwiXSsoej8xOi0xKX06e3g6YS54LHk6a1t6P1wieU1heFwiOlwieU1pblwiXSsoej8xOi0xKX07dmFyIG09dChDLHEpOy0xPG0mJihtPUNbbV0sbihtLGYuaGFyZEJvdW5kcykscVtkXT16P0Qoa1tkK1wiTWF4XCJdLXkrMSwobVtkK1wiTWluXCJdK2tbZCtcIk1heFwiXSkvMik6QihrW2QrXCJNaW5cIl0reS0xLChtW2QrXCJNYXhcIl0ra1tkK1wiTWluXCJdKS8yKSxhLng9PT1xLngmJmEueT09PXEueT8oYiYmKHFbZF09ej9EKGtbZCtcIk1heFwiXSxtW2QrXCJNYXhcIl0pKzE6QihrW2QrXCJNaW5cIl0sbVtkK1wiTWluXCJdKS0xKSxiPSFiKTpiPSExKTthPVt7c3RhcnQ6YSxlbmQ6cX1dfWVsc2UgZD1oKGEse3g6bD9jLng6YS54LHk6bD9hLnk6Yy55fSxcbmwpLGE9W3tzdGFydDphLGVuZDp7eDpkLngseTpkLnl9fV0sZFtsP1wieFwiOlwieVwiXSE9PWNbbD9cInhcIjpcInlcIl0mJih6PWUoZC5vYnN0YWNsZSxkLGMsIWwseiksbihkLm9ic3RhY2xlLGYuaGFyZEJvdW5kcyksej17eDpsP2QueDpkLm9ic3RhY2xlW3o/XCJ4TWF4XCI6XCJ4TWluXCJdKyh6PzE6LTEpLHk6bD9kLm9ic3RhY2xlW3o/XCJ5TWF4XCI6XCJ5TWluXCJdKyh6PzE6LTEpOmQueX0sbD0hbCxhPWEuY29uY2F0KGcoe3g6ZC54LHk6ZC55fSx6LGwpKSk7cmV0dXJuIGE9YS5jb25jYXQoZyhhW2EubGVuZ3RoLTFdLmVuZCxjLCFsKSl9ZnVuY3Rpb24gbShhLGIsbCl7dmFyIGM9QihhLnhNYXgtYi54LGIueC1hLnhNaW4pPEIoYS55TWF4LWIueSxiLnktYS55TWluKTtsPWUoYSxiLGwsYyx7c29mdDpmLmhhcmRCb3VuZHMsaGFyZDpmLmhhcmRCb3VuZHN9KTtyZXR1cm4gYz97eTpiLnkseDphW2w/XCJ4TWF4XCI6XCJ4TWluXCJdKyhsPzE6LTEpfTp7eDpiLngseTphW2w/XCJ5TWF4XCI6XCJ5TWluXCJdKyhsPzE6LTEpfX1cbnZhciBxPUEoZi5zdGFydERpcmVjdGlvblgscChrLngtYS54KT5wKGsueS1hLnkpKSxjPXE/XCJ4XCI6XCJ5XCIsZD1bXSxiPSExLHc9Zi5vYnN0YWNsZU1ldHJpY3MsST1CKGEueCxrLngpLXcubWF4V2lkdGgtMTAsSz1EKGEueCxrLngpK3cubWF4V2lkdGgrMTAsTD1CKGEueSxrLnkpLXcubWF4SGVpZ2h0LTEwLEg9RChhLnksay55KSt3Lm1heEhlaWdodCsxMCxDPWYuY2hhcnRPYnN0YWNsZXM7dmFyIE09dShDLEkpO3c9dShDLEspO0M9Qy5zbGljZShNLHcrMSk7aWYoLTE8KHc9dChDLGspKSl7dmFyIEU9bShDW3ddLGssYSk7ZC5wdXNoKHtlbmQ6ayxzdGFydDpFfSk7az1FfWZvcig7LTE8KHc9dChDLGspKTspTT0wPmtbY10tYVtjXSxFPXt4OmsueCx5OmsueX0sRVtjXT1DW3ddW00/YytcIk1heFwiOmMrXCJNaW5cIl0rKE0/MTotMSksZC5wdXNoKHtlbmQ6ayxzdGFydDpFfSksaz1FO2E9ZyhhLGsscSk7YT1hLmNvbmNhdChkLnJldmVyc2UoKSk7cmV0dXJue3BhdGg6cihhKSxvYnN0YWNsZXM6YX19LFxue3JlcXVpcmVzT2JzdGFjbGVzOiEwfSksc3RyYWlnaHQ6ZnVuY3Rpb24oYSxrKXtyZXR1cm57cGF0aDpbW1wiTVwiLGEueCxhLnldLFtcIkxcIixrLngsay55XV0sb2JzdGFjbGVzOlt7c3RhcnQ6YSxlbmQ6a31dfX0sc2ltcGxlQ29ubmVjdDphfX0pO0YoYSxcIkdhbnR0L1BhdGhmaW5kZXIuanNcIixbYVtcIkdhbnR0L0Nvbm5lY3Rpb24uanNcIl0sYVtcIkNvcmUvQ2hhcnQvQ2hhcnQuanNcIl0sYVtcIkNvcmUvR2xvYmFscy5qc1wiXSxhW1wiQ29yZS9PcHRpb25zLmpzXCJdLGFbXCJDb3JlL1Nlcmllcy9Qb2ludC5qc1wiXSxhW1wiQ29yZS9VdGlsaXRpZXMuanNcIl0sYVtcIkdhbnR0L1BhdGhmaW5kZXJBbGdvcml0aG1zLmpzXCJdXSxmdW5jdGlvbihhLHUsdCxyLG4saCxBKXtmdW5jdGlvbiBCKGEpe3ZhciBiPWEuc2hhcGVBcmdzO3JldHVybiBiP3t4TWluOmIueCx4TWF4OmIueCtiLndpZHRoLHlNaW46Yi55LHlNYXg6Yi55K2IuaGVpZ2h0fTooYj1hLmdyYXBoaWMmJmEuZ3JhcGhpYy5nZXRCQm94KCkpP3t4TWluOmEucGxvdFgtXG5iLndpZHRoLzIseE1heDphLnBsb3RYK2Iud2lkdGgvMix5TWluOmEucGxvdFktYi5oZWlnaHQvMix5TWF4OmEucGxvdFkrYi5oZWlnaHQvMn06bnVsbH1mdW5jdGlvbiBEKGEpe2Zvcih2YXIgYj1hLmxlbmd0aCxkPTAsZSxmLGs9W10saD1mdW5jdGlvbihhLGIsZCl7ZD1nKGQsMTApO3ZhciBlPWEueU1heCtkPmIueU1pbi1kJiZhLnlNaW4tZDxiLnlNYXgrZCxsPWEueE1heCtkPmIueE1pbi1kJiZhLnhNaW4tZDxiLnhNYXgrZCx4PWU/YS54TWluPmIueE1heD9hLnhNaW4tYi54TWF4OmIueE1pbi1hLnhNYXg6SW5maW5pdHksZj1sP2EueU1pbj5iLnlNYXg/YS55TWluLWIueU1heDpiLnlNaW4tYS55TWF4OkluZmluaXR5O3JldHVybiBsJiZlP2Q/aChhLGIsTWF0aC5mbG9vcihkLzIpKTpJbmZpbml0eTpjKHgsZil9O2Q8YjsrK2QpZm9yKGU9ZCsxO2U8YjsrK2UpZj1oKGFbZF0sYVtlXSksODA+ZiYmay5wdXNoKGYpO2sucHVzaCg4MCk7cmV0dXJuIHEoTWF0aC5mbG9vcihrLnNvcnQoZnVuY3Rpb24oYSxcbmIpe3JldHVybiBhLWJ9KVtNYXRoLmZsb29yKGsubGVuZ3RoLzEwKV0vMi0xKSwxKX1mdW5jdGlvbiBwKGEpe2lmKGEub3B0aW9ucy5wYXRoZmluZGVyfHxhLnNlcmllcy5yZWR1Y2UoZnVuY3Rpb24oYSxiKXtiLm9wdGlvbnMmJmUoITAsYi5vcHRpb25zLmNvbm5lY3RvcnM9Yi5vcHRpb25zLmNvbm5lY3RvcnN8fHt9LGIub3B0aW9ucy5wYXRoZmluZGVyKTtyZXR1cm4gYXx8Yi5vcHRpb25zJiZiLm9wdGlvbnMucGF0aGZpbmRlcn0sITEpKWUoITAsYS5vcHRpb25zLmNvbm5lY3RvcnM9YS5vcHRpb25zLmNvbm5lY3RvcnN8fHt9LGEub3B0aW9ucy5wYXRoZmluZGVyKSxmKCdXQVJOSU5HOiBQYXRoZmluZGVyIG9wdGlvbnMgaGF2ZSBiZWVuIHJlbmFtZWQuIFVzZSBcImNoYXJ0LmNvbm5lY3RvcnNcIiBvciBcInNlcmllcy5jb25uZWN0b3JzXCIgaW5zdGVhZC4nKX1cIlwiO3ZhciB3PWguYWRkRXZlbnQsaz1oLmRlZmluZWQsZj1oLmVycm9yLHY9aC5leHRlbmQsZT1oLm1lcmdlLGc9aC5waWNrLFxubT1oLnNwbGF0LHE9TWF0aC5tYXgsYz1NYXRoLm1pbjt2KHIuZGVmYXVsdE9wdGlvbnMse2Nvbm5lY3RvcnM6e3R5cGU6XCJzdHJhaWdodFwiLGxpbmVXaWR0aDoxLG1hcmtlcjp7ZW5hYmxlZDohMSxhbGlnbjpcImNlbnRlclwiLHZlcnRpY2FsQWxpZ246XCJtaWRkbGVcIixpbnNpZGU6ITEsbGluZVdpZHRoOjF9LHN0YXJ0TWFya2VyOntzeW1ib2w6XCJkaWFtb25kXCJ9LGVuZE1hcmtlcjp7c3ltYm9sOlwiYXJyb3ctZmlsbGVkXCJ9fX0pO3ZhciBkPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYihhKXt0aGlzLmxpbmVPYnN0YWNsZXM9dGhpcy5ncm91cD10aGlzLmNvbm5lY3Rpb25zPXRoaXMuY2hhcnRPYnN0YWNsZU1ldHJpY3M9dGhpcy5jaGFydE9ic3RhY2xlcz10aGlzLmNoYXJ0PXZvaWQgMDt0aGlzLmluaXQoYSl9Yi5wcm90b3R5cGUuaW5pdD1mdW5jdGlvbihhKXt0aGlzLmNoYXJ0PWE7dGhpcy5jb25uZWN0aW9ucz1bXTt3KGEsXCJyZWRyYXdcIixmdW5jdGlvbigpe3RoaXMucGF0aGZpbmRlci51cGRhdGUoKX0pfTtcbmIucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihiKXt2YXIgYz10aGlzLmNoYXJ0LGQ9dGhpcyxlPWQuY29ubmVjdGlvbnM7ZC5jb25uZWN0aW9ucz1bXTtjLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IudmlzaWJsZSYmIWIub3B0aW9ucy5pc0ludGVybmFsJiZiLnBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uKGIpe3ZhciBsPWIub3B0aW9ucztsJiZsLmRlcGVuZGVuY3kmJihsLmNvbm5lY3Q9bC5kZXBlbmRlbmN5KTt2YXIgZTtsPWIub3B0aW9ucyYmYi5vcHRpb25zLmNvbm5lY3QmJm0oYi5vcHRpb25zLmNvbm5lY3QpO2IudmlzaWJsZSYmITEhPT1iLmlzSW5zaWRlJiZsJiZsLmZvckVhY2goZnVuY3Rpb24obCl7ZT1jLmdldChcInN0cmluZ1wiPT09dHlwZW9mIGw/bDpsLnRvKTtlIGluc3RhbmNlb2YgbiYmZS5zZXJpZXMudmlzaWJsZSYmZS52aXNpYmxlJiYhMSE9PWUuaXNJbnNpZGUmJmQuY29ubmVjdGlvbnMucHVzaChuZXcgYShiLGUsXCJzdHJpbmdcIj09PXR5cGVvZiBsP3t9OmwpKX0pfSl9KTtcbmZvcih2YXIgZj0wLGcsayxxPWUubGVuZ3RoLHk9ZC5jb25uZWN0aW9ucy5sZW5ndGg7ZjxxOysrZil7az0hMTtmb3IoZz0wO2c8eTsrK2cpaWYoZVtmXS5mcm9tUG9pbnQ9PT1kLmNvbm5lY3Rpb25zW2ddLmZyb21Qb2ludCYmZVtmXS50b1BvaW50PT09ZC5jb25uZWN0aW9uc1tnXS50b1BvaW50KXtkLmNvbm5lY3Rpb25zW2ddLmdyYXBoaWNzPWVbZl0uZ3JhcGhpY3M7az0hMDticmVha31rfHxlW2ZdLmRlc3Ryb3koKX1kZWxldGUgdGhpcy5jaGFydE9ic3RhY2xlcztkZWxldGUgdGhpcy5saW5lT2JzdGFjbGVzO2QucmVuZGVyQ29ubmVjdGlvbnMoYil9O2IucHJvdG90eXBlLnJlbmRlckNvbm5lY3Rpb25zPWZ1bmN0aW9uKGEpe2E/dGhpcy5jaGFydC5zZXJpZXMuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1mdW5jdGlvbigpe3ZhciBiPWEuY2hhcnQucGF0aGZpbmRlcjsoYiYmYi5jb25uZWN0aW9uc3x8W10pLmZvckVhY2goZnVuY3Rpb24oYil7Yi5mcm9tUG9pbnQmJmIuZnJvbVBvaW50LnNlcmllcz09PVxuYSYmYi5yZW5kZXIoKX0pO2EucGF0aGZpbmRlclJlbW92ZVJlbmRlckV2ZW50JiYoYS5wYXRoZmluZGVyUmVtb3ZlUmVuZGVyRXZlbnQoKSxkZWxldGUgYS5wYXRoZmluZGVyUmVtb3ZlUmVuZGVyRXZlbnQpfTshMT09PWEub3B0aW9ucy5hbmltYXRpb24/YigpOmEucGF0aGZpbmRlclJlbW92ZVJlbmRlckV2ZW50PXcoYSxcImFmdGVyQW5pbWF0ZVwiLGIpfSk6dGhpcy5jb25uZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EucmVuZGVyKCl9KX07Yi5wcm90b3R5cGUuZ2V0Q2hhcnRPYnN0YWNsZXM9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9dGhpcy5jaGFydC5zZXJpZXMsZD1nKGEuYWxnb3JpdGhtTWFyZ2luLDApLGUsZj0wLHE9Yy5sZW5ndGg7ZjxxOysrZilpZihjW2ZdLnZpc2libGUmJiFjW2ZdLm9wdGlvbnMuaXNJbnRlcm5hbClmb3IodmFyIGg9MCx5PWNbZl0ucG9pbnRzLmxlbmd0aCx6O2g8eTsrK2gpej1jW2ZdLnBvaW50c1toXSx6LnZpc2libGUmJih6PUIoeikpJiZcbmIucHVzaCh7eE1pbjp6LnhNaW4tZCx4TWF4OnoueE1heCtkLHlNaW46ei55TWluLWQseU1heDp6LnlNYXgrZH0pO2I9Yi5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEueE1pbi1iLnhNaW59KTtrKGEuYWxnb3JpdGhtTWFyZ2luKXx8KGU9YS5hbGdvcml0aG1NYXJnaW49RChiKSxiLmZvckVhY2goZnVuY3Rpb24oYSl7YS54TWluLT1lO2EueE1heCs9ZTthLnlNaW4tPWU7YS55TWF4Kz1lfSkpO3JldHVybiBifTtiLnByb3RvdHlwZS5nZXRPYnN0YWNsZU1ldHJpY3M9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPTAsYz0wLGQsZSxmPWEubGVuZ3RoO2YtLTspZD1hW2ZdLnhNYXgtYVtmXS54TWluLGU9YVtmXS55TWF4LWFbZl0ueU1pbixiPGQmJihiPWQpLGM8ZSYmKGM9ZSk7cmV0dXJue21heEhlaWdodDpjLG1heFdpZHRoOmJ9fTtiLnByb3RvdHlwZS5nZXRBbGdvcml0aG1TdGFydERpcmVjdGlvbj1mdW5jdGlvbihhKXt2YXIgYj1cInRvcFwiIT09YS52ZXJ0aWNhbEFsaWduJiZcImJvdHRvbVwiIT09XG5hLnZlcnRpY2FsQWxpZ247cmV0dXJuXCJsZWZ0XCIhPT1hLmFsaWduJiZcInJpZ2h0XCIhPT1hLmFsaWduP2I/dm9pZCAwOiExOmI/ITA6dm9pZCAwfTtyZXR1cm4gYn0oKTtkLnByb3RvdHlwZS5hbGdvcml0aG1zPUE7dC5QYXRoZmluZGVyPWQ7dihuLnByb3RvdHlwZSx7Z2V0UGF0aGZpbmRlckFuY2hvclBvaW50OmZ1bmN0aW9uKGEpe3ZhciBiPUIodGhpcyk7c3dpdGNoKGEuYWxpZ24pe2Nhc2UgXCJyaWdodFwiOnZhciBjPVwieE1heFwiO2JyZWFrO2Nhc2UgXCJsZWZ0XCI6Yz1cInhNaW5cIn1zd2l0Y2goYS52ZXJ0aWNhbEFsaWduKXtjYXNlIFwidG9wXCI6dmFyIGQ9XCJ5TWluXCI7YnJlYWs7Y2FzZSBcImJvdHRvbVwiOmQ9XCJ5TWF4XCJ9cmV0dXJue3g6Yz9iW2NdOihiLnhNaW4rYi54TWF4KS8yLHk6ZD9iW2RdOihiLnlNaW4rYi55TWF4KS8yfX0sZ2V0UmFkaWFuc1RvVmVjdG9yOmZ1bmN0aW9uKGEsYyl7dmFyIGI7ayhjKXx8KGI9Qih0aGlzKSkmJihjPXt4OihiLnhNaW4rYi54TWF4KS8yLHk6KGIueU1pbitcbmIueU1heCkvMn0pO3JldHVybiBNYXRoLmF0YW4yKGMueS1hLnksYS54LWMueCl9LGdldE1hcmtlclZlY3RvcjpmdW5jdGlvbihhLGMsZCl7dmFyIGI9MipNYXRoLlBJLGU9Qih0aGlzKSxmPWUueE1heC1lLnhNaW4sZz1lLnlNYXgtZS55TWluLGs9TWF0aC5hdGFuMihnLGYpLHE9ITE7Zi89Mjt2YXIgeT1nLzIsej1lLnhNaW4rZjtlPWUueU1pbit5O2Zvcih2YXIgbD16LHg9ZSxHPTEsaD0xO2E8LU1hdGguUEk7KWErPWI7Zm9yKDthPk1hdGguUEk7KWEtPWI7Yj1NYXRoLnRhbihhKTthPi1rJiZhPD1rPyhoPS0xLHE9ITApOmE+ayYmYTw9TWF0aC5QSS1rP2g9LTE6YT5NYXRoLlBJLWt8fGE8PS0oTWF0aC5QSS1rKT8oRz0tMSxxPSEwKTpHPS0xO3E/KGwrPUcqZix4Kz1oKmYqYik6KGwrPWcvKDIqYikqRyx4Kz1oKnkpO2QueCE9PXomJihsPWQueCk7ZC55IT09ZSYmKHg9ZC55KTtyZXR1cm57eDpsK2MqTWF0aC5jb3MoYSkseTp4LWMqTWF0aC5zaW4oYSl9fX0pO3UucHJvdG90eXBlLmNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKGEpeyExIT09XG5hLm9wdGlvbnMuY29ubmVjdG9ycy5lbmFibGVkJiYocChhKSx0aGlzLnBhdGhmaW5kZXI9bmV3IGQodGhpcyksdGhpcy5wYXRoZmluZGVyLnVwZGF0ZSghMCkpfSk7cmV0dXJuIGR9KTtGKGEsXCJTZXJpZXMvR2FudHQvR2FudHRTZXJpZXMuanNcIixbYVtcIlNlcmllcy9HYW50dC9HYW50dFBvaW50LmpzXCJdLGFbXCJDb3JlL1Nlcmllcy9TZXJpZXNSZWdpc3RyeS5qc1wiXSxhW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGEsdSx0KXt2YXIgcj10aGlzJiZ0aGlzLl9fZXh0ZW5kc3x8ZnVuY3Rpb24oKXt2YXIgYT1mdW5jdGlvbihrLGYpe2E9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGEsZSl7YS5fX3Byb3RvX189ZX18fGZ1bmN0aW9uKGEsZSl7Zm9yKHZhciBmIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShmKSYmKGFbZl09ZVtmXSl9O3JldHVybiBhKGssZil9O3JldHVybiBmdW5jdGlvbihrLGYpe2Z1bmN0aW9uIGgoKXt0aGlzLmNvbnN0cnVjdG9yPVxua31hKGssZik7ay5wcm90b3R5cGU9bnVsbD09PWY/T2JqZWN0LmNyZWF0ZShmKTooaC5wcm90b3R5cGU9Zi5wcm90b3R5cGUsbmV3IGgpfX0oKSxuPXUuc2VyaWVzLGg9dS5zZXJpZXNUeXBlcy54cmFuZ2UsQT10LmV4dGVuZCxCPXQuaXNOdW1iZXIsRD10Lm1lcmdlLHA9dC5zcGxhdDt0PWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGsoKXt2YXIgZj1udWxsIT09YSYmYS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXM7Zi5kYXRhPXZvaWQgMDtmLm9wdGlvbnM9dm9pZCAwO2YucG9pbnRzPXZvaWQgMDtyZXR1cm4gZn1yKGssYSk7ay5wcm90b3R5cGUuZHJhd1BvaW50PWZ1bmN0aW9uKGEsayl7dmFyIGU9dGhpcy5vcHRpb25zLGY9dGhpcy5jaGFydC5yZW5kZXJlcixtPWEuc2hhcGVBcmdzLHE9YS5wbG90WSxjPWEuZ3JhcGhpYyxkPWEuc2VsZWN0ZWQmJlwic2VsZWN0XCIsYj1lLnN0YWNraW5nJiYhZS5ib3JkZXJSYWRpdXM7aWYoYS5vcHRpb25zLm1pbGVzdG9uZSlpZihCKHEpJiZudWxsIT09XG5hLnkmJiExIT09YS52aXNpYmxlKXttPWYuc3ltYm9scy5kaWFtb25kKG0ueCxtLnksbS53aWR0aCxtLmhlaWdodCk7aWYoYyljW2tdKHtkOm19KTtlbHNlIGEuZ3JhcGhpYz1mLnBhdGgobSkuYWRkQ2xhc3MoYS5nZXRDbGFzc05hbWUoKSwhMCkuYWRkKGEuZ3JvdXB8fHRoaXMuZ3JvdXApO3RoaXMuY2hhcnQuc3R5bGVkTW9kZXx8YS5ncmFwaGljLmF0dHIodGhpcy5wb2ludEF0dHJpYnMoYSxkKSkuc2hhZG93KGUuc2hhZG93LG51bGwsYil9ZWxzZSBjJiYoYS5ncmFwaGljPWMuZGVzdHJveSgpKTtlbHNlIGgucHJvdG90eXBlLmRyYXdQb2ludC5jYWxsKHRoaXMsYSxrKX07ay5wcm90b3R5cGUudHJhbnNsYXRlUG9pbnQ9ZnVuY3Rpb24oYSl7aC5wcm90b3R5cGUudHJhbnNsYXRlUG9pbnQuY2FsbCh0aGlzLGEpO2lmKGEub3B0aW9ucy5taWxlc3RvbmUpe3ZhciBmPWEuc2hhcGVBcmdzO3ZhciBlPWYuaGVpZ2h0O2Euc2hhcGVBcmdzPXt4OmYueC1lLzIseTpmLnksd2lkdGg6ZSxoZWlnaHQ6ZX19fTtcbmsuZGVmYXVsdE9wdGlvbnM9RChoLmRlZmF1bHRPcHRpb25zLHtncm91cGluZzohMSxkYXRhTGFiZWxzOntlbmFibGVkOiEwfSx0b29sdGlwOntoZWFkZXJGb3JtYXQ6JzxzcGFuIHN0eWxlPVwiZm9udC1zaXplOiAxMHB4XCI+e3Nlcmllcy5uYW1lfTwvc3Bhbj48YnIvPicscG9pbnRGb3JtYXQ6bnVsbCxwb2ludEZvcm1hdHRlcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuc2VyaWVzLGs9YS5jaGFydC50b29sdGlwLGU9YS54QXhpcyxnPWEudG9vbHRpcE9wdGlvbnMuZGF0ZVRpbWVMYWJlbEZvcm1hdHMsaD1lLm9wdGlvbnMuc3RhcnRPZldlZWsscT1hLnRvb2x0aXBPcHRpb25zLGM9cS54RGF0ZUZvcm1hdCxkPXRoaXMub3B0aW9ucy5taWxlc3RvbmUsYj1cIjxiPlwiKyh0aGlzLm5hbWV8fHRoaXMueUNhdGVnb3J5KStcIjwvYj5cIjtpZihxLnBvaW50Rm9ybWF0KXJldHVybiB0aGlzLnRvb2x0aXBGb3JtYXR0ZXIocS5wb2ludEZvcm1hdCk7Y3x8KGM9cChrLmdldERhdGVGb3JtYXQoZS5jbG9zZXN0UG9pbnRSYW5nZSxcbnRoaXMuc3RhcnQsaCxnKSlbMF0pO2s9YS5jaGFydC50aW1lLmRhdGVGb3JtYXQoYyx0aGlzLnN0YXJ0KTthPWEuY2hhcnQudGltZS5kYXRlRm9ybWF0KGMsdGhpcy5lbmQpO2IrPVwiPGJyLz5cIjtyZXR1cm4gZD9iKyhrK1wiPGJyLz5cIik6YisoXCJTdGFydDogXCIraytcIjxici8+RW5kOiBcIikrKGErXCI8YnIvPlwiKX19LGNvbm5lY3RvcnM6e3R5cGU6XCJzaW1wbGVDb25uZWN0XCIsYW5pbWF0aW9uOntyZXZlcnNlZDohMH0sc3RhcnRNYXJrZXI6e2VuYWJsZWQ6ITAsc3ltYm9sOlwiYXJyb3ctZmlsbGVkXCIscmFkaXVzOjQsZmlsbDpcIiNmYTBcIixhbGlnbjpcImxlZnRcIn0sZW5kTWFya2VyOntlbmFibGVkOiExLGFsaWduOlwicmlnaHRcIn19fSk7cmV0dXJuIGt9KGgpO0EodC5wcm90b3R5cGUse2tleWJvYXJkTW92ZVZlcnRpY2FsOiExLHBvaW50QXJyYXlNYXA6W1wic3RhcnRcIixcImVuZFwiLFwieVwiXSxwb2ludENsYXNzOmEsc2V0RGF0YTpuLnByb3RvdHlwZS5zZXREYXRhfSk7dS5yZWdpc3RlclNlcmllc1R5cGUoXCJnYW50dFwiLFxudCk7XCJcIjtyZXR1cm4gdH0pO0YoYSxcIkNvcmUvQ2hhcnQvR2FudHRDaGFydC5qc1wiLFthW1wiQ29yZS9DaGFydC9DaGFydC5qc1wiXSxhW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGFbXCJDb3JlL1V0aWxpdGllcy5qc1wiXV0sZnVuY3Rpb24oYSx1LHQpe3ZhciByPXQuZ2V0T3B0aW9ucyxuPXQuaXNBcnJheSxoPXQubWVyZ2UsQT10LnNwbGF0O3UuZ2FudHRDaGFydD1mdW5jdGlvbih0LHUscCl7dmFyIHc9XCJzdHJpbmdcIj09PXR5cGVvZiB0fHx0Lm5vZGVOYW1lLGs9dS5zZXJpZXMsZj1yKCksdixlPXU7dT1hcmd1bWVudHNbdz8xOjBdO24odS54QXhpcyl8fCh1LnhBeGlzPVt1LnhBeGlzfHx7fSx7fV0pO3UueEF4aXM9dS54QXhpcy5tYXAoZnVuY3Rpb24oYSxlKXsxPT09ZSYmKHY9MCk7cmV0dXJuIGgoZi54QXhpcyx7Z3JpZDp7ZW5hYmxlZDohMH0sb3Bwb3NpdGU6ITAsbGlua2VkVG86dn0sYSx7dHlwZTpcImRhdGV0aW1lXCJ9KX0pO3UueUF4aXM9QSh1LnlBeGlzfHx7fSkubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBoKGYueUF4aXMsXG57Z3JpZDp7ZW5hYmxlZDohMH0sc3RhdGljU2NhbGU6NTAscmV2ZXJzZWQ6ITAsdHlwZTphLmNhdGVnb3JpZXM/YS50eXBlOlwidHJlZWdyaWRcIn0sYSl9KTt1LnNlcmllcz1udWxsO3U9aCghMCx7Y2hhcnQ6e3R5cGU6XCJnYW50dFwifSx0aXRsZTp7dGV4dDpudWxsfSxsZWdlbmQ6e2VuYWJsZWQ6ITF9LG5hdmlnYXRvcjp7c2VyaWVzOnt0eXBlOlwiZ2FudHRcIn0seUF4aXM6e3R5cGU6XCJjYXRlZ29yeVwifX19LHUse2lzR2FudHQ6ITB9KTt1LnNlcmllcz1lLnNlcmllcz1rO3JldHVybiB3P25ldyBhKHQsdSxwKTpuZXcgYSh1LHUpfX0pO0YoYSxcIkNvcmUvQXhpcy9TY3JvbGxiYXJBeGlzLmpzXCIsW2FbXCJDb3JlL0dsb2JhbHMuanNcIl0sYVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihhLHUpe3ZhciB0PXUuYWRkRXZlbnQscj11LmRlZmluZWQsbj11LnBpY2s7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gaCgpe31oLmNvbXBvc2U9ZnVuY3Rpb24oaCx1KXt2YXIgQT1mdW5jdGlvbihhKXt2YXIgaD1cbm4oYS5vcHRpb25zJiZhLm9wdGlvbnMubWluLGEubWluKSxrPW4oYS5vcHRpb25zJiZhLm9wdGlvbnMubWF4LGEubWF4KTtyZXR1cm57YXhpc01pbjpoLGF4aXNNYXg6ayxzY3JvbGxNaW46cihhLmRhdGFNaW4pP01hdGgubWluKGgsYS5taW4sYS5kYXRhTWluLG4oYS50aHJlc2hvbGQsSW5maW5pdHkpKTpoLHNjcm9sbE1heDpyKGEuZGF0YU1heCk/TWF0aC5tYXgoayxhLm1heCxhLmRhdGFNYXgsbihhLnRocmVzaG9sZCwtSW5maW5pdHkpKTprfX07dChoLFwiYWZ0ZXJJbml0XCIsZnVuY3Rpb24oKXt2YXIgaD10aGlzO2gub3B0aW9ucyYmaC5vcHRpb25zLnNjcm9sbGJhciYmaC5vcHRpb25zLnNjcm9sbGJhci5lbmFibGVkJiYoaC5vcHRpb25zLnNjcm9sbGJhci52ZXJ0aWNhbD0haC5ob3JpeixoLm9wdGlvbnMuc3RhcnRPblRpY2s9aC5vcHRpb25zLmVuZE9uVGljaz0hMSxoLnNjcm9sbGJhcj1uZXcgdShoLmNoYXJ0LnJlbmRlcmVyLGgub3B0aW9ucy5zY3JvbGxiYXIsaC5jaGFydCksXG50KGguc2Nyb2xsYmFyLFwiY2hhbmdlZFwiLGZ1bmN0aW9uKHApe3ZhciBrPUEoaCksZj1rLmF4aXNNYXgsdj1rLnNjcm9sbE1pbixlPWsuc2Nyb2xsTWF4LXY7cihrLmF4aXNNaW4pJiZyKGYpJiYoaC5ob3JpeiYmIWgucmV2ZXJzZWR8fCFoLmhvcml6JiZoLnJldmVyc2VkPyhrPXYrZSp0aGlzLnRvLHYrPWUqdGhpcy5mcm9tKTooaz12K2UqKDEtdGhpcy5mcm9tKSx2Kz1lKigxLXRoaXMudG8pKSxuKHRoaXMub3B0aW9ucy5saXZlUmVkcmF3LGEuc3ZnJiYhYS5pc1RvdWNoRGV2aWNlJiYhdGhpcy5jaGFydC5pc0Jvb3N0aW5nKXx8XCJtb3VzZXVwXCI9PT1wLkRPTVR5cGV8fFwidG91Y2hlbmRcIj09PXAuRE9NVHlwZXx8IXIocC5ET01UeXBlKT9oLnNldEV4dHJlbWVzKHYsaywhMCxcIm1vdXNlbW92ZVwiIT09cC5ET01UeXBlJiZcInRvdWNobW92ZVwiIT09cC5ET01UeXBlLHApOnRoaXMuc2V0UmFuZ2UodGhpcy5mcm9tLHRoaXMudG8pKX0pKX0pO3QoaCxcImFmdGVyUmVuZGVyXCIsZnVuY3Rpb24oKXt2YXIgYT1cbkEodGhpcyksaD1hLnNjcm9sbE1pbixrPWEuc2Nyb2xsTWF4O2E9dGhpcy5zY3JvbGxiYXI7dmFyIGY9dGhpcy5heGlzVGl0bGVNYXJnaW4rKHRoaXMudGl0bGVPZmZzZXR8fDApLG49dGhpcy5jaGFydC5zY3JvbGxiYXJzT2Zmc2V0cyxlPXRoaXMub3B0aW9ucy5tYXJnaW58fDA7YSYmKHRoaXMuaG9yaXo/KHRoaXMub3Bwb3NpdGV8fChuWzFdKz1mKSxhLnBvc2l0aW9uKHRoaXMubGVmdCx0aGlzLnRvcCt0aGlzLmhlaWdodCsyK25bMV0tKHRoaXMub3Bwb3NpdGU/ZTowKSx0aGlzLndpZHRoLHRoaXMuaGVpZ2h0KSx0aGlzLm9wcG9zaXRlfHwoblsxXSs9ZSksZj0xKToodGhpcy5vcHBvc2l0ZSYmKG5bMF0rPWYpLGEucG9zaXRpb24odGhpcy5sZWZ0K3RoaXMud2lkdGgrMituWzBdLSh0aGlzLm9wcG9zaXRlPzA6ZSksdGhpcy50b3AsdGhpcy53aWR0aCx0aGlzLmhlaWdodCksdGhpcy5vcHBvc2l0ZSYmKG5bMF0rPWUpLGY9MCksbltmXSs9YS5zaXplK2Eub3B0aW9ucy5tYXJnaW4saXNOYU4oaCl8fFxuaXNOYU4oayl8fCFyKHRoaXMubWluKXx8IXIodGhpcy5tYXgpfHx0aGlzLm1pbj09PXRoaXMubWF4P2Euc2V0UmFuZ2UoMCwxKToobj0odGhpcy5taW4taCkvKGstaCksaD0odGhpcy5tYXgtaCkvKGstaCksdGhpcy5ob3JpeiYmIXRoaXMucmV2ZXJzZWR8fCF0aGlzLmhvcml6JiZ0aGlzLnJldmVyc2VkP2Euc2V0UmFuZ2UobixoKTphLnNldFJhbmdlKDEtaCwxLW4pKSl9KTt0KGgsXCJhZnRlckdldE9mZnNldFwiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5ob3Jpej8yOjEsaD10aGlzLnNjcm9sbGJhcjtoJiYodGhpcy5jaGFydC5zY3JvbGxiYXJzT2Zmc2V0cz1bMCwwXSx0aGlzLmNoYXJ0LmF4aXNPZmZzZXRbYV0rPWguc2l6ZStoLm9wdGlvbnMubWFyZ2luKX0pfTtyZXR1cm4gaH0oKX0pO0YoYSxcIkNvcmUvU2Nyb2xsYmFyLmpzXCIsW2FbXCJDb3JlL0F4aXMvQXhpcy5qc1wiXSxhW1wiQ29yZS9HbG9iYWxzLmpzXCJdLGFbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sYVtcIkNvcmUvQXhpcy9TY3JvbGxiYXJBeGlzLmpzXCJdLFxuYVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdLGFbXCJDb3JlL09wdGlvbnMuanNcIl1dLGZ1bmN0aW9uKGEsdSx0LHIsbixoKXt2YXIgQT1uLmFkZEV2ZW50LEI9bi5jb3JyZWN0RmxvYXQsRD1uLmRlZmluZWQscD1uLmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLHc9bi5maXJlRXZlbnQsaz1uLm1lcmdlLGY9bi5waWNrLHY9bi5yZW1vdmVFdmVudDtuPWguZGVmYXVsdE9wdGlvbnM7dmFyIGU9dS5pc1RvdWNoRGV2aWNlLGc9dS5zd2FwWFk9ZnVuY3Rpb24oYSxlKXtlJiZhLmZvckVhY2goZnVuY3Rpb24oYSl7Zm9yKHZhciBjPWEubGVuZ3RoLGIsZT0wO2U8YztlKz0yKWI9YVtlKzFdLFwibnVtYmVyXCI9PT10eXBlb2YgYiYmKGFbZSsxXT1hW2UrMl0sYVtlKzJdPWIpfSk7cmV0dXJuIGF9O2g9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYyxkKXt0aGlzLl9ldmVudHM9W107dGhpcy5mcm9tPXRoaXMuY2hhcnRZPXRoaXMuY2hhcnRYPTA7dGhpcy5zY3JvbGxiYXI9dGhpcy5ncm91cD12b2lkIDA7dGhpcy5zY3JvbGxiYXJCdXR0b25zPVxuW107dGhpcy5zY3JvbGxiYXJHcm91cD12b2lkIDA7dGhpcy5zY3JvbGxiYXJMZWZ0PTA7dGhpcy5zY3JvbGxiYXJSaWZsZXM9dm9pZCAwO3RoaXMuc2Nyb2xsYmFyU3Ryb2tlV2lkdGg9MTt0aGlzLnRvPXRoaXMuc2l6ZT10aGlzLnNjcm9sbGJhclRvcD0wO3RoaXMudHJhY2s9dm9pZCAwO3RoaXMudHJhY2tCb3JkZXJXaWR0aD0xO3RoaXMudXNlck9wdGlvbnM9e307dGhpcy55PXRoaXMueD0wO3RoaXMuY2hhcnQ9ZDt0aGlzLm9wdGlvbnM9Yzt0aGlzLnJlbmRlcmVyPWQucmVuZGVyZXI7dGhpcy5pbml0KGEsYyxkKX1hLnByb3RvdHlwZS5hZGRFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMuaW52ZXJ0ZWQ/WzEsMF06WzAsMV0sYz10aGlzLnNjcm9sbGJhckJ1dHRvbnMsZD10aGlzLnNjcm9sbGJhckdyb3VwLmVsZW1lbnQsYj10aGlzLnRyYWNrLmVsZW1lbnQsZT10aGlzLm1vdXNlRG93bkhhbmRsZXIuYmluZCh0aGlzKSxmPXRoaXMubW91c2VNb3ZlSGFuZGxlci5iaW5kKHRoaXMpLFxuZz10aGlzLm1vdXNlVXBIYW5kbGVyLmJpbmQodGhpcyk7YT1bW2NbYVswXV0uZWxlbWVudCxcImNsaWNrXCIsdGhpcy5idXR0b25Ub01pbkNsaWNrLmJpbmQodGhpcyldLFtjW2FbMV1dLmVsZW1lbnQsXCJjbGlja1wiLHRoaXMuYnV0dG9uVG9NYXhDbGljay5iaW5kKHRoaXMpXSxbYixcImNsaWNrXCIsdGhpcy50cmFja0NsaWNrLmJpbmQodGhpcyldLFtkLFwibW91c2Vkb3duXCIsZV0sW2Qub3duZXJEb2N1bWVudCxcIm1vdXNlbW92ZVwiLGZdLFtkLm93bmVyRG9jdW1lbnQsXCJtb3VzZXVwXCIsZ11dO3UuaGFzVG91Y2gmJmEucHVzaChbZCxcInRvdWNoc3RhcnRcIixlXSxbZC5vd25lckRvY3VtZW50LFwidG91Y2htb3ZlXCIsZl0sW2Qub3duZXJEb2N1bWVudCxcInRvdWNoZW5kXCIsZ10pO2EuZm9yRWFjaChmdW5jdGlvbihhKXtBLmFwcGx5KG51bGwsYSl9KTt0aGlzLl9ldmVudHM9YX07YS5wcm90b3R5cGUuYnV0dG9uVG9NYXhDbGljaz1mdW5jdGlvbihhKXt2YXIgYz0odGhpcy50by10aGlzLmZyb20pKmYodGhpcy5vcHRpb25zLnN0ZXAsXG4uMik7dGhpcy51cGRhdGVQb3NpdGlvbih0aGlzLmZyb20rYyx0aGlzLnRvK2MpO3codGhpcyxcImNoYW5nZWRcIix7ZnJvbTp0aGlzLmZyb20sdG86dGhpcy50byx0cmlnZ2VyOlwic2Nyb2xsYmFyXCIsRE9NRXZlbnQ6YX0pfTthLnByb3RvdHlwZS5idXR0b25Ub01pbkNsaWNrPWZ1bmN0aW9uKGEpe3ZhciBjPUIodGhpcy50by10aGlzLmZyb20pKmYodGhpcy5vcHRpb25zLnN0ZXAsLjIpO3RoaXMudXBkYXRlUG9zaXRpb24oQih0aGlzLmZyb20tYyksQih0aGlzLnRvLWMpKTt3KHRoaXMsXCJjaGFuZ2VkXCIse2Zyb206dGhpcy5mcm9tLHRvOnRoaXMudG8sdHJpZ2dlcjpcInNjcm9sbGJhclwiLERPTUV2ZW50OmF9KX07YS5wcm90b3R5cGUuY3Vyc29yVG9TY3JvbGxiYXJQb3NpdGlvbj1mdW5jdGlvbihhKXt2YXIgYz10aGlzLm9wdGlvbnM7Yz1jLm1pbldpZHRoPnRoaXMuY2FsY3VsYXRlZFdpZHRoP2MubWluV2lkdGg6MDtyZXR1cm57Y2hhcnRYOihhLmNoYXJ0WC10aGlzLngtdGhpcy54T2Zmc2V0KS9cbih0aGlzLmJhcldpZHRoLWMpLGNoYXJ0WTooYS5jaGFydFktdGhpcy55LXRoaXMueU9mZnNldCkvKHRoaXMuYmFyV2lkdGgtYyl9fTthLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydC5zY3JvbGxlcjt0aGlzLnJlbW92ZUV2ZW50cygpO1tcInRyYWNrXCIsXCJzY3JvbGxiYXJSaWZsZXNcIixcInNjcm9sbGJhclwiLFwic2Nyb2xsYmFyR3JvdXBcIixcImdyb3VwXCJdLmZvckVhY2goZnVuY3Rpb24oYSl7dGhpc1thXSYmdGhpc1thXS5kZXN0cm95JiYodGhpc1thXT10aGlzW2FdLmRlc3Ryb3koKSl9LHRoaXMpO2EmJnRoaXM9PT1hLnNjcm9sbGJhciYmKGEuc2Nyb2xsYmFyPW51bGwscChhLnNjcm9sbGJhckJ1dHRvbnMpKX07YS5wcm90b3R5cGUuZHJhd1Njcm9sbGJhckJ1dHRvbj1mdW5jdGlvbihhKXt2YXIgYz10aGlzLnJlbmRlcmVyLGQ9dGhpcy5zY3JvbGxiYXJCdXR0b25zLGI9dGhpcy5vcHRpb25zLGU9dGhpcy5zaXplO3ZhciBmPWMuZygpLmFkZCh0aGlzLmdyb3VwKTtcbmQucHVzaChmKTtmPWMucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1zY3JvbGxiYXItYnV0dG9uXCIpLmFkZChmKTt0aGlzLmNoYXJ0LnN0eWxlZE1vZGV8fGYuYXR0cih7c3Ryb2tlOmIuYnV0dG9uQm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpiLmJ1dHRvbkJvcmRlcldpZHRoLGZpbGw6Yi5idXR0b25CYWNrZ3JvdW5kQ29sb3J9KTtmLmF0dHIoZi5jcmlzcCh7eDotLjUseTotLjUsd2lkdGg6ZSsxLGhlaWdodDplKzEscjpiLmJ1dHRvbkJvcmRlclJhZGl1c30sZi5zdHJva2VXaWR0aCgpKSk7Zj1jLnBhdGgoZyhbW1wiTVwiLGUvMisoYT8tMToxKSxlLzItM10sW1wiTFwiLGUvMisoYT8tMToxKSxlLzIrM10sW1wiTFwiLGUvMisoYT8yOi0yKSxlLzJdXSxiLnZlcnRpY2FsKSkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNjcm9sbGJhci1hcnJvd1wiKS5hZGQoZFthXSk7dGhpcy5jaGFydC5zdHlsZWRNb2RlfHxmLmF0dHIoe2ZpbGw6Yi5idXR0b25BcnJvd0NvbG9yfSl9O2EucHJvdG90eXBlLmluaXQ9XG5mdW5jdGlvbihlLGMsZCl7dGhpcy5zY3JvbGxiYXJCdXR0b25zPVtdO3RoaXMucmVuZGVyZXI9ZTt0aGlzLnVzZXJPcHRpb25zPWM7dGhpcy5vcHRpb25zPWsoYS5kZWZhdWx0T3B0aW9ucyxjKTt0aGlzLmNoYXJ0PWQ7dGhpcy5zaXplPWYodGhpcy5vcHRpb25zLnNpemUsdGhpcy5vcHRpb25zLmhlaWdodCk7Yy5lbmFibGVkJiYodGhpcy5yZW5kZXIoKSx0aGlzLmFkZEV2ZW50cygpKX07YS5wcm90b3R5cGUubW91c2VEb3duSGFuZGxlcj1mdW5jdGlvbihhKXthPXRoaXMuY2hhcnQucG9pbnRlci5ub3JtYWxpemUoYSk7YT10aGlzLmN1cnNvclRvU2Nyb2xsYmFyUG9zaXRpb24oYSk7dGhpcy5jaGFydFg9YS5jaGFydFg7dGhpcy5jaGFydFk9YS5jaGFydFk7dGhpcy5pbml0UG9zaXRpb25zPVt0aGlzLmZyb20sdGhpcy50b107dGhpcy5ncmFiYmVkQ2VudGVyPSEwfTthLnByb3RvdHlwZS5tb3VzZU1vdmVIYW5kbGVyPWZ1bmN0aW9uKGEpe3ZhciBjPXRoaXMuY2hhcnQucG9pbnRlci5ub3JtYWxpemUoYSksXG5kPXRoaXMub3B0aW9ucy52ZXJ0aWNhbD9cImNoYXJ0WVwiOlwiY2hhcnRYXCIsYj10aGlzLmluaXRQb3NpdGlvbnN8fFtdOyF0aGlzLmdyYWJiZWRDZW50ZXJ8fGEudG91Y2hlcyYmMD09PWEudG91Y2hlc1swXVtkXXx8KGM9dGhpcy5jdXJzb3JUb1Njcm9sbGJhclBvc2l0aW9uKGMpW2RdLGQ9dGhpc1tkXSxkPWMtZCx0aGlzLmhhc0RyYWdnZWQ9ITAsdGhpcy51cGRhdGVQb3NpdGlvbihiWzBdK2QsYlsxXStkKSx0aGlzLmhhc0RyYWdnZWQmJncodGhpcyxcImNoYW5nZWRcIix7ZnJvbTp0aGlzLmZyb20sdG86dGhpcy50byx0cmlnZ2VyOlwic2Nyb2xsYmFyXCIsRE9NVHlwZTphLnR5cGUsRE9NRXZlbnQ6YX0pKX07YS5wcm90b3R5cGUubW91c2VVcEhhbmRsZXI9ZnVuY3Rpb24oYSl7dGhpcy5oYXNEcmFnZ2VkJiZ3KHRoaXMsXCJjaGFuZ2VkXCIse2Zyb206dGhpcy5mcm9tLHRvOnRoaXMudG8sdHJpZ2dlcjpcInNjcm9sbGJhclwiLERPTVR5cGU6YS50eXBlLERPTUV2ZW50OmF9KTt0aGlzLmdyYWJiZWRDZW50ZXI9XG50aGlzLmhhc0RyYWdnZWQ9dGhpcy5jaGFydFg9dGhpcy5jaGFydFk9bnVsbH07YS5wcm90b3R5cGUucG9zaXRpb249ZnVuY3Rpb24oYSxjLGQsYil7dmFyIGU9dGhpcy5vcHRpb25zLnZlcnRpY2FsLGY9MCxnPXRoaXMucmVuZGVyZWQ/XCJhbmltYXRlXCI6XCJhdHRyXCI7dGhpcy54PWE7dGhpcy55PWMrdGhpcy50cmFja0JvcmRlcldpZHRoO3RoaXMud2lkdGg9ZDt0aGlzLnhPZmZzZXQ9dGhpcy5oZWlnaHQ9Yjt0aGlzLnlPZmZzZXQ9ZjtlPyh0aGlzLndpZHRoPXRoaXMueU9mZnNldD1kPWY9dGhpcy5zaXplLHRoaXMueE9mZnNldD1jPTAsdGhpcy5iYXJXaWR0aD1iLTIqZCx0aGlzLng9YSs9dGhpcy5vcHRpb25zLm1hcmdpbik6KHRoaXMuaGVpZ2h0PXRoaXMueE9mZnNldD1iPWM9dGhpcy5zaXplLHRoaXMuYmFyV2lkdGg9ZC0yKmIsdGhpcy55Kz10aGlzLm9wdGlvbnMubWFyZ2luKTt0aGlzLmdyb3VwW2ddKHt0cmFuc2xhdGVYOmEsdHJhbnNsYXRlWTp0aGlzLnl9KTt0aGlzLnRyYWNrW2ddKHt3aWR0aDpkLFxuaGVpZ2h0OmJ9KTt0aGlzLnNjcm9sbGJhckJ1dHRvbnNbMV1bZ10oe3RyYW5zbGF0ZVg6ZT8wOmQtYyx0cmFuc2xhdGVZOmU/Yi1mOjB9KX07YS5wcm90b3R5cGUucmVtb3ZlRXZlbnRzPWZ1bmN0aW9uKCl7dGhpcy5fZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oYSl7di5hcHBseShudWxsLGEpfSk7dGhpcy5fZXZlbnRzLmxlbmd0aD0wfTthLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnJlbmRlcmVyLGM9dGhpcy5vcHRpb25zLGQ9dGhpcy5zaXplLGI9dGhpcy5jaGFydC5zdHlsZWRNb2RlLGU7dGhpcy5ncm91cD1lPWEuZyhcInNjcm9sbGJhclwiKS5hdHRyKHt6SW5kZXg6Yy56SW5kZXgsdHJhbnNsYXRlWTotOTk5OTl9KS5hZGQoKTt0aGlzLnRyYWNrPWEucmVjdCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1zY3JvbGxiYXItdHJhY2tcIikuYXR0cih7eDowLHI6Yy50cmFja0JvcmRlclJhZGl1c3x8MCxoZWlnaHQ6ZCx3aWR0aDpkfSkuYWRkKGUpO2J8fHRoaXMudHJhY2suYXR0cih7ZmlsbDpjLnRyYWNrQmFja2dyb3VuZENvbG9yLFxuc3Ryb2tlOmMudHJhY2tCb3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOmMudHJhY2tCb3JkZXJXaWR0aH0pO3RoaXMudHJhY2tCb3JkZXJXaWR0aD10aGlzLnRyYWNrLnN0cm9rZVdpZHRoKCk7dGhpcy50cmFjay5hdHRyKHt5Oi10aGlzLnRyYWNrQm9yZGVyV2lkdGglMi8yfSk7dGhpcy5zY3JvbGxiYXJHcm91cD1hLmcoKS5hZGQoZSk7dGhpcy5zY3JvbGxiYXI9YS5yZWN0KCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXNjcm9sbGJhci10aHVtYlwiKS5hdHRyKHtoZWlnaHQ6ZCx3aWR0aDpkLHI6Yy5iYXJCb3JkZXJSYWRpdXN8fDB9KS5hZGQodGhpcy5zY3JvbGxiYXJHcm91cCk7dGhpcy5zY3JvbGxiYXJSaWZsZXM9YS5wYXRoKGcoW1tcIk1cIiwtMyxkLzRdLFtcIkxcIiwtMywyKmQvM10sW1wiTVwiLDAsZC80XSxbXCJMXCIsMCwyKmQvM10sW1wiTVwiLDMsZC80XSxbXCJMXCIsMywyKmQvM11dLGMudmVydGljYWwpKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtc2Nyb2xsYmFyLXJpZmxlc1wiKS5hZGQodGhpcy5zY3JvbGxiYXJHcm91cCk7XG5ifHwodGhpcy5zY3JvbGxiYXIuYXR0cih7ZmlsbDpjLmJhckJhY2tncm91bmRDb2xvcixzdHJva2U6Yy5iYXJCb3JkZXJDb2xvcixcInN0cm9rZS13aWR0aFwiOmMuYmFyQm9yZGVyV2lkdGh9KSx0aGlzLnNjcm9sbGJhclJpZmxlcy5hdHRyKHtzdHJva2U6Yy5yaWZsZUNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6MX0pKTt0aGlzLnNjcm9sbGJhclN0cm9rZVdpZHRoPXRoaXMuc2Nyb2xsYmFyLnN0cm9rZVdpZHRoKCk7dGhpcy5zY3JvbGxiYXJHcm91cC50cmFuc2xhdGUoLXRoaXMuc2Nyb2xsYmFyU3Ryb2tlV2lkdGglMi8yLC10aGlzLnNjcm9sbGJhclN0cm9rZVdpZHRoJTIvMik7dGhpcy5kcmF3U2Nyb2xsYmFyQnV0dG9uKDApO3RoaXMuZHJhd1Njcm9sbGJhckJ1dHRvbigxKX07YS5wcm90b3R5cGUuc2V0UmFuZ2U9ZnVuY3Rpb24oYSxjKXt2YXIgZD10aGlzLm9wdGlvbnMsYj1kLnZlcnRpY2FsLGU9ZC5taW5XaWR0aCxmPXRoaXMuYmFyV2lkdGgsZyxoPSF0aGlzLnJlbmRlcmVkfHx0aGlzLmhhc0RyYWdnZWR8fFxudGhpcy5jaGFydC5uYXZpZ2F0b3ImJnRoaXMuY2hhcnQubmF2aWdhdG9yLmhhc0RyYWdnZWQ/XCJhdHRyXCI6XCJhbmltYXRlXCI7aWYoRChmKSl7YT1NYXRoLm1heChhLDApO3ZhciBrPU1hdGguY2VpbChmKmEpO3RoaXMuY2FsY3VsYXRlZFdpZHRoPWc9QihmKk1hdGgubWluKGMsMSktayk7ZzxlJiYoaz0oZi1lK2cpKmEsZz1lKTtlPU1hdGguZmxvb3Ioayt0aGlzLnhPZmZzZXQrdGhpcy55T2Zmc2V0KTtmPWcvMi0uNTt0aGlzLmZyb209YTt0aGlzLnRvPWM7Yj8odGhpcy5zY3JvbGxiYXJHcm91cFtoXSh7dHJhbnNsYXRlWTplfSksdGhpcy5zY3JvbGxiYXJbaF0oe2hlaWdodDpnfSksdGhpcy5zY3JvbGxiYXJSaWZsZXNbaF0oe3RyYW5zbGF0ZVk6Zn0pLHRoaXMuc2Nyb2xsYmFyVG9wPWUsdGhpcy5zY3JvbGxiYXJMZWZ0PTApOih0aGlzLnNjcm9sbGJhckdyb3VwW2hdKHt0cmFuc2xhdGVYOmV9KSx0aGlzLnNjcm9sbGJhcltoXSh7d2lkdGg6Z30pLHRoaXMuc2Nyb2xsYmFyUmlmbGVzW2hdKHt0cmFuc2xhdGVYOmZ9KSxcbnRoaXMuc2Nyb2xsYmFyTGVmdD1lLHRoaXMuc2Nyb2xsYmFyVG9wPTApOzEyPj1nP3RoaXMuc2Nyb2xsYmFyUmlmbGVzLmhpZGUoKTp0aGlzLnNjcm9sbGJhclJpZmxlcy5zaG93KCEwKTshMT09PWQuc2hvd0Z1bGwmJigwPj1hJiYxPD1jP3RoaXMuZ3JvdXAuaGlkZSgpOnRoaXMuZ3JvdXAuc2hvdygpKTt0aGlzLnJlbmRlcmVkPSEwfX07YS5wcm90b3R5cGUudHJhY2tDbGljaz1mdW5jdGlvbihhKXt2YXIgYz10aGlzLmNoYXJ0LnBvaW50ZXIubm9ybWFsaXplKGEpLGQ9dGhpcy50by10aGlzLmZyb20sYj10aGlzLnkrdGhpcy5zY3JvbGxiYXJUb3AsZT10aGlzLngrdGhpcy5zY3JvbGxiYXJMZWZ0O3RoaXMub3B0aW9ucy52ZXJ0aWNhbCYmYy5jaGFydFk+Ynx8IXRoaXMub3B0aW9ucy52ZXJ0aWNhbCYmYy5jaGFydFg+ZT90aGlzLnVwZGF0ZVBvc2l0aW9uKHRoaXMuZnJvbStkLHRoaXMudG8rZCk6dGhpcy51cGRhdGVQb3NpdGlvbih0aGlzLmZyb20tZCx0aGlzLnRvLWQpO3codGhpcyxcblwiY2hhbmdlZFwiLHtmcm9tOnRoaXMuZnJvbSx0bzp0aGlzLnRvLHRyaWdnZXI6XCJzY3JvbGxiYXJcIixET01FdmVudDphfSl9O2EucHJvdG90eXBlLnVwZGF0ZT1mdW5jdGlvbihhKXt0aGlzLmRlc3Ryb3koKTt0aGlzLmluaXQodGhpcy5jaGFydC5yZW5kZXJlcixrKCEwLHRoaXMub3B0aW9ucyxhKSx0aGlzLmNoYXJ0KX07YS5wcm90b3R5cGUudXBkYXRlUG9zaXRpb249ZnVuY3Rpb24oYSxjKXsxPGMmJihhPUIoMS1CKGMtYSkpLGM9MSk7MD5hJiYoYz1CKGMtYSksYT0wKTt0aGlzLmZyb209YTt0aGlzLnRvPWN9O2EuZGVmYXVsdE9wdGlvbnM9e2hlaWdodDplPzIwOjE0LGJhckJvcmRlclJhZGl1czowLGJ1dHRvbkJvcmRlclJhZGl1czowLGxpdmVSZWRyYXc6dm9pZCAwLG1hcmdpbjoxMCxtaW5XaWR0aDo2LHN0ZXA6LjIsekluZGV4OjMsYmFyQmFja2dyb3VuZENvbG9yOnQubmV1dHJhbENvbG9yMjAsYmFyQm9yZGVyV2lkdGg6MSxiYXJCb3JkZXJDb2xvcjp0Lm5ldXRyYWxDb2xvcjIwLFxuYnV0dG9uQXJyb3dDb2xvcjp0Lm5ldXRyYWxDb2xvcjgwLGJ1dHRvbkJhY2tncm91bmRDb2xvcjp0Lm5ldXRyYWxDb2xvcjEwLGJ1dHRvbkJvcmRlckNvbG9yOnQubmV1dHJhbENvbG9yMjAsYnV0dG9uQm9yZGVyV2lkdGg6MSxyaWZsZUNvbG9yOnQubmV1dHJhbENvbG9yODAsdHJhY2tCYWNrZ3JvdW5kQ29sb3I6dC5uZXV0cmFsQ29sb3I1LHRyYWNrQm9yZGVyQ29sb3I6dC5uZXV0cmFsQ29sb3I1LHRyYWNrQm9yZGVyV2lkdGg6MX07cmV0dXJuIGF9KCk7dS5TY3JvbGxiYXJ8fChuLnNjcm9sbGJhcj1rKCEwLGguZGVmYXVsdE9wdGlvbnMsbi5zY3JvbGxiYXIpLHUuU2Nyb2xsYmFyPWgsci5jb21wb3NlKGEsaCkpO3JldHVybiB1LlNjcm9sbGJhcn0pO0YoYSxcIkV4dGVuc2lvbnMvUmFuZ2VTZWxlY3Rvci5qc1wiLFthW1wiQ29yZS9BeGlzL0F4aXMuanNcIl0sYVtcIkNvcmUvQ2hhcnQvQ2hhcnQuanNcIl0sYVtcIkNvcmUvR2xvYmFscy5qc1wiXSxhW1wiQ29yZS9PcHRpb25zLmpzXCJdLGFbXCJDb3JlL0NvbG9yL1BhbGV0dGUuanNcIl0sXG5hW1wiQ29yZS9SZW5kZXJlci9TVkcvU1ZHRWxlbWVudC5qc1wiXSxhW1wiQ29yZS9VdGlsaXRpZXMuanNcIl1dLGZ1bmN0aW9uKGEsdSx0LHIsbixoLEEpe2Z1bmN0aW9uIEIoYSl7aWYoLTEhPT1hLmluZGV4T2YoXCIlTFwiKSlyZXR1cm5cInRleHRcIjt2YXIgYj1cImFBZGV3YkJtb3lZXCIuc3BsaXQoXCJcIikuc29tZShmdW5jdGlvbihiKXtyZXR1cm4tMSE9PWEuaW5kZXhPZihcIiVcIitiKX0pLGM9XCJIa0lsTVNcIi5zcGxpdChcIlwiKS5zb21lKGZ1bmN0aW9uKGIpe3JldHVybi0xIT09YS5pbmRleE9mKFwiJVwiK2IpfSk7cmV0dXJuIGImJmM/XCJkYXRldGltZS1sb2NhbFwiOmI/XCJkYXRlXCI6Yz9cInRpbWVcIjpcInRleHRcIn12YXIgRD1yLmRlZmF1bHRPcHRpb25zLHA9QS5hZGRFdmVudCx3PUEuY3JlYXRlRWxlbWVudCxrPUEuY3NzLGY9QS5kZWZpbmVkLHY9QS5kZXN0cm95T2JqZWN0UHJvcGVydGllcyxlPUEuZGlzY2FyZEVsZW1lbnQsZz1BLmV4dGVuZCxtPUEuZmluZCxxPUEuZmlyZUV2ZW50LGM9QS5pc051bWJlcixcbmQ9QS5tZXJnZSxiPUEub2JqZWN0RWFjaCxGPUEucGFkLEk9QS5waWNrLEs9QS5wSW50LEw9QS5zcGxhdDtnKEQse3JhbmdlU2VsZWN0b3I6e2FsbEJ1dHRvbnNFbmFibGVkOiExLGJ1dHRvbnM6dm9pZCAwLGJ1dHRvblNwYWNpbmc6NSxkcm9wZG93bjpcInJlc3BvbnNpdmVcIixlbmFibGVkOnZvaWQgMCx2ZXJ0aWNhbEFsaWduOlwidG9wXCIsYnV0dG9uVGhlbWU6e3dpZHRoOjI4LGhlaWdodDoxOCxwYWRkaW5nOjIsekluZGV4Ojd9LGZsb2F0aW5nOiExLHg6MCx5OjAsaGVpZ2h0OnZvaWQgMCxpbnB1dEJveEJvcmRlckNvbG9yOlwibm9uZVwiLGlucHV0Qm94SGVpZ2h0OjE3LGlucHV0Qm94V2lkdGg6dm9pZCAwLGlucHV0RGF0ZUZvcm1hdDpcIiViICVlLCAlWVwiLGlucHV0RGF0ZVBhcnNlcjp2b2lkIDAsaW5wdXRFZGl0RGF0ZUZvcm1hdDpcIiVZLSVtLSVkXCIsaW5wdXRFbmFibGVkOiEwLGlucHV0UG9zaXRpb246e2FsaWduOlwicmlnaHRcIix4OjAseTowfSxpbnB1dFNwYWNpbmc6NSxzZWxlY3RlZDp2b2lkIDAsXG5idXR0b25Qb3NpdGlvbjp7YWxpZ246XCJsZWZ0XCIseDowLHk6MH0saW5wdXRTdHlsZTp7Y29sb3I6bi5oaWdobGlnaHRDb2xvcjgwLGN1cnNvcjpcInBvaW50ZXJcIn0sbGFiZWxTdHlsZTp7Y29sb3I6bi5uZXV0cmFsQ29sb3I2MH19fSk7ZyhELmxhbmcse3JhbmdlU2VsZWN0b3Jab29tOlwiWm9vbVwiLHJhbmdlU2VsZWN0b3JGcm9tOlwiXCIscmFuZ2VTZWxlY3RvclRvOlwiXFx1MjE5MlwifSk7dmFyIEg9ZnVuY3Rpb24oKXtmdW5jdGlvbiBtKGEpe3RoaXMuYnV0dG9ucz12b2lkIDA7dGhpcy5idXR0b25PcHRpb25zPW0ucHJvdG90eXBlLmRlZmF1bHRCdXR0b25zO3RoaXMuaW5pdGlhbEJ1dHRvbkdyb3VwV2lkdGg9MDt0aGlzLm9wdGlvbnM9dm9pZCAwO3RoaXMuY2hhcnQ9YTt0aGlzLmluaXQoYSl9bS5wcm90b3R5cGUuY2xpY2tCdXR0b249ZnVuY3Rpb24oYixkKXt2YXIgbD10aGlzLmNoYXJ0LGU9dGhpcy5idXR0b25PcHRpb25zW2JdLGc9bC54QXhpc1swXSxoPWwuc2Nyb2xsZXImJmwuc2Nyb2xsZXIuZ2V0VW5pb25FeHRyZW1lcygpfHxcbmd8fHt9LHk9aC5kYXRhTWluLGs9aC5kYXRhTWF4LHo9ZyYmTWF0aC5yb3VuZChNYXRoLm1pbihnLm1heCxJKGssZy5tYXgpKSksbT1lLnR5cGU7aD1lLl9yYW5nZTt2YXIgbixyPWUuZGF0YUdyb3VwaW5nO2lmKG51bGwhPT15JiZudWxsIT09ayl7bC5maXhlZFJhbmdlPWg7ciYmKHRoaXMuZm9yY2VkRGF0YUdyb3VwaW5nPSEwLGEucHJvdG90eXBlLnNldERhdGFHcm91cGluZy5jYWxsKGd8fHtjaGFydDp0aGlzLmNoYXJ0fSxyLCExKSx0aGlzLmZyb3plblN0YXRlcz1lLnByZXNlcnZlRGF0YUdyb3VwaW5nKTtpZihcIm1vbnRoXCI9PT1tfHxcInllYXJcIj09PW0paWYoZyl7bT17cmFuZ2U6ZSxtYXg6eixjaGFydDpsLGRhdGFNaW46eSxkYXRhTWF4Omt9O3ZhciB0PWcubWluRnJvbVJhbmdlLmNhbGwobSk7YyhtLm5ld01heCkmJih6PW0ubmV3TWF4KX1lbHNlIGg9ZTtlbHNlIGlmKGgpdD1NYXRoLm1heCh6LWgseSksej1NYXRoLm1pbih0K2gsayk7ZWxzZSBpZihcInl0ZFwiPT09bSlpZihnKVwidW5kZWZpbmVkXCI9PT1cbnR5cGVvZiBrJiYoeT1OdW1iZXIuTUFYX1ZBTFVFLGs9TnVtYmVyLk1JTl9WQUxVRSxsLnNlcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2E9YS54RGF0YTt5PU1hdGgubWluKGFbMF0seSk7az1NYXRoLm1heChhW2EubGVuZ3RoLTFdLGspfSksZD0hMSksej10aGlzLmdldFlUREV4dHJlbWVzKGsseSxsLnRpbWUudXNlVVRDKSx0PW49ei5taW4sej16Lm1heDtlbHNle3RoaXMuZGVmZXJyZWRZVERDbGljaz1iO3JldHVybn1lbHNlXCJhbGxcIj09PW0mJmcmJih0PXksej1rKTtmKHQpJiYodCs9ZS5fb2Zmc2V0TWluKTtmKHopJiYoeis9ZS5fb2Zmc2V0TWF4KTt0aGlzLnNldFNlbGVjdGVkKGIpO3RoaXMuZHJvcGRvd24mJih0aGlzLmRyb3Bkb3duLnNlbGVjdGVkSW5kZXg9YisxKTtpZihnKWcuc2V0RXh0cmVtZXModCx6LEkoZCwhMCksdm9pZCAwLHt0cmlnZ2VyOlwicmFuZ2VTZWxlY3RvckJ1dHRvblwiLHJhbmdlU2VsZWN0b3JCdXR0b246ZX0pO2Vsc2V7dmFyIHY9TChsLm9wdGlvbnMueEF4aXMpWzBdO1xudmFyIHU9di5yYW5nZTt2LnJhbmdlPWg7dmFyIHc9di5taW47di5taW49bjtwKGwsXCJsb2FkXCIsZnVuY3Rpb24oKXt2LnJhbmdlPXU7di5taW49d30pfXEodGhpcyxcImFmdGVyQnRuQ2xpY2tcIil9fTttLnByb3RvdHlwZS5zZXRTZWxlY3RlZD1mdW5jdGlvbihhKXt0aGlzLnNlbGVjdGVkPXRoaXMub3B0aW9ucy5zZWxlY3RlZD1hfTttLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1hLm9wdGlvbnMucmFuZ2VTZWxlY3RvcixkPWMuYnV0dG9uc3x8Yi5kZWZhdWx0QnV0dG9ucy5zbGljZSgpLGU9Yy5zZWxlY3RlZCxmPWZ1bmN0aW9uKCl7dmFyIGE9Yi5taW5JbnB1dCxjPWIubWF4SW5wdXQ7YSYmYS5ibHVyJiZxKGEsXCJibHVyXCIpO2MmJmMuYmx1ciYmcShjLFwiYmx1clwiKX07Yi5jaGFydD1hO2Iub3B0aW9ucz1jO2IuYnV0dG9ucz1bXTtiLmJ1dHRvbk9wdGlvbnM9ZDt0aGlzLmV2ZW50c1RvVW5iaW5kPVtdO3RoaXMuZXZlbnRzVG9VbmJpbmQucHVzaChwKGEuY29udGFpbmVyLFxuXCJtb3VzZWRvd25cIixmKSk7dGhpcy5ldmVudHNUb1VuYmluZC5wdXNoKHAoYSxcInJlc2l6ZVwiLGYpKTtkLmZvckVhY2goYi5jb21wdXRlQnV0dG9uUmFuZ2UpO1widW5kZWZpbmVkXCIhPT10eXBlb2YgZSYmZFtlXSYmdGhpcy5jbGlja0J1dHRvbihlLCExKTt0aGlzLmV2ZW50c1RvVW5iaW5kLnB1c2gocChhLFwibG9hZFwiLGZ1bmN0aW9uKCl7YS54QXhpcyYmYS54QXhpc1swXSYmcChhLnhBeGlzWzBdLFwic2V0RXh0cmVtZXNcIixmdW5jdGlvbihjKXt0aGlzLm1heC10aGlzLm1pbiE9PWEuZml4ZWRSYW5nZSYmXCJyYW5nZVNlbGVjdG9yQnV0dG9uXCIhPT1jLnRyaWdnZXImJlwidXBkYXRlZERhdGFcIiE9PWMudHJpZ2dlciYmYi5mb3JjZWREYXRhR3JvdXBpbmcmJiFiLmZyb3plblN0YXRlcyYmdGhpcy5zZXREYXRhR3JvdXBpbmcoITEsITEpfSl9KSl9O20ucHJvdG90eXBlLnVwZGF0ZUJ1dHRvblN0YXRlcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmNoYXJ0LGQ9dGhpcy5kcm9wZG93bixcbmU9Yi54QXhpc1swXSxmPU1hdGgucm91bmQoZS5tYXgtZS5taW4pLGc9IWUuaGFzVmlzaWJsZVNlcmllcyxoPWIuc2Nyb2xsZXImJmIuc2Nyb2xsZXIuZ2V0VW5pb25FeHRyZW1lcygpfHxlLGs9aC5kYXRhTWluLG09aC5kYXRhTWF4O2I9YS5nZXRZVERFeHRyZW1lcyhtLGssYi50aW1lLnVzZVVUQyk7dmFyIG49Yi5taW4scT1iLm1heCx0PWEuc2VsZWN0ZWQscD1jKHQpLHI9YS5vcHRpb25zLmFsbEJ1dHRvbnNFbmFibGVkLHY9YS5idXR0b25zO2EuYnV0dG9uT3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGIsYyl7dmFyIGw9Yi5fcmFuZ2UseD1iLnR5cGUsaD1iLmNvdW50fHwxLHk9dltjXSx6PTAsRz1iLl9vZmZzZXRNYXgtYi5fb2Zmc2V0TWluO2I9Yz09PXQ7dmFyIE89bD5tLWssUD1sPGUubWluUmFuZ2UsTj0hMSx1PSExO2w9bD09PWY7KFwibW9udGhcIj09PXh8fFwieWVhclwiPT09eCkmJmYrMzZFNT49ODY0RTUqe21vbnRoOjI4LHllYXI6MzY1fVt4XSpoLUcmJmYtMzZFNTw9ODY0RTUqXG57bW9udGg6MzEseWVhcjozNjZ9W3hdKmgrRz9sPSEwOlwieXRkXCI9PT14PyhsPXEtbitHPT09ZixOPSFiKTpcImFsbFwiPT09eCYmKGw9ZS5tYXgtZS5taW4+PW0tayx1PSFiJiZwJiZsKTt4PSFyJiYoT3x8UHx8dXx8Zyk7aD1iJiZsfHxsJiYhcCYmIU58fGImJmEuZnJvemVuU3RhdGVzO3g/ej0zOmgmJihwPSEwLHo9Mik7eS5zdGF0ZSE9PXomJih5LnNldFN0YXRlKHopLGQmJihkLm9wdGlvbnNbYysxXS5kaXNhYmxlZD14LDI9PT16JiYoZC5zZWxlY3RlZEluZGV4PWMrMSkpLDA9PT16JiZ0PT09YyYmYS5zZXRTZWxlY3RlZCgpKX0pfTttLnByb3RvdHlwZS5jb21wdXRlQnV0dG9uUmFuZ2U9ZnVuY3Rpb24oYSl7dmFyIGI9YS50eXBlLGM9YS5jb3VudHx8MSxkPXttaWxsaXNlY29uZDoxLHNlY29uZDoxRTMsbWludXRlOjZFNCxob3VyOjM2RTUsZGF5Ojg2NEU1LHdlZWs6NjA0OEU1fTtpZihkW2JdKWEuX3JhbmdlPWRbYl0qYztlbHNlIGlmKFwibW9udGhcIj09PWJ8fFwieWVhclwiPT09YilhLl9yYW5nZT1cbjg2NEU1Knttb250aDozMCx5ZWFyOjM2NX1bYl0qYzthLl9vZmZzZXRNaW49SShhLm9mZnNldE1pbiwwKTthLl9vZmZzZXRNYXg9SShhLm9mZnNldE1heCwwKTthLl9yYW5nZSs9YS5fb2Zmc2V0TWF4LWEuX29mZnNldE1pbn07bS5wcm90b3R5cGUuZ2V0SW5wdXRWYWx1ZT1mdW5jdGlvbihhKXthPVwibWluXCI9PT1hP3RoaXMubWluSW5wdXQ6dGhpcy5tYXhJbnB1dDt2YXIgYj10aGlzLmNoYXJ0Lm9wdGlvbnMucmFuZ2VTZWxlY3RvcixjPXRoaXMuY2hhcnQudGltZTtyZXR1cm4gYT8oXCJ0ZXh0XCI9PT1hLnR5cGUmJmIuaW5wdXREYXRlUGFyc2VyfHx0aGlzLmRlZmF1bHRJbnB1dERhdGVQYXJzZXIpKGEudmFsdWUsYy51c2VVVEMsYyk6MH07bS5wcm90b3R5cGUuc2V0SW5wdXRWYWx1ZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMub3B0aW9ucyxkPXRoaXMuY2hhcnQudGltZSxlPVwibWluXCI9PT1hP3RoaXMubWluSW5wdXQ6dGhpcy5tYXhJbnB1dDthPVwibWluXCI9PT1hP3RoaXMubWluRGF0ZUJveDpcbnRoaXMubWF4RGF0ZUJveDtpZihlKXt2YXIgZz1lLmdldEF0dHJpYnV0ZShcImRhdGEtaGMtdGltZVwiKTtnPWYoZyk/TnVtYmVyKGcpOnZvaWQgMDtmKGIpJiYoZihnKSYmZS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhjLXRpbWUtcHJldmlvdXNcIixnKSxlLnNldEF0dHJpYnV0ZShcImRhdGEtaGMtdGltZVwiLGIpLGc9Yik7ZS52YWx1ZT1kLmRhdGVGb3JtYXQodGhpcy5pbnB1dFR5cGVGb3JtYXRzW2UudHlwZV18fGMuaW5wdXRFZGl0RGF0ZUZvcm1hdCxnKTthJiZhLmF0dHIoe3RleHQ6ZC5kYXRlRm9ybWF0KGMuaW5wdXREYXRlRm9ybWF0LGcpfSl9fTttLnByb3RvdHlwZS5zZXRJbnB1dEV4dHJlbWVzPWZ1bmN0aW9uKGEsYixjKXtpZihhPVwibWluXCI9PT1hP3RoaXMubWluSW5wdXQ6dGhpcy5tYXhJbnB1dCl7dmFyIGQ9dGhpcy5pbnB1dFR5cGVGb3JtYXRzW2EudHlwZV0sbD10aGlzLmNoYXJ0LnRpbWU7ZCYmKGI9bC5kYXRlRm9ybWF0KGQsYiksYS5taW4hPT1iJiYoYS5taW49YiksYz1sLmRhdGVGb3JtYXQoZCxcbmMpLGEubWF4IT09YyYmKGEubWF4PWMpKX19O20ucHJvdG90eXBlLnNob3dJbnB1dD1mdW5jdGlvbihhKXt2YXIgYj1cIm1pblwiPT09YT90aGlzLm1pbkRhdGVCb3g6dGhpcy5tYXhEYXRlQm94O2lmKChhPVwibWluXCI9PT1hP3RoaXMubWluSW5wdXQ6dGhpcy5tYXhJbnB1dCkmJmImJnRoaXMuaW5wdXRHcm91cCl7dmFyIGM9XCJ0ZXh0XCI9PT1hLnR5cGUsZD10aGlzLmlucHV0R3JvdXAsZT1kLnRyYW5zbGF0ZVg7ZD1kLnRyYW5zbGF0ZVk7ayhhLHt3aWR0aDpjP2Iud2lkdGgtMitcInB4XCI6XCJhdXRvXCIsaGVpZ2h0OmM/Yi5oZWlnaHQtMitcInB4XCI6XCJhdXRvXCIsYm9yZGVyOlwiMnB4IHNvbGlkIHNpbHZlclwifSk7Yz9rKGEse2xlZnQ6ZStiLngrXCJweFwiLHRvcDpkK1wicHhcIn0pOmsoYSx7bGVmdDpNYXRoLm1pbihNYXRoLnJvdW5kKGIueCtlLShhLm9mZnNldFdpZHRoLWIud2lkdGgpLzIpLHRoaXMuY2hhcnQuY2hhcnRXaWR0aC1hLm9mZnNldFdpZHRoKStcInB4XCIsdG9wOmQtKGEub2Zmc2V0SGVpZ2h0LVxuYi5oZWlnaHQpLzIrXCJweFwifSl9fTttLnByb3RvdHlwZS5oaWRlSW5wdXQ9ZnVuY3Rpb24oYSl7KGE9XCJtaW5cIj09PWE/dGhpcy5taW5JbnB1dDp0aGlzLm1heElucHV0KSYmayhhLHt0b3A6XCItOTk5OWVtXCIsYm9yZGVyOjAsd2lkdGg6XCIxcHhcIixoZWlnaHQ6XCIxcHhcIn0pfTttLnByb3RvdHlwZS5kZWZhdWx0SW5wdXREYXRlUGFyc2VyPWZ1bmN0aW9uKGEsYixkKXt2YXIgZT1hLnNwbGl0KFwiL1wiKS5qb2luKFwiLVwiKS5zcGxpdChcIiBcIikuam9pbihcIlRcIik7LTE9PT1lLmluZGV4T2YoXCJUXCIpJiYoZSs9XCJUMDA6MDBcIik7aWYoYillKz1cIlpcIjtlbHNle3ZhciBsO2lmKGw9dC5pc1NhZmFyaSlsPWUsbD0hKDY8bC5sZW5ndGgmJihsLmxhc3RJbmRleE9mKFwiLVwiKT09PWwubGVuZ3RoLTZ8fGwubGFzdEluZGV4T2YoXCIrXCIpPT09bC5sZW5ndGgtNikpO2wmJihsPShuZXcgRGF0ZShlKSkuZ2V0VGltZXpvbmVPZmZzZXQoKS82MCxlKz0wPj1sP1wiK1wiK0YoLWwpK1wiOjAwXCI6XCItXCIrRihsKStcIjowMFwiKX1lPVxuRGF0ZS5wYXJzZShlKTtjKGUpfHwoYT1hLnNwbGl0KFwiLVwiKSxlPURhdGUuVVRDKEsoYVswXSksSyhhWzFdKS0xLEsoYVsyXSkpKTtkJiZiJiYoZSs9ZC5nZXRUaW1lem9uZU9mZnNldChlKSk7cmV0dXJuIGV9O20ucHJvdG90eXBlLmRyYXdJbnB1dD1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKCl7dmFyIGI9bS5nZXRJbnB1dFZhbHVlKGEpLGQ9ZS54QXhpc1swXSxsPWUuc2Nyb2xsZXImJmUuc2Nyb2xsZXIueEF4aXM/ZS5zY3JvbGxlci54QXhpczpkLGY9bC5kYXRhTWluO2w9bC5kYXRhTWF4O3ZhciBnPW0ubWF4SW5wdXQseD1tLm1pbklucHV0O2IhPT1OdW1iZXIodS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWhjLXRpbWUtcHJldmlvdXNcIikpJiZjKGIpJiYodS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWhjLXRpbWUtcHJldmlvdXNcIixiKSxyJiZnJiZjKGYpP2I+TnVtYmVyKGcuZ2V0QXR0cmlidXRlKFwiZGF0YS1oYy10aW1lXCIpKT9iPXZvaWQgMDpiPGYmJihiPWYpOngmJmMobCkmJihiPE51bWJlcih4LmdldEF0dHJpYnV0ZShcImRhdGEtaGMtdGltZVwiKSk/XG5iPXZvaWQgMDpiPmwmJihiPWwpKSxcInVuZGVmaW5lZFwiIT09dHlwZW9mIGImJmQuc2V0RXh0cmVtZXMocj9iOmQubWluLHI/ZC5tYXg6Yix2b2lkIDAsdm9pZCAwLHt0cmlnZ2VyOlwicmFuZ2VTZWxlY3RvcklucHV0XCJ9KSl9dmFyIGU9dGhpcy5jaGFydCxmPXRoaXMuZGl2LGg9dGhpcy5pbnB1dEdyb3VwLG09dGhpcyx5PWUucmVuZGVyZXIuc3R5bGV8fHt9LHE9ZS5yZW5kZXJlcixwPWUub3B0aW9ucy5yYW5nZVNlbGVjdG9yLHI9XCJtaW5cIj09PWEsdj1ELmxhbmdbcj9cInJhbmdlU2VsZWN0b3JGcm9tXCI6XCJyYW5nZVNlbGVjdG9yVG9cIl07dj1xLmxhYmVsKHYsMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXJhbmdlLWxhYmVsXCIpLmF0dHIoe3BhZGRpbmc6dj8yOjB9KS5hZGQoaCk7cT1xLmxhYmVsKFwiXCIsMCkuYWRkQ2xhc3MoXCJoaWdoY2hhcnRzLXJhbmdlLWlucHV0XCIpLmF0dHIoe3BhZGRpbmc6Mix3aWR0aDpwLmlucHV0Qm94V2lkdGgsaGVpZ2h0OnAuaW5wdXRCb3hIZWlnaHQsXCJ0ZXh0LWFsaWduXCI6XCJjZW50ZXJcIn0pLm9uKFwiY2xpY2tcIixcbmZ1bmN0aW9uKCl7bS5zaG93SW5wdXQoYSk7bVthK1wiSW5wdXRcIl0uZm9jdXMoKX0pO2Uuc3R5bGVkTW9kZXx8cS5hdHRyKHtzdHJva2U6cC5pbnB1dEJveEJvcmRlckNvbG9yLFwic3Ryb2tlLXdpZHRoXCI6MX0pO3EuYWRkKGgpO3ZhciB1PXcoXCJpbnB1dFwiLHtuYW1lOmEsY2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1yYW5nZS1zZWxlY3RvclwifSx2b2lkIDAsZik7dS5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsQihwLmlucHV0RGF0ZUZvcm1hdHx8XCIlYiAlZSwgJVlcIikpO2Uuc3R5bGVkTW9kZXx8KHYuY3NzKGQoeSxwLmxhYmVsU3R5bGUpKSxxLmNzcyhkKHtjb2xvcjpuLm5ldXRyYWxDb2xvcjgwfSx5LHAuaW5wdXRTdHlsZSkpLGsodSxnKHtwb3NpdGlvbjpcImFic29sdXRlXCIsYm9yZGVyOjAsYm94U2hhZG93OlwiMCAwIDE1cHggcmdiYSgwLDAsMCwwLjMpXCIsd2lkdGg6XCIxcHhcIixoZWlnaHQ6XCIxcHhcIixwYWRkaW5nOjAsdGV4dEFsaWduOlwiY2VudGVyXCIsZm9udFNpemU6eS5mb250U2l6ZSxmb250RmFtaWx5OnkuZm9udEZhbWlseSxcbnRvcDpcIi05OTk5ZW1cIn0scC5pbnB1dFN0eWxlKSkpO3Uub25mb2N1cz1mdW5jdGlvbigpe20uc2hvd0lucHV0KGEpfTt1Lm9uYmx1cj1mdW5jdGlvbigpe3U9PT10LmRvYy5hY3RpdmVFbGVtZW50JiZiKCk7bS5oaWRlSW5wdXQoYSk7bS5zZXRJbnB1dFZhbHVlKGEpO3UuYmx1cigpfTt2YXIgRT0hMTt1Lm9uY2hhbmdlPWZ1bmN0aW9uKCl7YigpO0V8fChtLmhpZGVJbnB1dChhKSx1LmJsdXIoKSl9O3Uub25rZXlwcmVzcz1mdW5jdGlvbihhKXsxMz09PWEua2V5Q29kZSYmYigpfTt1Lm9ua2V5ZG93bj1mdW5jdGlvbigpe0U9ITB9O3Uub25rZXl1cD1mdW5jdGlvbigpe0U9ITF9O3JldHVybntkYXRlQm94OnEsaW5wdXQ6dSxsYWJlbDp2fX07bS5wcm90b3R5cGUuZ2V0UG9zaXRpb249ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNoYXJ0LGI9YS5vcHRpb25zLnJhbmdlU2VsZWN0b3I7YT1cInRvcFwiPT09Yi52ZXJ0aWNhbEFsaWduP2EucGxvdFRvcC1hLmF4aXNPZmZzZXRbMF06MDtyZXR1cm57YnV0dG9uVG9wOmErXG5iLmJ1dHRvblBvc2l0aW9uLnksaW5wdXRUb3A6YStiLmlucHV0UG9zaXRpb24ueS0xMH19O20ucHJvdG90eXBlLmdldFlUREV4dHJlbWVzPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD10aGlzLmNoYXJ0LnRpbWUsZT1uZXcgZC5EYXRlKGEpLGw9ZC5nZXQoXCJGdWxsWWVhclwiLGUpO2M9Yz9kLkRhdGUuVVRDKGwsMCwxKTorbmV3IGQuRGF0ZShsLDAsMSk7Yj1NYXRoLm1heChiLGMpO2U9ZS5nZXRUaW1lKCk7cmV0dXJue21heDpNYXRoLm1pbihhfHxlLGUpLG1pbjpifX07bS5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydCxkPWMucmVuZGVyZXIsZT1jLmNvbnRhaW5lcixnPWMub3B0aW9ucyxoPWcucmFuZ2VTZWxlY3RvcixrPUkoZy5jaGFydC5zdHlsZSYmZy5jaGFydC5zdHlsZS56SW5kZXgsMCkrMTtnPWguaW5wdXRFbmFibGVkO2lmKCExIT09aC5lbmFibGVkKXt0aGlzLnJlbmRlcmVkfHwodGhpcy5ncm91cD1kLmcoXCJyYW5nZS1zZWxlY3Rvci1ncm91cFwiKS5hdHRyKHt6SW5kZXg6N30pLmFkZCgpLFxudGhpcy5kaXY9dyhcImRpdlwiLHZvaWQgMCx7cG9zaXRpb246XCJyZWxhdGl2ZVwiLGhlaWdodDowLHpJbmRleDprfSksdGhpcy5idXR0b25PcHRpb25zLmxlbmd0aCYmdGhpcy5yZW5kZXJCdXR0b25zKCksZS5wYXJlbnROb2RlJiZlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuZGl2LGUpLGcmJih0aGlzLmlucHV0R3JvdXA9ZC5nKFwiaW5wdXQtZ3JvdXBcIikuYWRkKHRoaXMuZ3JvdXApLGQ9dGhpcy5kcmF3SW5wdXQoXCJtaW5cIiksdGhpcy5taW5EYXRlQm94PWQuZGF0ZUJveCx0aGlzLm1pbkxhYmVsPWQubGFiZWwsdGhpcy5taW5JbnB1dD1kLmlucHV0LGQ9dGhpcy5kcmF3SW5wdXQoXCJtYXhcIiksdGhpcy5tYXhEYXRlQm94PWQuZGF0ZUJveCx0aGlzLm1heExhYmVsPWQubGFiZWwsdGhpcy5tYXhJbnB1dD1kLmlucHV0KSk7aWYoZyYmKHRoaXMuc2V0SW5wdXRWYWx1ZShcIm1pblwiLGEpLHRoaXMuc2V0SW5wdXRWYWx1ZShcIm1heFwiLGIpLGE9Yy5zY3JvbGxlciYmYy5zY3JvbGxlci5nZXRVbmlvbkV4dHJlbWVzKCl8fFxuYy54QXhpc1swXXx8e30sZihhLmRhdGFNaW4pJiZmKGEuZGF0YU1heCkmJihjPWMueEF4aXNbMF0ubWluUmFuZ2V8fDAsdGhpcy5zZXRJbnB1dEV4dHJlbWVzKFwibWluXCIsYS5kYXRhTWluLE1hdGgubWluKGEuZGF0YU1heCx0aGlzLmdldElucHV0VmFsdWUoXCJtYXhcIikpLWMpLHRoaXMuc2V0SW5wdXRFeHRyZW1lcyhcIm1heFwiLE1hdGgubWF4KGEuZGF0YU1pbix0aGlzLmdldElucHV0VmFsdWUoXCJtaW5cIikpK2MsYS5kYXRhTWF4KSksdGhpcy5pbnB1dEdyb3VwKSl7dmFyIG09MDtbdGhpcy5taW5MYWJlbCx0aGlzLm1pbkRhdGVCb3gsdGhpcy5tYXhMYWJlbCx0aGlzLm1heERhdGVCb3hdLmZvckVhY2goZnVuY3Rpb24oYSl7YSYmYS53aWR0aCYmKGEuYXR0cih7eDptfSksbSs9YS53aWR0aCtoLmlucHV0U3BhY2luZyl9KX10aGlzLmFsaWduRWxlbWVudHMoKTt0aGlzLnJlbmRlcmVkPSEwfX07bS5wcm90b3R5cGUucmVuZGVyQnV0dG9ucz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmJ1dHRvbnMsXG5jPXRoaXMub3B0aW9ucyxlPUQubGFuZyxmPXRoaXMuY2hhcnQucmVuZGVyZXIsZz1kKGMuYnV0dG9uVGhlbWUpLGg9ZyYmZy5zdGF0ZXMsaz1nLndpZHRofHwyODtkZWxldGUgZy53aWR0aDt0aGlzLmJ1dHRvbkdyb3VwPWYuZyhcInJhbmdlLXNlbGVjdG9yLWJ1dHRvbnNcIikuYWRkKHRoaXMuZ3JvdXApO3ZhciBtPXRoaXMuZHJvcGRvd249dyhcInNlbGVjdFwiLHZvaWQgMCx7cG9zaXRpb246XCJhYnNvbHV0ZVwiLHdpZHRoOlwiMXB4XCIsaGVpZ2h0OlwiMXB4XCIscGFkZGluZzowLGJvcmRlcjowLHRvcDpcIi05OTk5ZW1cIixjdXJzb3I6XCJwb2ludGVyXCIsb3BhY2l0eTouMDAwMX0sdGhpcy5kaXYpO3AobSxcInRvdWNoc3RhcnRcIixmdW5jdGlvbigpe20uc3R5bGUuZm9udFNpemU9XCIxNnB4XCJ9KTtbW3QuaXNNUz9cIm1vdXNlb3ZlclwiOlwibW91c2VlbnRlclwiXSxbdC5pc01TP1wibW91c2VvdXRcIjpcIm1vdXNlbGVhdmVcIl0sW1wiY2hhbmdlXCIsXCJjbGlja1wiXV0uZm9yRWFjaChmdW5jdGlvbihjKXt2YXIgZD1jWzBdLFxuZT1jWzFdO3AobSxkLGZ1bmN0aW9uKCl7dmFyIGM9YlthLmN1cnJlbnRCdXR0b25JbmRleCgpXTtjJiZxKGMuZWxlbWVudCxlfHxkKX0pfSk7dGhpcy56b29tVGV4dD1mLnRleHQoZS5yYW5nZVNlbGVjdG9yWm9vbSwwLDE1KS5hZGQodGhpcy5idXR0b25Hcm91cCk7dGhpcy5jaGFydC5zdHlsZWRNb2RlfHwodGhpcy56b29tVGV4dC5jc3MoYy5sYWJlbFN0eWxlKSxnW1wic3Ryb2tlLXdpZHRoXCJdPUkoZ1tcInN0cm9rZS13aWR0aFwiXSwwKSk7dyhcIm9wdGlvblwiLHt0ZXh0Q29udGVudDp0aGlzLnpvb21UZXh0LnRleHRTdHIsZGlzYWJsZWQ6ITB9LHZvaWQgMCxtKTt0aGlzLmJ1dHRvbk9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbihjLGQpe3coXCJvcHRpb25cIix7dGV4dENvbnRlbnQ6Yy50aXRsZXx8Yy50ZXh0fSx2b2lkIDAsbSk7YltkXT1mLmJ1dHRvbihjLnRleHQsMCwwLGZ1bmN0aW9uKGIpe3ZhciBlPWMuZXZlbnRzJiZjLmV2ZW50cy5jbGljayxsO2UmJihsPWUuY2FsbChjLGIpKTshMSE9PVxubCYmYS5jbGlja0J1dHRvbihkKTthLmlzQWN0aXZlPSEwfSxnLGgmJmguaG92ZXIsaCYmaC5zZWxlY3QsaCYmaC5kaXNhYmxlZCkuYXR0cih7XCJ0ZXh0LWFsaWduXCI6XCJjZW50ZXJcIix3aWR0aDprfSkuYWRkKGEuYnV0dG9uR3JvdXApO2MudGl0bGUmJmJbZF0uYXR0cihcInRpdGxlXCIsYy50aXRsZSl9KX07bS5wcm90b3R5cGUuYWxpZ25FbGVtZW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj10aGlzLmJ1dHRvbkdyb3VwLGM9dGhpcy5idXR0b25zLGQ9dGhpcy5jaGFydCxlPXRoaXMuZ3JvdXAsZj10aGlzLmlucHV0R3JvdXAsZz10aGlzLm9wdGlvbnMsaD10aGlzLnpvb21UZXh0LGs9ZC5vcHRpb25zLG09ay5leHBvcnRpbmcmJiExIT09ay5leHBvcnRpbmcuZW5hYmxlZCYmay5uYXZpZ2F0aW9uJiZrLm5hdmlnYXRpb24uYnV0dG9uT3B0aW9ucztrPWcuYnV0dG9uUG9zaXRpb247dmFyIG49Zy5pbnB1dFBvc2l0aW9uLHE9Zy52ZXJ0aWNhbEFsaWduLHA9ZnVuY3Rpb24oYixjKXtyZXR1cm4gbSYmXG5hLnRpdGxlQ29sbGlzaW9uKGQpJiZcInRvcFwiPT09cSYmXCJyaWdodFwiPT09Yy5hbGlnbiYmYy55LWIuZ2V0QkJveCgpLmhlaWdodC0xMjwobS55fHwwKSsobS5oZWlnaHR8fDApK2Quc3BhY2luZ1swXT8tNDA6MH0sdD1kLnBsb3RMZWZ0O2lmKGUmJmsmJm4pe3ZhciByPWsueC1kLnNwYWNpbmdbM107aWYoYil7dGhpcy5wb3NpdGlvbkJ1dHRvbnMoKTtpZighdGhpcy5pbml0aWFsQnV0dG9uR3JvdXBXaWR0aCl7dmFyIHU9MDtoJiYodSs9aC5nZXRCQm94KCkud2lkdGgrNSk7Yy5mb3JFYWNoKGZ1bmN0aW9uKGEsYil7dSs9YS53aWR0aDtiIT09Yy5sZW5ndGgtMSYmKHUrPWcuYnV0dG9uU3BhY2luZyl9KTt0aGlzLmluaXRpYWxCdXR0b25Hcm91cFdpZHRoPXV9dC09ZC5zcGFjaW5nWzNdO3RoaXMudXBkYXRlQnV0dG9uU3RhdGVzKCk7aD1wKGIsayk7dGhpcy5hbGlnbkJ1dHRvbkdyb3VwKGgpO2UucGxhY2VkPWIucGxhY2VkPWQuaGFzTG9hZGVkfWI9MDtmJiYoYj1wKGYsbiksXCJsZWZ0XCI9PT1cbm4uYWxpZ24/cj10OlwicmlnaHRcIj09PW4uYWxpZ24mJihyPS1NYXRoLm1heChkLmF4aXNPZmZzZXRbMV0sLWIpKSxmLmFsaWduKHt5Om4ueSx3aWR0aDpmLmdldEJCb3goKS53aWR0aCxhbGlnbjpuLmFsaWduLHg6bi54K3ItMn0sITAsZC5zcGFjaW5nQm94KSxmLnBsYWNlZD1kLmhhc0xvYWRlZCk7dGhpcy5oYW5kbGVDb2xsaXNpb24oYik7ZS5hbGlnbih7dmVydGljYWxBbGlnbjpxfSwhMCxkLnNwYWNpbmdCb3gpO2Y9ZS5hbGlnbkF0dHIudHJhbnNsYXRlWTtiPWUuZ2V0QkJveCgpLmhlaWdodCsyMDtwPTA7XCJib3R0b21cIj09PXEmJihwPShwPWQubGVnZW5kJiZkLmxlZ2VuZC5vcHRpb25zKSYmXCJib3R0b21cIj09PXAudmVydGljYWxBbGlnbiYmcC5lbmFibGVkJiYhcC5mbG9hdGluZz9kLmxlZ2VuZC5sZWdlbmRIZWlnaHQrSShwLm1hcmdpbiwxMCk6MCxiPWIrcC0yMCxwPWYtYi0oZy5mbG9hdGluZz8wOmcueSktKGQudGl0bGVPZmZzZXQ/ZC50aXRsZU9mZnNldFsyXTowKS0xMCk7aWYoXCJ0b3BcIj09PVxucSlnLmZsb2F0aW5nJiYocD0wKSxkLnRpdGxlT2Zmc2V0JiZkLnRpdGxlT2Zmc2V0WzBdJiYocD1kLnRpdGxlT2Zmc2V0WzBdKSxwKz1kLm1hcmdpblswXS1kLnNwYWNpbmdbMF18fDA7ZWxzZSBpZihcIm1pZGRsZVwiPT09cSlpZihuLnk9PT1rLnkpcD1mO2Vsc2UgaWYobi55fHxrLnkpcD0wPm4ueXx8MD5rLnk/cC1NYXRoLm1pbihuLnksay55KTpmLWI7ZS50cmFuc2xhdGUoZy54LGcueStNYXRoLmZsb29yKHApKTtrPXRoaXMubWluSW5wdXQ7bj10aGlzLm1heElucHV0O2Y9dGhpcy5kcm9wZG93bjtnLmlucHV0RW5hYmxlZCYmayYmbiYmKGsuc3R5bGUubWFyZ2luVG9wPWUudHJhbnNsYXRlWStcInB4XCIsbi5zdHlsZS5tYXJnaW5Ub3A9ZS50cmFuc2xhdGVZK1wicHhcIik7ZiYmKGYuc3R5bGUubWFyZ2luVG9wPWUudHJhbnNsYXRlWStcInB4XCIpfX07bS5wcm90b3R5cGUuYWxpZ25CdXR0b25Hcm91cD1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXMuY2hhcnQsZD10aGlzLmJ1dHRvbkdyb3VwLGU9XG50aGlzLm9wdGlvbnMuYnV0dG9uUG9zaXRpb24sZj1jLnBsb3RMZWZ0LWMuc3BhY2luZ1szXSxnPWUueC1jLnNwYWNpbmdbM107XCJyaWdodFwiPT09ZS5hbGlnbj9nKz1hLWY6XCJjZW50ZXJcIj09PWUuYWxpZ24mJihnLT1mLzIpO2QmJmQuYWxpZ24oe3k6ZS55LHdpZHRoOkkoYix0aGlzLmluaXRpYWxCdXR0b25Hcm91cFdpZHRoKSxhbGlnbjplLmFsaWduLHg6Z30sITAsYy5zcGFjaW5nQm94KX07bS5wcm90b3R5cGUucG9zaXRpb25CdXR0b25zPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5idXR0b25zLGI9dGhpcy5jaGFydCxjPXRoaXMub3B0aW9ucyxkPXRoaXMuem9vbVRleHQsZT1iLmhhc0xvYWRlZD9cImFuaW1hdGVcIjpcImF0dHJcIixmPWMuYnV0dG9uUG9zaXRpb24sZz1iLnBsb3RMZWZ0LGg9ZztkJiZcImhpZGRlblwiIT09ZC52aXNpYmlsaXR5JiYoZFtlXSh7eDpJKGcrZi54LGcpfSksaCs9Zi54K2QuZ2V0QkJveCgpLndpZHRoKzUpO3RoaXMuYnV0dG9uT3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGIsXG5kKXtpZihcImhpZGRlblwiIT09YVtkXS52aXNpYmlsaXR5KWFbZF1bZV0oe3g6aH0pLGgrPWFbZF0ud2lkdGgrYy5idXR0b25TcGFjaW5nO2Vsc2UgYVtkXVtlXSh7eDpnfSl9KX07bS5wcm90b3R5cGUuaGFuZGxlQ29sbGlzaW9uPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz10aGlzLmNoYXJ0LGQ9dGhpcy5idXR0b25Hcm91cCxlPXRoaXMuaW5wdXRHcm91cCxmPXRoaXMub3B0aW9ucyxnPWYuYnV0dG9uUG9zaXRpb24saD1mLmRyb3Bkb3duLGs9Zi5pbnB1dFBvc2l0aW9uO2Y9ZnVuY3Rpb24oKXt2YXIgYT0wO2IuYnV0dG9ucy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2I9Yi5nZXRCQm94KCk7Yi53aWR0aD5hJiYoYT1iLndpZHRoKX0pO3JldHVybiBhfTt2YXIgbT1mdW5jdGlvbihiKXtpZihlJiZkKXt2YXIgYz1lLmFsaWduQXR0ci50cmFuc2xhdGVYK2UuYWxpZ25PcHRpb25zLngtYStlLmdldEJCb3goKS54KzIsbD1lLmFsaWduT3B0aW9ucy53aWR0aCxmPWQuYWxpZ25BdHRyLnRyYW5zbGF0ZVgrXG5kLmdldEJCb3goKS54O3JldHVybiBmK2I+YyYmYytsPmYmJmcueTxrLnkrZS5nZXRCQm94KCkuaGVpZ2h0fXJldHVybiExfSxuPWZ1bmN0aW9uKCl7ZSYmZCYmZS5hdHRyKHt0cmFuc2xhdGVYOmUuYWxpZ25BdHRyLnRyYW5zbGF0ZVgrKGMuYXhpc09mZnNldFsxXT49LWE/MDotYSksdHJhbnNsYXRlWTplLmFsaWduQXR0ci50cmFuc2xhdGVZK2QuZ2V0QkJveCgpLmhlaWdodCsxMH0pfTtpZihkKXtpZihcImFsd2F5c1wiPT09aCl7dGhpcy5jb2xsYXBzZUJ1dHRvbnMoYSk7bShmKCkpJiZuKCk7cmV0dXJufVwibmV2ZXJcIj09PWgmJnRoaXMuZXhwYW5kQnV0dG9ucygpfWUmJmQ/ay5hbGlnbj09PWcuYWxpZ258fG0odGhpcy5pbml0aWFsQnV0dG9uR3JvdXBXaWR0aCsyMCk/XCJyZXNwb25zaXZlXCI9PT1oPyh0aGlzLmNvbGxhcHNlQnV0dG9ucyhhKSxtKGYoKSkmJm4oKSk6bigpOlwicmVzcG9uc2l2ZVwiPT09aCYmdGhpcy5leHBhbmRCdXR0b25zKCk6ZCYmXCJyZXNwb25zaXZlXCI9PT1oJiYodGhpcy5pbml0aWFsQnV0dG9uR3JvdXBXaWR0aD5cbmMucGxvdFdpZHRoP3RoaXMuY29sbGFwc2VCdXR0b25zKGEpOnRoaXMuZXhwYW5kQnV0dG9ucygpKX07bS5wcm90b3R5cGUuY29sbGFwc2VCdXR0b25zPWZ1bmN0aW9uKGEpe3ZhciBiLGM9dGhpcy5idXR0b25zLGQ9dGhpcy5idXR0b25PcHRpb25zLGU9dGhpcy5kcm9wZG93bixmPXRoaXMub3B0aW9ucyxnPXRoaXMuem9vbVRleHQsaD1mdW5jdGlvbihhKXtyZXR1cm57dGV4dDphP2ErXCIgXFx1MjViZVwiOlwiXFx1MjViZVwiLHdpZHRoOlwiYXV0b1wiLHBhZGRpbmdMZWZ0OjgscGFkZGluZ1JpZ2h0Ojh9fTtnJiZnLmhpZGUoKTt2YXIgaz0hMTtkLmZvckVhY2goZnVuY3Rpb24oYSxiKXtiPWNbYl07MiE9PWIuc3RhdGU/Yi5oaWRlKCk6KGIuc2hvdygpLGIuYXR0cihoKGEudGV4dCkpLGs9ITApfSk7a3x8KGUmJihlLnNlbGVjdGVkSW5kZXg9MCksY1swXS5zaG93KCksY1swXS5hdHRyKGgobnVsbD09PShiPXRoaXMuem9vbVRleHQpfHx2b2lkIDA9PT1iP3ZvaWQgMDpiLnRleHRTdHIpKSk7Yj1mLmJ1dHRvblBvc2l0aW9uLmFsaWduO1xudGhpcy5wb3NpdGlvbkJ1dHRvbnMoKTtcInJpZ2h0XCIhPT1iJiZcImNlbnRlclwiIT09Ynx8dGhpcy5hbGlnbkJ1dHRvbkdyb3VwKGEsY1t0aGlzLmN1cnJlbnRCdXR0b25JbmRleCgpXS5nZXRCQm94KCkud2lkdGgpO3RoaXMuc2hvd0Ryb3Bkb3duKCl9O20ucHJvdG90eXBlLmV4cGFuZEJ1dHRvbnM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmJ1dHRvbnMsYj10aGlzLmJ1dHRvbk9wdGlvbnMsYz10aGlzLm9wdGlvbnMsZD10aGlzLnpvb21UZXh0O3RoaXMuaGlkZURyb3Bkb3duKCk7ZCYmZC5zaG93KCk7Yi5mb3JFYWNoKGZ1bmN0aW9uKGIsZCl7ZD1hW2RdO2Quc2hvdygpO2QuYXR0cih7dGV4dDpiLnRleHQsd2lkdGg6Yy5idXR0b25UaGVtZS53aWR0aHx8MjgscGFkZGluZ0xlZnQ6XCJ1bnNldFwiLHBhZGRpbmdSaWdodDpcInVuc2V0XCJ9KTsyPmQuc3RhdGUmJmQuc2V0U3RhdGUoMCl9KTt0aGlzLnBvc2l0aW9uQnV0dG9ucygpfTttLnByb3RvdHlwZS5jdXJyZW50QnV0dG9uSW5kZXg9ZnVuY3Rpb24oKXt2YXIgYT1cbnRoaXMuZHJvcGRvd247cmV0dXJuIGEmJjA8YS5zZWxlY3RlZEluZGV4P2Euc2VsZWN0ZWRJbmRleC0xOjB9O20ucHJvdG90eXBlLnNob3dEcm9wZG93bj1mdW5jdGlvbigpe3ZhciBhPXRoaXMuYnV0dG9uR3JvdXAsYj10aGlzLmJ1dHRvbnMsZD10aGlzLmNoYXJ0LGM9dGhpcy5kcm9wZG93bjtpZihhJiZjKXt2YXIgZT1hLnRyYW5zbGF0ZVg7YT1hLnRyYW5zbGF0ZVk7Yj1iW3RoaXMuY3VycmVudEJ1dHRvbkluZGV4KCldLmdldEJCb3goKTtrKGMse2xlZnQ6ZC5wbG90TGVmdCtlK1wicHhcIix0b3A6YSsuNStcInB4XCIsd2lkdGg6Yi53aWR0aCtcInB4XCIsaGVpZ2h0OmIuaGVpZ2h0K1wicHhcIn0pO3RoaXMuaGFzVmlzaWJsZURyb3Bkb3duPSEwfX07bS5wcm90b3R5cGUuaGlkZURyb3Bkb3duPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5kcm9wZG93bjthJiYoayhhLHt0b3A6XCItOTk5OWVtXCIsd2lkdGg6XCIxcHhcIixoZWlnaHQ6XCIxcHhcIn0pLHRoaXMuaGFzVmlzaWJsZURyb3Bkb3duPSExKX07bS5wcm90b3R5cGUuZ2V0SGVpZ2h0PVxuZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnMsYj10aGlzLmdyb3VwLGQ9YS55LGM9YS5idXR0b25Qb3NpdGlvbi55LGU9YS5pbnB1dFBvc2l0aW9uLnk7aWYoYS5oZWlnaHQpcmV0dXJuIGEuaGVpZ2h0O3RoaXMuYWxpZ25FbGVtZW50cygpO2E9Yj9iLmdldEJCb3goITApLmhlaWdodCsxMytkOjA7Yj1NYXRoLm1pbihlLGMpO2lmKDA+ZSYmMD5jfHwwPGUmJjA8YylhKz1NYXRoLmFicyhiKTtyZXR1cm4gYX07bS5wcm90b3R5cGUudGl0bGVDb2xsaXNpb249ZnVuY3Rpb24oYSl7cmV0dXJuIShhLm9wdGlvbnMudGl0bGUudGV4dHx8YS5vcHRpb25zLnN1YnRpdGxlLnRleHQpfTttLnByb3RvdHlwZS51cGRhdGU9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5jaGFydDtkKCEwLGIub3B0aW9ucy5yYW5nZVNlbGVjdG9yLGEpO3RoaXMuZGVzdHJveSgpO3RoaXMuaW5pdChiKTt0aGlzLnJlbmRlcigpfTttLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxjPWEubWluSW5wdXQsXG5kPWEubWF4SW5wdXQ7YS5ldmVudHNUb1VuYmluZCYmKGEuZXZlbnRzVG9VbmJpbmQuZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYSgpfSksYS5ldmVudHNUb1VuYmluZD12b2lkIDApO3YoYS5idXR0b25zKTtjJiYoYy5vbmZvY3VzPWMub25ibHVyPWMub25jaGFuZ2U9bnVsbCk7ZCYmKGQub25mb2N1cz1kLm9uYmx1cj1kLm9uY2hhbmdlPW51bGwpO2IoYSxmdW5jdGlvbihiLGMpe2ImJlwiY2hhcnRcIiE9PWMmJihiIGluc3RhbmNlb2YgaD9iLmRlc3Ryb3koKTpiIGluc3RhbmNlb2Ygd2luZG93LkhUTUxFbGVtZW50JiZlKGIpKTtiIT09bS5wcm90b3R5cGVbY10mJihhW2NdPW51bGwpfSx0aGlzKX07cmV0dXJuIG19KCk7SC5wcm90b3R5cGUuZGVmYXVsdEJ1dHRvbnM9W3t0eXBlOlwibW9udGhcIixjb3VudDoxLHRleHQ6XCIxbVwiLHRpdGxlOlwiVmlldyAxIG1vbnRoXCJ9LHt0eXBlOlwibW9udGhcIixjb3VudDozLHRleHQ6XCIzbVwiLHRpdGxlOlwiVmlldyAzIG1vbnRoc1wifSx7dHlwZTpcIm1vbnRoXCIsXG5jb3VudDo2LHRleHQ6XCI2bVwiLHRpdGxlOlwiVmlldyA2IG1vbnRoc1wifSx7dHlwZTpcInl0ZFwiLHRleHQ6XCJZVERcIix0aXRsZTpcIlZpZXcgeWVhciB0byBkYXRlXCJ9LHt0eXBlOlwieWVhclwiLGNvdW50OjEsdGV4dDpcIjF5XCIsdGl0bGU6XCJWaWV3IDEgeWVhclwifSx7dHlwZTpcImFsbFwiLHRleHQ6XCJBbGxcIix0aXRsZTpcIlZpZXcgYWxsXCJ9XTtILnByb3RvdHlwZS5pbnB1dFR5cGVGb3JtYXRzPXtcImRhdGV0aW1lLWxvY2FsXCI6XCIlWS0lbS0lZFQlSDolTTolU1wiLGRhdGU6XCIlWS0lbS0lZFwiLHRpbWU6XCIlSDolTTolU1wifTthLnByb3RvdHlwZS5taW5Gcm9tUmFuZ2U9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLnJhbmdlLGI9YS50eXBlLGQ9dGhpcy5tYXgsZT10aGlzLmNoYXJ0LnRpbWUsZj1mdW5jdGlvbihhLGQpe3ZhciBjPVwieWVhclwiPT09Yj9cIkZ1bGxZZWFyXCI6XCJNb250aFwiLGw9bmV3IGUuRGF0ZShhKSxmPWUuZ2V0KGMsbCk7ZS5zZXQoYyxsLGYrZCk7Zj09PWUuZ2V0KGMsbCkmJmUuc2V0KFwiRGF0ZVwiLFxubCwwKTtyZXR1cm4gbC5nZXRUaW1lKCktYX07aWYoYyhhKSl7dmFyIGc9ZC1hO3ZhciBoPWF9ZWxzZSBnPWQrZihkLC1hLmNvdW50KSx0aGlzLmNoYXJ0JiYodGhpcy5jaGFydC5maXhlZFJhbmdlPWQtZyk7dmFyIGs9SSh0aGlzLmRhdGFNaW4sTnVtYmVyLk1JTl9WQUxVRSk7YyhnKXx8KGc9ayk7Zzw9ayYmKGc9ayxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGgmJihoPWYoZyxhLmNvdW50KSksdGhpcy5uZXdNYXg9TWF0aC5taW4oZytoLHRoaXMuZGF0YU1heCkpO2MoZCl8fChnPXZvaWQgMCk7cmV0dXJuIGd9O2lmKCF0LlJhbmdlU2VsZWN0b3Ipe3ZhciBDPVtdLE09ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYigpe2wmJihlPWEueEF4aXNbMF0uZ2V0RXh0cmVtZXMoKSxmPWEubGVnZW5kLGg9bnVsbD09PWx8fHZvaWQgMD09PWw/dm9pZCAwOmwub3B0aW9ucy52ZXJ0aWNhbEFsaWduLGMoZS5taW4pJiZsLnJlbmRlcihlLm1pbixlLm1heCksZi5kaXNwbGF5JiZcInRvcFwiPT09aCYmaD09PWYub3B0aW9ucy52ZXJ0aWNhbEFsaWduJiZcbihnPWQoYS5zcGFjaW5nQm94KSxnLnk9XCJ2ZXJ0aWNhbFwiPT09Zi5vcHRpb25zLmxheW91dD9hLnBsb3RUb3A6Zy55K2wuZ2V0SGVpZ2h0KCksZi5ncm91cC5wbGFjZWQ9ITEsZi5hbGlnbihnKSkpfXZhciBlLGw9YS5yYW5nZVNlbGVjdG9yLGYsZyxoO2wmJihtKEMsZnVuY3Rpb24oYil7cmV0dXJuIGJbMF09PT1hfSl8fEMucHVzaChbYSxbcChhLnhBeGlzWzBdLFwiYWZ0ZXJTZXRFeHRyZW1lc1wiLGZ1bmN0aW9uKGEpe2wmJmwucmVuZGVyKGEubWluLGEubWF4KX0pLHAoYSxcInJlZHJhd1wiLGIpXV0pLGIoKSl9O3AodSxcImFmdGVyR2V0Q29udGFpbmVyXCIsZnVuY3Rpb24oKXt2YXIgYTtpZihudWxsPT09KGE9dGhpcy5vcHRpb25zLnJhbmdlU2VsZWN0b3IpfHx2b2lkIDA9PT1hPzA6YS5lbmFibGVkKXRoaXMucmFuZ2VTZWxlY3Rvcj1uZXcgSCh0aGlzKX0pO3AodSxcImJlZm9yZVJlbmRlclwiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5heGVzLGI9dGhpcy5yYW5nZVNlbGVjdG9yO2ImJihjKGIuZGVmZXJyZWRZVERDbGljaykmJlxuKGIuY2xpY2tCdXR0b24oYi5kZWZlcnJlZFlURENsaWNrKSxkZWxldGUgYi5kZWZlcnJlZFlURENsaWNrKSxhLmZvckVhY2goZnVuY3Rpb24oYSl7YS51cGRhdGVOYW1lcygpO2Euc2V0U2NhbGUoKX0pLHRoaXMuZ2V0QXhpc01hcmdpbnMoKSxiLnJlbmRlcigpLGE9Yi5vcHRpb25zLnZlcnRpY2FsQWxpZ24sYi5vcHRpb25zLmZsb2F0aW5nfHwoXCJib3R0b21cIj09PWE/dGhpcy5leHRyYUJvdHRvbU1hcmdpbj0hMDpcIm1pZGRsZVwiIT09YSYmKHRoaXMuZXh0cmFUb3BNYXJnaW49ITApKSl9KTtwKHUsXCJ1cGRhdGVcIixmdW5jdGlvbihhKXt2YXIgYj1hLm9wdGlvbnMucmFuZ2VTZWxlY3RvcjthPXRoaXMucmFuZ2VTZWxlY3Rvcjt2YXIgYz10aGlzLmV4dHJhQm90dG9tTWFyZ2luLGQ9dGhpcy5leHRyYVRvcE1hcmdpbjtiJiZiLmVuYWJsZWQmJiFmKGEpJiZ0aGlzLm9wdGlvbnMucmFuZ2VTZWxlY3RvciYmKHRoaXMub3B0aW9ucy5yYW5nZVNlbGVjdG9yLmVuYWJsZWQ9ITAsdGhpcy5yYW5nZVNlbGVjdG9yPVxuYT1uZXcgSCh0aGlzKSk7dGhpcy5leHRyYVRvcE1hcmdpbj10aGlzLmV4dHJhQm90dG9tTWFyZ2luPSExO2EmJihNKHRoaXMpLGI9YiYmYi52ZXJ0aWNhbEFsaWdufHxhLm9wdGlvbnMmJmEub3B0aW9ucy52ZXJ0aWNhbEFsaWduLGEub3B0aW9ucy5mbG9hdGluZ3x8KFwiYm90dG9tXCI9PT1iP3RoaXMuZXh0cmFCb3R0b21NYXJnaW49ITA6XCJtaWRkbGVcIiE9PWImJih0aGlzLmV4dHJhVG9wTWFyZ2luPSEwKSksdGhpcy5leHRyYUJvdHRvbU1hcmdpbiE9PWN8fHRoaXMuZXh0cmFUb3BNYXJnaW4hPT1kKSYmKHRoaXMuaXNEaXJ0eUJveD0hMCl9KTtwKHUsXCJyZW5kZXJcIixmdW5jdGlvbigpe3ZhciBhPXRoaXMucmFuZ2VTZWxlY3RvcjthJiYhYS5vcHRpb25zLmZsb2F0aW5nJiYoYS5yZW5kZXIoKSxhPWEub3B0aW9ucy52ZXJ0aWNhbEFsaWduLFwiYm90dG9tXCI9PT1hP3RoaXMuZXh0cmFCb3R0b21NYXJnaW49ITA6XCJtaWRkbGVcIiE9PWEmJih0aGlzLmV4dHJhVG9wTWFyZ2luPSEwKSl9KTtwKHUsXG5cImdldE1hcmdpbnNcIixmdW5jdGlvbigpe3ZhciBhPXRoaXMucmFuZ2VTZWxlY3RvcjthJiYoYT1hLmdldEhlaWdodCgpLHRoaXMuZXh0cmFUb3BNYXJnaW4mJih0aGlzLnBsb3RUb3ArPWEpLHRoaXMuZXh0cmFCb3R0b21NYXJnaW4mJih0aGlzLm1hcmdpbkJvdHRvbSs9YSkpfSk7dS5wcm90b3R5cGUuY2FsbGJhY2tzLnB1c2goTSk7cCh1LFwiZGVzdHJveVwiLGZ1bmN0aW9uKCl7Zm9yKHZhciBhPTA7YTxDLmxlbmd0aDthKyspe3ZhciBiPUNbYV07aWYoYlswXT09PXRoaXMpe2JbMV0uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYSgpfSk7Qy5zcGxpY2UoYSwxKTticmVha319fSk7dC5SYW5nZVNlbGVjdG9yPUh9cmV0dXJuIHQuUmFuZ2VTZWxlY3Rvcn0pO0YoYSxcIkNvcmUvQXhpcy9OYXZpZ2F0b3JBeGlzLmpzXCIsW2FbXCJDb3JlL0dsb2JhbHMuanNcIl0sYVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihhLHUpe3ZhciB0PWEuaXNUb3VjaERldmljZSxyPXUuYWRkRXZlbnQsXG5uPXUuY29ycmVjdEZsb2F0LGg9dS5kZWZpbmVkLEE9dS5pc051bWJlcixCPXUucGljayxEPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXt0aGlzLmF4aXM9YX1hLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7dGhpcy5heGlzPXZvaWQgMH07YS5wcm90b3R5cGUudG9GaXhlZFJhbmdlPWZ1bmN0aW9uKGEsayxmLHApe3ZhciBlPXRoaXMuYXhpcyxnPWUuY2hhcnQ7Zz1nJiZnLmZpeGVkUmFuZ2U7dmFyIG09KGUucG9pbnRSYW5nZXx8MCkvMjthPUIoZixlLnRyYW5zbGF0ZShhLCEwLCFlLmhvcml6KSk7az1CKHAsZS50cmFuc2xhdGUoaywhMCwhZS5ob3JpeikpO2U9ZyYmKGstYSkvZztoKGYpfHwoYT1uKGErbSkpO2gocCl8fChrPW4oay1tKSk7Ljc8ZSYmMS4zPmUmJihwP2E9ay1nOms9YStnKTtBKGEpJiZBKGspfHwoYT1rPXZvaWQgMCk7cmV0dXJue21pbjphLG1heDprfX07cmV0dXJuIGF9KCk7cmV0dXJuIGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe31hLmNvbXBvc2U9ZnVuY3Rpb24oYSl7YS5rZWVwUHJvcHMucHVzaChcIm5hdmlnYXRvckF4aXNcIik7XG5yKGEsXCJpbml0XCIsZnVuY3Rpb24oKXt0aGlzLm5hdmlnYXRvckF4aXN8fCh0aGlzLm5hdmlnYXRvckF4aXM9bmV3IEQodGhpcykpfSk7cihhLFwiem9vbVwiLGZ1bmN0aW9uKGEpe3ZhciBmPXRoaXMuY2hhcnQub3B0aW9ucyxrPWYubmF2aWdhdG9yLGU9dGhpcy5uYXZpZ2F0b3JBeGlzLGc9Zi5jaGFydC5waW5jaFR5cGUsbT1mLnJhbmdlU2VsZWN0b3I7Zj1mLmNoYXJ0Lnpvb21UeXBlO3RoaXMuaXNYQXhpcyYmKGsmJmsuZW5hYmxlZHx8bSYmbS5lbmFibGVkKSYmKFwieVwiPT09Zj9hLnpvb21lZD0hMTooIXQmJlwieHlcIj09PWZ8fHQmJlwieHlcIj09PWcpJiZ0aGlzLm9wdGlvbnMucmFuZ2UmJihrPWUucHJldmlvdXNab29tLGgoYS5uZXdNaW4pP2UucHJldmlvdXNab29tPVt0aGlzLm1pbix0aGlzLm1heF06ayYmKGEubmV3TWluPWtbMF0sYS5uZXdNYXg9a1sxXSxlLnByZXZpb3VzWm9vbT12b2lkIDApKSk7XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBhLnpvb21lZCYmYS5wcmV2ZW50RGVmYXVsdCgpfSl9O1xuYS5BZGRpdGlvbnNDbGFzcz1EO3JldHVybiBhfSgpfSk7RihhLFwiQ29yZS9OYXZpZ2F0b3IuanNcIixbYVtcIkNvcmUvQXhpcy9BeGlzLmpzXCJdLGFbXCJDb3JlL0NoYXJ0L0NoYXJ0LmpzXCJdLGFbXCJDb3JlL0NvbG9yL0NvbG9yLmpzXCJdLGFbXCJDb3JlL0dsb2JhbHMuanNcIl0sYVtcIkNvcmUvQXhpcy9OYXZpZ2F0b3JBeGlzLmpzXCJdLGFbXCJDb3JlL09wdGlvbnMuanNcIl0sYVtcIkNvcmUvQ29sb3IvUGFsZXR0ZS5qc1wiXSxhW1wiQ29yZS9TY3JvbGxiYXIuanNcIl0sYVtcIkNvcmUvU2VyaWVzL1Nlcmllcy5qc1wiXSxhW1wiQ29yZS9TZXJpZXMvU2VyaWVzUmVnaXN0cnkuanNcIl0sYVtcIkNvcmUvVXRpbGl0aWVzLmpzXCJdXSxmdW5jdGlvbihhLHUsdCxyLG4saCxBLEIsRCxwLHcpe3Q9dC5wYXJzZTt2YXIgaz1yLmhhc1RvdWNoLGY9ci5pc1RvdWNoRGV2aWNlLHY9aC5kZWZhdWx0T3B0aW9ucyxlPXcuYWRkRXZlbnQsZz13LmNsYW1wLG09dy5jb3JyZWN0RmxvYXQscT13LmRlZmluZWQsYz13LmRlc3Ryb3lPYmplY3RQcm9wZXJ0aWVzLFxuZD13LmVyYXNlLGI9dy5leHRlbmQsRj13LmZpbmQsST13LmlzQXJyYXksSz13LmlzTnVtYmVyLEw9dy5tZXJnZSxIPXcucGljayxDPXcucmVtb3ZlRXZlbnQsTT13LnNwbGF0LEU9ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVtdLGM9MTtjPGFyZ3VtZW50cy5sZW5ndGg7YysrKWJbYy0xXT1hcmd1bWVudHNbY107Yj1bXS5maWx0ZXIuY2FsbChiLEspO2lmKGIubGVuZ3RoKXJldHVybiBNYXRoW2FdLmFwcGx5KDAsYil9O2g9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBwLnNlcmllc1R5cGVzLmFyZWFzcGxpbmU/XCJsaW5lXCI6XCJhcmVhc3BsaW5lXCI7Yih2LHtuYXZpZ2F0b3I6e2hlaWdodDo0MCxtYXJnaW46MjUsbWFza0luc2lkZTohMCxoYW5kbGVzOnt3aWR0aDo3LGhlaWdodDoxNSxzeW1ib2xzOltcIm5hdmlnYXRvci1oYW5kbGVcIixcIm5hdmlnYXRvci1oYW5kbGVcIl0sZW5hYmxlZDohMCxsaW5lV2lkdGg6MSxiYWNrZ3JvdW5kQ29sb3I6QS5uZXV0cmFsQ29sb3I1LGJvcmRlckNvbG9yOkEubmV1dHJhbENvbG9yNDB9LFxubWFza0ZpbGw6dChBLmhpZ2hsaWdodENvbG9yNjApLnNldE9wYWNpdHkoLjMpLmdldCgpLG91dGxpbmVDb2xvcjpBLm5ldXRyYWxDb2xvcjIwLG91dGxpbmVXaWR0aDoxLHNlcmllczp7dHlwZTpoLGZpbGxPcGFjaXR5Oi4wNSxsaW5lV2lkdGg6MSxjb21wYXJlOm51bGwsZGF0YUdyb3VwaW5nOnthcHByb3hpbWF0aW9uOlwiYXZlcmFnZVwiLGVuYWJsZWQ6ITAsZ3JvdXBQaXhlbFdpZHRoOjIsc21vb3RoZWQ6ITAsdW5pdHM6W1tcIm1pbGxpc2Vjb25kXCIsWzEsMiw1LDEwLDIwLDI1LDUwLDEwMCwyMDAsNTAwXV0sW1wic2Vjb25kXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wibWludXRlXCIsWzEsMiw1LDEwLDE1LDMwXV0sW1wiaG91clwiLFsxLDIsMyw0LDYsOCwxMl1dLFtcImRheVwiLFsxLDIsMyw0XV0sW1wid2Vla1wiLFsxLDIsM11dLFtcIm1vbnRoXCIsWzEsMyw2XV0sW1wieWVhclwiLG51bGxdXX0sZGF0YUxhYmVsczp7ZW5hYmxlZDohMSx6SW5kZXg6Mn0saWQ6XCJoaWdoY2hhcnRzLW5hdmlnYXRvci1zZXJpZXNcIixcbmNsYXNzTmFtZTpcImhpZ2hjaGFydHMtbmF2aWdhdG9yLXNlcmllc1wiLGxpbmVDb2xvcjpudWxsLG1hcmtlcjp7ZW5hYmxlZDohMX0sdGhyZXNob2xkOm51bGx9LHhBeGlzOntvdmVyc2Nyb2xsOjAsY2xhc3NOYW1lOlwiaGlnaGNoYXJ0cy1uYXZpZ2F0b3IteGF4aXNcIix0aWNrTGVuZ3RoOjAsbGluZVdpZHRoOjAsZ3JpZExpbmVDb2xvcjpBLm5ldXRyYWxDb2xvcjEwLGdyaWRMaW5lV2lkdGg6MSx0aWNrUGl4ZWxJbnRlcnZhbDoyMDAsbGFiZWxzOnthbGlnbjpcImxlZnRcIixzdHlsZTp7Y29sb3I6QS5uZXV0cmFsQ29sb3I0MH0seDozLHk6LTR9LGNyb3NzaGFpcjohMX0seUF4aXM6e2NsYXNzTmFtZTpcImhpZ2hjaGFydHMtbmF2aWdhdG9yLXlheGlzXCIsZ3JpZExpbmVXaWR0aDowLHN0YXJ0T25UaWNrOiExLGVuZE9uVGljazohMSxtaW5QYWRkaW5nOi4xLG1heFBhZGRpbmc6LjEsbGFiZWxzOntlbmFibGVkOiExfSxjcm9zc2hhaXI6ITEsdGl0bGU6e3RleHQ6bnVsbH0sdGlja0xlbmd0aDowLFxudGlja1dpZHRoOjB9fX0pO3IuUmVuZGVyZXIucHJvdG90eXBlLnN5bWJvbHNbXCJuYXZpZ2F0b3ItaGFuZGxlXCJdPWZ1bmN0aW9uKGEsYixjLGQsZSl7YT0oZSYmZS53aWR0aHx8MCkvMjtiPU1hdGgucm91bmQoYS8zKSsuNTtlPWUmJmUuaGVpZ2h0fHwwO3JldHVybltbXCJNXCIsLWEtMSwuNV0sW1wiTFwiLGEsLjVdLFtcIkxcIixhLGUrLjVdLFtcIkxcIiwtYS0xLGUrLjVdLFtcIkxcIiwtYS0xLC41XSxbXCJNXCIsLWIsNF0sW1wiTFwiLC1iLGUtM10sW1wiTVwiLGItMSw0XSxbXCJMXCIsYi0xLGUtM11dfTt2YXIgeT1mdW5jdGlvbigpe2Z1bmN0aW9uIGgoYSl7dGhpcy56b29tZWRNaW49dGhpcy56b29tZWRNYXg9dGhpcy55QXhpcz10aGlzLnhBeGlzPXRoaXMudG9wPXRoaXMuc2l6ZT10aGlzLnNoYWRlcz10aGlzLnJlbmRlcmVkPXRoaXMucmFuZ2U9dGhpcy5vdXRsaW5lSGVpZ2h0PXRoaXMub3V0bGluZT10aGlzLm9wcG9zaXRlPXRoaXMubmF2aWdhdG9yU2l6ZT10aGlzLm5hdmlnYXRvclNlcmllcz10aGlzLm5hdmlnYXRvck9wdGlvbnM9XG50aGlzLm5hdmlnYXRvckdyb3VwPXRoaXMubmF2aWdhdG9yRW5hYmxlZD10aGlzLmxlZnQ9dGhpcy5oZWlnaHQ9dGhpcy5oYW5kbGVzPXRoaXMuY2hhcnQ9dGhpcy5iYXNlU2VyaWVzPXZvaWQgMDt0aGlzLmluaXQoYSl9aC5wcm90b3R5cGUuZHJhd0hhbmRsZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLm5hdmlnYXRvck9wdGlvbnMuaGFuZGxlcy5oZWlnaHQ7dGhpcy5oYW5kbGVzW2JdW2RdKGM/e3RyYW5zbGF0ZVg6TWF0aC5yb3VuZCh0aGlzLmxlZnQrdGhpcy5oZWlnaHQvMiksdHJhbnNsYXRlWTpNYXRoLnJvdW5kKHRoaXMudG9wK3BhcnNlSW50KGEsMTApKy41LWUpfTp7dHJhbnNsYXRlWDpNYXRoLnJvdW5kKHRoaXMubGVmdCtwYXJzZUludChhLDEwKSksdHJhbnNsYXRlWTpNYXRoLnJvdW5kKHRoaXMudG9wK3RoaXMuaGVpZ2h0LzItZS8yLTEpfSl9O2gucHJvdG90eXBlLmRyYXdPdXRsaW5lPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMubmF2aWdhdG9yT3B0aW9ucy5tYXNrSW5zaWRlLFxubD10aGlzLm91dGxpbmUuc3Ryb2tlV2lkdGgoKSxmPWwvMixnPWwlMi8yO2w9dGhpcy5vdXRsaW5lSGVpZ2h0O3ZhciBoPXRoaXMuc2Nyb2xsYmFySGVpZ2h0fHwwLGs9dGhpcy5zaXplLG09dGhpcy5sZWZ0LWgseD10aGlzLnRvcDtjPyhtLT1mLGM9eCtiK2csYj14K2ErZyxnPVtbXCJNXCIsbStsLHgtaC1nXSxbXCJMXCIsbStsLGNdLFtcIkxcIixtLGNdLFtcIkxcIixtLGJdLFtcIkxcIixtK2wsYl0sW1wiTFwiLG0rbCx4K2sraF1dLGUmJmcucHVzaChbXCJNXCIsbStsLGMtZl0sW1wiTFwiLG0rbCxiK2ZdKSk6KGErPW0raC1nLGIrPW0raC1nLHgrPWYsZz1bW1wiTVwiLG0seF0sW1wiTFwiLGEseF0sW1wiTFwiLGEseCtsXSxbXCJMXCIsYix4K2xdLFtcIkxcIixiLHhdLFtcIkxcIixtK2srMipoLHhdXSxlJiZnLnB1c2goW1wiTVwiLGEtZix4XSxbXCJMXCIsYitmLHhdKSk7dGhpcy5vdXRsaW5lW2RdKHtkOmd9KX07aC5wcm90b3R5cGUuZHJhd01hc2tzPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMubGVmdCxsPXRoaXMudG9wLGY9XG50aGlzLmhlaWdodDtpZihjKXt2YXIgZz1bZSxlLGVdO3ZhciBoPVtsLGwrYSxsK2JdO3ZhciBrPVtmLGYsZl07dmFyIG09W2EsYi1hLHRoaXMuc2l6ZS1iXX1lbHNlIGc9W2UsZSthLGUrYl0saD1bbCxsLGxdLGs9W2EsYi1hLHRoaXMuc2l6ZS1iXSxtPVtmLGYsZl07dGhpcy5zaGFkZXMuZm9yRWFjaChmdW5jdGlvbihhLGIpe2FbZF0oe3g6Z1tiXSx5OmhbYl0sd2lkdGg6a1tiXSxoZWlnaHQ6bVtiXX0pfSl9O2gucHJvdG90eXBlLnJlbmRlckVsZW1lbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWEubmF2aWdhdG9yT3B0aW9ucyxjPWIubWFza0luc2lkZSxkPWEuY2hhcnQsZT1kLnJlbmRlcmVyLGYsZz17Y3Vyc29yOmQuaW52ZXJ0ZWQ/XCJucy1yZXNpemVcIjpcImV3LXJlc2l6ZVwifTthLm5hdmlnYXRvckdyb3VwPWY9ZS5nKFwibmF2aWdhdG9yXCIpLmF0dHIoe3pJbmRleDo4LHZpc2liaWxpdHk6XCJoaWRkZW5cIn0pLmFkZCgpO1shYyxjLCFjXS5mb3JFYWNoKGZ1bmN0aW9uKGMsbCl7YS5zaGFkZXNbbF09XG5lLnJlY3QoKS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbmF2aWdhdG9yLW1hc2tcIisoMT09PWw/XCItaW5zaWRlXCI6XCItb3V0c2lkZVwiKSkuYWRkKGYpO2Quc3R5bGVkTW9kZXx8YS5zaGFkZXNbbF0uYXR0cih7ZmlsbDpjP2IubWFza0ZpbGw6XCJyZ2JhKDAsMCwwLDApXCJ9KS5jc3MoMT09PWwmJmcpfSk7YS5vdXRsaW5lPWUucGF0aCgpLmFkZENsYXNzKFwiaGlnaGNoYXJ0cy1uYXZpZ2F0b3Itb3V0bGluZVwiKS5hZGQoZik7ZC5zdHlsZWRNb2RlfHxhLm91dGxpbmUuYXR0cih7XCJzdHJva2Utd2lkdGhcIjpiLm91dGxpbmVXaWR0aCxzdHJva2U6Yi5vdXRsaW5lQ29sb3J9KTtiLmhhbmRsZXMuZW5hYmxlZCYmWzAsMV0uZm9yRWFjaChmdW5jdGlvbihjKXtiLmhhbmRsZXMuaW52ZXJ0ZWQ9ZC5pbnZlcnRlZDthLmhhbmRsZXNbY109ZS5zeW1ib2woYi5oYW5kbGVzLnN5bWJvbHNbY10sLWIuaGFuZGxlcy53aWR0aC8yLTEsMCxiLmhhbmRsZXMud2lkdGgsYi5oYW5kbGVzLmhlaWdodCxiLmhhbmRsZXMpO1xuYS5oYW5kbGVzW2NdLmF0dHIoe3pJbmRleDo3LWN9KS5hZGRDbGFzcyhcImhpZ2hjaGFydHMtbmF2aWdhdG9yLWhhbmRsZSBoaWdoY2hhcnRzLW5hdmlnYXRvci1oYW5kbGUtXCIrW1wibGVmdFwiLFwicmlnaHRcIl1bY10pLmFkZChmKTtpZighZC5zdHlsZWRNb2RlKXt2YXIgbD1iLmhhbmRsZXM7YS5oYW5kbGVzW2NdLmF0dHIoe2ZpbGw6bC5iYWNrZ3JvdW5kQ29sb3Isc3Ryb2tlOmwuYm9yZGVyQ29sb3IsXCJzdHJva2Utd2lkdGhcIjpsLmxpbmVXaWR0aH0pLmNzcyhnKX19KX07aC5wcm90b3R5cGUudXBkYXRlPWZ1bmN0aW9uKGEpeyh0aGlzLnNlcmllc3x8W10pLmZvckVhY2goZnVuY3Rpb24oYSl7YS5iYXNlU2VyaWVzJiZkZWxldGUgYS5iYXNlU2VyaWVzLm5hdmlnYXRvclNlcmllc30pO3RoaXMuZGVzdHJveSgpO0woITAsdGhpcy5jaGFydC5vcHRpb25zLm5hdmlnYXRvcix0aGlzLm9wdGlvbnMsYSk7dGhpcy5pbml0KHRoaXMuY2hhcnQpfTtoLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSxcbmIsYyxkKXt2YXIgZT10aGlzLmNoYXJ0LGw9dGhpcy5zY3JvbGxiYXJIZWlnaHQsZixoPXRoaXMueEF4aXMsaz1oLnBvaW50UmFuZ2V8fDA7dmFyIHg9aC5uYXZpZ2F0b3JBeGlzLmZha2U/ZS54QXhpc1swXTpoO3ZhciBuPXRoaXMubmF2aWdhdG9yRW5hYmxlZCxwLHQ9dGhpcy5yZW5kZXJlZDt2YXIgcj1lLmludmVydGVkO3ZhciB1PWUueEF4aXNbMF0ubWluUmFuZ2Usdj1lLnhBeGlzWzBdLm9wdGlvbnMubWF4UmFuZ2U7aWYoIXRoaXMuaGFzRHJhZ2dlZHx8cShjKSl7YT1tKGEtay8yKTtiPW0oYitrLzIpO2lmKCFLKGEpfHwhSyhiKSlpZih0KWM9MCxkPUgoaC53aWR0aCx4LndpZHRoKTtlbHNlIHJldHVybjt0aGlzLmxlZnQ9SChoLmxlZnQsZS5wbG90TGVmdCtsKyhyP2UucGxvdFdpZHRoOjApKTt0aGlzLnNpemU9cD1mPUgoaC5sZW4sKHI/ZS5wbG90SGVpZ2h0OmUucGxvdFdpZHRoKS0yKmwpO2U9cj9sOmYrMipsO2M9SChjLGgudG9QaXhlbHMoYSwhMCkpO2Q9SChkLGgudG9QaXhlbHMoYixcbiEwKSk7SyhjKSYmSW5maW5pdHkhPT1NYXRoLmFicyhjKXx8KGM9MCxkPWUpO2E9aC50b1ZhbHVlKGMsITApO2I9aC50b1ZhbHVlKGQsITApO3ZhciBHPU1hdGguYWJzKG0oYi1hKSk7Rzx1P3RoaXMuZ3JhYmJlZExlZnQ/Yz1oLnRvUGl4ZWxzKGItdS1rLCEwKTp0aGlzLmdyYWJiZWRSaWdodCYmKGQ9aC50b1BpeGVscyhhK3UraywhMCkpOnEodikmJm0oRy1rKT52JiYodGhpcy5ncmFiYmVkTGVmdD9jPWgudG9QaXhlbHMoYi12LWssITApOnRoaXMuZ3JhYmJlZFJpZ2h0JiYoZD1oLnRvUGl4ZWxzKGErditrLCEwKSkpO3RoaXMuem9vbWVkTWF4PWcoTWF0aC5tYXgoYyxkKSwwLHApO3RoaXMuem9vbWVkTWluPWcodGhpcy5maXhlZFdpZHRoP3RoaXMuem9vbWVkTWF4LXRoaXMuZml4ZWRXaWR0aDpNYXRoLm1pbihjLGQpLDAscCk7dGhpcy5yYW5nZT10aGlzLnpvb21lZE1heC10aGlzLnpvb21lZE1pbjtwPU1hdGgucm91bmQodGhpcy56b29tZWRNYXgpO2M9TWF0aC5yb3VuZCh0aGlzLnpvb21lZE1pbik7XG5uJiYodGhpcy5uYXZpZ2F0b3JHcm91cC5hdHRyKHt2aXNpYmlsaXR5OlwidmlzaWJsZVwifSksdD10JiYhdGhpcy5oYXNEcmFnZ2VkP1wiYW5pbWF0ZVwiOlwiYXR0clwiLHRoaXMuZHJhd01hc2tzKGMscCxyLHQpLHRoaXMuZHJhd091dGxpbmUoYyxwLHIsdCksdGhpcy5uYXZpZ2F0b3JPcHRpb25zLmhhbmRsZXMuZW5hYmxlZCYmKHRoaXMuZHJhd0hhbmRsZShjLDAscix0KSx0aGlzLmRyYXdIYW5kbGUocCwxLHIsdCkpKTt0aGlzLnNjcm9sbGJhciYmKHI/KHI9dGhpcy50b3AtbCx4PXRoaXMubGVmdC1sKyhufHwheC5vcHBvc2l0ZT8wOih4LnRpdGxlT2Zmc2V0fHwwKSt4LmF4aXNUaXRsZU1hcmdpbiksbD1mKzIqbCk6KHI9dGhpcy50b3ArKG4/dGhpcy5oZWlnaHQ6LWwpLHg9dGhpcy5sZWZ0LWwpLHRoaXMuc2Nyb2xsYmFyLnBvc2l0aW9uKHgscixlLGwpLHRoaXMuc2Nyb2xsYmFyLnNldFJhbmdlKHRoaXMuem9vbWVkTWluLyhmfHwxKSx0aGlzLnpvb21lZE1heC8oZnx8MSkpKTt0aGlzLnJlbmRlcmVkPVxuITB9fTtoLnByb3RvdHlwZS5hZGRNb3VzZUV2ZW50cz1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1hLmNoYXJ0LGM9Yi5jb250YWluZXIsZD1bXSxmLGc7YS5tb3VzZU1vdmVIYW5kbGVyPWY9ZnVuY3Rpb24oYil7YS5vbk1vdXNlTW92ZShiKX07YS5tb3VzZVVwSGFuZGxlcj1nPWZ1bmN0aW9uKGIpe2Eub25Nb3VzZVVwKGIpfTtkPWEuZ2V0UGFydHNFdmVudHMoXCJtb3VzZWRvd25cIik7ZC5wdXNoKGUoYi5yZW5kZXJUbyxcIm1vdXNlbW92ZVwiLGYpLGUoYy5vd25lckRvY3VtZW50LFwibW91c2V1cFwiLGcpKTtrJiYoZC5wdXNoKGUoYi5yZW5kZXJUbyxcInRvdWNobW92ZVwiLGYpLGUoYy5vd25lckRvY3VtZW50LFwidG91Y2hlbmRcIixnKSksZC5jb25jYXQoYS5nZXRQYXJ0c0V2ZW50cyhcInRvdWNoc3RhcnRcIikpKTthLmV2ZW50c1RvVW5iaW5kPWQ7YS5zZXJpZXMmJmEuc2VyaWVzWzBdJiZkLnB1c2goZShhLnNlcmllc1swXS54QXhpcyxcImZvdW5kRXh0cmVtZXNcIixmdW5jdGlvbigpe2IubmF2aWdhdG9yLm1vZGlmeU5hdmlnYXRvckF4aXNFeHRyZW1lcygpfSkpfTtcbmgucHJvdG90eXBlLmdldFBhcnRzRXZlbnRzPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1bXTtbXCJzaGFkZXNcIixcImhhbmRsZXNcIl0uZm9yRWFjaChmdW5jdGlvbihkKXtiW2RdLmZvckVhY2goZnVuY3Rpb24obCxmKXtjLnB1c2goZShsLmVsZW1lbnQsYSxmdW5jdGlvbihhKXtiW2QrXCJNb3VzZWRvd25cIl0oYSxmKX0pKX0pfSk7cmV0dXJuIGN9O2gucHJvdG90eXBlLnNoYWRlc01vdXNlZG93bj1mdW5jdGlvbihhLGIpe2E9dGhpcy5jaGFydC5wb2ludGVyLm5vcm1hbGl6ZShhKTt2YXIgYz10aGlzLmNoYXJ0LGQ9dGhpcy54QXhpcyxlPXRoaXMuem9vbWVkTWluLGw9dGhpcy5sZWZ0LGY9dGhpcy5zaXplLGc9dGhpcy5yYW5nZSxoPWEuY2hhcnRYO2MuaW52ZXJ0ZWQmJihoPWEuY2hhcnRZLGw9dGhpcy50b3ApO2lmKDE9PT1iKXRoaXMuZ3JhYmJlZENlbnRlcj1oLHRoaXMuZml4ZWRXaWR0aD1nLHRoaXMuZHJhZ09mZnNldD1oLWU7ZWxzZXthPWgtbC1nLzI7aWYoMD09PWIpYT1NYXRoLm1heCgwLFxuYSk7ZWxzZSBpZigyPT09YiYmYStnPj1mKWlmKGE9Zi1nLHRoaXMucmV2ZXJzZWRFeHRyZW1lcyl7YS09Zzt2YXIgaz10aGlzLmdldFVuaW9uRXh0cmVtZXMoKS5kYXRhTWlufWVsc2UgdmFyIG09dGhpcy5nZXRVbmlvbkV4dHJlbWVzKCkuZGF0YU1heDthIT09ZSYmKHRoaXMuZml4ZWRXaWR0aD1nLGI9ZC5uYXZpZ2F0b3JBeGlzLnRvRml4ZWRSYW5nZShhLGErZyxrLG0pLHEoYi5taW4pJiZjLnhBeGlzWzBdLnNldEV4dHJlbWVzKE1hdGgubWluKGIubWluLGIubWF4KSxNYXRoLm1heChiLm1pbixiLm1heCksITAsbnVsbCx7dHJpZ2dlcjpcIm5hdmlnYXRvclwifSkpfX07aC5wcm90b3R5cGUuaGFuZGxlc01vdXNlZG93bj1mdW5jdGlvbihhLGIpe3RoaXMuY2hhcnQucG9pbnRlci5ub3JtYWxpemUoYSk7YT10aGlzLmNoYXJ0O3ZhciBjPWEueEF4aXNbMF0sZD10aGlzLnJldmVyc2VkRXh0cmVtZXM7MD09PWI/KHRoaXMuZ3JhYmJlZExlZnQ9ITAsdGhpcy5vdGhlckhhbmRsZVBvcz10aGlzLnpvb21lZE1heCxcbnRoaXMuZml4ZWRFeHRyZW1lPWQ/Yy5taW46Yy5tYXgpOih0aGlzLmdyYWJiZWRSaWdodD0hMCx0aGlzLm90aGVySGFuZGxlUG9zPXRoaXMuem9vbWVkTWluLHRoaXMuZml4ZWRFeHRyZW1lPWQ/Yy5tYXg6Yy5taW4pO2EuZml4ZWRSYW5nZT1udWxsfTtoLnByb3RvdHlwZS5vbk1vdXNlTW92ZT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9Yi5jaGFydCxkPWIubGVmdCxlPWIubmF2aWdhdG9yU2l6ZSxsPWIucmFuZ2UsZz1iLmRyYWdPZmZzZXQsaD1jLmludmVydGVkO2EudG91Y2hlcyYmMD09PWEudG91Y2hlc1swXS5wYWdlWHx8KGE9Yy5wb2ludGVyLm5vcm1hbGl6ZShhKSxjPWEuY2hhcnRYLGgmJihkPWIudG9wLGM9YS5jaGFydFkpLGIuZ3JhYmJlZExlZnQ/KGIuaGFzRHJhZ2dlZD0hMCxiLnJlbmRlcigwLDAsYy1kLGIub3RoZXJIYW5kbGVQb3MpKTpiLmdyYWJiZWRSaWdodD8oYi5oYXNEcmFnZ2VkPSEwLGIucmVuZGVyKDAsMCxiLm90aGVySGFuZGxlUG9zLGMtZCkpOmIuZ3JhYmJlZENlbnRlciYmXG4oYi5oYXNEcmFnZ2VkPSEwLGM8Zz9jPWc6Yz5lK2ctbCYmKGM9ZStnLWwpLGIucmVuZGVyKDAsMCxjLWcsYy1nK2wpKSxiLmhhc0RyYWdnZWQmJmIuc2Nyb2xsYmFyJiZIKGIuc2Nyb2xsYmFyLm9wdGlvbnMubGl2ZVJlZHJhdyxyLnN2ZyYmIWYmJiF0aGlzLmNoYXJ0LmlzQm9vc3RpbmcpJiYoYS5ET01UeXBlPWEudHlwZSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7Yi5vbk1vdXNlVXAoYSl9LDApKSl9O2gucHJvdG90eXBlLm9uTW91c2VVcD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LGM9dGhpcy54QXhpcyxkPXRoaXMuc2Nyb2xsYmFyLGU9YS5ET01FdmVudHx8YSxmPWIuaW52ZXJ0ZWQsZz10aGlzLnJlbmRlcmVkJiYhdGhpcy5oYXNEcmFnZ2VkP1wiYW5pbWF0ZVwiOlwiYXR0clwiO2lmKHRoaXMuaGFzRHJhZ2dlZCYmKCFkfHwhZC5oYXNEcmFnZ2VkKXx8XCJzY3JvbGxiYXJcIj09PWEudHJpZ2dlcil7ZD10aGlzLmdldFVuaW9uRXh0cmVtZXMoKTtpZih0aGlzLnpvb21lZE1pbj09PXRoaXMub3RoZXJIYW5kbGVQb3MpdmFyIGw9XG50aGlzLmZpeGVkRXh0cmVtZTtlbHNlIGlmKHRoaXMuem9vbWVkTWF4PT09dGhpcy5vdGhlckhhbmRsZVBvcyl2YXIgaD10aGlzLmZpeGVkRXh0cmVtZTt0aGlzLnpvb21lZE1heD09PXRoaXMuc2l6ZSYmKGg9dGhpcy5yZXZlcnNlZEV4dHJlbWVzP2QuZGF0YU1pbjpkLmRhdGFNYXgpOzA9PT10aGlzLnpvb21lZE1pbiYmKGw9dGhpcy5yZXZlcnNlZEV4dHJlbWVzP2QuZGF0YU1heDpkLmRhdGFNaW4pO2M9Yy5uYXZpZ2F0b3JBeGlzLnRvRml4ZWRSYW5nZSh0aGlzLnpvb21lZE1pbix0aGlzLnpvb21lZE1heCxsLGgpO3EoYy5taW4pJiZiLnhBeGlzWzBdLnNldEV4dHJlbWVzKE1hdGgubWluKGMubWluLGMubWF4KSxNYXRoLm1heChjLm1pbixjLm1heCksITAsdGhpcy5oYXNEcmFnZ2VkPyExOm51bGwse3RyaWdnZXI6XCJuYXZpZ2F0b3JcIix0cmlnZ2VyT3A6XCJuYXZpZ2F0b3ItZHJhZ1wiLERPTUV2ZW50OmV9KX1cIm1vdXNlbW92ZVwiIT09YS5ET01UeXBlJiZcInRvdWNobW92ZVwiIT09YS5ET01UeXBlJiZcbih0aGlzLmdyYWJiZWRMZWZ0PXRoaXMuZ3JhYmJlZFJpZ2h0PXRoaXMuZ3JhYmJlZENlbnRlcj10aGlzLmZpeGVkV2lkdGg9dGhpcy5maXhlZEV4dHJlbWU9dGhpcy5vdGhlckhhbmRsZVBvcz10aGlzLmhhc0RyYWdnZWQ9dGhpcy5kcmFnT2Zmc2V0PW51bGwpO3RoaXMubmF2aWdhdG9yRW5hYmxlZCYmSyh0aGlzLnpvb21lZE1pbikmJksodGhpcy56b29tZWRNYXgpJiYoYj1NYXRoLnJvdW5kKHRoaXMuem9vbWVkTWluKSxhPU1hdGgucm91bmQodGhpcy56b29tZWRNYXgpLHRoaXMuc2hhZGVzJiZ0aGlzLmRyYXdNYXNrcyhiLGEsZixnKSx0aGlzLm91dGxpbmUmJnRoaXMuZHJhd091dGxpbmUoYixhLGYsZyksdGhpcy5uYXZpZ2F0b3JPcHRpb25zLmhhbmRsZXMuZW5hYmxlZCYmT2JqZWN0LmtleXModGhpcy5oYW5kbGVzKS5sZW5ndGg9PT10aGlzLmhhbmRsZXMubGVuZ3RoJiYodGhpcy5kcmF3SGFuZGxlKGIsMCxmLGcpLHRoaXMuZHJhd0hhbmRsZShhLDEsZixnKSkpfTtoLnByb3RvdHlwZS5yZW1vdmVFdmVudHM9XG5mdW5jdGlvbigpe3RoaXMuZXZlbnRzVG9VbmJpbmQmJih0aGlzLmV2ZW50c1RvVW5iaW5kLmZvckVhY2goZnVuY3Rpb24oYSl7YSgpfSksdGhpcy5ldmVudHNUb1VuYmluZD12b2lkIDApO3RoaXMucmVtb3ZlQmFzZVNlcmllc0V2ZW50cygpfTtoLnByb3RvdHlwZS5yZW1vdmVCYXNlU2VyaWVzRXZlbnRzPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5iYXNlU2VyaWVzfHxbXTt0aGlzLm5hdmlnYXRvckVuYWJsZWQmJmFbMF0mJighMSE9PXRoaXMubmF2aWdhdG9yT3B0aW9ucy5hZGFwdFRvVXBkYXRlZERhdGEmJmEuZm9yRWFjaChmdW5jdGlvbihhKXtDKGEsXCJ1cGRhdGVkRGF0YVwiLHRoaXMudXBkYXRlZERhdGFIYW5kbGVyKX0sdGhpcyksYVswXS54QXhpcyYmQyhhWzBdLnhBeGlzLFwiZm91bmRFeHRyZW1lc1wiLHRoaXMubW9kaWZ5QmFzZUF4aXNFeHRyZW1lcykpfTtoLnByb3RvdHlwZS5pbml0PWZ1bmN0aW9uKGIpe3ZhciBjPWIub3B0aW9ucyxkPWMubmF2aWdhdG9yLGY9ZC5lbmFibGVkLFxuZz1jLnNjcm9sbGJhcixoPWcuZW5hYmxlZDtjPWY/ZC5oZWlnaHQ6MDt2YXIgbD1oP2cuaGVpZ2h0OjA7dGhpcy5oYW5kbGVzPVtdO3RoaXMuc2hhZGVzPVtdO3RoaXMuY2hhcnQ9Yjt0aGlzLnNldEJhc2VTZXJpZXMoKTt0aGlzLmhlaWdodD1jO3RoaXMuc2Nyb2xsYmFySGVpZ2h0PWw7dGhpcy5zY3JvbGxiYXJFbmFibGVkPWg7dGhpcy5uYXZpZ2F0b3JFbmFibGVkPWY7dGhpcy5uYXZpZ2F0b3JPcHRpb25zPWQ7dGhpcy5zY3JvbGxiYXJPcHRpb25zPWc7dGhpcy5vdXRsaW5lSGVpZ2h0PWMrbDt0aGlzLm9wcG9zaXRlPUgoZC5vcHBvc2l0ZSwhKGZ8fCFiLmludmVydGVkKSk7dmFyIGs9dGhpcztmPWsuYmFzZVNlcmllcztnPWIueEF4aXMubGVuZ3RoO2g9Yi55QXhpcy5sZW5ndGg7dmFyIG09ZiYmZlswXSYmZlswXS54QXhpc3x8Yi54QXhpc1swXXx8e29wdGlvbnM6e319O2IuaXNEaXJ0eUJveD0hMDtrLm5hdmlnYXRvckVuYWJsZWQ/KGsueEF4aXM9bmV3IGEoYixMKHticmVha3M6bS5vcHRpb25zLmJyZWFrcyxcbm9yZGluYWw6bS5vcHRpb25zLm9yZGluYWx9LGQueEF4aXMse2lkOlwibmF2aWdhdG9yLXgtYXhpc1wiLHlBeGlzOlwibmF2aWdhdG9yLXktYXhpc1wiLGlzWDohMCx0eXBlOlwiZGF0ZXRpbWVcIixpbmRleDpnLGlzSW50ZXJuYWw6ITAsb2Zmc2V0OjAsa2VlcE9yZGluYWxQYWRkaW5nOiEwLHN0YXJ0T25UaWNrOiExLGVuZE9uVGljazohMSxtaW5QYWRkaW5nOjAsbWF4UGFkZGluZzowLHpvb21FbmFibGVkOiExfSxiLmludmVydGVkP3tvZmZzZXRzOltsLDAsLWwsMF0sd2lkdGg6Y306e29mZnNldHM6WzAsLWwsMCxsXSxoZWlnaHQ6Y30pKSxrLnlBeGlzPW5ldyBhKGIsTChkLnlBeGlzLHtpZDpcIm5hdmlnYXRvci15LWF4aXNcIixhbGlnblRpY2tzOiExLG9mZnNldDowLGluZGV4OmgsaXNJbnRlcm5hbDohMCxyZXZlcnNlZDpIKGQueUF4aXMmJmQueUF4aXMucmV2ZXJzZWQsYi55QXhpc1swXSYmYi55QXhpc1swXS5yZXZlcnNlZCwhMSksem9vbUVuYWJsZWQ6ITF9LGIuaW52ZXJ0ZWQ/e3dpZHRoOmN9Olxue2hlaWdodDpjfSkpLGZ8fGQuc2VyaWVzLmRhdGE/ay51cGRhdGVOYXZpZ2F0b3JTZXJpZXMoITEpOjA9PT1iLnNlcmllcy5sZW5ndGgmJihrLnVuYmluZFJlZHJhdz1lKGIsXCJiZWZvcmVSZWRyYXdcIixmdW5jdGlvbigpezA8Yi5zZXJpZXMubGVuZ3RoJiYhay5zZXJpZXMmJihrLnNldEJhc2VTZXJpZXMoKSxrLnVuYmluZFJlZHJhdygpKX0pKSxrLnJldmVyc2VkRXh0cmVtZXM9Yi5pbnZlcnRlZCYmIWsueEF4aXMucmV2ZXJzZWR8fCFiLmludmVydGVkJiZrLnhBeGlzLnJldmVyc2VkLGsucmVuZGVyRWxlbWVudHMoKSxrLmFkZE1vdXNlRXZlbnRzKCkpOihrLnhBeGlzPXtjaGFydDpiLG5hdmlnYXRvckF4aXM6e2Zha2U6ITB9LHRyYW5zbGF0ZTpmdW5jdGlvbihhLGMpe3ZhciBkPWIueEF4aXNbMF0sZT1kLmdldEV4dHJlbWVzKCksZj1kLmxlbi0yKmwsZz1FKFwibWluXCIsZC5vcHRpb25zLm1pbixlLmRhdGFNaW4pO2Q9RShcIm1heFwiLGQub3B0aW9ucy5tYXgsZS5kYXRhTWF4KS1nO3JldHVybiBjP1xuYSpkL2YrZzpmKihhLWcpL2R9LHRvUGl4ZWxzOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnRyYW5zbGF0ZShhKX0sdG9WYWx1ZTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy50cmFuc2xhdGUoYSwhMCl9fSxrLnhBeGlzLm5hdmlnYXRvckF4aXMuYXhpcz1rLnhBeGlzLGsueEF4aXMubmF2aWdhdG9yQXhpcy50b0ZpeGVkUmFuZ2U9bi5BZGRpdGlvbnNDbGFzcy5wcm90b3R5cGUudG9GaXhlZFJhbmdlLmJpbmQoay54QXhpcy5uYXZpZ2F0b3JBeGlzKSk7Yi5vcHRpb25zLnNjcm9sbGJhci5lbmFibGVkJiYoYi5zY3JvbGxiYXI9ay5zY3JvbGxiYXI9bmV3IEIoYi5yZW5kZXJlcixMKGIub3B0aW9ucy5zY3JvbGxiYXIse21hcmdpbjprLm5hdmlnYXRvckVuYWJsZWQ/MDoxMCx2ZXJ0aWNhbDpiLmludmVydGVkfSksYiksZShrLnNjcm9sbGJhcixcImNoYW5nZWRcIixmdW5jdGlvbihhKXt2YXIgYz1rLnNpemUsZD1jKnRoaXMudG87Yyo9dGhpcy5mcm9tO2suaGFzRHJhZ2dlZD1rLnNjcm9sbGJhci5oYXNEcmFnZ2VkO1xuay5yZW5kZXIoMCwwLGMsZCk7KGIub3B0aW9ucy5zY3JvbGxiYXIubGl2ZVJlZHJhd3x8XCJtb3VzZW1vdmVcIiE9PWEuRE9NVHlwZSYmXCJ0b3VjaG1vdmVcIiE9PWEuRE9NVHlwZSkmJnNldFRpbWVvdXQoZnVuY3Rpb24oKXtrLm9uTW91c2VVcChhKX0pfSkpO2suYWRkQmFzZVNlcmllc0V2ZW50cygpO2suYWRkQ2hhcnRFdmVudHMoKX07aC5wcm90b3R5cGUuZ2V0VW5pb25FeHRyZW1lcz1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmNoYXJ0LnhBeGlzWzBdLGM9dGhpcy54QXhpcyxkPWMub3B0aW9ucyxlPWIub3B0aW9ucyxmO2EmJm51bGw9PT1iLmRhdGFNaW58fChmPXtkYXRhTWluOkgoZCYmZC5taW4sRShcIm1pblwiLGUubWluLGIuZGF0YU1pbixjLmRhdGFNaW4sYy5taW4pKSxkYXRhTWF4OkgoZCYmZC5tYXgsRShcIm1heFwiLGUubWF4LGIuZGF0YU1heCxjLmRhdGFNYXgsYy5tYXgpKX0pO3JldHVybiBmfTtoLnByb3RvdHlwZS5zZXRCYXNlU2VyaWVzPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcy5jaGFydCxcbmQ9dGhpcy5iYXNlU2VyaWVzPVtdO2E9YXx8Yy5vcHRpb25zJiZjLm9wdGlvbnMubmF2aWdhdG9yLmJhc2VTZXJpZXN8fChjLnNlcmllcy5sZW5ndGg/RihjLnNlcmllcyxmdW5jdGlvbihhKXtyZXR1cm4hYS5vcHRpb25zLmlzSW50ZXJuYWx9KS5pbmRleDowKTsoYy5zZXJpZXN8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGIsYyl7Yi5vcHRpb25zLmlzSW50ZXJuYWx8fCFiLm9wdGlvbnMuc2hvd0luTmF2aWdhdG9yJiYoYyE9PWEmJmIub3B0aW9ucy5pZCE9PWF8fCExPT09Yi5vcHRpb25zLnNob3dJbk5hdmlnYXRvcil8fGQucHVzaChiKX0pO3RoaXMueEF4aXMmJiF0aGlzLnhBeGlzLm5hdmlnYXRvckF4aXMuZmFrZSYmdGhpcy51cGRhdGVOYXZpZ2F0b3JTZXJpZXMoITAsYil9O2gucHJvdG90eXBlLnVwZGF0ZU5hdmlnYXRvclNlcmllcz1mdW5jdGlvbihhLGMpe3ZhciBkPXRoaXMsZT1kLmNoYXJ0LGY9ZC5iYXNlU2VyaWVzLGcsaCxsPWQubmF2aWdhdG9yT3B0aW9ucy5zZXJpZXMsayxcbm09e2VuYWJsZU1vdXNlVHJhY2tpbmc6ITEsaW5kZXg6bnVsbCxsaW5rZWRUbzpudWxsLGdyb3VwOlwibmF2XCIscGFkWEF4aXM6ITEseEF4aXM6XCJuYXZpZ2F0b3IteC1heGlzXCIseUF4aXM6XCJuYXZpZ2F0b3IteS1heGlzXCIsc2hvd0luTGVnZW5kOiExLHN0YWNraW5nOnZvaWQgMCxpc0ludGVybmFsOiEwLHN0YXRlczp7aW5hY3RpdmU6e29wYWNpdHk6MX19fSxuPWQuc2VyaWVzPShkLnNlcmllc3x8W10pLmZpbHRlcihmdW5jdGlvbihhKXt2YXIgYj1hLmJhc2VTZXJpZXM7cmV0dXJuIDA+Zi5pbmRleE9mKGIpPyhiJiYoQyhiLFwidXBkYXRlZERhdGFcIixkLnVwZGF0ZWREYXRhSGFuZGxlciksZGVsZXRlIGIubmF2aWdhdG9yU2VyaWVzKSxhLmNoYXJ0JiZhLmRlc3Ryb3koKSwhMSk6ITB9KTtmJiZmLmxlbmd0aCYmZi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBwPWEubmF2aWdhdG9yU2VyaWVzLHE9Yih7Y29sb3I6YS5jb2xvcix2aXNpYmxlOmEudmlzaWJsZX0sSShsKT92Lm5hdmlnYXRvci5zZXJpZXM6XG5sKTtwJiYhMT09PWQubmF2aWdhdG9yT3B0aW9ucy5hZGFwdFRvVXBkYXRlZERhdGF8fChtLm5hbWU9XCJOYXZpZ2F0b3IgXCIrZi5sZW5ndGgsZz1hLm9wdGlvbnN8fHt9LGs9Zy5uYXZpZ2F0b3JPcHRpb25zfHx7fSxoPUwoZyxtLHEsayksaC5wb2ludFJhbmdlPUgocS5wb2ludFJhbmdlLGsucG9pbnRSYW5nZSx2LnBsb3RPcHRpb25zW2gudHlwZXx8XCJsaW5lXCJdLnBvaW50UmFuZ2UpLHE9ay5kYXRhfHxxLmRhdGEsZC5oYXNOYXZpZ2F0b3JEYXRhPWQuaGFzTmF2aWdhdG9yRGF0YXx8ISFxLGguZGF0YT1xfHxnLmRhdGEmJmcuZGF0YS5zbGljZSgwKSxwJiZwLm9wdGlvbnM/cC51cGRhdGUoaCxjKTooYS5uYXZpZ2F0b3JTZXJpZXM9ZS5pbml0U2VyaWVzKGgpLGEubmF2aWdhdG9yU2VyaWVzLmJhc2VTZXJpZXM9YSxuLnB1c2goYS5uYXZpZ2F0b3JTZXJpZXMpKSl9KTtpZihsLmRhdGEmJighZnx8IWYubGVuZ3RoKXx8SShsKSlkLmhhc05hdmlnYXRvckRhdGE9ITEsbD1NKGwpLGwuZm9yRWFjaChmdW5jdGlvbihhLFxuYil7bS5uYW1lPVwiTmF2aWdhdG9yIFwiKyhuLmxlbmd0aCsxKTtoPUwodi5uYXZpZ2F0b3Iuc2VyaWVzLHtjb2xvcjplLnNlcmllc1tiXSYmIWUuc2VyaWVzW2JdLm9wdGlvbnMuaXNJbnRlcm5hbCYmZS5zZXJpZXNbYl0uY29sb3J8fGUub3B0aW9ucy5jb2xvcnNbYl18fGUub3B0aW9ucy5jb2xvcnNbMF19LG0sYSk7aC5kYXRhPWEuZGF0YTtoLmRhdGEmJihkLmhhc05hdmlnYXRvckRhdGE9ITAsbi5wdXNoKGUuaW5pdFNlcmllcyhoKSkpfSk7YSYmdGhpcy5hZGRCYXNlU2VyaWVzRXZlbnRzKCl9O2gucHJvdG90eXBlLmFkZEJhc2VTZXJpZXNFdmVudHM9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9YS5iYXNlU2VyaWVzfHxbXTtiWzBdJiZiWzBdLnhBeGlzJiZlKGJbMF0ueEF4aXMsXCJmb3VuZEV4dHJlbWVzXCIsdGhpcy5tb2RpZnlCYXNlQXhpc0V4dHJlbWVzKTtiLmZvckVhY2goZnVuY3Rpb24oYil7ZShiLFwic2hvd1wiLGZ1bmN0aW9uKCl7dGhpcy5uYXZpZ2F0b3JTZXJpZXMmJnRoaXMubmF2aWdhdG9yU2VyaWVzLnNldFZpc2libGUoITAsXG4hMSl9KTtlKGIsXCJoaWRlXCIsZnVuY3Rpb24oKXt0aGlzLm5hdmlnYXRvclNlcmllcyYmdGhpcy5uYXZpZ2F0b3JTZXJpZXMuc2V0VmlzaWJsZSghMSwhMSl9KTshMSE9PXRoaXMubmF2aWdhdG9yT3B0aW9ucy5hZGFwdFRvVXBkYXRlZERhdGEmJmIueEF4aXMmJmUoYixcInVwZGF0ZWREYXRhXCIsdGhpcy51cGRhdGVkRGF0YUhhbmRsZXIpO2UoYixcInJlbW92ZVwiLGZ1bmN0aW9uKCl7dGhpcy5uYXZpZ2F0b3JTZXJpZXMmJihkKGEuc2VyaWVzLHRoaXMubmF2aWdhdG9yU2VyaWVzKSxxKHRoaXMubmF2aWdhdG9yU2VyaWVzLm9wdGlvbnMpJiZ0aGlzLm5hdmlnYXRvclNlcmllcy5yZW1vdmUoITEpLGRlbGV0ZSB0aGlzLm5hdmlnYXRvclNlcmllcyl9KX0sdGhpcyl9O2gucHJvdG90eXBlLmdldEJhc2VTZXJpZXNNaW49ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuYmFzZVNlcmllcy5yZWR1Y2UoZnVuY3Rpb24oYSxiKXtyZXR1cm4gTWF0aC5taW4oYSxiLnhEYXRhP2IueERhdGFbMF06YSl9LGEpfTtcbmgucHJvdG90eXBlLm1vZGlmeU5hdmlnYXRvckF4aXNFeHRyZW1lcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMueEF4aXMsYjtcInVuZGVmaW5lZFwiIT09dHlwZW9mIGEuZ2V0RXh0cmVtZXMmJighKGI9dGhpcy5nZXRVbmlvbkV4dHJlbWVzKCEwKSl8fGIuZGF0YU1pbj09PWEubWluJiZiLmRhdGFNYXg9PT1hLm1heHx8KGEubWluPWIuZGF0YU1pbixhLm1heD1iLmRhdGFNYXgpKX07aC5wcm90b3R5cGUubW9kaWZ5QmFzZUF4aXNFeHRyZW1lcz1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY2hhcnQubmF2aWdhdG9yLGI9dGhpcy5nZXRFeHRyZW1lcygpLGM9Yi5kYXRhTWluLGQ9Yi5kYXRhTWF4O2I9Yi5tYXgtYi5taW47dmFyIGU9YS5zdGlja1RvTWluLGY9YS5zdGlja1RvTWF4LGc9SCh0aGlzLm9wdGlvbnMub3ZlcnNjcm9sbCwwKSxoPWEuc2VyaWVzJiZhLnNlcmllc1swXSxrPSEhdGhpcy5zZXRFeHRyZW1lcztpZighdGhpcy5ldmVudEFyZ3N8fFwicmFuZ2VTZWxlY3RvckJ1dHRvblwiIT09dGhpcy5ldmVudEFyZ3MudHJpZ2dlcil7aWYoZSl7dmFyIG09XG5jO3ZhciBuPW0rYn1mJiYobj1kK2csZXx8KG09TWF0aC5tYXgoYyxuLWIsYS5nZXRCYXNlU2VyaWVzTWluKGgmJmgueERhdGE/aC54RGF0YVswXTotTnVtYmVyLk1BWF9WQUxVRSkpKSk7ayYmKGV8fGYpJiZLKG0pJiYodGhpcy5taW49dGhpcy51c2VyTWluPW0sdGhpcy5tYXg9dGhpcy51c2VyTWF4PW4pfWEuc3RpY2tUb01pbj1hLnN0aWNrVG9NYXg9bnVsbH07aC5wcm90b3R5cGUudXBkYXRlZERhdGFIYW5kbGVyPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jaGFydC5uYXZpZ2F0b3IsYj10aGlzLm5hdmlnYXRvclNlcmllcyxjPWEuZ2V0QmFzZVNlcmllc01pbih0aGlzLnhEYXRhWzBdKTthLnN0aWNrVG9NYXg9YS5yZXZlcnNlZEV4dHJlbWVzPzA9PT1NYXRoLnJvdW5kKGEuem9vbWVkTWluKTpNYXRoLnJvdW5kKGEuem9vbWVkTWF4KT49TWF0aC5yb3VuZChhLnNpemUpO2Euc3RpY2tUb01pbj1LKHRoaXMueEF4aXMubWluKSYmdGhpcy54QXhpcy5taW48PWMmJighdGhpcy5jaGFydC5maXhlZFJhbmdlfHxcbiFhLnN0aWNrVG9NYXgpO2ImJiFhLmhhc05hdmlnYXRvckRhdGEmJihiLm9wdGlvbnMucG9pbnRTdGFydD10aGlzLnhEYXRhWzBdLGIuc2V0RGF0YSh0aGlzLm9wdGlvbnMuZGF0YSwhMSxudWxsLCExKSl9O2gucHJvdG90eXBlLmFkZENoYXJ0RXZlbnRzPWZ1bmN0aW9uKCl7dGhpcy5ldmVudHNUb1VuYmluZHx8KHRoaXMuZXZlbnRzVG9VbmJpbmQ9W10pO3RoaXMuZXZlbnRzVG9VbmJpbmQucHVzaChlKHRoaXMuY2hhcnQsXCJyZWRyYXdcIixmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF2aWdhdG9yLGI9YSYmKGEuYmFzZVNlcmllcyYmYS5iYXNlU2VyaWVzWzBdJiZhLmJhc2VTZXJpZXNbMF0ueEF4aXN8fHRoaXMueEF4aXNbMF0pO2ImJmEucmVuZGVyKGIubWluLGIubWF4KX0pLGUodGhpcy5jaGFydCxcImdldE1hcmdpbnNcIixmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF2aWdhdG9yLGI9YS5vcHBvc2l0ZT9cInBsb3RUb3BcIjpcIm1hcmdpbkJvdHRvbVwiO3RoaXMuaW52ZXJ0ZWQmJihiPWEub3Bwb3NpdGU/XG5cIm1hcmdpblJpZ2h0XCI6XCJwbG90TGVmdFwiKTt0aGlzW2JdPSh0aGlzW2JdfHwwKSsoYS5uYXZpZ2F0b3JFbmFibGVkfHwhdGhpcy5pbnZlcnRlZD9hLm91dGxpbmVIZWlnaHQ6MCkrYS5uYXZpZ2F0b3JPcHRpb25zLm1hcmdpbn0pKX07aC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe3RoaXMucmVtb3ZlRXZlbnRzKCk7dGhpcy54QXhpcyYmKGQodGhpcy5jaGFydC54QXhpcyx0aGlzLnhBeGlzKSxkKHRoaXMuY2hhcnQuYXhlcyx0aGlzLnhBeGlzKSk7dGhpcy55QXhpcyYmKGQodGhpcy5jaGFydC55QXhpcyx0aGlzLnlBeGlzKSxkKHRoaXMuY2hhcnQuYXhlcyx0aGlzLnlBeGlzKSk7KHRoaXMuc2VyaWVzfHxbXSkuZm9yRWFjaChmdW5jdGlvbihhKXthLmRlc3Ryb3kmJmEuZGVzdHJveSgpfSk7XCJzZXJpZXMgeEF4aXMgeUF4aXMgc2hhZGVzIG91dGxpbmUgc2Nyb2xsYmFyVHJhY2sgc2Nyb2xsYmFyUmlmbGVzIHNjcm9sbGJhckdyb3VwIHNjcm9sbGJhciBuYXZpZ2F0b3JHcm91cCByZW5kZXJlZFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3RoaXNbYV0mJlxudGhpc1thXS5kZXN0cm95JiZ0aGlzW2FdLmRlc3Ryb3koKTt0aGlzW2FdPW51bGx9LHRoaXMpO1t0aGlzLmhhbmRsZXNdLmZvckVhY2goZnVuY3Rpb24oYSl7YyhhKX0sdGhpcyl9O3JldHVybiBofSgpO3IuTmF2aWdhdG9yfHwoci5OYXZpZ2F0b3I9eSxuLmNvbXBvc2UoYSksZSh1LFwiYmVmb3JlU2hvd1Jlc2V0Wm9vbVwiLGZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5vcHRpb25zLGI9YS5uYXZpZ2F0b3IsYz1hLnJhbmdlU2VsZWN0b3I7aWYoKGImJmIuZW5hYmxlZHx8YyYmYy5lbmFibGVkKSYmKCFmJiZcInhcIj09PWEuY2hhcnQuem9vbVR5cGV8fGYmJlwieFwiPT09YS5jaGFydC5waW5jaFR5cGUpKXJldHVybiExfSksZSh1LFwiYmVmb3JlUmVuZGVyXCIsZnVuY3Rpb24oKXt2YXIgYT10aGlzLm9wdGlvbnM7aWYoYS5uYXZpZ2F0b3IuZW5hYmxlZHx8YS5zY3JvbGxiYXIuZW5hYmxlZCl0aGlzLnNjcm9sbGVyPXRoaXMubmF2aWdhdG9yPW5ldyB5KHRoaXMpfSksZSh1LFwiYWZ0ZXJTZXRDaGFydFNpemVcIixcbmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5sZWdlbmQsYj10aGlzLm5hdmlnYXRvcjtpZihiKXt2YXIgYz1hJiZhLm9wdGlvbnM7dmFyIGQ9Yi54QXhpczt2YXIgZT1iLnlBeGlzO3ZhciBmPWIuc2Nyb2xsYmFySGVpZ2h0O3RoaXMuaW52ZXJ0ZWQ/KGIubGVmdD1iLm9wcG9zaXRlP3RoaXMuY2hhcnRXaWR0aC1mLWIuaGVpZ2h0OnRoaXMuc3BhY2luZ1szXStmLGIudG9wPXRoaXMucGxvdFRvcCtmKTooYi5sZWZ0PXRoaXMucGxvdExlZnQrZixiLnRvcD1iLm5hdmlnYXRvck9wdGlvbnMudG9wfHx0aGlzLmNoYXJ0SGVpZ2h0LWIuaGVpZ2h0LWYtdGhpcy5zcGFjaW5nWzJdLSh0aGlzLnJhbmdlU2VsZWN0b3ImJnRoaXMuZXh0cmFCb3R0b21NYXJnaW4/dGhpcy5yYW5nZVNlbGVjdG9yLmdldEhlaWdodCgpOjApLShjJiZcImJvdHRvbVwiPT09Yy52ZXJ0aWNhbEFsaWduJiZcInByb3hpbWF0ZVwiIT09Yy5sYXlvdXQmJmMuZW5hYmxlZCYmIWMuZmxvYXRpbmc/YS5sZWdlbmRIZWlnaHQrSChjLm1hcmdpbixcbjEwKTowKS0odGhpcy50aXRsZU9mZnNldD90aGlzLnRpdGxlT2Zmc2V0WzJdOjApKTtkJiZlJiYodGhpcy5pbnZlcnRlZD9kLm9wdGlvbnMubGVmdD1lLm9wdGlvbnMubGVmdD1iLmxlZnQ6ZC5vcHRpb25zLnRvcD1lLm9wdGlvbnMudG9wPWIudG9wLGQuc2V0QXhpc1NpemUoKSxlLnNldEF4aXNTaXplKCkpfX0pLGUodSxcInVwZGF0ZVwiLGZ1bmN0aW9uKGEpe3ZhciBiPWEub3B0aW9ucy5uYXZpZ2F0b3J8fHt9LGM9YS5vcHRpb25zLnNjcm9sbGJhcnx8e307dGhpcy5uYXZpZ2F0b3J8fHRoaXMuc2Nyb2xsZXJ8fCFiLmVuYWJsZWQmJiFjLmVuYWJsZWR8fChMKCEwLHRoaXMub3B0aW9ucy5uYXZpZ2F0b3IsYiksTCghMCx0aGlzLm9wdGlvbnMuc2Nyb2xsYmFyLGMpLGRlbGV0ZSBhLm9wdGlvbnMubmF2aWdhdG9yLGRlbGV0ZSBhLm9wdGlvbnMuc2Nyb2xsYmFyKX0pLGUodSxcImFmdGVyVXBkYXRlXCIsZnVuY3Rpb24oYSl7dGhpcy5uYXZpZ2F0b3J8fHRoaXMuc2Nyb2xsZXJ8fCF0aGlzLm9wdGlvbnMubmF2aWdhdG9yLmVuYWJsZWQmJlxuIXRoaXMub3B0aW9ucy5zY3JvbGxiYXIuZW5hYmxlZHx8KHRoaXMuc2Nyb2xsZXI9dGhpcy5uYXZpZ2F0b3I9bmV3IHkodGhpcyksSChhLnJlZHJhdywhMCkmJnRoaXMucmVkcmF3KGEuYW5pbWF0aW9uKSl9KSxlKHUsXCJhZnRlckFkZFNlcmllc1wiLGZ1bmN0aW9uKCl7dGhpcy5uYXZpZ2F0b3ImJnRoaXMubmF2aWdhdG9yLnNldEJhc2VTZXJpZXMobnVsbCwhMSl9KSxlKEQsXCJhZnRlclVwZGF0ZVwiLGZ1bmN0aW9uKCl7dGhpcy5jaGFydC5uYXZpZ2F0b3ImJiF0aGlzLm9wdGlvbnMuaXNJbnRlcm5hbCYmdGhpcy5jaGFydC5uYXZpZ2F0b3Iuc2V0QmFzZVNlcmllcyhudWxsLCExKX0pLHUucHJvdG90eXBlLmNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEubmF2aWdhdG9yO2ImJmEueEF4aXNbMF0mJihhPWEueEF4aXNbMF0uZ2V0RXh0cmVtZXMoKSxiLnJlbmRlcihhLm1pbixhLm1heCkpfSkpO3IuTmF2aWdhdG9yPXk7cmV0dXJuIHIuTmF2aWdhdG9yfSk7RihhLFwibWFzdGVycy9tb2R1bGVzL2dhbnR0LnNyYy5qc1wiLFxuW10sZnVuY3Rpb24oKXt9KX0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2FudHQuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///564\n");

/***/ })

}]);